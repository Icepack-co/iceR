// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cvrptw-acyas3nzweqb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cvrptw_2dacyas3nzweqb_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cvrptw_2dacyas3nzweqb_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cvrptw_2dacyas3nzweqb_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_cvrptw_2dacyas3nzweqb_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_cvrptw_2dacyas3nzweqb_2eproto;
namespace CVRPTW {
class CVRPTW;
struct CVRPTWDefaultTypeInternal;
extern CVRPTWDefaultTypeInternal _CVRPTW_default_instance_;
class Edge;
struct EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Edge_Geometry;
struct Edge_GeometryDefaultTypeInternal;
extern Edge_GeometryDefaultTypeInternal _Edge_Geometry_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Route;
struct SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
}  // namespace CVRPTW
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace CVRPTW {
enum CVRPTW_eDistanceType : int {
  CVRPTW_eDistanceType_RoadNetwork = 1,
  CVRPTW_eDistanceType_Euclidean = 2,
  CVRPTW_eDistanceType_Haversine = 3,
};

bool CVRPTW_eDistanceType_IsValid(int value);
constexpr CVRPTW_eDistanceType CVRPTW_eDistanceType_eDistanceType_MIN = static_cast<CVRPTW_eDistanceType>(1);
constexpr CVRPTW_eDistanceType CVRPTW_eDistanceType_eDistanceType_MAX = static_cast<CVRPTW_eDistanceType>(3);
constexpr int CVRPTW_eDistanceType_eDistanceType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CVRPTW_eDistanceType_descriptor();
template <typename T>
const std::string& CVRPTW_eDistanceType_Name(T value) {
  static_assert(std::is_same<T, CVRPTW_eDistanceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eDistanceType_Name().");
  return CVRPTW_eDistanceType_Name(static_cast<CVRPTW_eDistanceType>(value));
}
template <>
inline const std::string& CVRPTW_eDistanceType_Name(CVRPTW_eDistanceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CVRPTW_eDistanceType_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool CVRPTW_eDistanceType_Parse(absl::string_view name, CVRPTW_eDistanceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CVRPTW_eDistanceType>(
      CVRPTW_eDistanceType_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(2);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kQuantityFieldNumber = 4,
    kWindowStartFieldNumber = 5,
    kWindowEndFieldNumber = 6,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float x = 2;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 3;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float quantity = 4 [default = 0];
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // optional float windowStart = 5;
  bool has_windowstart() const;
  void clear_windowstart() ;
  float windowstart() const;
  void set_windowstart(float value);

  private:
  float _internal_windowstart() const;
  void _internal_set_windowstart(float value);

  public:
  // optional float windowEnd = 6;
  bool has_windowend() const;
  void clear_windowend() ;
  float windowend() const;
  void set_windowend(float value);

  private:
  float _internal_windowend() const;
  void _internal_set_windowend(float value);

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 25, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float x_;
    float y_;
    float quantity_;
    float windowstart_;
    float windowend_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};// -------------------------------------------------------------------

class CVRPTW final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.CVRPTW) */ {
 public:
  inline CVRPTW() : CVRPTW(nullptr) {}
  ~CVRPTW() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CVRPTW(::google::protobuf::internal::ConstantInitialized);

  CVRPTW(const CVRPTW& from);
  CVRPTW(CVRPTW&& from) noexcept
    : CVRPTW() {
    *this = ::std::move(from);
  }

  inline CVRPTW& operator=(const CVRPTW& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVRPTW& operator=(CVRPTW&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVRPTW& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVRPTW* internal_default_instance() {
    return reinterpret_cast<const CVRPTW*>(
               &_CVRPTW_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CVRPTW& a, CVRPTW& b) {
    a.Swap(&b);
  }
  inline void Swap(CVRPTW* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVRPTW* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVRPTW* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVRPTW>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CVRPTW& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CVRPTW& from) {
    CVRPTW::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVRPTW* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.CVRPTW";
  }
  protected:
  explicit CVRPTW(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eDistanceType = CVRPTW_eDistanceType;
  static constexpr eDistanceType RoadNetwork = CVRPTW_eDistanceType_RoadNetwork;
  static constexpr eDistanceType Euclidean = CVRPTW_eDistanceType_Euclidean;
  static constexpr eDistanceType Haversine = CVRPTW_eDistanceType_Haversine;
  static inline bool eDistanceType_IsValid(int value) {
    return CVRPTW_eDistanceType_IsValid(value);
  }
  static constexpr eDistanceType eDistanceType_MIN = CVRPTW_eDistanceType_eDistanceType_MIN;
  static constexpr eDistanceType eDistanceType_MAX = CVRPTW_eDistanceType_eDistanceType_MAX;
  static constexpr int eDistanceType_ARRAYSIZE = CVRPTW_eDistanceType_eDistanceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eDistanceType_descriptor() {
    return CVRPTW_eDistanceType_descriptor();
  }
  template <typename T>
  static inline const std::string& eDistanceType_Name(T value) {
    return CVRPTW_eDistanceType_Name(value);
  }
  static inline bool eDistanceType_Parse(absl::string_view name, eDistanceType* value) {
    return CVRPTW_eDistanceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kDepotFieldNumber = 2,
    kNumberOfVehiclesFieldNumber = 3,
    kVehicleCapacityFieldNumber = 4,
    kDistancetypeFieldNumber = 5,
  };
  // repeated .CVRPTW.Geocode points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::CVRPTW::Geocode* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRPTW::Geocode >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::CVRPTW::Geocode>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::CVRPTW::Geocode>* _internal_mutable_points();
  public:
  const ::CVRPTW::Geocode& points(int index) const;
  ::CVRPTW::Geocode* add_points();
  const ::google::protobuf::RepeatedPtrField< ::CVRPTW::Geocode >&
      points() const;
  // required .CVRPTW.Geocode depot = 2;
  bool has_depot() const;
  void clear_depot() ;
  const ::CVRPTW::Geocode& depot() const;
  PROTOBUF_NODISCARD ::CVRPTW::Geocode* release_depot();
  ::CVRPTW::Geocode* mutable_depot();
  void set_allocated_depot(::CVRPTW::Geocode* value);
  void unsafe_arena_set_allocated_depot(::CVRPTW::Geocode* value);
  ::CVRPTW::Geocode* unsafe_arena_release_depot();

  private:
  const ::CVRPTW::Geocode& _internal_depot() const;
  ::CVRPTW::Geocode* _internal_mutable_depot();

  public:
  // required int32 NumberOfVehicles = 3;
  bool has_numberofvehicles() const;
  void clear_numberofvehicles() ;
  ::int32_t numberofvehicles() const;
  void set_numberofvehicles(::int32_t value);

  private:
  ::int32_t _internal_numberofvehicles() const;
  void _internal_set_numberofvehicles(::int32_t value);

  public:
  // required float VehicleCapacity = 4;
  bool has_vehiclecapacity() const;
  void clear_vehiclecapacity() ;
  float vehiclecapacity() const;
  void set_vehiclecapacity(float value);

  private:
  float _internal_vehiclecapacity() const;
  void _internal_set_vehiclecapacity(float value);

  public:
  // optional .CVRPTW.CVRPTW.eDistanceType distancetype = 5 [default = RoadNetwork];
  bool has_distancetype() const;
  void clear_distancetype() ;
  ::CVRPTW::CVRPTW_eDistanceType distancetype() const;
  void set_distancetype(::CVRPTW::CVRPTW_eDistanceType value);

  private:
  ::CVRPTW::CVRPTW_eDistanceType _internal_distancetype() const;
  void _internal_set_distancetype(::CVRPTW::CVRPTW_eDistanceType value);

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.CVRPTW)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::CVRPTW::Geocode > points_;
    ::CVRPTW::Geocode* depot_;
    ::int32_t numberofvehicles_;
    float vehiclecapacity_;
    int distancetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVisitSequenceFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated string visitSequence = 3;
  int visitsequence_size() const;
  private:
  int _internal_visitsequence_size() const;

  public:
  void clear_visitsequence() ;
  const std::string& visitsequence(int index) const;
  std::string* mutable_visitsequence(int index);
  void set_visitsequence(int index, const std::string& value);
  void set_visitsequence(int index, std::string&& value);
  void set_visitsequence(int index, const char* value);
  void set_visitsequence(int index, const char* value, std::size_t size);
  void set_visitsequence(int index, absl::string_view value);
  std::string* add_visitsequence();
  void add_visitsequence(const std::string& value);
  void add_visitsequence(std::string&& value);
  void add_visitsequence(const char* value);
  void add_visitsequence(const char* value, std::size_t size);
  void add_visitsequence(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& visitsequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_visitsequence();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_visitsequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_visitsequence();

  public:
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .CVRPTW.CVRPTW model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::CVRPTW::CVRPTW& model() const;
  PROTOBUF_NODISCARD ::CVRPTW::CVRPTW* release_model();
  ::CVRPTW::CVRPTW* mutable_model();
  void set_allocated_model(::CVRPTW::CVRPTW* value);
  void unsafe_arena_set_allocated_model(::CVRPTW::CVRPTW* value);
  ::CVRPTW::CVRPTW* unsafe_arena_release_model();

  private:
  const ::CVRPTW::CVRPTW& _internal_model() const;
  ::CVRPTW::CVRPTW* _internal_mutable_model();

  public:
  // optional .CVRPTW.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::CVRPTW::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::CVRPTW::SolveRequest_SolveType value);

  private:
  ::CVRPTW::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::CVRPTW::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> visitsequence_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::CVRPTW::CVRPTW* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};// -------------------------------------------------------------------

class Edge_Geometry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.Edge.Geometry) */ {
 public:
  inline Edge_Geometry() : Edge_Geometry(nullptr) {}
  ~Edge_Geometry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Edge_Geometry(::google::protobuf::internal::ConstantInitialized);

  Edge_Geometry(const Edge_Geometry& from);
  Edge_Geometry(Edge_Geometry&& from) noexcept
    : Edge_Geometry() {
    *this = ::std::move(from);
  }

  inline Edge_Geometry& operator=(const Edge_Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge_Geometry& operator=(Edge_Geometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge_Geometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge_Geometry* internal_default_instance() {
    return reinterpret_cast<const Edge_Geometry*>(
               &_Edge_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Edge_Geometry& a, Edge_Geometry& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge_Geometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge_Geometry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge_Geometry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge_Geometry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Edge_Geometry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Edge_Geometry& from) {
    Edge_Geometry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge_Geometry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.Edge.Geometry";
  }
  protected:
  explicit Edge_Geometry(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.Edge.Geometry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};// -------------------------------------------------------------------

class Edge final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.Edge) */ {
 public:
  inline Edge() : Edge(nullptr) {}
  ~Edge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Edge(::google::protobuf::internal::ConstantInitialized);

  Edge(const Edge& from);
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge& operator=(Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Edge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Edge& from) {
    Edge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.Edge";
  }
  protected:
  explicit Edge(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Edge_Geometry Geometry;

  // accessors -------------------------------------------------------

  enum : int {
    kGeometryFieldNumber = 5,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // repeated .CVRPTW.Edge.Geometry geometry = 5;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;

  public:
  void clear_geometry() ;
  ::CVRPTW::Edge_Geometry* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge_Geometry >*
      mutable_geometry();
  private:
  const ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge_Geometry>& _internal_geometry() const;
  ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge_Geometry>* _internal_mutable_geometry();
  public:
  const ::CVRPTW::Edge_Geometry& geometry(int index) const;
  ::CVRPTW::Edge_Geometry* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge_Geometry >&
      geometry() const;
  // required string from = 1;
  bool has_from() const;
  void clear_from() ;
  const std::string& from() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from(Arg_&& arg, Args_... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* ptr);

  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(
      const std::string& value);
  std::string* _internal_mutable_from();

  public:
  // required string to = 2;
  bool has_to() const;
  void clear_to() ;
  const std::string& to() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to(Arg_&& arg, Args_... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* ptr);

  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(
      const std::string& value);
  std::string* _internal_mutable_to();

  public:
  // optional float distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.Edge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4, 1, 26, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge_Geometry > geometry_;
    ::google::protobuf::internal::ArenaStringPtr from_;
    ::google::protobuf::internal::ArenaStringPtr to_;
    float distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Route final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.SolutionResponse.Route) */ {
 public:
  inline SolutionResponse_Route() : SolutionResponse_Route(nullptr) {}
  ~SolutionResponse_Route() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Route(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Route(const SolutionResponse_Route& from);
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Route* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Route* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Route& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Route& from) {
    SolutionResponse_Route::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.SolutionResponse.Route";
  }
  protected:
  explicit SolutionResponse_Route(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
    kEdgesFieldNumber = 2,
    kVisitCapacitiesFieldNumber = 3,
    kArrivalTimesFieldNumber = 4,
  };
  // repeated string sequence = 1;
  int sequence_size() const;
  private:
  int _internal_sequence_size() const;

  public:
  void clear_sequence() ;
  const std::string& sequence(int index) const;
  std::string* mutable_sequence(int index);
  void set_sequence(int index, const std::string& value);
  void set_sequence(int index, std::string&& value);
  void set_sequence(int index, const char* value);
  void set_sequence(int index, const char* value, std::size_t size);
  void set_sequence(int index, absl::string_view value);
  std::string* add_sequence();
  void add_sequence(const std::string& value);
  void add_sequence(std::string&& value);
  void add_sequence(const char* value);
  void add_sequence(const char* value, std::size_t size);
  void add_sequence(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& sequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_sequence();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_sequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_sequence();

  public:
  // repeated .CVRPTW.Edge edges = 2;
  int edges_size() const;
  private:
  int _internal_edges_size() const;

  public:
  void clear_edges() ;
  ::CVRPTW::Edge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge >*
      mutable_edges();
  private:
  const ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge>& _internal_edges() const;
  ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge>* _internal_mutable_edges();
  public:
  const ::CVRPTW::Edge& edges(int index) const;
  ::CVRPTW::Edge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge >&
      edges() const;
  // repeated float visitCapacities = 3;
  int visitcapacities_size() const;
  private:
  int _internal_visitcapacities_size() const;

  public:
  void clear_visitcapacities() ;
  float visitcapacities(int index) const;
  void set_visitcapacities(int index, float value);
  void add_visitcapacities(float value);
  const ::google::protobuf::RepeatedField<float>& visitcapacities() const;
  ::google::protobuf::RepeatedField<float>* mutable_visitcapacities();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_visitcapacities() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_visitcapacities();

  public:
  // repeated float arrivalTimes = 4;
  int arrivaltimes_size() const;
  private:
  int _internal_arrivaltimes_size() const;

  public:
  void clear_arrivaltimes() ;
  float arrivaltimes(int index) const;
  void set_arrivaltimes(int index, float value);
  void add_arrivaltimes(float value);
  const ::google::protobuf::RepeatedField<float>& arrivaltimes() const;
  ::google::protobuf::RepeatedField<float>* mutable_arrivaltimes();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_arrivaltimes() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_arrivaltimes();

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.SolutionResponse.Route)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> sequence_;
    ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge > edges_;
    ::google::protobuf::RepeatedField<float> visitcapacities_;
    ::google::protobuf::RepeatedField<float> arrivaltimes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRPTW.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CVRPTW.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Route Route;

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
    kObjectiveFieldNumber = 2,
  };
  // repeated .CVRPTW.SolutionResponse.Route routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::CVRPTW::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRPTW::SolutionResponse_Route >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::CVRPTW::SolutionResponse_Route>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::CVRPTW::SolutionResponse_Route>* _internal_mutable_routes();
  public:
  const ::CVRPTW::SolutionResponse_Route& routes(int index) const;
  ::CVRPTW::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::CVRPTW::SolutionResponse_Route >&
      routes() const;
  // required float objective = 2;
  bool has_objective() const;
  void clear_objective() ;
  float objective() const;
  void set_objective(float value);

  private:
  float _internal_objective() const;
  void _internal_set_objective(float value);

  public:
  // @@protoc_insertion_point(class_scope:CVRPTW.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::CVRPTW::SolutionResponse_Route > routes_;
    float objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cvrptw_2dacyas3nzweqb_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Geocode

// required string id = 1;
inline bool Geocode::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Geocode::id() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Geocode.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Geocode::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVRPTW.Geocode.id)
}
inline std::string* Geocode::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:CVRPTW.Geocode.id)
  return _s;
}
inline const std::string& Geocode::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Geocode::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Geocode::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Geocode::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CVRPTW.Geocode.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Geocode::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVRPTW.Geocode.id)
}

// required float x = 2;
inline bool Geocode::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::x() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Geocode.x)
  return _internal_x();
}
inline void Geocode::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Geocode.x)
}
inline float Geocode::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Geocode::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}

// required float y = 3;
inline bool Geocode::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Geocode::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Geocode::y() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Geocode.y)
  return _internal_y();
}
inline void Geocode::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Geocode.y)
}
inline float Geocode::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Geocode::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}

// required float quantity = 4 [default = 0];
inline bool Geocode::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Geocode::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Geocode::quantity() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Geocode.quantity)
  return _internal_quantity();
}
inline void Geocode::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Geocode.quantity)
}
inline float Geocode::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Geocode::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quantity_ = value;
}

// optional float windowStart = 5;
inline bool Geocode::has_windowstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Geocode::clear_windowstart() {
  _impl_.windowstart_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Geocode::windowstart() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Geocode.windowStart)
  return _internal_windowstart();
}
inline void Geocode::set_windowstart(float value) {
  _internal_set_windowstart(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Geocode.windowStart)
}
inline float Geocode::_internal_windowstart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowstart_;
}
inline void Geocode::_internal_set_windowstart(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.windowstart_ = value;
}

// optional float windowEnd = 6;
inline bool Geocode::has_windowend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Geocode::clear_windowend() {
  _impl_.windowend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Geocode::windowend() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Geocode.windowEnd)
  return _internal_windowend();
}
inline void Geocode::set_windowend(float value) {
  _internal_set_windowend(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Geocode.windowEnd)
}
inline float Geocode::_internal_windowend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowend_;
}
inline void Geocode::_internal_set_windowend(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.windowend_ = value;
}

// -------------------------------------------------------------------

// CVRPTW

// repeated .CVRPTW.Geocode points = 1;
inline int CVRPTW::_internal_points_size() const {
  return _internal_points().size();
}
inline int CVRPTW::points_size() const {
  return _internal_points_size();
}
inline void CVRPTW::clear_points() {
  _internal_mutable_points()->Clear();
}
inline ::CVRPTW::Geocode* CVRPTW::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:CVRPTW.CVRPTW.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRPTW::Geocode >*
CVRPTW::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.CVRPTW.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::CVRPTW::Geocode& CVRPTW::points(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.CVRPTW.points)
    return _internal_points().Get(index);
}
inline ::CVRPTW::Geocode* CVRPTW::add_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CVRPTW::Geocode* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:CVRPTW.CVRPTW.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRPTW::Geocode >&
CVRPTW::points() const {
  // @@protoc_insertion_point(field_list:CVRPTW.CVRPTW.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::CVRPTW::Geocode>&
CVRPTW::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::CVRPTW::Geocode>*
CVRPTW::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// required .CVRPTW.Geocode depot = 2;
inline bool CVRPTW::has_depot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.depot_ != nullptr);
  return value;
}
inline void CVRPTW::clear_depot() {
  if (_impl_.depot_ != nullptr) _impl_.depot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CVRPTW::Geocode& CVRPTW::_internal_depot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CVRPTW::Geocode* p = _impl_.depot_;
  return p != nullptr ? *p : reinterpret_cast<const ::CVRPTW::Geocode&>(::CVRPTW::_Geocode_default_instance_);
}
inline const ::CVRPTW::Geocode& CVRPTW::depot() const {
  // @@protoc_insertion_point(field_get:CVRPTW.CVRPTW.depot)
  return _internal_depot();
}
inline void CVRPTW::unsafe_arena_set_allocated_depot(::CVRPTW::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depot_);
  }
  _impl_.depot_ = reinterpret_cast<::CVRPTW::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CVRPTW.CVRPTW.depot)
}
inline ::CVRPTW::Geocode* CVRPTW::release_depot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CVRPTW::Geocode* released = _impl_.depot_;
  _impl_.depot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CVRPTW::Geocode* CVRPTW::unsafe_arena_release_depot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CVRPTW.CVRPTW.depot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CVRPTW::Geocode* temp = _impl_.depot_;
  _impl_.depot_ = nullptr;
  return temp;
}
inline ::CVRPTW::Geocode* CVRPTW::_internal_mutable_depot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.depot_ == nullptr) {
    auto* p = CreateMaybeMessage<::CVRPTW::Geocode>(GetArenaForAllocation());
    _impl_.depot_ = reinterpret_cast<::CVRPTW::Geocode*>(p);
  }
  return _impl_.depot_;
}
inline ::CVRPTW::Geocode* CVRPTW::mutable_depot() {
  ::CVRPTW::Geocode* _msg = _internal_mutable_depot();
  // @@protoc_insertion_point(field_mutable:CVRPTW.CVRPTW.depot)
  return _msg;
}
inline void CVRPTW::set_allocated_depot(::CVRPTW::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::CVRPTW::Geocode*>(_impl_.depot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::CVRPTW::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.depot_ = reinterpret_cast<::CVRPTW::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:CVRPTW.CVRPTW.depot)
}

// required int32 NumberOfVehicles = 3;
inline bool CVRPTW::has_numberofvehicles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CVRPTW::clear_numberofvehicles() {
  _impl_.numberofvehicles_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CVRPTW::numberofvehicles() const {
  // @@protoc_insertion_point(field_get:CVRPTW.CVRPTW.NumberOfVehicles)
  return _internal_numberofvehicles();
}
inline void CVRPTW::set_numberofvehicles(::int32_t value) {
  _internal_set_numberofvehicles(value);
  // @@protoc_insertion_point(field_set:CVRPTW.CVRPTW.NumberOfVehicles)
}
inline ::int32_t CVRPTW::_internal_numberofvehicles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numberofvehicles_;
}
inline void CVRPTW::_internal_set_numberofvehicles(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.numberofvehicles_ = value;
}

// required float VehicleCapacity = 4;
inline bool CVRPTW::has_vehiclecapacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CVRPTW::clear_vehiclecapacity() {
  _impl_.vehiclecapacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CVRPTW::vehiclecapacity() const {
  // @@protoc_insertion_point(field_get:CVRPTW.CVRPTW.VehicleCapacity)
  return _internal_vehiclecapacity();
}
inline void CVRPTW::set_vehiclecapacity(float value) {
  _internal_set_vehiclecapacity(value);
  // @@protoc_insertion_point(field_set:CVRPTW.CVRPTW.VehicleCapacity)
}
inline float CVRPTW::_internal_vehiclecapacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehiclecapacity_;
}
inline void CVRPTW::_internal_set_vehiclecapacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.vehiclecapacity_ = value;
}

// optional .CVRPTW.CVRPTW.eDistanceType distancetype = 5 [default = RoadNetwork];
inline bool CVRPTW::has_distancetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CVRPTW::clear_distancetype() {
  _impl_.distancetype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::CVRPTW::CVRPTW_eDistanceType CVRPTW::distancetype() const {
  // @@protoc_insertion_point(field_get:CVRPTW.CVRPTW.distancetype)
  return _internal_distancetype();
}
inline void CVRPTW::set_distancetype(::CVRPTW::CVRPTW_eDistanceType value) {
  _internal_set_distancetype(value);
  // @@protoc_insertion_point(field_set:CVRPTW.CVRPTW.distancetype)
}
inline ::CVRPTW::CVRPTW_eDistanceType CVRPTW::_internal_distancetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CVRPTW::CVRPTW_eDistanceType>(_impl_.distancetype_);
}
inline void CVRPTW::_internal_set_distancetype(::CVRPTW::CVRPTW_eDistanceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CVRPTW::CVRPTW_eDistanceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.distancetype_ = value;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .CVRPTW.CVRPTW model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CVRPTW::CVRPTW& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CVRPTW::CVRPTW* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::CVRPTW::CVRPTW&>(::CVRPTW::_CVRPTW_default_instance_);
}
inline const ::CVRPTW::CVRPTW& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::CVRPTW::CVRPTW* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::CVRPTW::CVRPTW*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CVRPTW.SolveRequest.model)
}
inline ::CVRPTW::CVRPTW* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CVRPTW::CVRPTW* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CVRPTW::CVRPTW* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CVRPTW.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CVRPTW::CVRPTW* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::CVRPTW::CVRPTW* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::CVRPTW::CVRPTW>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::CVRPTW::CVRPTW*>(p);
  }
  return _impl_.model_;
}
inline ::CVRPTW::CVRPTW* SolveRequest::mutable_model() {
  ::CVRPTW::CVRPTW* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:CVRPTW.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::CVRPTW::CVRPTW* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::CVRPTW::CVRPTW*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::CVRPTW::CVRPTW*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::CVRPTW::CVRPTW*>(value);
  // @@protoc_insertion_point(field_set_allocated:CVRPTW.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVRPTW.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:CVRPTW.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CVRPTW.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVRPTW.SolveRequest.modelID)
}

// repeated string visitSequence = 3;
inline int SolveRequest::_internal_visitsequence_size() const {
  return _internal_visitsequence().size();
}
inline int SolveRequest::visitsequence_size() const {
  return _internal_visitsequence_size();
}
inline void SolveRequest::clear_visitsequence() {
  _internal_mutable_visitsequence()->Clear();
}
inline std::string* SolveRequest::add_visitsequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_visitsequence()->Add();
  // @@protoc_insertion_point(field_add_mutable:CVRPTW.SolveRequest.visitSequence)
  return _s;
}
inline const std::string& SolveRequest::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolveRequest.visitSequence)
  return _internal_visitsequence().Get(index);
}
inline std::string* SolveRequest::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:CVRPTW.SolveRequest.visitSequence)
  return _internal_mutable_visitsequence()->Mutable(index);
}
inline void SolveRequest::set_visitsequence(int index, const std::string& value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, std::string&& value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_visitsequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, absl::string_view value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CVRPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:CVRPTW.SolveRequest.visitSequence)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolveRequest::visitsequence() const {
  // @@protoc_insertion_point(field_list:CVRPTW.SolveRequest.visitSequence)
  return _internal_visitsequence();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolveRequest::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.SolveRequest.visitSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitsequence();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolveRequest::_internal_visitsequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolveRequest::_internal_mutable_visitsequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitsequence_;
}

// optional .CVRPTW.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::CVRPTW::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::CVRPTW::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:CVRPTW.SolveRequest.solveType)
}
inline ::CVRPTW::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CVRPTW::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::CVRPTW::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CVRPTW::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// Edge_Geometry

// required float x = 1;
inline bool Edge_Geometry::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Edge_Geometry::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Edge_Geometry::x() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Edge.Geometry.x)
  return _internal_x();
}
inline void Edge_Geometry::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Edge.Geometry.x)
}
inline float Edge_Geometry::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Edge_Geometry::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Edge_Geometry::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Edge_Geometry::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Edge_Geometry::y() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Edge.Geometry.y)
  return _internal_y();
}
inline void Edge_Geometry::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Edge.Geometry.y)
}
inline float Edge_Geometry::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Edge_Geometry::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Edge

// required string from = 1;
inline bool Edge::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Edge::clear_from() {
  _impl_.from_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Edge::from() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Edge.from)
  return _internal_from();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Edge::set_from(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVRPTW.Edge.from)
}
inline std::string* Edge::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:CVRPTW.Edge.from)
  return _s;
}
inline const std::string& Edge::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_.Get();
}
inline void Edge::_internal_set_from(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* Edge::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.from_.Mutable( GetArenaForAllocation());
}
inline std::string* Edge::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CVRPTW.Edge.from)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.from_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Edge::set_allocated_from(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_.IsDefault()) {
          _impl_.from_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVRPTW.Edge.from)
}

// required string to = 2;
inline bool Edge::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Edge::clear_to() {
  _impl_.to_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Edge::to() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Edge.to)
  return _internal_to();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Edge::set_to(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVRPTW.Edge.to)
}
inline std::string* Edge::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:CVRPTW.Edge.to)
  return _s;
}
inline const std::string& Edge::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_.Get();
}
inline void Edge::_internal_set_to(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* Edge::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.to_.Mutable( GetArenaForAllocation());
}
inline std::string* Edge::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CVRPTW.Edge.to)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.to_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.to_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Edge::set_allocated_to(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.to_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_.IsDefault()) {
          _impl_.to_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVRPTW.Edge.to)
}

// optional float distance = 3;
inline bool Edge::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Edge::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Edge::distance() const {
  // @@protoc_insertion_point(field_get:CVRPTW.Edge.distance)
  return _internal_distance();
}
inline void Edge::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:CVRPTW.Edge.distance)
}
inline float Edge::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void Edge::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.distance_ = value;
}

// repeated .CVRPTW.Edge.Geometry geometry = 5;
inline int Edge::_internal_geometry_size() const {
  return _internal_geometry().size();
}
inline int Edge::geometry_size() const {
  return _internal_geometry_size();
}
inline void Edge::clear_geometry() {
  _internal_mutable_geometry()->Clear();
}
inline ::CVRPTW::Edge_Geometry* Edge::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:CVRPTW.Edge.geometry)
  return _internal_mutable_geometry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge_Geometry >*
Edge::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.Edge.geometry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometry();
}
inline const ::CVRPTW::Edge_Geometry& Edge::geometry(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.Edge.geometry)
    return _internal_geometry().Get(index);
}
inline ::CVRPTW::Edge_Geometry* Edge::add_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CVRPTW::Edge_Geometry* _add = _internal_mutable_geometry()->Add();
  // @@protoc_insertion_point(field_add:CVRPTW.Edge.geometry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge_Geometry >&
Edge::geometry() const {
  // @@protoc_insertion_point(field_list:CVRPTW.Edge.geometry)
  return _internal_geometry();
}
inline const ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge_Geometry>&
Edge::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometry_;
}
inline ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge_Geometry>*
Edge::_internal_mutable_geometry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// repeated string sequence = 1;
inline int SolutionResponse_Route::_internal_sequence_size() const {
  return _internal_sequence().size();
}
inline int SolutionResponse_Route::sequence_size() const {
  return _internal_sequence_size();
}
inline void SolutionResponse_Route::clear_sequence() {
  _internal_mutable_sequence()->Clear();
}
inline std::string* SolutionResponse_Route::add_sequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_sequence()->Add();
  // @@protoc_insertion_point(field_add_mutable:CVRPTW.SolutionResponse.Route.sequence)
  return _s;
}
inline const std::string& SolutionResponse_Route::sequence(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolutionResponse.Route.sequence)
  return _internal_sequence().Get(index);
}
inline std::string* SolutionResponse_Route::mutable_sequence(int index) {
  // @@protoc_insertion_point(field_mutable:CVRPTW.SolutionResponse.Route.sequence)
  return _internal_mutable_sequence()->Mutable(index);
}
inline void SolutionResponse_Route::set_sequence(int index, const std::string& value) {
  _internal_mutable_sequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::set_sequence(int index, std::string&& value) {
  _internal_mutable_sequence()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::set_sequence(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_sequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::set_sequence(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_sequence()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::set_sequence(int index, absl::string_view value) {
  _internal_mutable_sequence()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::add_sequence(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::add_sequence(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sequence()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::add_sequence(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::add_sequence(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sequence()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CVRPTW.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::add_sequence(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sequence()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:CVRPTW.SolutionResponse.Route.sequence)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Route::sequence() const {
  // @@protoc_insertion_point(field_list:CVRPTW.SolutionResponse.Route.sequence)
  return _internal_sequence();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_Route::mutable_sequence() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.SolutionResponse.Route.sequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sequence();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Route::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_Route::_internal_mutable_sequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sequence_;
}

// repeated .CVRPTW.Edge edges = 2;
inline int SolutionResponse_Route::_internal_edges_size() const {
  return _internal_edges().size();
}
inline int SolutionResponse_Route::edges_size() const {
  return _internal_edges_size();
}
inline void SolutionResponse_Route::clear_edges() {
  _internal_mutable_edges()->Clear();
}
inline ::CVRPTW::Edge* SolutionResponse_Route::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:CVRPTW.SolutionResponse.Route.edges)
  return _internal_mutable_edges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge >*
SolutionResponse_Route::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.SolutionResponse.Route.edges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_edges();
}
inline const ::CVRPTW::Edge& SolutionResponse_Route::edges(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolutionResponse.Route.edges)
    return _internal_edges().Get(index);
}
inline ::CVRPTW::Edge* SolutionResponse_Route::add_edges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CVRPTW::Edge* _add = _internal_mutable_edges()->Add();
  // @@protoc_insertion_point(field_add:CVRPTW.SolutionResponse.Route.edges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRPTW::Edge >&
SolutionResponse_Route::edges() const {
  // @@protoc_insertion_point(field_list:CVRPTW.SolutionResponse.Route.edges)
  return _internal_edges();
}
inline const ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge>&
SolutionResponse_Route::_internal_edges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.edges_;
}
inline ::google::protobuf::RepeatedPtrField<::CVRPTW::Edge>*
SolutionResponse_Route::_internal_mutable_edges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.edges_;
}

// repeated float visitCapacities = 3;
inline int SolutionResponse_Route::_internal_visitcapacities_size() const {
  return _internal_visitcapacities().size();
}
inline int SolutionResponse_Route::visitcapacities_size() const {
  return _internal_visitcapacities_size();
}
inline void SolutionResponse_Route::clear_visitcapacities() {
  _internal_mutable_visitcapacities()->Clear();
}
inline float SolutionResponse_Route::visitcapacities(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolutionResponse.Route.visitCapacities)
  return _internal_visitcapacities().Get(index);
}
inline void SolutionResponse_Route::set_visitcapacities(int index, float value) {
  _internal_mutable_visitcapacities()->Set(index, value);
  // @@protoc_insertion_point(field_set:CVRPTW.SolutionResponse.Route.visitCapacities)
}
inline void SolutionResponse_Route::add_visitcapacities(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitcapacities()->Add(value);
  // @@protoc_insertion_point(field_add:CVRPTW.SolutionResponse.Route.visitCapacities)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::visitcapacities() const {
  // @@protoc_insertion_point(field_list:CVRPTW.SolutionResponse.Route.visitCapacities)
  return _internal_visitcapacities();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::mutable_visitcapacities() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.SolutionResponse.Route.visitCapacities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitcapacities();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::_internal_visitcapacities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitcapacities_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::_internal_mutable_visitcapacities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitcapacities_;
}

// repeated float arrivalTimes = 4;
inline int SolutionResponse_Route::_internal_arrivaltimes_size() const {
  return _internal_arrivaltimes().size();
}
inline int SolutionResponse_Route::arrivaltimes_size() const {
  return _internal_arrivaltimes_size();
}
inline void SolutionResponse_Route::clear_arrivaltimes() {
  _internal_mutable_arrivaltimes()->Clear();
}
inline float SolutionResponse_Route::arrivaltimes(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolutionResponse.Route.arrivalTimes)
  return _internal_arrivaltimes().Get(index);
}
inline void SolutionResponse_Route::set_arrivaltimes(int index, float value) {
  _internal_mutable_arrivaltimes()->Set(index, value);
  // @@protoc_insertion_point(field_set:CVRPTW.SolutionResponse.Route.arrivalTimes)
}
inline void SolutionResponse_Route::add_arrivaltimes(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_arrivaltimes()->Add(value);
  // @@protoc_insertion_point(field_add:CVRPTW.SolutionResponse.Route.arrivalTimes)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::arrivaltimes() const {
  // @@protoc_insertion_point(field_list:CVRPTW.SolutionResponse.Route.arrivalTimes)
  return _internal_arrivaltimes();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::mutable_arrivaltimes() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.SolutionResponse.Route.arrivalTimes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arrivaltimes();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::_internal_arrivaltimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrivaltimes_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::_internal_mutable_arrivaltimes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arrivaltimes_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated .CVRPTW.SolutionResponse.Route routes = 1;
inline int SolutionResponse::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolutionResponse::routes_size() const {
  return _internal_routes_size();
}
inline void SolutionResponse::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::CVRPTW::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:CVRPTW.SolutionResponse.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRPTW::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:CVRPTW.SolutionResponse.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::CVRPTW::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolutionResponse.routes)
    return _internal_routes().Get(index);
}
inline ::CVRPTW::SolutionResponse_Route* SolutionResponse::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CVRPTW::SolutionResponse_Route* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:CVRPTW.SolutionResponse.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRPTW::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:CVRPTW.SolutionResponse.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::CVRPTW::SolutionResponse_Route>&
SolutionResponse::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::CVRPTW::SolutionResponse_Route>*
SolutionResponse::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// required float objective = 2;
inline bool SolutionResponse::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse::clear_objective() {
  _impl_.objective_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:CVRPTW.SolutionResponse.objective)
  return _internal_objective();
}
inline void SolutionResponse::set_objective(float value) {
  _internal_set_objective(value);
  // @@protoc_insertion_point(field_set:CVRPTW.SolutionResponse.objective)
}
inline float SolutionResponse::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objective_;
}
inline void SolutionResponse::_internal_set_objective(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.objective_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace CVRPTW


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::CVRPTW::CVRPTW_eDistanceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CVRPTW::CVRPTW_eDistanceType>() {
  return ::CVRPTW::CVRPTW_eDistanceType_descriptor();
}
template <>
struct is_proto_enum<::CVRPTW::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CVRPTW::SolveRequest_SolveType>() {
  return ::CVRPTW::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cvrptw_2dacyas3nzweqb_2eproto_2epb_2eh
