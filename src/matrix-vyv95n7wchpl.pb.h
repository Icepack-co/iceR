// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: matrix-vyv95n7wchpl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_matrix_2dvyv95n7wchpl_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_matrix_2dvyv95n7wchpl_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_matrix_2dvyv95n7wchpl_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_matrix_2dvyv95n7wchpl_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_matrix_2dvyv95n7wchpl_2eproto;
namespace Matrix {
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class MatrixRequest;
struct MatrixRequestDefaultTypeInternal;
extern MatrixRequestDefaultTypeInternal _MatrixRequest_default_instance_;
class MatrixResponse;
struct MatrixResponseDefaultTypeInternal;
extern MatrixResponseDefaultTypeInternal _MatrixResponse_default_instance_;
class MatrixResponse_Element;
struct MatrixResponse_ElementDefaultTypeInternal;
extern MatrixResponse_ElementDefaultTypeInternal _MatrixResponse_Element_default_instance_;
}  // namespace Matrix
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace Matrix {
enum MatrixRequest_eDurationUnit : int {
  MatrixRequest_eDurationUnit_SECONDS = 0,
  MatrixRequest_eDurationUnit_MINUTES = 1,
  MatrixRequest_eDurationUnit_HOURS = 2,
  MatrixRequest_eDurationUnit_DAYS = 3,
};

bool MatrixRequest_eDurationUnit_IsValid(int value);
constexpr MatrixRequest_eDurationUnit MatrixRequest_eDurationUnit_eDurationUnit_MIN = static_cast<MatrixRequest_eDurationUnit>(0);
constexpr MatrixRequest_eDurationUnit MatrixRequest_eDurationUnit_eDurationUnit_MAX = static_cast<MatrixRequest_eDurationUnit>(3);
constexpr int MatrixRequest_eDurationUnit_eDurationUnit_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
MatrixRequest_eDurationUnit_descriptor();
template <typename T>
const std::string& MatrixRequest_eDurationUnit_Name(T value) {
  static_assert(std::is_same<T, MatrixRequest_eDurationUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eDurationUnit_Name().");
  return MatrixRequest_eDurationUnit_Name(static_cast<MatrixRequest_eDurationUnit>(value));
}
template <>
inline const std::string& MatrixRequest_eDurationUnit_Name(MatrixRequest_eDurationUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MatrixRequest_eDurationUnit_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool MatrixRequest_eDurationUnit_Parse(absl::string_view name, MatrixRequest_eDurationUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatrixRequest_eDurationUnit>(
      MatrixRequest_eDurationUnit_descriptor(), name, value);
}
enum MatrixRequest_eDistanceUnit : int {
  MatrixRequest_eDistanceUnit_KILOMETRES = 0,
  MatrixRequest_eDistanceUnit_MILES = 1,
};

bool MatrixRequest_eDistanceUnit_IsValid(int value);
constexpr MatrixRequest_eDistanceUnit MatrixRequest_eDistanceUnit_eDistanceUnit_MIN = static_cast<MatrixRequest_eDistanceUnit>(0);
constexpr MatrixRequest_eDistanceUnit MatrixRequest_eDistanceUnit_eDistanceUnit_MAX = static_cast<MatrixRequest_eDistanceUnit>(1);
constexpr int MatrixRequest_eDistanceUnit_eDistanceUnit_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
MatrixRequest_eDistanceUnit_descriptor();
template <typename T>
const std::string& MatrixRequest_eDistanceUnit_Name(T value) {
  static_assert(std::is_same<T, MatrixRequest_eDistanceUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eDistanceUnit_Name().");
  return MatrixRequest_eDistanceUnit_Name(static_cast<MatrixRequest_eDistanceUnit>(value));
}
template <>
inline const std::string& MatrixRequest_eDistanceUnit_Name(MatrixRequest_eDistanceUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MatrixRequest_eDistanceUnit_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool MatrixRequest_eDistanceUnit_Parse(absl::string_view name, MatrixRequest_eDistanceUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatrixRequest_eDistanceUnit>(
      MatrixRequest_eDistanceUnit_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Matrix.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Matrix.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:Matrix.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float longitude_;
    float latitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_matrix_2dvyv95n7wchpl_2eproto;
};// -------------------------------------------------------------------

class Location final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Matrix.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Location(::google::protobuf::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Matrix.Location";
  }
  protected:
  explicit Location(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGeocodeFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .Matrix.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode() ;
  const ::Matrix::Geocode& geocode() const;
  PROTOBUF_NODISCARD ::Matrix::Geocode* release_geocode();
  ::Matrix::Geocode* mutable_geocode();
  void set_allocated_geocode(::Matrix::Geocode* value);
  void unsafe_arena_set_allocated_geocode(::Matrix::Geocode* value);
  ::Matrix::Geocode* unsafe_arena_release_geocode();

  private:
  const ::Matrix::Geocode& _internal_geocode() const;
  ::Matrix::Geocode* _internal_mutable_geocode();

  public:
  // @@protoc_insertion_point(class_scope:Matrix.Location)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 26, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::Matrix::Geocode* geocode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_matrix_2dvyv95n7wchpl_2eproto;
};// -------------------------------------------------------------------

class MatrixRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Matrix.MatrixRequest) */ {
 public:
  inline MatrixRequest() : MatrixRequest(nullptr) {}
  ~MatrixRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MatrixRequest(::google::protobuf::internal::ConstantInitialized);

  MatrixRequest(const MatrixRequest& from);
  MatrixRequest(MatrixRequest&& from) noexcept
    : MatrixRequest() {
    *this = ::std::move(from);
  }

  inline MatrixRequest& operator=(const MatrixRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatrixRequest& operator=(MatrixRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatrixRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatrixRequest* internal_default_instance() {
    return reinterpret_cast<const MatrixRequest*>(
               &_MatrixRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MatrixRequest& a, MatrixRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MatrixRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatrixRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatrixRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatrixRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatrixRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MatrixRequest& from) {
    MatrixRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatrixRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Matrix.MatrixRequest";
  }
  protected:
  explicit MatrixRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eDurationUnit = MatrixRequest_eDurationUnit;
  static constexpr eDurationUnit SECONDS = MatrixRequest_eDurationUnit_SECONDS;
  static constexpr eDurationUnit MINUTES = MatrixRequest_eDurationUnit_MINUTES;
  static constexpr eDurationUnit HOURS = MatrixRequest_eDurationUnit_HOURS;
  static constexpr eDurationUnit DAYS = MatrixRequest_eDurationUnit_DAYS;
  static inline bool eDurationUnit_IsValid(int value) {
    return MatrixRequest_eDurationUnit_IsValid(value);
  }
  static constexpr eDurationUnit eDurationUnit_MIN = MatrixRequest_eDurationUnit_eDurationUnit_MIN;
  static constexpr eDurationUnit eDurationUnit_MAX = MatrixRequest_eDurationUnit_eDurationUnit_MAX;
  static constexpr int eDurationUnit_ARRAYSIZE = MatrixRequest_eDurationUnit_eDurationUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eDurationUnit_descriptor() {
    return MatrixRequest_eDurationUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eDurationUnit_Name(T value) {
    return MatrixRequest_eDurationUnit_Name(value);
  }
  static inline bool eDurationUnit_Parse(absl::string_view name, eDurationUnit* value) {
    return MatrixRequest_eDurationUnit_Parse(name, value);
  }

  using eDistanceUnit = MatrixRequest_eDistanceUnit;
  static constexpr eDistanceUnit KILOMETRES = MatrixRequest_eDistanceUnit_KILOMETRES;
  static constexpr eDistanceUnit MILES = MatrixRequest_eDistanceUnit_MILES;
  static inline bool eDistanceUnit_IsValid(int value) {
    return MatrixRequest_eDistanceUnit_IsValid(value);
  }
  static constexpr eDistanceUnit eDistanceUnit_MIN = MatrixRequest_eDistanceUnit_eDistanceUnit_MIN;
  static constexpr eDistanceUnit eDistanceUnit_MAX = MatrixRequest_eDistanceUnit_eDistanceUnit_MAX;
  static constexpr int eDistanceUnit_ARRAYSIZE = MatrixRequest_eDistanceUnit_eDistanceUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eDistanceUnit_descriptor() {
    return MatrixRequest_eDistanceUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eDistanceUnit_Name(T value) {
    return MatrixRequest_eDistanceUnit_Name(value);
  }
  static inline bool eDistanceUnit_Parse(absl::string_view name, eDistanceUnit* value) {
    return MatrixRequest_eDistanceUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 1,
    kSourcesFieldNumber = 2,
    kDestinationsFieldNumber = 3,
    kDistanceUnitFieldNumber = 4,
    kDurationUnitFieldNumber = 5,
  };
  // repeated .Matrix.Location locations = 1;
  int locations_size() const;
  private:
  int _internal_locations_size() const;

  public:
  void clear_locations() ;
  ::Matrix::Location* mutable_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::Matrix::Location >*
      mutable_locations();
  private:
  const ::google::protobuf::RepeatedPtrField<::Matrix::Location>& _internal_locations() const;
  ::google::protobuf::RepeatedPtrField<::Matrix::Location>* _internal_mutable_locations();
  public:
  const ::Matrix::Location& locations(int index) const;
  ::Matrix::Location* add_locations();
  const ::google::protobuf::RepeatedPtrField< ::Matrix::Location >&
      locations() const;
  // repeated string sources = 2;
  int sources_size() const;
  private:
  int _internal_sources_size() const;

  public:
  void clear_sources() ;
  const std::string& sources(int index) const;
  std::string* mutable_sources(int index);
  void set_sources(int index, const std::string& value);
  void set_sources(int index, std::string&& value);
  void set_sources(int index, const char* value);
  void set_sources(int index, const char* value, std::size_t size);
  void set_sources(int index, absl::string_view value);
  std::string* add_sources();
  void add_sources(const std::string& value);
  void add_sources(std::string&& value);
  void add_sources(const char* value);
  void add_sources(const char* value, std::size_t size);
  void add_sources(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_sources();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_sources();

  public:
  // repeated string destinations = 3;
  int destinations_size() const;
  private:
  int _internal_destinations_size() const;

  public:
  void clear_destinations() ;
  const std::string& destinations(int index) const;
  std::string* mutable_destinations(int index);
  void set_destinations(int index, const std::string& value);
  void set_destinations(int index, std::string&& value);
  void set_destinations(int index, const char* value);
  void set_destinations(int index, const char* value, std::size_t size);
  void set_destinations(int index, absl::string_view value);
  std::string* add_destinations();
  void add_destinations(const std::string& value);
  void add_destinations(std::string&& value);
  void add_destinations(const char* value);
  void add_destinations(const char* value, std::size_t size);
  void add_destinations(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& destinations() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_destinations();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_destinations() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_destinations();

  public:
  // required .Matrix.MatrixRequest.eDistanceUnit distanceUnit = 4 [default = KILOMETRES];
  bool has_distanceunit() const;
  void clear_distanceunit() ;
  ::Matrix::MatrixRequest_eDistanceUnit distanceunit() const;
  void set_distanceunit(::Matrix::MatrixRequest_eDistanceUnit value);

  private:
  ::Matrix::MatrixRequest_eDistanceUnit _internal_distanceunit() const;
  void _internal_set_distanceunit(::Matrix::MatrixRequest_eDistanceUnit value);

  public:
  // required .Matrix.MatrixRequest.eDurationUnit durationUnit = 5 [default = MINUTES];
  bool has_durationunit() const;
  void clear_durationunit() ;
  ::Matrix::MatrixRequest_eDurationUnit durationunit() const;
  void set_durationunit(::Matrix::MatrixRequest_eDurationUnit value);

  private:
  ::Matrix::MatrixRequest_eDurationUnit _internal_durationunit() const;
  void _internal_set_durationunit(::Matrix::MatrixRequest_eDurationUnit value);

  public:
  // @@protoc_insertion_point(class_scope:Matrix.MatrixRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::Matrix::Location > locations_;
    ::google::protobuf::RepeatedPtrField<std::string> sources_;
    ::google::protobuf::RepeatedPtrField<std::string> destinations_;
    int distanceunit_;
    int durationunit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_matrix_2dvyv95n7wchpl_2eproto;
};// -------------------------------------------------------------------

class MatrixResponse_Element final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Matrix.MatrixResponse.Element) */ {
 public:
  inline MatrixResponse_Element() : MatrixResponse_Element(nullptr) {}
  ~MatrixResponse_Element() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MatrixResponse_Element(::google::protobuf::internal::ConstantInitialized);

  MatrixResponse_Element(const MatrixResponse_Element& from);
  MatrixResponse_Element(MatrixResponse_Element&& from) noexcept
    : MatrixResponse_Element() {
    *this = ::std::move(from);
  }

  inline MatrixResponse_Element& operator=(const MatrixResponse_Element& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatrixResponse_Element& operator=(MatrixResponse_Element&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatrixResponse_Element& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatrixResponse_Element* internal_default_instance() {
    return reinterpret_cast<const MatrixResponse_Element*>(
               &_MatrixResponse_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MatrixResponse_Element& a, MatrixResponse_Element& b) {
    a.Swap(&b);
  }
  inline void Swap(MatrixResponse_Element* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatrixResponse_Element* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatrixResponse_Element* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatrixResponse_Element>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatrixResponse_Element& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MatrixResponse_Element& from) {
    MatrixResponse_Element::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatrixResponse_Element* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Matrix.MatrixResponse.Element";
  }
  protected:
  explicit MatrixResponse_Element(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromIdFieldNumber = 1,
    kToIdFieldNumber = 2,
    kDistanceFieldNumber = 3,
    kDurationFieldNumber = 4,
  };
  // required string fromId = 1;
  bool has_fromid() const;
  void clear_fromid() ;
  const std::string& fromid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromid(Arg_&& arg, Args_... args);
  std::string* mutable_fromid();
  PROTOBUF_NODISCARD std::string* release_fromid();
  void set_allocated_fromid(std::string* ptr);

  private:
  const std::string& _internal_fromid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromid(
      const std::string& value);
  std::string* _internal_mutable_fromid();

  public:
  // required string toId = 2;
  bool has_toid() const;
  void clear_toid() ;
  const std::string& toid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_toid(Arg_&& arg, Args_... args);
  std::string* mutable_toid();
  PROTOBUF_NODISCARD std::string* release_toid();
  void set_allocated_toid(std::string* ptr);

  private:
  const std::string& _internal_toid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toid(
      const std::string& value);
  std::string* _internal_mutable_toid();

  public:
  // required float distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  // required float duration = 4;
  bool has_duration() const;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // @@protoc_insertion_point(class_scope:Matrix.MatrixResponse.Element)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr fromid_;
    ::google::protobuf::internal::ArenaStringPtr toid_;
    float distance_;
    float duration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_matrix_2dvyv95n7wchpl_2eproto;
};// -------------------------------------------------------------------

class MatrixResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Matrix.MatrixResponse) */ {
 public:
  inline MatrixResponse() : MatrixResponse(nullptr) {}
  ~MatrixResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MatrixResponse(::google::protobuf::internal::ConstantInitialized);

  MatrixResponse(const MatrixResponse& from);
  MatrixResponse(MatrixResponse&& from) noexcept
    : MatrixResponse() {
    *this = ::std::move(from);
  }

  inline MatrixResponse& operator=(const MatrixResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatrixResponse& operator=(MatrixResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatrixResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatrixResponse* internal_default_instance() {
    return reinterpret_cast<const MatrixResponse*>(
               &_MatrixResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MatrixResponse& a, MatrixResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MatrixResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatrixResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatrixResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatrixResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatrixResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MatrixResponse& from) {
    MatrixResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatrixResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Matrix.MatrixResponse";
  }
  protected:
  explicit MatrixResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MatrixResponse_Element Element;

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .Matrix.MatrixResponse.Element elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;

  public:
  void clear_elements() ;
  ::Matrix::MatrixResponse_Element* mutable_elements(int index);
  ::google::protobuf::RepeatedPtrField< ::Matrix::MatrixResponse_Element >*
      mutable_elements();
  private:
  const ::google::protobuf::RepeatedPtrField<::Matrix::MatrixResponse_Element>& _internal_elements() const;
  ::google::protobuf::RepeatedPtrField<::Matrix::MatrixResponse_Element>* _internal_mutable_elements();
  public:
  const ::Matrix::MatrixResponse_Element& elements(int index) const;
  ::Matrix::MatrixResponse_Element* add_elements();
  const ::google::protobuf::RepeatedPtrField< ::Matrix::MatrixResponse_Element >&
      elements() const;
  // @@protoc_insertion_point(class_scope:Matrix.MatrixResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::Matrix::MatrixResponse_Element > elements_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_matrix_2dvyv95n7wchpl_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:Matrix.Geocode.longitude)
  return _internal_longitude();
}
inline void Geocode::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:Matrix.Geocode.longitude)
}
inline float Geocode::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Geocode::_internal_set_longitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_ = value;
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:Matrix.Geocode.latitude)
  return _internal_latitude();
}
inline void Geocode::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:Matrix.Geocode.latitude)
}
inline float Geocode::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Geocode::_internal_set_latitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// Location

// required string id = 1;
inline bool Location::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Location::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:Matrix.Location.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Matrix.Location.id)
}
inline std::string* Location::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Matrix.Location.id)
  return _s;
}
inline const std::string& Location::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Location::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Location::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Matrix.Location.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Matrix.Location.id)
}

// required .Matrix.Geocode geocode = 2;
inline bool Location::has_geocode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geocode_ != nullptr);
  return value;
}
inline void Location::clear_geocode() {
  if (_impl_.geocode_ != nullptr) _impl_.geocode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Matrix::Geocode& Location::_internal_geocode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Matrix::Geocode* p = _impl_.geocode_;
  return p != nullptr ? *p : reinterpret_cast<const ::Matrix::Geocode&>(::Matrix::_Geocode_default_instance_);
}
inline const ::Matrix::Geocode& Location::geocode() const {
  // @@protoc_insertion_point(field_get:Matrix.Location.geocode)
  return _internal_geocode();
}
inline void Location::unsafe_arena_set_allocated_geocode(::Matrix::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geocode_);
  }
  _impl_.geocode_ = reinterpret_cast<::Matrix::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Matrix.Location.geocode)
}
inline ::Matrix::Geocode* Location::release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Matrix::Geocode* released = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Matrix::Geocode* Location::unsafe_arena_release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Matrix.Location.geocode)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Matrix::Geocode* temp = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
  return temp;
}
inline ::Matrix::Geocode* Location::_internal_mutable_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.geocode_ == nullptr) {
    auto* p = CreateMaybeMessage<::Matrix::Geocode>(GetArenaForAllocation());
    _impl_.geocode_ = reinterpret_cast<::Matrix::Geocode*>(p);
  }
  return _impl_.geocode_;
}
inline ::Matrix::Geocode* Location::mutable_geocode() {
  ::Matrix::Geocode* _msg = _internal_mutable_geocode();
  // @@protoc_insertion_point(field_mutable:Matrix.Location.geocode)
  return _msg;
}
inline void Location::set_allocated_geocode(::Matrix::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Matrix::Geocode*>(_impl_.geocode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::Matrix::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.geocode_ = reinterpret_cast<::Matrix::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:Matrix.Location.geocode)
}

// -------------------------------------------------------------------

// MatrixRequest

// repeated .Matrix.Location locations = 1;
inline int MatrixRequest::_internal_locations_size() const {
  return _internal_locations().size();
}
inline int MatrixRequest::locations_size() const {
  return _internal_locations_size();
}
inline void MatrixRequest::clear_locations() {
  _internal_mutable_locations()->Clear();
}
inline ::Matrix::Location* MatrixRequest::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:Matrix.MatrixRequest.locations)
  return _internal_mutable_locations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Matrix::Location >*
MatrixRequest::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:Matrix.MatrixRequest.locations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_locations();
}
inline const ::Matrix::Location& MatrixRequest::locations(int index) const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixRequest.locations)
    return _internal_locations().Get(index);
}
inline ::Matrix::Location* MatrixRequest::add_locations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Matrix::Location* _add = _internal_mutable_locations()->Add();
  // @@protoc_insertion_point(field_add:Matrix.MatrixRequest.locations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::Matrix::Location >&
MatrixRequest::locations() const {
  // @@protoc_insertion_point(field_list:Matrix.MatrixRequest.locations)
  return _internal_locations();
}
inline const ::google::protobuf::RepeatedPtrField<::Matrix::Location>&
MatrixRequest::_internal_locations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locations_;
}
inline ::google::protobuf::RepeatedPtrField<::Matrix::Location>*
MatrixRequest::_internal_mutable_locations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.locations_;
}

// repeated string sources = 2;
inline int MatrixRequest::_internal_sources_size() const {
  return _internal_sources().size();
}
inline int MatrixRequest::sources_size() const {
  return _internal_sources_size();
}
inline void MatrixRequest::clear_sources() {
  _internal_mutable_sources()->Clear();
}
inline std::string* MatrixRequest::add_sources() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_sources()->Add();
  // @@protoc_insertion_point(field_add_mutable:Matrix.MatrixRequest.sources)
  return _s;
}
inline const std::string& MatrixRequest::sources(int index) const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixRequest.sources)
  return _internal_sources().Get(index);
}
inline std::string* MatrixRequest::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:Matrix.MatrixRequest.sources)
  return _internal_mutable_sources()->Mutable(index);
}
inline void MatrixRequest::set_sources(int index, const std::string& value) {
  _internal_mutable_sources()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::set_sources(int index, std::string&& value) {
  _internal_mutable_sources()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::set_sources(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_sources()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::set_sources(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_sources()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::set_sources(int index, absl::string_view value) {
  _internal_mutable_sources()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::add_sources(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sources()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::add_sources(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sources()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::add_sources(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sources()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::add_sources(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sources()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Matrix.MatrixRequest.sources)
}
inline void MatrixRequest::add_sources(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sources()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:Matrix.MatrixRequest.sources)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MatrixRequest::sources() const {
  // @@protoc_insertion_point(field_list:Matrix.MatrixRequest.sources)
  return _internal_sources();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* MatrixRequest::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:Matrix.MatrixRequest.sources)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sources();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MatrixRequest::_internal_sources() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sources_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MatrixRequest::_internal_mutable_sources() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sources_;
}

// repeated string destinations = 3;
inline int MatrixRequest::_internal_destinations_size() const {
  return _internal_destinations().size();
}
inline int MatrixRequest::destinations_size() const {
  return _internal_destinations_size();
}
inline void MatrixRequest::clear_destinations() {
  _internal_mutable_destinations()->Clear();
}
inline std::string* MatrixRequest::add_destinations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_destinations()->Add();
  // @@protoc_insertion_point(field_add_mutable:Matrix.MatrixRequest.destinations)
  return _s;
}
inline const std::string& MatrixRequest::destinations(int index) const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixRequest.destinations)
  return _internal_destinations().Get(index);
}
inline std::string* MatrixRequest::mutable_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:Matrix.MatrixRequest.destinations)
  return _internal_mutable_destinations()->Mutable(index);
}
inline void MatrixRequest::set_destinations(int index, const std::string& value) {
  _internal_mutable_destinations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::set_destinations(int index, std::string&& value) {
  _internal_mutable_destinations()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::set_destinations(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_destinations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::set_destinations(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_destinations()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::set_destinations(int index, absl::string_view value) {
  _internal_mutable_destinations()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::add_destinations(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destinations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::add_destinations(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destinations()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::add_destinations(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destinations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::add_destinations(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destinations()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Matrix.MatrixRequest.destinations)
}
inline void MatrixRequest::add_destinations(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destinations()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:Matrix.MatrixRequest.destinations)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MatrixRequest::destinations() const {
  // @@protoc_insertion_point(field_list:Matrix.MatrixRequest.destinations)
  return _internal_destinations();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* MatrixRequest::mutable_destinations() {
  // @@protoc_insertion_point(field_mutable_list:Matrix.MatrixRequest.destinations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_destinations();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MatrixRequest::_internal_destinations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destinations_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MatrixRequest::_internal_mutable_destinations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.destinations_;
}

// required .Matrix.MatrixRequest.eDistanceUnit distanceUnit = 4 [default = KILOMETRES];
inline bool MatrixRequest::has_distanceunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MatrixRequest::clear_distanceunit() {
  _impl_.distanceunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Matrix::MatrixRequest_eDistanceUnit MatrixRequest::distanceunit() const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixRequest.distanceUnit)
  return _internal_distanceunit();
}
inline void MatrixRequest::set_distanceunit(::Matrix::MatrixRequest_eDistanceUnit value) {
  _internal_set_distanceunit(value);
  // @@protoc_insertion_point(field_set:Matrix.MatrixRequest.distanceUnit)
}
inline ::Matrix::MatrixRequest_eDistanceUnit MatrixRequest::_internal_distanceunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Matrix::MatrixRequest_eDistanceUnit>(_impl_.distanceunit_);
}
inline void MatrixRequest::_internal_set_distanceunit(::Matrix::MatrixRequest_eDistanceUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::Matrix::MatrixRequest_eDistanceUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.distanceunit_ = value;
}

// required .Matrix.MatrixRequest.eDurationUnit durationUnit = 5 [default = MINUTES];
inline bool MatrixRequest::has_durationunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MatrixRequest::clear_durationunit() {
  _impl_.durationunit_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Matrix::MatrixRequest_eDurationUnit MatrixRequest::durationunit() const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixRequest.durationUnit)
  return _internal_durationunit();
}
inline void MatrixRequest::set_durationunit(::Matrix::MatrixRequest_eDurationUnit value) {
  _internal_set_durationunit(value);
  // @@protoc_insertion_point(field_set:Matrix.MatrixRequest.durationUnit)
}
inline ::Matrix::MatrixRequest_eDurationUnit MatrixRequest::_internal_durationunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Matrix::MatrixRequest_eDurationUnit>(_impl_.durationunit_);
}
inline void MatrixRequest::_internal_set_durationunit(::Matrix::MatrixRequest_eDurationUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::Matrix::MatrixRequest_eDurationUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.durationunit_ = value;
}

// -------------------------------------------------------------------

// MatrixResponse_Element

// required string fromId = 1;
inline bool MatrixResponse_Element::has_fromid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MatrixResponse_Element::clear_fromid() {
  _impl_.fromid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MatrixResponse_Element::fromid() const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixResponse.Element.fromId)
  return _internal_fromid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatrixResponse_Element::set_fromid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Matrix.MatrixResponse.Element.fromId)
}
inline std::string* MatrixResponse_Element::mutable_fromid() {
  std::string* _s = _internal_mutable_fromid();
  // @@protoc_insertion_point(field_mutable:Matrix.MatrixResponse.Element.fromId)
  return _s;
}
inline const std::string& MatrixResponse_Element::_internal_fromid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromid_.Get();
}
inline void MatrixResponse_Element::_internal_set_fromid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(value, GetArenaForAllocation());
}
inline std::string* MatrixResponse_Element::_internal_mutable_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fromid_.Mutable( GetArenaForAllocation());
}
inline std::string* MatrixResponse_Element::release_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Matrix.MatrixResponse.Element.fromId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fromid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fromid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MatrixResponse_Element::set_allocated_fromid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fromid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromid_.IsDefault()) {
          _impl_.fromid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Matrix.MatrixResponse.Element.fromId)
}

// required string toId = 2;
inline bool MatrixResponse_Element::has_toid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MatrixResponse_Element::clear_toid() {
  _impl_.toid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MatrixResponse_Element::toid() const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixResponse.Element.toId)
  return _internal_toid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatrixResponse_Element::set_toid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Matrix.MatrixResponse.Element.toId)
}
inline std::string* MatrixResponse_Element::mutable_toid() {
  std::string* _s = _internal_mutable_toid();
  // @@protoc_insertion_point(field_mutable:Matrix.MatrixResponse.Element.toId)
  return _s;
}
inline const std::string& MatrixResponse_Element::_internal_toid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.toid_.Get();
}
inline void MatrixResponse_Element::_internal_set_toid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(value, GetArenaForAllocation());
}
inline std::string* MatrixResponse_Element::_internal_mutable_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.toid_.Mutable( GetArenaForAllocation());
}
inline std::string* MatrixResponse_Element::release_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Matrix.MatrixResponse.Element.toId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.toid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.toid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MatrixResponse_Element::set_allocated_toid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.toid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.toid_.IsDefault()) {
          _impl_.toid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Matrix.MatrixResponse.Element.toId)
}

// required float distance = 3;
inline bool MatrixResponse_Element::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MatrixResponse_Element::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float MatrixResponse_Element::distance() const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixResponse.Element.distance)
  return _internal_distance();
}
inline void MatrixResponse_Element::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:Matrix.MatrixResponse.Element.distance)
}
inline float MatrixResponse_Element::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void MatrixResponse_Element::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.distance_ = value;
}

// required float duration = 4;
inline bool MatrixResponse_Element::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MatrixResponse_Element::clear_duration() {
  _impl_.duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MatrixResponse_Element::duration() const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixResponse.Element.duration)
  return _internal_duration();
}
inline void MatrixResponse_Element::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:Matrix.MatrixResponse.Element.duration)
}
inline float MatrixResponse_Element::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void MatrixResponse_Element::_internal_set_duration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.duration_ = value;
}

// -------------------------------------------------------------------

// MatrixResponse

// repeated .Matrix.MatrixResponse.Element elements = 1;
inline int MatrixResponse::_internal_elements_size() const {
  return _internal_elements().size();
}
inline int MatrixResponse::elements_size() const {
  return _internal_elements_size();
}
inline void MatrixResponse::clear_elements() {
  _internal_mutable_elements()->Clear();
}
inline ::Matrix::MatrixResponse_Element* MatrixResponse::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Matrix.MatrixResponse.elements)
  return _internal_mutable_elements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Matrix::MatrixResponse_Element >*
MatrixResponse::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Matrix.MatrixResponse.elements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_elements();
}
inline const ::Matrix::MatrixResponse_Element& MatrixResponse::elements(int index) const {
  // @@protoc_insertion_point(field_get:Matrix.MatrixResponse.elements)
    return _internal_elements().Get(index);
}
inline ::Matrix::MatrixResponse_Element* MatrixResponse::add_elements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Matrix::MatrixResponse_Element* _add = _internal_mutable_elements()->Add();
  // @@protoc_insertion_point(field_add:Matrix.MatrixResponse.elements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::Matrix::MatrixResponse_Element >&
MatrixResponse::elements() const {
  // @@protoc_insertion_point(field_list:Matrix.MatrixResponse.elements)
  return _internal_elements();
}
inline const ::google::protobuf::RepeatedPtrField<::Matrix::MatrixResponse_Element>&
MatrixResponse::_internal_elements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elements_;
}
inline ::google::protobuf::RepeatedPtrField<::Matrix::MatrixResponse_Element>*
MatrixResponse::_internal_mutable_elements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.elements_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Matrix


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Matrix::MatrixRequest_eDurationUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Matrix::MatrixRequest_eDurationUnit>() {
  return ::Matrix::MatrixRequest_eDurationUnit_descriptor();
}
template <>
struct is_proto_enum<::Matrix::MatrixRequest_eDistanceUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Matrix::MatrixRequest_eDistanceUnit>() {
  return ::Matrix::MatrixRequest_eDistanceUnit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_matrix_2dvyv95n7wchpl_2eproto_2epb_2eh
