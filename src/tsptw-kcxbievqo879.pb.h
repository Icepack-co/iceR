// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tsptw-kcxbievqo879.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tsptw_2dkcxbievqo879_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tsptw_2dkcxbievqo879_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tsptw_2dkcxbievqo879_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_tsptw_2dkcxbievqo879_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tsptw_2dkcxbievqo879_2eproto;
namespace TSPTW {
class Edge;
struct EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Edge_Geometry;
struct Edge_GeometryDefaultTypeInternal;
extern Edge_GeometryDefaultTypeInternal _Edge_Geometry_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class TSP;
struct TSPDefaultTypeInternal;
extern TSPDefaultTypeInternal _TSP_default_instance_;
}  // namespace TSPTW
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace TSPTW {
enum TSP_eDistanceType : int {
  TSP_eDistanceType_RoadNetwork = 1,
  TSP_eDistanceType_Euclidean = 2,
  TSP_eDistanceType_Haversine = 3,
};

bool TSP_eDistanceType_IsValid(int value);
constexpr TSP_eDistanceType TSP_eDistanceType_eDistanceType_MIN = static_cast<TSP_eDistanceType>(1);
constexpr TSP_eDistanceType TSP_eDistanceType_eDistanceType_MAX = static_cast<TSP_eDistanceType>(3);
constexpr int TSP_eDistanceType_eDistanceType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TSP_eDistanceType_descriptor();
template <typename T>
const std::string& TSP_eDistanceType_Name(T value) {
  static_assert(std::is_same<T, TSP_eDistanceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eDistanceType_Name().");
  return TSP_eDistanceType_Name(static_cast<TSP_eDistanceType>(value));
}
template <>
inline const std::string& TSP_eDistanceType_Name(TSP_eDistanceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TSP_eDistanceType_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool TSP_eDistanceType_Parse(absl::string_view name, TSP_eDistanceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TSP_eDistanceType>(
      TSP_eDistanceType_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(2);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSPTW.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSPTW.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kWindowStartFieldNumber = 4,
    kWindowEndFieldNumber = 5,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float x = 2;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 3;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // optional float windowStart = 4;
  bool has_windowstart() const;
  void clear_windowstart() ;
  float windowstart() const;
  void set_windowstart(float value);

  private:
  float _internal_windowstart() const;
  void _internal_set_windowstart(float value);

  public:
  // optional float windowEnd = 5;
  bool has_windowend() const;
  void clear_windowend() ;
  float windowend() const;
  void set_windowend(float value);

  private:
  float _internal_windowend() const;
  void _internal_set_windowend(float value);

  public:
  // @@protoc_insertion_point(class_scope:TSPTW.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 24, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float x_;
    float y_;
    float windowstart_;
    float windowend_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsptw_2dkcxbievqo879_2eproto;
};// -------------------------------------------------------------------

class TSP final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSPTW.TSP) */ {
 public:
  inline TSP() : TSP(nullptr) {}
  ~TSP() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TSP(::google::protobuf::internal::ConstantInitialized);

  TSP(const TSP& from);
  TSP(TSP&& from) noexcept
    : TSP() {
    *this = ::std::move(from);
  }

  inline TSP& operator=(const TSP& from) {
    CopyFrom(from);
    return *this;
  }
  inline TSP& operator=(TSP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TSP& default_instance() {
    return *internal_default_instance();
  }
  static inline const TSP* internal_default_instance() {
    return reinterpret_cast<const TSP*>(
               &_TSP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TSP& a, TSP& b) {
    a.Swap(&b);
  }
  inline void Swap(TSP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TSP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TSP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TSP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TSP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TSP& from) {
    TSP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TSP* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSPTW.TSP";
  }
  protected:
  explicit TSP(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eDistanceType = TSP_eDistanceType;
  static constexpr eDistanceType RoadNetwork = TSP_eDistanceType_RoadNetwork;
  static constexpr eDistanceType Euclidean = TSP_eDistanceType_Euclidean;
  static constexpr eDistanceType Haversine = TSP_eDistanceType_Haversine;
  static inline bool eDistanceType_IsValid(int value) {
    return TSP_eDistanceType_IsValid(value);
  }
  static constexpr eDistanceType eDistanceType_MIN = TSP_eDistanceType_eDistanceType_MIN;
  static constexpr eDistanceType eDistanceType_MAX = TSP_eDistanceType_eDistanceType_MAX;
  static constexpr int eDistanceType_ARRAYSIZE = TSP_eDistanceType_eDistanceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eDistanceType_descriptor() {
    return TSP_eDistanceType_descriptor();
  }
  template <typename T>
  static inline const std::string& eDistanceType_Name(T value) {
    return TSP_eDistanceType_Name(value);
  }
  static inline bool eDistanceType_Parse(absl::string_view name, eDistanceType* value) {
    return TSP_eDistanceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kDistancetypeFieldNumber = 2,
  };
  // repeated .TSPTW.Geocode points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::TSPTW::Geocode* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::TSPTW::Geocode >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::TSPTW::Geocode>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::TSPTW::Geocode>* _internal_mutable_points();
  public:
  const ::TSPTW::Geocode& points(int index) const;
  ::TSPTW::Geocode* add_points();
  const ::google::protobuf::RepeatedPtrField< ::TSPTW::Geocode >&
      points() const;
  // optional .TSPTW.TSP.eDistanceType distancetype = 2 [default = RoadNetwork];
  bool has_distancetype() const;
  void clear_distancetype() ;
  ::TSPTW::TSP_eDistanceType distancetype() const;
  void set_distancetype(::TSPTW::TSP_eDistanceType value);

  private:
  ::TSPTW::TSP_eDistanceType _internal_distancetype() const;
  void _internal_set_distancetype(::TSPTW::TSP_eDistanceType value);

  public:
  // @@protoc_insertion_point(class_scope:TSPTW.TSP)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::TSPTW::Geocode > points_;
    int distancetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsptw_2dkcxbievqo879_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSPTW.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSPTW.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVisitSequenceFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated string visitSequence = 3;
  int visitsequence_size() const;
  private:
  int _internal_visitsequence_size() const;

  public:
  void clear_visitsequence() ;
  const std::string& visitsequence(int index) const;
  std::string* mutable_visitsequence(int index);
  void set_visitsequence(int index, const std::string& value);
  void set_visitsequence(int index, std::string&& value);
  void set_visitsequence(int index, const char* value);
  void set_visitsequence(int index, const char* value, std::size_t size);
  void set_visitsequence(int index, absl::string_view value);
  std::string* add_visitsequence();
  void add_visitsequence(const std::string& value);
  void add_visitsequence(std::string&& value);
  void add_visitsequence(const char* value);
  void add_visitsequence(const char* value, std::size_t size);
  void add_visitsequence(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& visitsequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_visitsequence();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_visitsequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_visitsequence();

  public:
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .TSPTW.TSP model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::TSPTW::TSP& model() const;
  PROTOBUF_NODISCARD ::TSPTW::TSP* release_model();
  ::TSPTW::TSP* mutable_model();
  void set_allocated_model(::TSPTW::TSP* value);
  void unsafe_arena_set_allocated_model(::TSPTW::TSP* value);
  ::TSPTW::TSP* unsafe_arena_release_model();

  private:
  const ::TSPTW::TSP& _internal_model() const;
  ::TSPTW::TSP* _internal_mutable_model();

  public:
  // optional .TSPTW.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::TSPTW::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::TSPTW::SolveRequest_SolveType value);

  private:
  ::TSPTW::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::TSPTW::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:TSPTW.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> visitsequence_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::TSPTW::TSP* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsptw_2dkcxbievqo879_2eproto;
};// -------------------------------------------------------------------

class Edge_Geometry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSPTW.Edge.Geometry) */ {
 public:
  inline Edge_Geometry() : Edge_Geometry(nullptr) {}
  ~Edge_Geometry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Edge_Geometry(::google::protobuf::internal::ConstantInitialized);

  Edge_Geometry(const Edge_Geometry& from);
  Edge_Geometry(Edge_Geometry&& from) noexcept
    : Edge_Geometry() {
    *this = ::std::move(from);
  }

  inline Edge_Geometry& operator=(const Edge_Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge_Geometry& operator=(Edge_Geometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge_Geometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge_Geometry* internal_default_instance() {
    return reinterpret_cast<const Edge_Geometry*>(
               &_Edge_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Edge_Geometry& a, Edge_Geometry& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge_Geometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge_Geometry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge_Geometry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge_Geometry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Edge_Geometry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Edge_Geometry& from) {
    Edge_Geometry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge_Geometry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSPTW.Edge.Geometry";
  }
  protected:
  explicit Edge_Geometry(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:TSPTW.Edge.Geometry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsptw_2dkcxbievqo879_2eproto;
};// -------------------------------------------------------------------

class Edge final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSPTW.Edge) */ {
 public:
  inline Edge() : Edge(nullptr) {}
  ~Edge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Edge(::google::protobuf::internal::ConstantInitialized);

  Edge(const Edge& from);
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge& operator=(Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Edge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Edge& from) {
    Edge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSPTW.Edge";
  }
  protected:
  explicit Edge(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Edge_Geometry Geometry;

  // accessors -------------------------------------------------------

  enum : int {
    kGeometryFieldNumber = 5,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kDistanceFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // repeated .TSPTW.Edge.Geometry geometry = 5;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;

  public:
  void clear_geometry() ;
  ::TSPTW::Edge_Geometry* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge_Geometry >*
      mutable_geometry();
  private:
  const ::google::protobuf::RepeatedPtrField<::TSPTW::Edge_Geometry>& _internal_geometry() const;
  ::google::protobuf::RepeatedPtrField<::TSPTW::Edge_Geometry>* _internal_mutable_geometry();
  public:
  const ::TSPTW::Edge_Geometry& geometry(int index) const;
  ::TSPTW::Edge_Geometry* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge_Geometry >&
      geometry() const;
  // required string from = 1;
  bool has_from() const;
  void clear_from() ;
  const std::string& from() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from(Arg_&& arg, Args_... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* ptr);

  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(
      const std::string& value);
  std::string* _internal_mutable_from();

  public:
  // required string to = 2;
  bool has_to() const;
  void clear_to() ;
  const std::string& to() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to(Arg_&& arg, Args_... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* ptr);

  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(
      const std::string& value);
  std::string* _internal_mutable_to();

  public:
  // optional float distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  // optional float time = 4;
  bool has_time() const;
  void clear_time() ;
  float time() const;
  void set_time(float value);

  private:
  float _internal_time() const;
  void _internal_set_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:TSPTW.Edge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 1, 25, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge_Geometry > geometry_;
    ::google::protobuf::internal::ArenaStringPtr from_;
    ::google::protobuf::internal::ArenaStringPtr to_;
    float distance_;
    float time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsptw_2dkcxbievqo879_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSPTW.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSPTW.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTourFieldNumber = 1,
    kEdgesFieldNumber = 2,
    kArrivalTimesFieldNumber = 3,
  };
  // repeated string tour = 1;
  int tour_size() const;
  private:
  int _internal_tour_size() const;

  public:
  void clear_tour() ;
  const std::string& tour(int index) const;
  std::string* mutable_tour(int index);
  void set_tour(int index, const std::string& value);
  void set_tour(int index, std::string&& value);
  void set_tour(int index, const char* value);
  void set_tour(int index, const char* value, std::size_t size);
  void set_tour(int index, absl::string_view value);
  std::string* add_tour();
  void add_tour(const std::string& value);
  void add_tour(std::string&& value);
  void add_tour(const char* value);
  void add_tour(const char* value, std::size_t size);
  void add_tour(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tour() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tour();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tour() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tour();

  public:
  // repeated .TSPTW.Edge edges = 2;
  int edges_size() const;
  private:
  int _internal_edges_size() const;

  public:
  void clear_edges() ;
  ::TSPTW::Edge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge >*
      mutable_edges();
  private:
  const ::google::protobuf::RepeatedPtrField<::TSPTW::Edge>& _internal_edges() const;
  ::google::protobuf::RepeatedPtrField<::TSPTW::Edge>* _internal_mutable_edges();
  public:
  const ::TSPTW::Edge& edges(int index) const;
  ::TSPTW::Edge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge >&
      edges() const;
  // repeated float arrivalTimes = 3;
  int arrivaltimes_size() const;
  private:
  int _internal_arrivaltimes_size() const;

  public:
  void clear_arrivaltimes() ;
  float arrivaltimes(int index) const;
  void set_arrivaltimes(int index, float value);
  void add_arrivaltimes(float value);
  const ::google::protobuf::RepeatedField<float>& arrivaltimes() const;
  ::google::protobuf::RepeatedField<float>* mutable_arrivaltimes();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_arrivaltimes() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_arrivaltimes();

  public:
  // @@protoc_insertion_point(class_scope:TSPTW.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 35, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> tour_;
    ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge > edges_;
    ::google::protobuf::RepeatedField<float> arrivaltimes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsptw_2dkcxbievqo879_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Geocode

// required string id = 1;
inline bool Geocode::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Geocode::id() const {
  // @@protoc_insertion_point(field_get:TSPTW.Geocode.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Geocode::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSPTW.Geocode.id)
}
inline std::string* Geocode::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:TSPTW.Geocode.id)
  return _s;
}
inline const std::string& Geocode::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Geocode::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Geocode::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Geocode::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSPTW.Geocode.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Geocode::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSPTW.Geocode.id)
}

// required float x = 2;
inline bool Geocode::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::x() const {
  // @@protoc_insertion_point(field_get:TSPTW.Geocode.x)
  return _internal_x();
}
inline void Geocode::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TSPTW.Geocode.x)
}
inline float Geocode::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Geocode::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}

// required float y = 3;
inline bool Geocode::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Geocode::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Geocode::y() const {
  // @@protoc_insertion_point(field_get:TSPTW.Geocode.y)
  return _internal_y();
}
inline void Geocode::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TSPTW.Geocode.y)
}
inline float Geocode::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Geocode::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}

// optional float windowStart = 4;
inline bool Geocode::has_windowstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Geocode::clear_windowstart() {
  _impl_.windowstart_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Geocode::windowstart() const {
  // @@protoc_insertion_point(field_get:TSPTW.Geocode.windowStart)
  return _internal_windowstart();
}
inline void Geocode::set_windowstart(float value) {
  _internal_set_windowstart(value);
  // @@protoc_insertion_point(field_set:TSPTW.Geocode.windowStart)
}
inline float Geocode::_internal_windowstart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowstart_;
}
inline void Geocode::_internal_set_windowstart(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.windowstart_ = value;
}

// optional float windowEnd = 5;
inline bool Geocode::has_windowend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Geocode::clear_windowend() {
  _impl_.windowend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Geocode::windowend() const {
  // @@protoc_insertion_point(field_get:TSPTW.Geocode.windowEnd)
  return _internal_windowend();
}
inline void Geocode::set_windowend(float value) {
  _internal_set_windowend(value);
  // @@protoc_insertion_point(field_set:TSPTW.Geocode.windowEnd)
}
inline float Geocode::_internal_windowend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowend_;
}
inline void Geocode::_internal_set_windowend(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.windowend_ = value;
}

// -------------------------------------------------------------------

// TSP

// repeated .TSPTW.Geocode points = 1;
inline int TSP::_internal_points_size() const {
  return _internal_points().size();
}
inline int TSP::points_size() const {
  return _internal_points_size();
}
inline void TSP::clear_points() {
  _internal_mutable_points()->Clear();
}
inline ::TSPTW::Geocode* TSP::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:TSPTW.TSP.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSPTW::Geocode >*
TSP::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:TSPTW.TSP.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::TSPTW::Geocode& TSP::points(int index) const {
  // @@protoc_insertion_point(field_get:TSPTW.TSP.points)
    return _internal_points().Get(index);
}
inline ::TSPTW::Geocode* TSP::add_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TSPTW::Geocode* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:TSPTW.TSP.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TSPTW::Geocode >&
TSP::points() const {
  // @@protoc_insertion_point(field_list:TSPTW.TSP.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::TSPTW::Geocode>&
TSP::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::TSPTW::Geocode>*
TSP::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// optional .TSPTW.TSP.eDistanceType distancetype = 2 [default = RoadNetwork];
inline bool TSP::has_distancetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TSP::clear_distancetype() {
  _impl_.distancetype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TSPTW::TSP_eDistanceType TSP::distancetype() const {
  // @@protoc_insertion_point(field_get:TSPTW.TSP.distancetype)
  return _internal_distancetype();
}
inline void TSP::set_distancetype(::TSPTW::TSP_eDistanceType value) {
  _internal_set_distancetype(value);
  // @@protoc_insertion_point(field_set:TSPTW.TSP.distancetype)
}
inline ::TSPTW::TSP_eDistanceType TSP::_internal_distancetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TSPTW::TSP_eDistanceType>(_impl_.distancetype_);
}
inline void TSP::_internal_set_distancetype(::TSPTW::TSP_eDistanceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::TSPTW::TSP_eDistanceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.distancetype_ = value;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .TSPTW.TSP model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSPTW::TSP& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TSPTW::TSP* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSPTW::TSP&>(::TSPTW::_TSP_default_instance_);
}
inline const ::TSPTW::TSP& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:TSPTW.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::TSPTW::TSP* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::TSPTW::TSP*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSPTW.SolveRequest.model)
}
inline ::TSPTW::TSP* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSPTW::TSP* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TSPTW::TSP* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSPTW.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSPTW::TSP* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::TSPTW::TSP* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSPTW::TSP>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::TSPTW::TSP*>(p);
  }
  return _impl_.model_;
}
inline ::TSPTW::TSP* SolveRequest::mutable_model() {
  ::TSPTW::TSP* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:TSPTW.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::TSPTW::TSP* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TSPTW::TSP*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::TSPTW::TSP*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::TSPTW::TSP*>(value);
  // @@protoc_insertion_point(field_set_allocated:TSPTW.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:TSPTW.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSPTW.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:TSPTW.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSPTW.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSPTW.SolveRequest.modelID)
}

// repeated string visitSequence = 3;
inline int SolveRequest::_internal_visitsequence_size() const {
  return _internal_visitsequence().size();
}
inline int SolveRequest::visitsequence_size() const {
  return _internal_visitsequence_size();
}
inline void SolveRequest::clear_visitsequence() {
  _internal_mutable_visitsequence()->Clear();
}
inline std::string* SolveRequest::add_visitsequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_visitsequence()->Add();
  // @@protoc_insertion_point(field_add_mutable:TSPTW.SolveRequest.visitSequence)
  return _s;
}
inline const std::string& SolveRequest::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:TSPTW.SolveRequest.visitSequence)
  return _internal_visitsequence().Get(index);
}
inline std::string* SolveRequest::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:TSPTW.SolveRequest.visitSequence)
  return _internal_mutable_visitsequence()->Mutable(index);
}
inline void SolveRequest::set_visitsequence(int index, const std::string& value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, std::string&& value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_visitsequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, absl::string_view value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSPTW.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TSPTW.SolveRequest.visitSequence)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolveRequest::visitsequence() const {
  // @@protoc_insertion_point(field_list:TSPTW.SolveRequest.visitSequence)
  return _internal_visitsequence();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolveRequest::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:TSPTW.SolveRequest.visitSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitsequence();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolveRequest::_internal_visitsequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolveRequest::_internal_mutable_visitsequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitsequence_;
}

// optional .TSPTW.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TSPTW::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:TSPTW.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::TSPTW::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:TSPTW.SolveRequest.solveType)
}
inline ::TSPTW::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TSPTW::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::TSPTW::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::TSPTW::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// Edge_Geometry

// required float x = 1;
inline bool Edge_Geometry::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Edge_Geometry::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Edge_Geometry::x() const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.Geometry.x)
  return _internal_x();
}
inline void Edge_Geometry::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TSPTW.Edge.Geometry.x)
}
inline float Edge_Geometry::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Edge_Geometry::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Edge_Geometry::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Edge_Geometry::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Edge_Geometry::y() const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.Geometry.y)
  return _internal_y();
}
inline void Edge_Geometry::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TSPTW.Edge.Geometry.y)
}
inline float Edge_Geometry::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Edge_Geometry::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Edge

// required string from = 1;
inline bool Edge::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Edge::clear_from() {
  _impl_.from_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Edge::from() const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.from)
  return _internal_from();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Edge::set_from(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSPTW.Edge.from)
}
inline std::string* Edge::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:TSPTW.Edge.from)
  return _s;
}
inline const std::string& Edge::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_.Get();
}
inline void Edge::_internal_set_from(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* Edge::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.from_.Mutable( GetArenaForAllocation());
}
inline std::string* Edge::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSPTW.Edge.from)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.from_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Edge::set_allocated_from(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_.IsDefault()) {
          _impl_.from_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSPTW.Edge.from)
}

// required string to = 2;
inline bool Edge::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Edge::clear_to() {
  _impl_.to_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Edge::to() const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.to)
  return _internal_to();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Edge::set_to(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSPTW.Edge.to)
}
inline std::string* Edge::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:TSPTW.Edge.to)
  return _s;
}
inline const std::string& Edge::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_.Get();
}
inline void Edge::_internal_set_to(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* Edge::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.to_.Mutable( GetArenaForAllocation());
}
inline std::string* Edge::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSPTW.Edge.to)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.to_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.to_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Edge::set_allocated_to(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.to_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_.IsDefault()) {
          _impl_.to_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSPTW.Edge.to)
}

// optional float distance = 3;
inline bool Edge::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Edge::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Edge::distance() const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.distance)
  return _internal_distance();
}
inline void Edge::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:TSPTW.Edge.distance)
}
inline float Edge::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void Edge::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.distance_ = value;
}

// optional float time = 4;
inline bool Edge::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Edge::clear_time() {
  _impl_.time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Edge::time() const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.time)
  return _internal_time();
}
inline void Edge::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:TSPTW.Edge.time)
}
inline float Edge::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void Edge::_internal_set_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.time_ = value;
}

// repeated .TSPTW.Edge.Geometry geometry = 5;
inline int Edge::_internal_geometry_size() const {
  return _internal_geometry().size();
}
inline int Edge::geometry_size() const {
  return _internal_geometry_size();
}
inline void Edge::clear_geometry() {
  _internal_mutable_geometry()->Clear();
}
inline ::TSPTW::Edge_Geometry* Edge::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:TSPTW.Edge.geometry)
  return _internal_mutable_geometry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge_Geometry >*
Edge::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:TSPTW.Edge.geometry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometry();
}
inline const ::TSPTW::Edge_Geometry& Edge::geometry(int index) const {
  // @@protoc_insertion_point(field_get:TSPTW.Edge.geometry)
    return _internal_geometry().Get(index);
}
inline ::TSPTW::Edge_Geometry* Edge::add_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TSPTW::Edge_Geometry* _add = _internal_mutable_geometry()->Add();
  // @@protoc_insertion_point(field_add:TSPTW.Edge.geometry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge_Geometry >&
Edge::geometry() const {
  // @@protoc_insertion_point(field_list:TSPTW.Edge.geometry)
  return _internal_geometry();
}
inline const ::google::protobuf::RepeatedPtrField<::TSPTW::Edge_Geometry>&
Edge::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometry_;
}
inline ::google::protobuf::RepeatedPtrField<::TSPTW::Edge_Geometry>*
Edge::_internal_mutable_geometry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated string tour = 1;
inline int SolutionResponse::_internal_tour_size() const {
  return _internal_tour().size();
}
inline int SolutionResponse::tour_size() const {
  return _internal_tour_size();
}
inline void SolutionResponse::clear_tour() {
  _internal_mutable_tour()->Clear();
}
inline std::string* SolutionResponse::add_tour() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tour()->Add();
  // @@protoc_insertion_point(field_add_mutable:TSPTW.SolutionResponse.tour)
  return _s;
}
inline const std::string& SolutionResponse::tour(int index) const {
  // @@protoc_insertion_point(field_get:TSPTW.SolutionResponse.tour)
  return _internal_tour().Get(index);
}
inline std::string* SolutionResponse::mutable_tour(int index) {
  // @@protoc_insertion_point(field_mutable:TSPTW.SolutionResponse.tour)
  return _internal_mutable_tour()->Mutable(index);
}
inline void SolutionResponse::set_tour(int index, const std::string& value) {
  _internal_mutable_tour()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, std::string&& value) {
  _internal_mutable_tour()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tour()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tour()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, absl::string_view value) {
  _internal_mutable_tour()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSPTW.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TSPTW.SolutionResponse.tour)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse::tour() const {
  // @@protoc_insertion_point(field_list:TSPTW.SolutionResponse.tour)
  return _internal_tour();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse::mutable_tour() {
  // @@protoc_insertion_point(field_mutable_list:TSPTW.SolutionResponse.tour)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tour();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse::_internal_tour() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tour_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse::_internal_mutable_tour() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tour_;
}

// repeated .TSPTW.Edge edges = 2;
inline int SolutionResponse::_internal_edges_size() const {
  return _internal_edges().size();
}
inline int SolutionResponse::edges_size() const {
  return _internal_edges_size();
}
inline void SolutionResponse::clear_edges() {
  _internal_mutable_edges()->Clear();
}
inline ::TSPTW::Edge* SolutionResponse::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:TSPTW.SolutionResponse.edges)
  return _internal_mutable_edges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge >*
SolutionResponse::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:TSPTW.SolutionResponse.edges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_edges();
}
inline const ::TSPTW::Edge& SolutionResponse::edges(int index) const {
  // @@protoc_insertion_point(field_get:TSPTW.SolutionResponse.edges)
    return _internal_edges().Get(index);
}
inline ::TSPTW::Edge* SolutionResponse::add_edges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TSPTW::Edge* _add = _internal_mutable_edges()->Add();
  // @@protoc_insertion_point(field_add:TSPTW.SolutionResponse.edges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TSPTW::Edge >&
SolutionResponse::edges() const {
  // @@protoc_insertion_point(field_list:TSPTW.SolutionResponse.edges)
  return _internal_edges();
}
inline const ::google::protobuf::RepeatedPtrField<::TSPTW::Edge>&
SolutionResponse::_internal_edges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.edges_;
}
inline ::google::protobuf::RepeatedPtrField<::TSPTW::Edge>*
SolutionResponse::_internal_mutable_edges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.edges_;
}

// repeated float arrivalTimes = 3;
inline int SolutionResponse::_internal_arrivaltimes_size() const {
  return _internal_arrivaltimes().size();
}
inline int SolutionResponse::arrivaltimes_size() const {
  return _internal_arrivaltimes_size();
}
inline void SolutionResponse::clear_arrivaltimes() {
  _internal_mutable_arrivaltimes()->Clear();
}
inline float SolutionResponse::arrivaltimes(int index) const {
  // @@protoc_insertion_point(field_get:TSPTW.SolutionResponse.arrivalTimes)
  return _internal_arrivaltimes().Get(index);
}
inline void SolutionResponse::set_arrivaltimes(int index, float value) {
  _internal_mutable_arrivaltimes()->Set(index, value);
  // @@protoc_insertion_point(field_set:TSPTW.SolutionResponse.arrivalTimes)
}
inline void SolutionResponse::add_arrivaltimes(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_arrivaltimes()->Add(value);
  // @@protoc_insertion_point(field_add:TSPTW.SolutionResponse.arrivalTimes)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse::arrivaltimes() const {
  // @@protoc_insertion_point(field_list:TSPTW.SolutionResponse.arrivalTimes)
  return _internal_arrivaltimes();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse::mutable_arrivaltimes() {
  // @@protoc_insertion_point(field_mutable_list:TSPTW.SolutionResponse.arrivalTimes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arrivaltimes();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse::_internal_arrivaltimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrivaltimes_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse::_internal_mutable_arrivaltimes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arrivaltimes_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSPTW


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::TSPTW::TSP_eDistanceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TSPTW::TSP_eDistanceType>() {
  return ::TSPTW::TSP_eDistanceType_descriptor();
}
template <>
struct is_proto_enum<::TSPTW::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TSPTW::SolveRequest_SolveType>() {
  return ::TSPTW::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tsptw_2dkcxbievqo879_2eproto_2epb_2eh
