// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ivr8-yni1c9k2swof.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ivr8_2dyni1c9k2swof_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ivr8_2dyni1c9k2swof_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ivr8_2dyni1c9k2swof_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ivr8_2dyni1c9k2swof_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ivr8_2dyni1c9k2swof_2eproto;
namespace IVR8 {
class CapacityDimension;
struct CapacityDimensionDefaultTypeInternal;
extern CapacityDimensionDefaultTypeInternal _CapacityDimension_default_instance_;
class Compartment;
struct CompartmentDefaultTypeInternal;
extern CompartmentDefaultTypeInternal _Compartment_default_instance_;
class CompartmentSet;
struct CompartmentSetDefaultTypeInternal;
extern CompartmentSetDefaultTypeInternal _CompartmentSet_default_instance_;
class CompartmentSet_GroupLimit;
struct CompartmentSet_GroupLimitDefaultTypeInternal;
extern CompartmentSet_GroupLimitDefaultTypeInternal _CompartmentSet_GroupLimit_default_instance_;
class Compartment_Capacity;
struct Compartment_CapacityDefaultTypeInternal;
extern Compartment_CapacityDefaultTypeInternal _Compartment_Capacity_default_instance_;
class DimensionConfiguration;
struct DimensionConfigurationDefaultTypeInternal;
extern DimensionConfigurationDefaultTypeInternal _DimensionConfiguration_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class InternalDimension;
struct InternalDimensionDefaultTypeInternal;
extern InternalDimensionDefaultTypeInternal _InternalDimension_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class Job_CompartmentRelation;
struct Job_CompartmentRelationDefaultTypeInternal;
extern Job_CompartmentRelationDefaultTypeInternal _Job_CompartmentRelation_default_instance_;
class Job_Task;
struct Job_TaskDefaultTypeInternal;
extern Job_TaskDefaultTypeInternal _Job_Task_default_instance_;
class Job_Task_Attribute;
struct Job_Task_AttributeDefaultTypeInternal;
extern Job_Task_AttributeDefaultTypeInternal _Job_Task_Attribute_default_instance_;
class Job_Task_TaskRelation;
struct Job_Task_TaskRelationDefaultTypeInternal;
extern Job_Task_TaskRelationDefaultTypeInternal _Job_Task_TaskRelation_default_instance_;
class Job_VehicleRelation;
struct Job_VehicleRelationDefaultTypeInternal;
extern Job_VehicleRelationDefaultTypeInternal _Job_VehicleRelation_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Location_Attribute;
struct Location_AttributeDefaultTypeInternal;
extern Location_AttributeDefaultTypeInternal _Location_Attribute_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Infeasibility;
struct SolutionResponse_InfeasibilityDefaultTypeInternal;
extern SolutionResponse_InfeasibilityDefaultTypeInternal _SolutionResponse_Infeasibility_default_instance_;
class SolutionResponse_Infeasibility_Info;
struct SolutionResponse_Infeasibility_InfoDefaultTypeInternal;
extern SolutionResponse_Infeasibility_InfoDefaultTypeInternal _SolutionResponse_Infeasibility_Info_default_instance_;
class SolutionResponse_InterStop;
struct SolutionResponse_InterStopDefaultTypeInternal;
extern SolutionResponse_InterStopDefaultTypeInternal _SolutionResponse_InterStop_default_instance_;
class SolutionResponse_InterStopAttribute;
struct SolutionResponse_InterStopAttributeDefaultTypeInternal;
extern SolutionResponse_InterStopAttributeDefaultTypeInternal _SolutionResponse_InterStopAttribute_default_instance_;
class SolutionResponse_Route;
struct SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolutionResponse_Stop;
struct SolutionResponse_StopDefaultTypeInternal;
extern SolutionResponse_StopDefaultTypeInternal _SolutionResponse_Stop_default_instance_;
class SolutionResponse_StopAttribute;
struct SolutionResponse_StopAttributeDefaultTypeInternal;
extern SolutionResponse_StopAttributeDefaultTypeInternal _SolutionResponse_StopAttribute_default_instance_;
class SolutionResponse_TransitRuleAttribute;
struct SolutionResponse_TransitRuleAttributeDefaultTypeInternal;
extern SolutionResponse_TransitRuleAttributeDefaultTypeInternal _SolutionResponse_TransitRuleAttribute_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class TaskSequence;
struct TaskSequenceDefaultTypeInternal;
extern TaskSequenceDefaultTypeInternal _TaskSequence_default_instance_;
class TransitGenerator;
struct TransitGeneratorDefaultTypeInternal;
extern TransitGeneratorDefaultTypeInternal _TransitGenerator_default_instance_;
class TransitRule;
struct TransitRuleDefaultTypeInternal;
extern TransitRuleDefaultTypeInternal _TransitRule_default_instance_;
class TransitRule_Trigger;
struct TransitRule_TriggerDefaultTypeInternal;
extern TransitRule_TriggerDefaultTypeInternal _TransitRule_Trigger_default_instance_;
class TransitSet;
struct TransitSetDefaultTypeInternal;
extern TransitSetDefaultTypeInternal _TransitSet_default_instance_;
class TransitSet_TransitValue;
struct TransitSet_TransitValueDefaultTypeInternal;
extern TransitSet_TransitValueDefaultTypeInternal _TransitSet_TransitValue_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
class VehicleClass;
struct VehicleClassDefaultTypeInternal;
extern VehicleClassDefaultTypeInternal _VehicleClass_default_instance_;
class VehicleClass_Attribute;
struct VehicleClass_AttributeDefaultTypeInternal;
extern VehicleClass_AttributeDefaultTypeInternal _VehicleClass_Attribute_default_instance_;
class VehicleCostClass;
struct VehicleCostClassDefaultTypeInternal;
extern VehicleCostClassDefaultTypeInternal _VehicleCostClass_default_instance_;
class VehicleCostClass_Attribute;
struct VehicleCostClass_AttributeDefaultTypeInternal;
extern VehicleCostClass_AttributeDefaultTypeInternal _VehicleCostClass_Attribute_default_instance_;
class Vehicle_Capacity;
struct Vehicle_CapacityDefaultTypeInternal;
extern Vehicle_CapacityDefaultTypeInternal _Vehicle_Capacity_default_instance_;
class Vehicle_Shift;
struct Vehicle_ShiftDefaultTypeInternal;
extern Vehicle_ShiftDefaultTypeInternal _Vehicle_Shift_default_instance_;
class Vehicle_Task;
struct Vehicle_TaskDefaultTypeInternal;
extern Vehicle_TaskDefaultTypeInternal _Vehicle_Task_default_instance_;
class Vehicle_Task_Attribute;
struct Vehicle_Task_AttributeDefaultTypeInternal;
extern Vehicle_Task_AttributeDefaultTypeInternal _Vehicle_Task_Attribute_default_instance_;
class Window;
struct WindowDefaultTypeInternal;
extern WindowDefaultTypeInternal _Window_default_instance_;
}  // namespace IVR8
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace IVR8 {
enum InternalDimension_eMeasurementUnit : int {
  InternalDimension_eMeasurementUnit_SECONDS = 0,
  InternalDimension_eMeasurementUnit_MINUTES = 1,
  InternalDimension_eMeasurementUnit_HOURS = 2,
  InternalDimension_eMeasurementUnit_DAYS = 3,
  InternalDimension_eMeasurementUnit_KILOMETRES = 4,
  InternalDimension_eMeasurementUnit_MILES = 5,
};

bool InternalDimension_eMeasurementUnit_IsValid(int value);
constexpr InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN = static_cast<InternalDimension_eMeasurementUnit>(0);
constexpr InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX = static_cast<InternalDimension_eMeasurementUnit>(5);
constexpr int InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
InternalDimension_eMeasurementUnit_descriptor();
template <typename T>
const std::string& InternalDimension_eMeasurementUnit_Name(T value) {
  static_assert(std::is_same<T, InternalDimension_eMeasurementUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eMeasurementUnit_Name().");
  return InternalDimension_eMeasurementUnit_Name(static_cast<InternalDimension_eMeasurementUnit>(value));
}
template <>
inline const std::string& InternalDimension_eMeasurementUnit_Name(InternalDimension_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InternalDimension_eMeasurementUnit_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool InternalDimension_eMeasurementUnit_Parse(absl::string_view name, InternalDimension_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalDimension_eMeasurementUnit>(
      InternalDimension_eMeasurementUnit_descriptor(), name, value);
}
enum Job_VehicleRelation_Type : int {
  Job_VehicleRelation_Type_INCLUSIVE = 0,
  Job_VehicleRelation_Type_EXCLUSIVE = 1,
};

bool Job_VehicleRelation_Type_IsValid(int value);
constexpr Job_VehicleRelation_Type Job_VehicleRelation_Type_Type_MIN = static_cast<Job_VehicleRelation_Type>(0);
constexpr Job_VehicleRelation_Type Job_VehicleRelation_Type_Type_MAX = static_cast<Job_VehicleRelation_Type>(1);
constexpr int Job_VehicleRelation_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Job_VehicleRelation_Type_descriptor();
template <typename T>
const std::string& Job_VehicleRelation_Type_Name(T value) {
  static_assert(std::is_same<T, Job_VehicleRelation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Job_VehicleRelation_Type_Name(static_cast<Job_VehicleRelation_Type>(value));
}
template <>
inline const std::string& Job_VehicleRelation_Type_Name(Job_VehicleRelation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Job_VehicleRelation_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Job_VehicleRelation_Type_Parse(absl::string_view name, Job_VehicleRelation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_VehicleRelation_Type>(
      Job_VehicleRelation_Type_descriptor(), name, value);
}
enum Job_CompartmentRelation_Type : int {
  Job_CompartmentRelation_Type_INCLUSIVE = 0,
  Job_CompartmentRelation_Type_EXCLUSIVE = 1,
};

bool Job_CompartmentRelation_Type_IsValid(int value);
constexpr Job_CompartmentRelation_Type Job_CompartmentRelation_Type_Type_MIN = static_cast<Job_CompartmentRelation_Type>(0);
constexpr Job_CompartmentRelation_Type Job_CompartmentRelation_Type_Type_MAX = static_cast<Job_CompartmentRelation_Type>(1);
constexpr int Job_CompartmentRelation_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Job_CompartmentRelation_Type_descriptor();
template <typename T>
const std::string& Job_CompartmentRelation_Type_Name(T value) {
  static_assert(std::is_same<T, Job_CompartmentRelation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Job_CompartmentRelation_Type_Name(static_cast<Job_CompartmentRelation_Type>(value));
}
template <>
inline const std::string& Job_CompartmentRelation_Type_Name(Job_CompartmentRelation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Job_CompartmentRelation_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Job_CompartmentRelation_Type_Parse(absl::string_view name, Job_CompartmentRelation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_CompartmentRelation_Type>(
      Job_CompartmentRelation_Type_descriptor(), name, value);
}
enum Job_Task_TaskRelation_Type : int {
  Job_Task_TaskRelation_Type_INCLUSIVE = 0,
  Job_Task_TaskRelation_Type_EXCLUSIVE = 1,
};

bool Job_Task_TaskRelation_Type_IsValid(int value);
constexpr Job_Task_TaskRelation_Type Job_Task_TaskRelation_Type_Type_MIN = static_cast<Job_Task_TaskRelation_Type>(0);
constexpr Job_Task_TaskRelation_Type Job_Task_TaskRelation_Type_Type_MAX = static_cast<Job_Task_TaskRelation_Type>(1);
constexpr int Job_Task_TaskRelation_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Job_Task_TaskRelation_Type_descriptor();
template <typename T>
const std::string& Job_Task_TaskRelation_Type_Name(T value) {
  static_assert(std::is_same<T, Job_Task_TaskRelation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Job_Task_TaskRelation_Type_Name(static_cast<Job_Task_TaskRelation_Type>(value));
}
template <>
inline const std::string& Job_Task_TaskRelation_Type_Name(Job_Task_TaskRelation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Job_Task_TaskRelation_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Job_Task_TaskRelation_Type_Parse(absl::string_view name, Job_Task_TaskRelation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_Task_TaskRelation_Type>(
      Job_Task_TaskRelation_Type_descriptor(), name, value);
}
enum Job_Task_TripConstraint : int {
  Job_Task_TripConstraint_FIRST = 0,
  Job_Task_TripConstraint_LAST = 1,
};

bool Job_Task_TripConstraint_IsValid(int value);
constexpr Job_Task_TripConstraint Job_Task_TripConstraint_TripConstraint_MIN = static_cast<Job_Task_TripConstraint>(0);
constexpr Job_Task_TripConstraint Job_Task_TripConstraint_TripConstraint_MAX = static_cast<Job_Task_TripConstraint>(1);
constexpr int Job_Task_TripConstraint_TripConstraint_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Job_Task_TripConstraint_descriptor();
template <typename T>
const std::string& Job_Task_TripConstraint_Name(T value) {
  static_assert(std::is_same<T, Job_Task_TripConstraint>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TripConstraint_Name().");
  return Job_Task_TripConstraint_Name(static_cast<Job_Task_TripConstraint>(value));
}
template <>
inline const std::string& Job_Task_TripConstraint_Name(Job_Task_TripConstraint value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Job_Task_TripConstraint_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Job_Task_TripConstraint_Parse(absl::string_view name, Job_Task_TripConstraint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_Task_TripConstraint>(
      Job_Task_TripConstraint_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(2);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class InternalDimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.InternalDimension) */ {
 public:
  inline InternalDimension() : InternalDimension(nullptr) {}
  ~InternalDimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InternalDimension(::google::protobuf::internal::ConstantInitialized);

  InternalDimension(const InternalDimension& from);
  InternalDimension(InternalDimension&& from) noexcept
    : InternalDimension() {
    *this = ::std::move(from);
  }

  inline InternalDimension& operator=(const InternalDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalDimension& operator=(InternalDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalDimension* internal_default_instance() {
    return reinterpret_cast<const InternalDimension*>(
               &_InternalDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InternalDimension& a, InternalDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalDimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InternalDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InternalDimension& from) {
    InternalDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalDimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.InternalDimension";
  }
  protected:
  explicit InternalDimension(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eMeasurementUnit = InternalDimension_eMeasurementUnit;
  static constexpr eMeasurementUnit SECONDS = InternalDimension_eMeasurementUnit_SECONDS;
  static constexpr eMeasurementUnit MINUTES = InternalDimension_eMeasurementUnit_MINUTES;
  static constexpr eMeasurementUnit HOURS = InternalDimension_eMeasurementUnit_HOURS;
  static constexpr eMeasurementUnit DAYS = InternalDimension_eMeasurementUnit_DAYS;
  static constexpr eMeasurementUnit KILOMETRES = InternalDimension_eMeasurementUnit_KILOMETRES;
  static constexpr eMeasurementUnit MILES = InternalDimension_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return InternalDimension_eMeasurementUnit_IsValid(value);
  }
  static constexpr eMeasurementUnit eMeasurementUnit_MIN = InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN;
  static constexpr eMeasurementUnit eMeasurementUnit_MAX = InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX;
  static constexpr int eMeasurementUnit_ARRAYSIZE = InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eMeasurementUnit_descriptor() {
    return InternalDimension_eMeasurementUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eMeasurementUnit_Name(T value) {
    return InternalDimension_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(absl::string_view name, eMeasurementUnit* value) {
    return InternalDimension_eMeasurementUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMeasurementUnitFieldNumber = 2,
    kSlackMaxFieldNumber = 3,
    kTardyMaxFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .IVR8.InternalDimension.eMeasurementUnit measurementUnit = 2;
  bool has_measurementunit() const;
  void clear_measurementunit() ;
  ::IVR8::InternalDimension_eMeasurementUnit measurementunit() const;
  void set_measurementunit(::IVR8::InternalDimension_eMeasurementUnit value);

  private:
  ::IVR8::InternalDimension_eMeasurementUnit _internal_measurementunit() const;
  void _internal_set_measurementunit(::IVR8::InternalDimension_eMeasurementUnit value);

  public:
  // optional float slackMax = 3 [default = 0];
  bool has_slackmax() const;
  void clear_slackmax() ;
  float slackmax() const;
  void set_slackmax(float value);

  private:
  float _internal_slackmax() const;
  void _internal_set_slackmax(float value);

  public:
  // optional float tardyMax = 4 [default = 0];
  bool has_tardymax() const;
  void clear_tardymax() ;
  float tardymax() const;
  void set_tardymax(float value);

  private:
  float _internal_tardymax() const;
  void _internal_set_tardymax(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.InternalDimension)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 33, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    int measurementunit_;
    float slackmax_;
    float tardymax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class CapacityDimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.CapacityDimension) */ {
 public:
  inline CapacityDimension() : CapacityDimension(nullptr) {}
  ~CapacityDimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CapacityDimension(::google::protobuf::internal::ConstantInitialized);

  CapacityDimension(const CapacityDimension& from);
  CapacityDimension(CapacityDimension&& from) noexcept
    : CapacityDimension() {
    *this = ::std::move(from);
  }

  inline CapacityDimension& operator=(const CapacityDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacityDimension& operator=(CapacityDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacityDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacityDimension* internal_default_instance() {
    return reinterpret_cast<const CapacityDimension*>(
               &_CapacityDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CapacityDimension& a, CapacityDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(CapacityDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacityDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacityDimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapacityDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacityDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CapacityDimension& from) {
    CapacityDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacityDimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.CapacityDimension";
  }
  protected:
  explicit CapacityDimension(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kSlackMaxFieldNumber = 3,
    kTardyMaxFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string units = 2;
  bool has_units() const;
  void clear_units() ;
  const std::string& units() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_units(Arg_&& arg, Args_... args);
  std::string* mutable_units();
  PROTOBUF_NODISCARD std::string* release_units();
  void set_allocated_units(std::string* ptr);

  private:
  const std::string& _internal_units() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_units(
      const std::string& value);
  std::string* _internal_mutable_units();

  public:
  // optional float slackMax = 3 [default = 0];
  bool has_slackmax() const;
  void clear_slackmax() ;
  float slackmax() const;
  void set_slackmax(float value);

  private:
  float _internal_slackmax() const;
  void _internal_set_slackmax(float value);

  public:
  // optional float tardyMax = 4 [default = 0];
  bool has_tardymax() const;
  void clear_tardymax() ;
  float tardymax() const;
  void set_tardymax(float value);

  private:
  float _internal_tardymax() const;
  void _internal_set_tardymax(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.CapacityDimension)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr units_;
    float slackmax_;
    float tardymax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class DimensionConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.DimensionConfiguration) */ {
 public:
  inline DimensionConfiguration() : DimensionConfiguration(nullptr) {}
  ~DimensionConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DimensionConfiguration(::google::protobuf::internal::ConstantInitialized);

  DimensionConfiguration(const DimensionConfiguration& from);
  DimensionConfiguration(DimensionConfiguration&& from) noexcept
    : DimensionConfiguration() {
    *this = ::std::move(from);
  }

  inline DimensionConfiguration& operator=(const DimensionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DimensionConfiguration& operator=(DimensionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DimensionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DimensionConfiguration* internal_default_instance() {
    return reinterpret_cast<const DimensionConfiguration*>(
               &_DimensionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DimensionConfiguration& a, DimensionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(DimensionConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DimensionConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DimensionConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DimensionConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DimensionConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DimensionConfiguration& from) {
    DimensionConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.DimensionConfiguration";
  }
  protected:
  explicit DimensionConfiguration(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityDimensionsFieldNumber = 3,
    kTimeConfigFieldNumber = 1,
    kDistanceConfigFieldNumber = 2,
  };
  // repeated .IVR8.CapacityDimension capacityDimensions = 3;
  int capacitydimensions_size() const;
  private:
  int _internal_capacitydimensions_size() const;

  public:
  void clear_capacitydimensions() ;
  ::IVR8::CapacityDimension* mutable_capacitydimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::CapacityDimension >*
      mutable_capacitydimensions();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::CapacityDimension>& _internal_capacitydimensions() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::CapacityDimension>* _internal_mutable_capacitydimensions();
  public:
  const ::IVR8::CapacityDimension& capacitydimensions(int index) const;
  ::IVR8::CapacityDimension* add_capacitydimensions();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::CapacityDimension >&
      capacitydimensions() const;
  // optional .IVR8.InternalDimension timeConfig = 1;
  bool has_timeconfig() const;
  void clear_timeconfig() ;
  const ::IVR8::InternalDimension& timeconfig() const;
  PROTOBUF_NODISCARD ::IVR8::InternalDimension* release_timeconfig();
  ::IVR8::InternalDimension* mutable_timeconfig();
  void set_allocated_timeconfig(::IVR8::InternalDimension* value);
  void unsafe_arena_set_allocated_timeconfig(::IVR8::InternalDimension* value);
  ::IVR8::InternalDimension* unsafe_arena_release_timeconfig();

  private:
  const ::IVR8::InternalDimension& _internal_timeconfig() const;
  ::IVR8::InternalDimension* _internal_mutable_timeconfig();

  public:
  // optional .IVR8.InternalDimension distanceConfig = 2;
  bool has_distanceconfig() const;
  void clear_distanceconfig() ;
  const ::IVR8::InternalDimension& distanceconfig() const;
  PROTOBUF_NODISCARD ::IVR8::InternalDimension* release_distanceconfig();
  ::IVR8::InternalDimension* mutable_distanceconfig();
  void set_allocated_distanceconfig(::IVR8::InternalDimension* value);
  void unsafe_arena_set_allocated_distanceconfig(::IVR8::InternalDimension* value);
  ::IVR8::InternalDimension* unsafe_arena_release_distanceconfig();

  private:
  const ::IVR8::InternalDimension& _internal_distanceconfig() const;
  ::IVR8::InternalDimension* _internal_mutable_distanceconfig();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.DimensionConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::CapacityDimension > capacitydimensions_;
    ::IVR8::InternalDimension* timeconfig_;
    ::IVR8::InternalDimension* distanceconfig_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float longitude_;
    float latitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Window final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Window) */ {
 public:
  inline Window() : Window(nullptr) {}
  ~Window() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Window(::google::protobuf::internal::ConstantInitialized);

  Window(const Window& from);
  Window(Window&& from) noexcept
    : Window() {
    *this = ::std::move(from);
  }

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  inline Window& operator=(Window&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Window& default_instance() {
    return *internal_default_instance();
  }
  static inline const Window* internal_default_instance() {
    return reinterpret_cast<const Window*>(
               &_Window_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Window& a, Window& b) {
    a.Swap(&b);
  }
  inline void Swap(Window* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Window* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Window* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Window>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Window& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Window& from) {
    Window::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Window* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Window";
  }
  protected:
  explicit Window(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kSlackCostCoefFieldNumber = 3,
    kTardyCostCoefFieldNumber = 4,
    kSlackMaxFieldNumber = 5,
    kTardyMaxFieldNumber = 6,
  };
  // required float start = 1;
  bool has_start() const;
  void clear_start() ;
  float start() const;
  void set_start(float value);

  private:
  float _internal_start() const;
  void _internal_set_start(float value);

  public:
  // required float end = 2;
  bool has_end() const;
  void clear_end() ;
  float end() const;
  void set_end(float value);

  private:
  float _internal_end() const;
  void _internal_set_end(float value);

  public:
  // optional float slackCostCoef = 3 [default = 0];
  bool has_slackcostcoef() const;
  void clear_slackcostcoef() ;
  float slackcostcoef() const;
  void set_slackcostcoef(float value);

  private:
  float _internal_slackcostcoef() const;
  void _internal_set_slackcostcoef(float value);

  public:
  // optional float tardyCostCoef = 4 [default = 0];
  bool has_tardycostcoef() const;
  void clear_tardycostcoef() ;
  float tardycostcoef() const;
  void set_tardycostcoef(float value);

  private:
  float _internal_tardycostcoef() const;
  void _internal_set_tardycostcoef(float value);

  public:
  // optional float slackMax = 5 [default = -1];
  bool has_slackmax() const;
  void clear_slackmax() ;
  float slackmax() const;
  void set_slackmax(float value);

  private:
  float _internal_slackmax() const;
  void _internal_set_slackmax(float value);

  public:
  // optional float tardyMax = 6 [default = -1];
  bool has_tardymax() const;
  void clear_tardymax() ;
  float tardymax() const;
  void set_tardymax(float value);

  private:
  float _internal_tardymax() const;
  void _internal_set_tardymax(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Window)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float start_;
    float end_;
    float slackcostcoef_;
    float tardycostcoef_;
    float slackmax_;
    float tardymax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Location_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Location.Attribute) */ {
 public:
  inline Location_Attribute() : Location_Attribute(nullptr) {}
  ~Location_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Location_Attribute(::google::protobuf::internal::ConstantInitialized);

  Location_Attribute(const Location_Attribute& from);
  Location_Attribute(Location_Attribute&& from) noexcept
    : Location_Attribute() {
    *this = ::std::move(from);
  }

  inline Location_Attribute& operator=(const Location_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location_Attribute& operator=(Location_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location_Attribute* internal_default_instance() {
    return reinterpret_cast<const Location_Attribute*>(
               &_Location_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Location_Attribute& a, Location_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Location_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Location_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Location_Attribute& from) {
    Location_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Location.Attribute";
  }
  protected:
  explicit Location_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrivalWindowsFieldNumber = 4,
    kDepartureWindowsFieldNumber = 5,
    kDimensionIdFieldNumber = 1,
    kVehicleIdFieldNumber = 2,
    kQuantityFieldNumber = 3,
  };
  // repeated .IVR8.Window arrivalWindows = 4;
  int arrivalwindows_size() const;
  private:
  int _internal_arrivalwindows_size() const;

  public:
  void clear_arrivalwindows() ;
  ::IVR8::Window* mutable_arrivalwindows(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
      mutable_arrivalwindows();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Window>& _internal_arrivalwindows() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Window>* _internal_mutable_arrivalwindows();
  public:
  const ::IVR8::Window& arrivalwindows(int index) const;
  ::IVR8::Window* add_arrivalwindows();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
      arrivalwindows() const;
  // repeated .IVR8.Window departureWindows = 5;
  int departurewindows_size() const;
  private:
  int _internal_departurewindows_size() const;

  public:
  void clear_departurewindows() ;
  ::IVR8::Window* mutable_departurewindows(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
      mutable_departurewindows();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Window>& _internal_departurewindows() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Window>* _internal_mutable_departurewindows();
  public:
  const ::IVR8::Window& departurewindows(int index) const;
  ::IVR8::Window* add_departurewindows();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
      departurewindows() const;
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional string vehicleId = 2;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // optional float quantity = 3;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Location.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 2, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Window > arrivalwindows_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Window > departurewindows_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Location final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Location(::google::protobuf::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Location";
  }
  protected:
  explicit Location(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Location_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kIdFieldNumber = 1,
    kGeocodeFieldNumber = 2,
  };
  // repeated .IVR8.Location.Attribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::Location_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Location_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Location_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Location_Attribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::Location_Attribute& attributes(int index) const;
  ::IVR8::Location_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Location_Attribute >&
      attributes() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .IVR8.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode() ;
  const ::IVR8::Geocode& geocode() const;
  PROTOBUF_NODISCARD ::IVR8::Geocode* release_geocode();
  ::IVR8::Geocode* mutable_geocode();
  void set_allocated_geocode(::IVR8::Geocode* value);
  void unsafe_arena_set_allocated_geocode(::IVR8::Geocode* value);
  ::IVR8::Geocode* unsafe_arena_release_geocode();

  private:
  const ::IVR8::Geocode& _internal_geocode() const;
  ::IVR8::Geocode* _internal_mutable_geocode();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Location)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 24, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Location_Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::IVR8::Geocode* geocode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Job_VehicleRelation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Job.VehicleRelation) */ {
 public:
  inline Job_VehicleRelation() : Job_VehicleRelation(nullptr) {}
  ~Job_VehicleRelation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_VehicleRelation(::google::protobuf::internal::ConstantInitialized);

  Job_VehicleRelation(const Job_VehicleRelation& from);
  Job_VehicleRelation(Job_VehicleRelation&& from) noexcept
    : Job_VehicleRelation() {
    *this = ::std::move(from);
  }

  inline Job_VehicleRelation& operator=(const Job_VehicleRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_VehicleRelation& operator=(Job_VehicleRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_VehicleRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_VehicleRelation* internal_default_instance() {
    return reinterpret_cast<const Job_VehicleRelation*>(
               &_Job_VehicleRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Job_VehicleRelation& a, Job_VehicleRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_VehicleRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_VehicleRelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_VehicleRelation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_VehicleRelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_VehicleRelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_VehicleRelation& from) {
    Job_VehicleRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_VehicleRelation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Job.VehicleRelation";
  }
  protected:
  explicit Job_VehicleRelation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Job_VehicleRelation_Type;
  static constexpr Type INCLUSIVE = Job_VehicleRelation_Type_INCLUSIVE;
  static constexpr Type EXCLUSIVE = Job_VehicleRelation_Type_EXCLUSIVE;
  static inline bool Type_IsValid(int value) {
    return Job_VehicleRelation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Job_VehicleRelation_Type_Type_MIN;
  static constexpr Type Type_MAX = Job_VehicleRelation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Job_VehicleRelation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Job_VehicleRelation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Job_VehicleRelation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Job_VehicleRelation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string vehicleIds = 2;
  int vehicleids_size() const;
  private:
  int _internal_vehicleids_size() const;

  public:
  void clear_vehicleids() ;
  const std::string& vehicleids(int index) const;
  std::string* mutable_vehicleids(int index);
  void set_vehicleids(int index, const std::string& value);
  void set_vehicleids(int index, std::string&& value);
  void set_vehicleids(int index, const char* value);
  void set_vehicleids(int index, const char* value, std::size_t size);
  void set_vehicleids(int index, absl::string_view value);
  std::string* add_vehicleids();
  void add_vehicleids(const std::string& value);
  void add_vehicleids(std::string&& value);
  void add_vehicleids(const char* value);
  void add_vehicleids(const char* value, std::size_t size);
  void add_vehicleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_vehicleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_vehicleids();

  public:
  // required .IVR8.Job.VehicleRelation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::IVR8::Job_VehicleRelation_Type type() const;
  void set_type(::IVR8::Job_VehicleRelation_Type value);

  private:
  ::IVR8::Job_VehicleRelation_Type _internal_type() const;
  void _internal_set_type(::IVR8::Job_VehicleRelation_Type value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Job.VehicleRelation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 43, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> vehicleids_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Job_CompartmentRelation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Job.CompartmentRelation) */ {
 public:
  inline Job_CompartmentRelation() : Job_CompartmentRelation(nullptr) {}
  ~Job_CompartmentRelation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_CompartmentRelation(::google::protobuf::internal::ConstantInitialized);

  Job_CompartmentRelation(const Job_CompartmentRelation& from);
  Job_CompartmentRelation(Job_CompartmentRelation&& from) noexcept
    : Job_CompartmentRelation() {
    *this = ::std::move(from);
  }

  inline Job_CompartmentRelation& operator=(const Job_CompartmentRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_CompartmentRelation& operator=(Job_CompartmentRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_CompartmentRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_CompartmentRelation* internal_default_instance() {
    return reinterpret_cast<const Job_CompartmentRelation*>(
               &_Job_CompartmentRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Job_CompartmentRelation& a, Job_CompartmentRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_CompartmentRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_CompartmentRelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_CompartmentRelation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_CompartmentRelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_CompartmentRelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_CompartmentRelation& from) {
    Job_CompartmentRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_CompartmentRelation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Job.CompartmentRelation";
  }
  protected:
  explicit Job_CompartmentRelation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Job_CompartmentRelation_Type;
  static constexpr Type INCLUSIVE = Job_CompartmentRelation_Type_INCLUSIVE;
  static constexpr Type EXCLUSIVE = Job_CompartmentRelation_Type_EXCLUSIVE;
  static inline bool Type_IsValid(int value) {
    return Job_CompartmentRelation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Job_CompartmentRelation_Type_Type_MIN;
  static constexpr Type Type_MAX = Job_CompartmentRelation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Job_CompartmentRelation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Job_CompartmentRelation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Job_CompartmentRelation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Job_CompartmentRelation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCompartmentIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string compartmentIds = 2;
  int compartmentids_size() const;
  private:
  int _internal_compartmentids_size() const;

  public:
  void clear_compartmentids() ;
  const std::string& compartmentids(int index) const;
  std::string* mutable_compartmentids(int index);
  void set_compartmentids(int index, const std::string& value);
  void set_compartmentids(int index, std::string&& value);
  void set_compartmentids(int index, const char* value);
  void set_compartmentids(int index, const char* value, std::size_t size);
  void set_compartmentids(int index, absl::string_view value);
  std::string* add_compartmentids();
  void add_compartmentids(const std::string& value);
  void add_compartmentids(std::string&& value);
  void add_compartmentids(const char* value);
  void add_compartmentids(const char* value, std::size_t size);
  void add_compartmentids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& compartmentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_compartmentids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_compartmentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_compartmentids();

  public:
  // required .IVR8.Job.CompartmentRelation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::IVR8::Job_CompartmentRelation_Type type() const;
  void set_type(::IVR8::Job_CompartmentRelation_Type value);

  private:
  ::IVR8::Job_CompartmentRelation_Type _internal_type() const;
  void _internal_set_type(::IVR8::Job_CompartmentRelation_Type value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Job.CompartmentRelation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> compartmentids_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Job_Task_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Job.Task.Attribute) */ {
 public:
  inline Job_Task_Attribute() : Job_Task_Attribute(nullptr) {}
  ~Job_Task_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_Task_Attribute(::google::protobuf::internal::ConstantInitialized);

  Job_Task_Attribute(const Job_Task_Attribute& from);
  Job_Task_Attribute(Job_Task_Attribute&& from) noexcept
    : Job_Task_Attribute() {
    *this = ::std::move(from);
  }

  inline Job_Task_Attribute& operator=(const Job_Task_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_Task_Attribute& operator=(Job_Task_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_Task_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_Task_Attribute* internal_default_instance() {
    return reinterpret_cast<const Job_Task_Attribute*>(
               &_Job_Task_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Job_Task_Attribute& a, Job_Task_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_Task_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_Task_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_Task_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_Task_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_Task_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_Task_Attribute& from) {
    Job_Task_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Job.Task.Attribute";
  }
  protected:
  explicit Job_Task_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowsFieldNumber = 3,
    kVehicleIdsFieldNumber = 4,
    kDimensionIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // repeated .IVR8.Window windows = 3;
  int windows_size() const;
  private:
  int _internal_windows_size() const;

  public:
  void clear_windows() ;
  ::IVR8::Window* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
      mutable_windows();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Window>& _internal_windows() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Window>* _internal_mutable_windows();
  public:
  const ::IVR8::Window& windows(int index) const;
  ::IVR8::Window* add_windows();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
      windows() const;
  // repeated string vehicleIds = 4;
  int vehicleids_size() const;
  private:
  int _internal_vehicleids_size() const;

  public:
  void clear_vehicleids() ;
  const std::string& vehicleids(int index) const;
  std::string* mutable_vehicleids(int index);
  void set_vehicleids(int index, const std::string& value);
  void set_vehicleids(int index, std::string&& value);
  void set_vehicleids(int index, const char* value);
  void set_vehicleids(int index, const char* value, std::size_t size);
  void set_vehicleids(int index, absl::string_view value);
  std::string* add_vehicleids();
  void add_vehicleids(const std::string& value);
  void add_vehicleids(std::string&& value);
  void add_vehicleids(const char* value);
  void add_vehicleids(const char* value, std::size_t size);
  void add_vehicleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_vehicleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_vehicleids();

  public:
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional float quantity = 2;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Job.Task.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Window > windows_;
    ::google::protobuf::RepeatedPtrField<std::string> vehicleids_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Job_Task_TaskRelation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Job.Task.TaskRelation) */ {
 public:
  inline Job_Task_TaskRelation() : Job_Task_TaskRelation(nullptr) {}
  ~Job_Task_TaskRelation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_Task_TaskRelation(::google::protobuf::internal::ConstantInitialized);

  Job_Task_TaskRelation(const Job_Task_TaskRelation& from);
  Job_Task_TaskRelation(Job_Task_TaskRelation&& from) noexcept
    : Job_Task_TaskRelation() {
    *this = ::std::move(from);
  }

  inline Job_Task_TaskRelation& operator=(const Job_Task_TaskRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_Task_TaskRelation& operator=(Job_Task_TaskRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_Task_TaskRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_Task_TaskRelation* internal_default_instance() {
    return reinterpret_cast<const Job_Task_TaskRelation*>(
               &_Job_Task_TaskRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Job_Task_TaskRelation& a, Job_Task_TaskRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_Task_TaskRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_Task_TaskRelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_Task_TaskRelation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_Task_TaskRelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_Task_TaskRelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_Task_TaskRelation& from) {
    Job_Task_TaskRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task_TaskRelation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Job.Task.TaskRelation";
  }
  protected:
  explicit Job_Task_TaskRelation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Job_Task_TaskRelation_Type;
  static constexpr Type INCLUSIVE = Job_Task_TaskRelation_Type_INCLUSIVE;
  static constexpr Type EXCLUSIVE = Job_Task_TaskRelation_Type_EXCLUSIVE;
  static inline bool Type_IsValid(int value) {
    return Job_Task_TaskRelation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Job_Task_TaskRelation_Type_Type_MIN;
  static constexpr Type Type_MAX = Job_Task_TaskRelation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Job_Task_TaskRelation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Job_Task_TaskRelation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Job_Task_TaskRelation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Job_Task_TaskRelation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string taskIds = 2;
  int taskids_size() const;
  private:
  int _internal_taskids_size() const;

  public:
  void clear_taskids() ;
  const std::string& taskids(int index) const;
  std::string* mutable_taskids(int index);
  void set_taskids(int index, const std::string& value);
  void set_taskids(int index, std::string&& value);
  void set_taskids(int index, const char* value);
  void set_taskids(int index, const char* value, std::size_t size);
  void set_taskids(int index, absl::string_view value);
  std::string* add_taskids();
  void add_taskids(const std::string& value);
  void add_taskids(std::string&& value);
  void add_taskids(const char* value);
  void add_taskids(const char* value, std::size_t size);
  void add_taskids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& taskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_taskids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_taskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_taskids();

  public:
  // required .IVR8.Job.Task.TaskRelation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::IVR8::Job_Task_TaskRelation_Type type() const;
  void set_type(::IVR8::Job_Task_TaskRelation_Type value);

  private:
  ::IVR8::Job_Task_TaskRelation_Type _internal_type() const;
  void _internal_set_type(::IVR8::Job_Task_TaskRelation_Type value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Job.Task.TaskRelation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 42, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> taskids_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Job_Task final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Job.Task) */ {
 public:
  inline Job_Task() : Job_Task(nullptr) {}
  ~Job_Task() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_Task(::google::protobuf::internal::ConstantInitialized);

  Job_Task(const Job_Task& from);
  Job_Task(Job_Task&& from) noexcept
    : Job_Task() {
    *this = ::std::move(from);
  }

  inline Job_Task& operator=(const Job_Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_Task& operator=(Job_Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_Task* internal_default_instance() {
    return reinterpret_cast<const Job_Task*>(
               &_Job_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Job_Task& a, Job_Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_Task* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_Task& from) {
    Job_Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Job.Task";
  }
  protected:
  explicit Job_Task(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_Task_Attribute Attribute;
  typedef Job_Task_TaskRelation TaskRelation;

  using TripConstraint = Job_Task_TripConstraint;
  static constexpr TripConstraint FIRST = Job_Task_TripConstraint_FIRST;
  static constexpr TripConstraint LAST = Job_Task_TripConstraint_LAST;
  static inline bool TripConstraint_IsValid(int value) {
    return Job_Task_TripConstraint_IsValid(value);
  }
  static constexpr TripConstraint TripConstraint_MIN = Job_Task_TripConstraint_TripConstraint_MIN;
  static constexpr TripConstraint TripConstraint_MAX = Job_Task_TripConstraint_TripConstraint_MAX;
  static constexpr int TripConstraint_ARRAYSIZE = Job_Task_TripConstraint_TripConstraint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TripConstraint_descriptor() {
    return Job_Task_TripConstraint_descriptor();
  }
  template <typename T>
  static inline const std::string& TripConstraint_Name(T value) {
    return Job_Task_TripConstraint_Name(value);
  }
  static inline bool TripConstraint_Parse(absl::string_view name, TripConstraint* value) {
    return Job_Task_TripConstraint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kTripConstraintsFieldNumber = 4,
    kTaskIdFieldNumber = 1,
    kLocationIdFieldNumber = 2,
    kPredecessorsFieldNumber = 5,
    kSuccessorsFieldNumber = 6,
  };
  // repeated .IVR8.Job.Task.Attribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::Job_Task_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Job_Task_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Job_Task_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Job_Task_Attribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::Job_Task_Attribute& attributes(int index) const;
  ::IVR8::Job_Task_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Job_Task_Attribute >&
      attributes() const;
  // repeated .IVR8.Job.Task.TripConstraint tripConstraints = 4;
  int tripconstraints_size() const;
  private:
  int _internal_tripconstraints_size() const;

  public:
  void clear_tripconstraints() ;
  public:
  ::IVR8::Job_Task_TripConstraint tripconstraints(int index) const;
  void set_tripconstraints(int index, ::IVR8::Job_Task_TripConstraint value);
  void add_tripconstraints(::IVR8::Job_Task_TripConstraint value);
  const ::google::protobuf::RepeatedField<int>& tripconstraints() const;
  ::google::protobuf::RepeatedField<int>* mutable_tripconstraints();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_tripconstraints() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_tripconstraints();

  public:
  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // required string locationId = 2;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // optional .IVR8.Job.Task.TaskRelation predecessors = 5;
  bool has_predecessors() const;
  void clear_predecessors() ;
  const ::IVR8::Job_Task_TaskRelation& predecessors() const;
  PROTOBUF_NODISCARD ::IVR8::Job_Task_TaskRelation* release_predecessors();
  ::IVR8::Job_Task_TaskRelation* mutable_predecessors();
  void set_allocated_predecessors(::IVR8::Job_Task_TaskRelation* value);
  void unsafe_arena_set_allocated_predecessors(::IVR8::Job_Task_TaskRelation* value);
  ::IVR8::Job_Task_TaskRelation* unsafe_arena_release_predecessors();

  private:
  const ::IVR8::Job_Task_TaskRelation& _internal_predecessors() const;
  ::IVR8::Job_Task_TaskRelation* _internal_mutable_predecessors();

  public:
  // optional .IVR8.Job.Task.TaskRelation successors = 6;
  bool has_successors() const;
  void clear_successors() ;
  const ::IVR8::Job_Task_TaskRelation& successors() const;
  PROTOBUF_NODISCARD ::IVR8::Job_Task_TaskRelation* release_successors();
  ::IVR8::Job_Task_TaskRelation* mutable_successors();
  void set_allocated_successors(::IVR8::Job_Task_TaskRelation* value);
  void unsafe_arena_set_allocated_successors(::IVR8::Job_Task_TaskRelation* value);
  ::IVR8::Job_Task_TaskRelation* unsafe_arena_release_successors();

  private:
  const ::IVR8::Job_Task_TaskRelation& _internal_successors() const;
  ::IVR8::Job_Task_TaskRelation* _internal_mutable_successors();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Job.Task)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 4, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Job_Task_Attribute > attributes_;
    ::google::protobuf::RepeatedField<int> tripconstraints_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    ::IVR8::Job_Task_TaskRelation* predecessors_;
    ::IVR8::Job_Task_TaskRelation* successors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Job final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job(::google::protobuf::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Job";
  }
  protected:
  explicit Job(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_VehicleRelation VehicleRelation;
  typedef Job_CompartmentRelation CompartmentRelation;
  typedef Job_Task Task;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPickupTaskFieldNumber = 2,
    kDropoffTaskFieldNumber = 3,
    kVehicleRelationsFieldNumber = 5,
    kCompartmentRelationsFieldNumber = 6,
    kPenaltyFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .IVR8.Job.Task pickupTask = 2;
  bool has_pickuptask() const;
  void clear_pickuptask() ;
  const ::IVR8::Job_Task& pickuptask() const;
  PROTOBUF_NODISCARD ::IVR8::Job_Task* release_pickuptask();
  ::IVR8::Job_Task* mutable_pickuptask();
  void set_allocated_pickuptask(::IVR8::Job_Task* value);
  void unsafe_arena_set_allocated_pickuptask(::IVR8::Job_Task* value);
  ::IVR8::Job_Task* unsafe_arena_release_pickuptask();

  private:
  const ::IVR8::Job_Task& _internal_pickuptask() const;
  ::IVR8::Job_Task* _internal_mutable_pickuptask();

  public:
  // optional .IVR8.Job.Task dropoffTask = 3;
  bool has_dropofftask() const;
  void clear_dropofftask() ;
  const ::IVR8::Job_Task& dropofftask() const;
  PROTOBUF_NODISCARD ::IVR8::Job_Task* release_dropofftask();
  ::IVR8::Job_Task* mutable_dropofftask();
  void set_allocated_dropofftask(::IVR8::Job_Task* value);
  void unsafe_arena_set_allocated_dropofftask(::IVR8::Job_Task* value);
  ::IVR8::Job_Task* unsafe_arena_release_dropofftask();

  private:
  const ::IVR8::Job_Task& _internal_dropofftask() const;
  ::IVR8::Job_Task* _internal_mutable_dropofftask();

  public:
  // optional .IVR8.Job.VehicleRelation vehicleRelations = 5;
  bool has_vehiclerelations() const;
  void clear_vehiclerelations() ;
  const ::IVR8::Job_VehicleRelation& vehiclerelations() const;
  PROTOBUF_NODISCARD ::IVR8::Job_VehicleRelation* release_vehiclerelations();
  ::IVR8::Job_VehicleRelation* mutable_vehiclerelations();
  void set_allocated_vehiclerelations(::IVR8::Job_VehicleRelation* value);
  void unsafe_arena_set_allocated_vehiclerelations(::IVR8::Job_VehicleRelation* value);
  ::IVR8::Job_VehicleRelation* unsafe_arena_release_vehiclerelations();

  private:
  const ::IVR8::Job_VehicleRelation& _internal_vehiclerelations() const;
  ::IVR8::Job_VehicleRelation* _internal_mutable_vehiclerelations();

  public:
  // optional .IVR8.Job.CompartmentRelation compartmentRelations = 6;
  bool has_compartmentrelations() const;
  void clear_compartmentrelations() ;
  const ::IVR8::Job_CompartmentRelation& compartmentrelations() const;
  PROTOBUF_NODISCARD ::IVR8::Job_CompartmentRelation* release_compartmentrelations();
  ::IVR8::Job_CompartmentRelation* mutable_compartmentrelations();
  void set_allocated_compartmentrelations(::IVR8::Job_CompartmentRelation* value);
  void unsafe_arena_set_allocated_compartmentrelations(::IVR8::Job_CompartmentRelation* value);
  ::IVR8::Job_CompartmentRelation* unsafe_arena_release_compartmentrelations();

  private:
  const ::IVR8::Job_CompartmentRelation& _internal_compartmentrelations() const;
  ::IVR8::Job_CompartmentRelation* _internal_mutable_compartmentrelations();

  public:
  // required float penalty = 4;
  bool has_penalty() const;
  void clear_penalty() ;
  float penalty() const;
  void set_penalty(float value);

  private:
  float _internal_penalty() const;
  void _internal_set_penalty(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Job)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 4, 19, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::IVR8::Job_Task* pickuptask_;
    ::IVR8::Job_Task* dropofftask_;
    ::IVR8::Job_VehicleRelation* vehiclerelations_;
    ::IVR8::Job_CompartmentRelation* compartmentrelations_;
    float penalty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class TransitSet_TransitValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.TransitSet.TransitValue) */ {
 public:
  inline TransitSet_TransitValue() : TransitSet_TransitValue(nullptr) {}
  ~TransitSet_TransitValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitSet_TransitValue(::google::protobuf::internal::ConstantInitialized);

  TransitSet_TransitValue(const TransitSet_TransitValue& from);
  TransitSet_TransitValue(TransitSet_TransitValue&& from) noexcept
    : TransitSet_TransitValue() {
    *this = ::std::move(from);
  }

  inline TransitSet_TransitValue& operator=(const TransitSet_TransitValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitSet_TransitValue& operator=(TransitSet_TransitValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitSet_TransitValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitSet_TransitValue* internal_default_instance() {
    return reinterpret_cast<const TransitSet_TransitValue*>(
               &_TransitSet_TransitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TransitSet_TransitValue& a, TransitSet_TransitValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitSet_TransitValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitSet_TransitValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitSet_TransitValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitSet_TransitValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitSet_TransitValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitSet_TransitValue& from) {
    TransitSet_TransitValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitSet_TransitValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.TransitSet.TransitValue";
  }
  protected:
  explicit TransitSet_TransitValue(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromIdFieldNumber = 1,
    kToIdFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // required string fromId = 1;
  bool has_fromid() const;
  void clear_fromid() ;
  const std::string& fromid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromid(Arg_&& arg, Args_... args);
  std::string* mutable_fromid();
  PROTOBUF_NODISCARD std::string* release_fromid();
  void set_allocated_fromid(std::string* ptr);

  private:
  const std::string& _internal_fromid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromid(
      const std::string& value);
  std::string* _internal_mutable_fromid();

  public:
  // required string toId = 2;
  bool has_toid() const;
  void clear_toid() ;
  const std::string& toid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_toid(Arg_&& arg, Args_... args);
  std::string* mutable_toid();
  PROTOBUF_NODISCARD std::string* release_toid();
  void set_allocated_toid(std::string* ptr);

  private:
  const std::string& _internal_toid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toid(
      const std::string& value);
  std::string* _internal_mutable_toid();

  public:
  // required float value = 3;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.TransitSet.TransitValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr fromid_;
    ::google::protobuf::internal::ArenaStringPtr toid_;
    float value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class TransitSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.TransitSet) */ {
 public:
  inline TransitSet() : TransitSet(nullptr) {}
  ~TransitSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitSet(::google::protobuf::internal::ConstantInitialized);

  TransitSet(const TransitSet& from);
  TransitSet(TransitSet&& from) noexcept
    : TransitSet() {
    *this = ::std::move(from);
  }

  inline TransitSet& operator=(const TransitSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitSet& operator=(TransitSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitSet* internal_default_instance() {
    return reinterpret_cast<const TransitSet*>(
               &_TransitSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransitSet& a, TransitSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitSet& from) {
    TransitSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitSet* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.TransitSet";
  }
  protected:
  explicit TransitSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransitSet_TransitValue TransitValue;

  // accessors -------------------------------------------------------

  enum : int {
    kTransitsFieldNumber = 1,
  };
  // repeated .IVR8.TransitSet.TransitValue transits = 1;
  int transits_size() const;
  private:
  int _internal_transits_size() const;

  public:
  void clear_transits() ;
  ::IVR8::TransitSet_TransitValue* mutable_transits(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::TransitSet_TransitValue >*
      mutable_transits();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::TransitSet_TransitValue>& _internal_transits() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::TransitSet_TransitValue>* _internal_mutable_transits();
  public:
  const ::IVR8::TransitSet_TransitValue& transits(int index) const;
  ::IVR8::TransitSet_TransitValue* add_transits();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitSet_TransitValue >&
      transits() const;
  // @@protoc_insertion_point(class_scope:IVR8.TransitSet)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::IVR8::TransitSet_TransitValue > transits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class TransitGenerator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.TransitGenerator) */ {
 public:
  inline TransitGenerator() : TransitGenerator(nullptr) {}
  ~TransitGenerator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitGenerator(::google::protobuf::internal::ConstantInitialized);

  TransitGenerator(const TransitGenerator& from);
  TransitGenerator(TransitGenerator&& from) noexcept
    : TransitGenerator() {
    *this = ::std::move(from);
  }

  inline TransitGenerator& operator=(const TransitGenerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitGenerator& operator=(TransitGenerator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitGenerator& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitGenerator* internal_default_instance() {
    return reinterpret_cast<const TransitGenerator*>(
               &_TransitGenerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransitGenerator& a, TransitGenerator& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitGenerator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitGenerator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitGenerator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitGenerator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitGenerator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitGenerator& from) {
    TransitGenerator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitGenerator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.TransitGenerator";
  }
  protected:
  explicit TransitGenerator(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kTransitSetFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string requestId = 2;
  bool has_requestid() const;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* ptr);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // optional .IVR8.TransitSet transitSet = 3;
  bool has_transitset() const;
  void clear_transitset() ;
  const ::IVR8::TransitSet& transitset() const;
  PROTOBUF_NODISCARD ::IVR8::TransitSet* release_transitset();
  ::IVR8::TransitSet* mutable_transitset();
  void set_allocated_transitset(::IVR8::TransitSet* value);
  void unsafe_arena_set_allocated_transitset(::IVR8::TransitSet* value);
  ::IVR8::TransitSet* unsafe_arena_release_transitset();

  private:
  const ::IVR8::TransitSet& _internal_transitset() const;
  ::IVR8::TransitSet* _internal_mutable_transitset();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.TransitGenerator)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 41, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::IVR8::TransitSet* transitset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class VehicleClass_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.VehicleClass.Attribute) */ {
 public:
  inline VehicleClass_Attribute() : VehicleClass_Attribute(nullptr) {}
  ~VehicleClass_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleClass_Attribute(::google::protobuf::internal::ConstantInitialized);

  VehicleClass_Attribute(const VehicleClass_Attribute& from);
  VehicleClass_Attribute(VehicleClass_Attribute&& from) noexcept
    : VehicleClass_Attribute() {
    *this = ::std::move(from);
  }

  inline VehicleClass_Attribute& operator=(const VehicleClass_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleClass_Attribute& operator=(VehicleClass_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleClass_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleClass_Attribute* internal_default_instance() {
    return reinterpret_cast<const VehicleClass_Attribute*>(
               &_VehicleClass_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VehicleClass_Attribute& a, VehicleClass_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleClass_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleClass_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleClass_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleClass_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleClass_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleClass_Attribute& from) {
    VehicleClass_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleClass_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.VehicleClass.Attribute";
  }
  protected:
  explicit VehicleClass_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kTransitGeneratorIdFieldNumber = 2,
    kTransitCoefFieldNumber = 3,
    kTaskCoefFieldNumber = 4,
    kLocationCoefFieldNumber = 5,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional string transitGeneratorId = 2;
  bool has_transitgeneratorid() const;
  void clear_transitgeneratorid() ;
  const std::string& transitgeneratorid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transitgeneratorid(Arg_&& arg, Args_... args);
  std::string* mutable_transitgeneratorid();
  PROTOBUF_NODISCARD std::string* release_transitgeneratorid();
  void set_allocated_transitgeneratorid(std::string* ptr);

  private:
  const std::string& _internal_transitgeneratorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transitgeneratorid(
      const std::string& value);
  std::string* _internal_mutable_transitgeneratorid();

  public:
  // optional float transitCoef = 3;
  bool has_transitcoef() const;
  void clear_transitcoef() ;
  float transitcoef() const;
  void set_transitcoef(float value);

  private:
  float _internal_transitcoef() const;
  void _internal_set_transitcoef(float value);

  public:
  // optional float taskCoef = 4;
  bool has_taskcoef() const;
  void clear_taskcoef() ;
  float taskcoef() const;
  void set_taskcoef(float value);

  private:
  float _internal_taskcoef() const;
  void _internal_set_taskcoef(float value);

  public:
  // optional float locationCoef = 5;
  bool has_locationcoef() const;
  void clear_locationcoef() ;
  float locationcoef() const;
  void set_locationcoef(float value);

  private:
  float _internal_locationcoef() const;
  void _internal_set_locationcoef(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.VehicleClass.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 65, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    ::google::protobuf::internal::ArenaStringPtr transitgeneratorid_;
    float transitcoef_;
    float taskcoef_;
    float locationcoef_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class VehicleClass final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.VehicleClass) */ {
 public:
  inline VehicleClass() : VehicleClass(nullptr) {}
  ~VehicleClass() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleClass(::google::protobuf::internal::ConstantInitialized);

  VehicleClass(const VehicleClass& from);
  VehicleClass(VehicleClass&& from) noexcept
    : VehicleClass() {
    *this = ::std::move(from);
  }

  inline VehicleClass& operator=(const VehicleClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleClass& operator=(VehicleClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleClass* internal_default_instance() {
    return reinterpret_cast<const VehicleClass*>(
               &_VehicleClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VehicleClass& a, VehicleClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleClass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleClass* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleClass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleClass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleClass& from) {
    VehicleClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleClass* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.VehicleClass";
  }
  protected:
  explicit VehicleClass(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleClass_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kTransitRuleIdsFieldNumber = 3,
    kIdFieldNumber = 1,
    kCompartmentSetIdFieldNumber = 4,
  };
  // repeated .IVR8.VehicleClass.Attribute attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::VehicleClass_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass_Attribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::VehicleClass_Attribute& attributes(int index) const;
  ::IVR8::VehicleClass_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass_Attribute >&
      attributes() const;
  // repeated string transitRuleIds = 3;
  int transitruleids_size() const;
  private:
  int _internal_transitruleids_size() const;

  public:
  void clear_transitruleids() ;
  const std::string& transitruleids(int index) const;
  std::string* mutable_transitruleids(int index);
  void set_transitruleids(int index, const std::string& value);
  void set_transitruleids(int index, std::string&& value);
  void set_transitruleids(int index, const char* value);
  void set_transitruleids(int index, const char* value, std::size_t size);
  void set_transitruleids(int index, absl::string_view value);
  std::string* add_transitruleids();
  void add_transitruleids(const std::string& value);
  void add_transitruleids(std::string&& value);
  void add_transitruleids(const char* value);
  void add_transitruleids(const char* value, std::size_t size);
  void add_transitruleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transitruleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transitruleids();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string compartmentSetId = 4;
  bool has_compartmentsetid() const;
  void clear_compartmentsetid() ;
  const std::string& compartmentsetid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compartmentsetid(Arg_&& arg, Args_... args);
  std::string* mutable_compartmentsetid();
  PROTOBUF_NODISCARD std::string* release_compartmentsetid();
  void set_allocated_compartmentsetid(std::string* ptr);

  private:
  const std::string& _internal_compartmentsetid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compartmentsetid(
      const std::string& value);
  std::string* _internal_mutable_compartmentsetid();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.VehicleClass)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 58, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass_Attribute > attributes_;
    ::google::protobuf::RepeatedPtrField<std::string> transitruleids_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr compartmentsetid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class VehicleCostClass_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.VehicleCostClass.Attribute) */ {
 public:
  inline VehicleCostClass_Attribute() : VehicleCostClass_Attribute(nullptr) {}
  ~VehicleCostClass_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleCostClass_Attribute(::google::protobuf::internal::ConstantInitialized);

  VehicleCostClass_Attribute(const VehicleCostClass_Attribute& from);
  VehicleCostClass_Attribute(VehicleCostClass_Attribute&& from) noexcept
    : VehicleCostClass_Attribute() {
    *this = ::std::move(from);
  }

  inline VehicleCostClass_Attribute& operator=(const VehicleCostClass_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleCostClass_Attribute& operator=(VehicleCostClass_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleCostClass_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleCostClass_Attribute* internal_default_instance() {
    return reinterpret_cast<const VehicleCostClass_Attribute*>(
               &_VehicleCostClass_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VehicleCostClass_Attribute& a, VehicleCostClass_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleCostClass_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleCostClass_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleCostClass_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleCostClass_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleCostClass_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleCostClass_Attribute& from) {
    VehicleCostClass_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCostClass_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.VehicleCostClass.Attribute";
  }
  protected:
  explicit VehicleCostClass_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kTransitCostCoefFieldNumber = 2,
    kTaskCostCoefFieldNumber = 3,
    kLocationCostCoefFieldNumber = 4,
    kSlackCostCoefFieldNumber = 5,
    kTardyCostCoefFieldNumber = 6,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional float transitCostCoef = 2;
  bool has_transitcostcoef() const;
  void clear_transitcostcoef() ;
  float transitcostcoef() const;
  void set_transitcostcoef(float value);

  private:
  float _internal_transitcostcoef() const;
  void _internal_set_transitcostcoef(float value);

  public:
  // optional float taskCostCoef = 3;
  bool has_taskcostcoef() const;
  void clear_taskcostcoef() ;
  float taskcostcoef() const;
  void set_taskcostcoef(float value);

  private:
  float _internal_taskcostcoef() const;
  void _internal_set_taskcostcoef(float value);

  public:
  // optional float locationCostCoef = 4;
  bool has_locationcostcoef() const;
  void clear_locationcostcoef() ;
  float locationcostcoef() const;
  void set_locationcostcoef(float value);

  private:
  float _internal_locationcostcoef() const;
  void _internal_set_locationcostcoef(float value);

  public:
  // optional float slackCostCoef = 5;
  bool has_slackcostcoef() const;
  void clear_slackcostcoef() ;
  float slackcostcoef() const;
  void set_slackcostcoef(float value);

  private:
  float _internal_slackcostcoef() const;
  void _internal_set_slackcostcoef(float value);

  public:
  // optional float tardyCostCoef = 6;
  bool has_tardycostcoef() const;
  void clear_tardycostcoef() ;
  float tardycostcoef() const;
  void set_tardycostcoef(float value);

  private:
  float _internal_tardycostcoef() const;
  void _internal_set_tardycostcoef(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.VehicleCostClass.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float transitcostcoef_;
    float taskcostcoef_;
    float locationcostcoef_;
    float slackcostcoef_;
    float tardycostcoef_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class VehicleCostClass final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.VehicleCostClass) */ {
 public:
  inline VehicleCostClass() : VehicleCostClass(nullptr) {}
  ~VehicleCostClass() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleCostClass(::google::protobuf::internal::ConstantInitialized);

  VehicleCostClass(const VehicleCostClass& from);
  VehicleCostClass(VehicleCostClass&& from) noexcept
    : VehicleCostClass() {
    *this = ::std::move(from);
  }

  inline VehicleCostClass& operator=(const VehicleCostClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleCostClass& operator=(VehicleCostClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleCostClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleCostClass* internal_default_instance() {
    return reinterpret_cast<const VehicleCostClass*>(
               &_VehicleCostClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VehicleCostClass& a, VehicleCostClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleCostClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleCostClass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleCostClass* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleCostClass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleCostClass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleCostClass& from) {
    VehicleCostClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCostClass* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.VehicleCostClass";
  }
  protected:
  explicit VehicleCostClass(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleCostClass_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kIdFieldNumber = 1,
    kFixedCostFieldNumber = 2,
  };
  // repeated .IVR8.VehicleCostClass.Attribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::VehicleCostClass_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass_Attribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::VehicleCostClass_Attribute& attributes(int index) const;
  ::IVR8::VehicleCostClass_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass_Attribute >&
      attributes() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float fixedCost = 2;
  bool has_fixedcost() const;
  void clear_fixedcost() ;
  float fixedcost() const;
  void set_fixedcost(float value);

  private:
  float _internal_fixedcost() const;
  void _internal_set_fixedcost(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.VehicleCostClass)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass_Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float fixedcost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Task_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Vehicle.Task.Attribute) */ {
 public:
  inline Vehicle_Task_Attribute() : Vehicle_Task_Attribute(nullptr) {}
  ~Vehicle_Task_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Task_Attribute(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Task_Attribute(const Vehicle_Task_Attribute& from);
  Vehicle_Task_Attribute(Vehicle_Task_Attribute&& from) noexcept
    : Vehicle_Task_Attribute() {
    *this = ::std::move(from);
  }

  inline Vehicle_Task_Attribute& operator=(const Vehicle_Task_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Task_Attribute& operator=(Vehicle_Task_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Task_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Task_Attribute* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Task_Attribute*>(
               &_Vehicle_Task_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Vehicle_Task_Attribute& a, Vehicle_Task_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Task_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Task_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Task_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Task_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Task_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Task_Attribute& from) {
    Vehicle_Task_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Task_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Vehicle.Task.Attribute";
  }
  protected:
  explicit Vehicle_Task_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowsFieldNumber = 3,
    kDimensionIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // repeated .IVR8.Window windows = 3;
  int windows_size() const;
  private:
  int _internal_windows_size() const;

  public:
  void clear_windows() ;
  ::IVR8::Window* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
      mutable_windows();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Window>& _internal_windows() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Window>* _internal_mutable_windows();
  public:
  const ::IVR8::Window& windows(int index) const;
  ::IVR8::Window* add_windows();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
      windows() const;
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional float quantity = 2;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Vehicle.Task.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Window > windows_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Task final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Vehicle.Task) */ {
 public:
  inline Vehicle_Task() : Vehicle_Task(nullptr) {}
  ~Vehicle_Task() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Task(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Task(const Vehicle_Task& from);
  Vehicle_Task(Vehicle_Task&& from) noexcept
    : Vehicle_Task() {
    *this = ::std::move(from);
  }

  inline Vehicle_Task& operator=(const Vehicle_Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Task& operator=(Vehicle_Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Task* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Task*>(
               &_Vehicle_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Vehicle_Task& a, Vehicle_Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Task* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Task& from) {
    Vehicle_Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Task* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Vehicle.Task";
  }
  protected:
  explicit Vehicle_Task(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_Task_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kLocationIdFieldNumber = 1,
  };
  // repeated .IVR8.Vehicle.Task.Attribute attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::Vehicle_Task_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Task_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Task_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Task_Attribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::Vehicle_Task_Attribute& attributes(int index) const;
  ::IVR8::Vehicle_Task_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Task_Attribute >&
      attributes() const;
  // required string locationId = 1;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Vehicle.Task)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Task_Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Shift final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Vehicle.Shift) */ {
 public:
  inline Vehicle_Shift() : Vehicle_Shift(nullptr) {}
  ~Vehicle_Shift() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Shift(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Shift(const Vehicle_Shift& from);
  Vehicle_Shift(Vehicle_Shift&& from) noexcept
    : Vehicle_Shift() {
    *this = ::std::move(from);
  }

  inline Vehicle_Shift& operator=(const Vehicle_Shift& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Shift& operator=(Vehicle_Shift&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Shift& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Shift* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Shift*>(
               &_Vehicle_Shift_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Vehicle_Shift& a, Vehicle_Shift& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Shift* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Shift* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Shift* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Shift>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Shift& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Shift& from) {
    Vehicle_Shift::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Shift* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Vehicle.Shift";
  }
  protected:
  explicit Vehicle_Shift(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShiftStartFieldNumber = 1,
    kShiftEndFieldNumber = 2,
  };
  // required .IVR8.Vehicle.Task shiftStart = 1;
  bool has_shiftstart() const;
  void clear_shiftstart() ;
  const ::IVR8::Vehicle_Task& shiftstart() const;
  PROTOBUF_NODISCARD ::IVR8::Vehicle_Task* release_shiftstart();
  ::IVR8::Vehicle_Task* mutable_shiftstart();
  void set_allocated_shiftstart(::IVR8::Vehicle_Task* value);
  void unsafe_arena_set_allocated_shiftstart(::IVR8::Vehicle_Task* value);
  ::IVR8::Vehicle_Task* unsafe_arena_release_shiftstart();

  private:
  const ::IVR8::Vehicle_Task& _internal_shiftstart() const;
  ::IVR8::Vehicle_Task* _internal_mutable_shiftstart();

  public:
  // optional .IVR8.Vehicle.Task shiftEnd = 2;
  bool has_shiftend() const;
  void clear_shiftend() ;
  const ::IVR8::Vehicle_Task& shiftend() const;
  PROTOBUF_NODISCARD ::IVR8::Vehicle_Task* release_shiftend();
  ::IVR8::Vehicle_Task* mutable_shiftend();
  void set_allocated_shiftend(::IVR8::Vehicle_Task* value);
  void unsafe_arena_set_allocated_shiftend(::IVR8::Vehicle_Task* value);
  ::IVR8::Vehicle_Task* unsafe_arena_release_shiftend();

  private:
  const ::IVR8::Vehicle_Task& _internal_shiftend() const;
  ::IVR8::Vehicle_Task* _internal_mutable_shiftend();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Vehicle.Shift)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::IVR8::Vehicle_Task* shiftstart_;
    ::IVR8::Vehicle_Task* shiftend_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Capacity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Vehicle.Capacity) */ {
 public:
  inline Vehicle_Capacity() : Vehicle_Capacity(nullptr) {}
  ~Vehicle_Capacity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Capacity(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Capacity(const Vehicle_Capacity& from);
  Vehicle_Capacity(Vehicle_Capacity&& from) noexcept
    : Vehicle_Capacity() {
    *this = ::std::move(from);
  }

  inline Vehicle_Capacity& operator=(const Vehicle_Capacity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Capacity& operator=(Vehicle_Capacity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Capacity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Capacity* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Capacity*>(
               &_Vehicle_Capacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Vehicle_Capacity& a, Vehicle_Capacity& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Capacity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Capacity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Capacity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Capacity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Capacity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Capacity& from) {
    Vehicle_Capacity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Capacity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Vehicle.Capacity";
  }
  protected:
  explicit Vehicle_Capacity(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kCapacityFieldNumber = 2,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required float capacity = 2;
  bool has_capacity() const;
  void clear_capacity() ;
  float capacity() const;
  void set_capacity(float value);

  private:
  float _internal_capacity() const;
  void _internal_set_capacity(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Vehicle.Capacity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 41, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Vehicle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle(::google::protobuf::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Vehicle";
  }
  protected:
  explicit Vehicle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_Task Task;
  typedef Vehicle_Shift Shift;
  typedef Vehicle_Capacity Capacity;

  // accessors -------------------------------------------------------

  enum : int {
    kCapacitiesFieldNumber = 5,
    kTransitRuleIdsFieldNumber = 6,
    kIdFieldNumber = 1,
    kClassIdFieldNumber = 2,
    kCostClassIdFieldNumber = 3,
    kCompartmentSetIdFieldNumber = 7,
    kShiftFieldNumber = 4,
  };
  // repeated .IVR8.Vehicle.Capacity capacities = 5;
  int capacities_size() const;
  private:
  int _internal_capacities_size() const;

  public:
  void clear_capacities() ;
  ::IVR8::Vehicle_Capacity* mutable_capacities(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Capacity >*
      mutable_capacities();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Capacity>& _internal_capacities() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Capacity>* _internal_mutable_capacities();
  public:
  const ::IVR8::Vehicle_Capacity& capacities(int index) const;
  ::IVR8::Vehicle_Capacity* add_capacities();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Capacity >&
      capacities() const;
  // repeated string transitRuleIds = 6;
  int transitruleids_size() const;
  private:
  int _internal_transitruleids_size() const;

  public:
  void clear_transitruleids() ;
  const std::string& transitruleids(int index) const;
  std::string* mutable_transitruleids(int index);
  void set_transitruleids(int index, const std::string& value);
  void set_transitruleids(int index, std::string&& value);
  void set_transitruleids(int index, const char* value);
  void set_transitruleids(int index, const char* value, std::size_t size);
  void set_transitruleids(int index, absl::string_view value);
  std::string* add_transitruleids();
  void add_transitruleids(const std::string& value);
  void add_transitruleids(std::string&& value);
  void add_transitruleids(const char* value);
  void add_transitruleids(const char* value, std::size_t size);
  void add_transitruleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transitruleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transitruleids();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string classId = 2;
  bool has_classid() const;
  void clear_classid() ;
  const std::string& classid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_classid(Arg_&& arg, Args_... args);
  std::string* mutable_classid();
  PROTOBUF_NODISCARD std::string* release_classid();
  void set_allocated_classid(std::string* ptr);

  private:
  const std::string& _internal_classid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classid(
      const std::string& value);
  std::string* _internal_mutable_classid();

  public:
  // required string costClassId = 3;
  bool has_costclassid() const;
  void clear_costclassid() ;
  const std::string& costclassid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_costclassid(Arg_&& arg, Args_... args);
  std::string* mutable_costclassid();
  PROTOBUF_NODISCARD std::string* release_costclassid();
  void set_allocated_costclassid(std::string* ptr);

  private:
  const std::string& _internal_costclassid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_costclassid(
      const std::string& value);
  std::string* _internal_mutable_costclassid();

  public:
  // optional string compartmentSetId = 7;
  bool has_compartmentsetid() const;
  void clear_compartmentsetid() ;
  const std::string& compartmentsetid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compartmentsetid(Arg_&& arg, Args_... args);
  std::string* mutable_compartmentsetid();
  PROTOBUF_NODISCARD std::string* release_compartmentsetid();
  void set_allocated_compartmentsetid(std::string* ptr);

  private:
  const std::string& _internal_compartmentsetid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compartmentsetid(
      const std::string& value);
  std::string* _internal_mutable_compartmentsetid();

  public:
  // required .IVR8.Vehicle.Shift shift = 4;
  bool has_shift() const;
  void clear_shift() ;
  const ::IVR8::Vehicle_Shift& shift() const;
  PROTOBUF_NODISCARD ::IVR8::Vehicle_Shift* release_shift();
  ::IVR8::Vehicle_Shift* mutable_shift();
  void set_allocated_shift(::IVR8::Vehicle_Shift* value);
  void unsafe_arena_set_allocated_shift(::IVR8::Vehicle_Shift* value);
  ::IVR8::Vehicle_Shift* unsafe_arena_release_shift();

  private:
  const ::IVR8::Vehicle_Shift& _internal_shift() const;
  ::IVR8::Vehicle_Shift* _internal_mutable_shift();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Vehicle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 2, 71, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Capacity > capacities_;
    ::google::protobuf::RepeatedPtrField<std::string> transitruleids_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr classid_;
    ::google::protobuf::internal::ArenaStringPtr costclassid_;
    ::google::protobuf::internal::ArenaStringPtr compartmentsetid_;
    ::IVR8::Vehicle_Shift* shift_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class TaskSequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.TaskSequence) */ {
 public:
  inline TaskSequence() : TaskSequence(nullptr) {}
  ~TaskSequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskSequence(::google::protobuf::internal::ConstantInitialized);

  TaskSequence(const TaskSequence& from);
  TaskSequence(TaskSequence&& from) noexcept
    : TaskSequence() {
    *this = ::std::move(from);
  }

  inline TaskSequence& operator=(const TaskSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskSequence& operator=(TaskSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskSequence* internal_default_instance() {
    return reinterpret_cast<const TaskSequence*>(
               &_TaskSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TaskSequence& a, TaskSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskSequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskSequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskSequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskSequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TaskSequence& from) {
    TaskSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskSequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.TaskSequence";
  }
  protected:
  explicit TaskSequence(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kCompartmentIdFieldNumber = 3,
    kVehicleIdFieldNumber = 1,
  };
  // repeated string taskId = 2;
  int taskid_size() const;
  private:
  int _internal_taskid_size() const;

  public:
  void clear_taskid() ;
  const std::string& taskid(int index) const;
  std::string* mutable_taskid(int index);
  void set_taskid(int index, const std::string& value);
  void set_taskid(int index, std::string&& value);
  void set_taskid(int index, const char* value);
  void set_taskid(int index, const char* value, std::size_t size);
  void set_taskid(int index, absl::string_view value);
  std::string* add_taskid();
  void add_taskid(const std::string& value);
  void add_taskid(std::string&& value);
  void add_taskid(const char* value);
  void add_taskid(const char* value, std::size_t size);
  void add_taskid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& taskid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_taskid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_taskid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_taskid();

  public:
  // repeated string compartmentId = 3;
  int compartmentid_size() const;
  private:
  int _internal_compartmentid_size() const;

  public:
  void clear_compartmentid() ;
  const std::string& compartmentid(int index) const;
  std::string* mutable_compartmentid(int index);
  void set_compartmentid(int index, const std::string& value);
  void set_compartmentid(int index, std::string&& value);
  void set_compartmentid(int index, const char* value);
  void set_compartmentid(int index, const char* value, std::size_t size);
  void set_compartmentid(int index, absl::string_view value);
  std::string* add_compartmentid();
  void add_compartmentid(const std::string& value);
  void add_compartmentid(std::string&& value);
  void add_compartmentid(const char* value);
  void add_compartmentid(const char* value, std::size_t size);
  void add_compartmentid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& compartmentid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_compartmentid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_compartmentid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_compartmentid();

  public:
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.TaskSequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 54, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> taskid_;
    ::google::protobuf::RepeatedPtrField<std::string> compartmentid_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class TransitRule_Trigger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.TransitRule.Trigger) */ {
 public:
  inline TransitRule_Trigger() : TransitRule_Trigger(nullptr) {}
  ~TransitRule_Trigger() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitRule_Trigger(::google::protobuf::internal::ConstantInitialized);

  TransitRule_Trigger(const TransitRule_Trigger& from);
  TransitRule_Trigger(TransitRule_Trigger&& from) noexcept
    : TransitRule_Trigger() {
    *this = ::std::move(from);
  }

  inline TransitRule_Trigger& operator=(const TransitRule_Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitRule_Trigger& operator=(TransitRule_Trigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitRule_Trigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitRule_Trigger* internal_default_instance() {
    return reinterpret_cast<const TransitRule_Trigger*>(
               &_TransitRule_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TransitRule_Trigger& a, TransitRule_Trigger& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitRule_Trigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitRule_Trigger* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitRule_Trigger* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitRule_Trigger>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitRule_Trigger& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitRule_Trigger& from) {
    TransitRule_Trigger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitRule_Trigger* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.TransitRule.Trigger";
  }
  protected:
  explicit TransitRule_Trigger(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // required float value = 1;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // required float quantity = 2;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.TransitRule.Trigger)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float value_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class TransitRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.TransitRule) */ {
 public:
  inline TransitRule() : TransitRule(nullptr) {}
  ~TransitRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitRule(::google::protobuf::internal::ConstantInitialized);

  TransitRule(const TransitRule& from);
  TransitRule(TransitRule&& from) noexcept
    : TransitRule() {
    *this = ::std::move(from);
  }

  inline TransitRule& operator=(const TransitRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitRule& operator=(TransitRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitRule* internal_default_instance() {
    return reinterpret_cast<const TransitRule*>(
               &_TransitRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TransitRule& a, TransitRule& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitRule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitRule& from) {
    TransitRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitRule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.TransitRule";
  }
  protected:
  explicit TransitRule(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransitRule_Trigger Trigger;

  // accessors -------------------------------------------------------

  enum : int {
    kTriggersFieldNumber = 6,
    kIdFieldNumber = 1,
    kDimensionIdFieldNumber = 2,
    kRuleIdPrefixFieldNumber = 5,
    kUseTransitStateFieldNumber = 4,
    kUseStandingStateFieldNumber = 3,
  };
  // repeated .IVR8.TransitRule.Trigger triggers = 6;
  int triggers_size() const;
  private:
  int _internal_triggers_size() const;

  public:
  void clear_triggers() ;
  ::IVR8::TransitRule_Trigger* mutable_triggers(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule_Trigger >*
      mutable_triggers();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule_Trigger>& _internal_triggers() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule_Trigger>* _internal_mutable_triggers();
  public:
  const ::IVR8::TransitRule_Trigger& triggers(int index) const;
  ::IVR8::TransitRule_Trigger* add_triggers();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule_Trigger >&
      triggers() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string dimensionId = 2;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required string ruleIdPrefix = 5;
  bool has_ruleidprefix() const;
  void clear_ruleidprefix() ;
  const std::string& ruleidprefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ruleidprefix(Arg_&& arg, Args_... args);
  std::string* mutable_ruleidprefix();
  PROTOBUF_NODISCARD std::string* release_ruleidprefix();
  void set_allocated_ruleidprefix(std::string* ptr);

  private:
  const std::string& _internal_ruleidprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruleidprefix(
      const std::string& value);
  std::string* _internal_mutable_ruleidprefix();

  public:
  // optional bool useTransitState = 4 [default = false];
  bool has_usetransitstate() const;
  void clear_usetransitstate() ;
  bool usetransitstate() const;
  void set_usetransitstate(bool value);

  private:
  bool _internal_usetransitstate() const;
  void _internal_set_usetransitstate(bool value);

  public:
  // optional bool useStandingState = 3 [default = true];
  bool has_usestandingstate() const;
  void clear_usestandingstate() ;
  bool usestandingstate() const;
  void set_usestandingstate(bool value);

  private:
  bool _internal_usestandingstate() const;
  void _internal_set_usestandingstate(bool value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.TransitRule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule_Trigger > triggers_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    ::google::protobuf::internal::ArenaStringPtr ruleidprefix_;
    bool usetransitstate_;
    bool usestandingstate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Compartment_Capacity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Compartment.Capacity) */ {
 public:
  inline Compartment_Capacity() : Compartment_Capacity(nullptr) {}
  ~Compartment_Capacity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Compartment_Capacity(::google::protobuf::internal::ConstantInitialized);

  Compartment_Capacity(const Compartment_Capacity& from);
  Compartment_Capacity(Compartment_Capacity&& from) noexcept
    : Compartment_Capacity() {
    *this = ::std::move(from);
  }

  inline Compartment_Capacity& operator=(const Compartment_Capacity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Compartment_Capacity& operator=(Compartment_Capacity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Compartment_Capacity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Compartment_Capacity* internal_default_instance() {
    return reinterpret_cast<const Compartment_Capacity*>(
               &_Compartment_Capacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Compartment_Capacity& a, Compartment_Capacity& b) {
    a.Swap(&b);
  }
  inline void Swap(Compartment_Capacity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Compartment_Capacity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Compartment_Capacity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Compartment_Capacity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Compartment_Capacity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Compartment_Capacity& from) {
    Compartment_Capacity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Compartment_Capacity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Compartment.Capacity";
  }
  protected:
  explicit Compartment_Capacity(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kCapacityFieldNumber = 2,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required float capacity = 2;
  bool has_capacity() const;
  void clear_capacity() ;
  float capacity() const;
  void set_capacity(float value);

  private:
  float _internal_capacity() const;
  void _internal_set_capacity(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Compartment.Capacity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Compartment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Compartment) */ {
 public:
  inline Compartment() : Compartment(nullptr) {}
  ~Compartment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Compartment(::google::protobuf::internal::ConstantInitialized);

  Compartment(const Compartment& from);
  Compartment(Compartment&& from) noexcept
    : Compartment() {
    *this = ::std::move(from);
  }

  inline Compartment& operator=(const Compartment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Compartment& operator=(Compartment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Compartment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Compartment* internal_default_instance() {
    return reinterpret_cast<const Compartment*>(
               &_Compartment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Compartment& a, Compartment& b) {
    a.Swap(&b);
  }
  inline void Swap(Compartment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Compartment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Compartment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Compartment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Compartment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Compartment& from) {
    Compartment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Compartment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Compartment";
  }
  protected:
  explicit Compartment(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Compartment_Capacity Capacity;

  // accessors -------------------------------------------------------

  enum : int {
    kCapacitiesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .IVR8.Compartment.Capacity capacities = 2;
  int capacities_size() const;
  private:
  int _internal_capacities_size() const;

  public:
  void clear_capacities() ;
  ::IVR8::Compartment_Capacity* mutable_capacities(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment_Capacity >*
      mutable_capacities();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Compartment_Capacity>& _internal_capacities() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Compartment_Capacity>* _internal_mutable_capacities();
  public:
  const ::IVR8::Compartment_Capacity& capacities(int index) const;
  ::IVR8::Compartment_Capacity* add_capacities();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment_Capacity >&
      capacities() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Compartment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 27, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment_Capacity > capacities_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class CompartmentSet_GroupLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.CompartmentSet.GroupLimit) */ {
 public:
  inline CompartmentSet_GroupLimit() : CompartmentSet_GroupLimit(nullptr) {}
  ~CompartmentSet_GroupLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompartmentSet_GroupLimit(::google::protobuf::internal::ConstantInitialized);

  CompartmentSet_GroupLimit(const CompartmentSet_GroupLimit& from);
  CompartmentSet_GroupLimit(CompartmentSet_GroupLimit&& from) noexcept
    : CompartmentSet_GroupLimit() {
    *this = ::std::move(from);
  }

  inline CompartmentSet_GroupLimit& operator=(const CompartmentSet_GroupLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompartmentSet_GroupLimit& operator=(CompartmentSet_GroupLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompartmentSet_GroupLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompartmentSet_GroupLimit* internal_default_instance() {
    return reinterpret_cast<const CompartmentSet_GroupLimit*>(
               &_CompartmentSet_GroupLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CompartmentSet_GroupLimit& a, CompartmentSet_GroupLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(CompartmentSet_GroupLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompartmentSet_GroupLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompartmentSet_GroupLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompartmentSet_GroupLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompartmentSet_GroupLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CompartmentSet_GroupLimit& from) {
    CompartmentSet_GroupLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompartmentSet_GroupLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.CompartmentSet.GroupLimit";
  }
  protected:
  explicit CompartmentSet_GroupLimit(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompartmentIdsFieldNumber = 1,
    kCoefficientsFieldNumber = 2,
    kDimensionIdFieldNumber = 3,
    kLimitFieldNumber = 4,
    kCheckStandingStateFieldNumber = 5,
  };
  // repeated string compartmentIds = 1;
  int compartmentids_size() const;
  private:
  int _internal_compartmentids_size() const;

  public:
  void clear_compartmentids() ;
  const std::string& compartmentids(int index) const;
  std::string* mutable_compartmentids(int index);
  void set_compartmentids(int index, const std::string& value);
  void set_compartmentids(int index, std::string&& value);
  void set_compartmentids(int index, const char* value);
  void set_compartmentids(int index, const char* value, std::size_t size);
  void set_compartmentids(int index, absl::string_view value);
  std::string* add_compartmentids();
  void add_compartmentids(const std::string& value);
  void add_compartmentids(std::string&& value);
  void add_compartmentids(const char* value);
  void add_compartmentids(const char* value, std::size_t size);
  void add_compartmentids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& compartmentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_compartmentids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_compartmentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_compartmentids();

  public:
  // repeated float coefficients = 2;
  int coefficients_size() const;
  private:
  int _internal_coefficients_size() const;

  public:
  void clear_coefficients() ;
  float coefficients(int index) const;
  void set_coefficients(int index, float value);
  void add_coefficients(float value);
  const ::google::protobuf::RepeatedField<float>& coefficients() const;
  ::google::protobuf::RepeatedField<float>* mutable_coefficients();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_coefficients() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_coefficients();

  public:
  // required string dimensionId = 3;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required float limit = 4;
  bool has_limit() const;
  void clear_limit() ;
  float limit() const;
  void set_limit(float value);

  private:
  float _internal_limit() const;
  void _internal_set_limit(float value);

  public:
  // optional bool checkStandingState = 5 [default = false];
  bool has_checkstandingstate() const;
  void clear_checkstandingstate() ;
  bool checkstandingstate() const;
  void set_checkstandingstate(bool value);

  private:
  bool _internal_checkstandingstate() const;
  void _internal_set_checkstandingstate(bool value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.CompartmentSet.GroupLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 64, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> compartmentids_;
    ::google::protobuf::RepeatedField<float> coefficients_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float limit_;
    bool checkstandingstate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class CompartmentSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.CompartmentSet) */ {
 public:
  inline CompartmentSet() : CompartmentSet(nullptr) {}
  ~CompartmentSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompartmentSet(::google::protobuf::internal::ConstantInitialized);

  CompartmentSet(const CompartmentSet& from);
  CompartmentSet(CompartmentSet&& from) noexcept
    : CompartmentSet() {
    *this = ::std::move(from);
  }

  inline CompartmentSet& operator=(const CompartmentSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompartmentSet& operator=(CompartmentSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompartmentSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompartmentSet* internal_default_instance() {
    return reinterpret_cast<const CompartmentSet*>(
               &_CompartmentSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CompartmentSet& a, CompartmentSet& b) {
    a.Swap(&b);
  }
  inline void Swap(CompartmentSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompartmentSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompartmentSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompartmentSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompartmentSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CompartmentSet& from) {
    CompartmentSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompartmentSet* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.CompartmentSet";
  }
  protected:
  explicit CompartmentSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompartmentSet_GroupLimit GroupLimit;

  // accessors -------------------------------------------------------

  enum : int {
    kCompartmentIdsFieldNumber = 2,
    kGroupLimitsFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated string compartmentIds = 2;
  int compartmentids_size() const;
  private:
  int _internal_compartmentids_size() const;

  public:
  void clear_compartmentids() ;
  const std::string& compartmentids(int index) const;
  std::string* mutable_compartmentids(int index);
  void set_compartmentids(int index, const std::string& value);
  void set_compartmentids(int index, std::string&& value);
  void set_compartmentids(int index, const char* value);
  void set_compartmentids(int index, const char* value, std::size_t size);
  void set_compartmentids(int index, absl::string_view value);
  std::string* add_compartmentids();
  void add_compartmentids(const std::string& value);
  void add_compartmentids(std::string&& value);
  void add_compartmentids(const char* value);
  void add_compartmentids(const char* value, std::size_t size);
  void add_compartmentids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& compartmentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_compartmentids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_compartmentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_compartmentids();

  public:
  // repeated .IVR8.CompartmentSet.GroupLimit groupLimits = 3;
  int grouplimits_size() const;
  private:
  int _internal_grouplimits_size() const;

  public:
  void clear_grouplimits() ;
  ::IVR8::CompartmentSet_GroupLimit* mutable_grouplimits(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet_GroupLimit >*
      mutable_grouplimits();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet_GroupLimit>& _internal_grouplimits() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet_GroupLimit>* _internal_mutable_grouplimits();
  public:
  const ::IVR8::CompartmentSet_GroupLimit& grouplimits(int index) const;
  ::IVR8::CompartmentSet_GroupLimit* add_grouplimits();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet_GroupLimit >&
      grouplimits() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.CompartmentSet)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> compartmentids_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet_GroupLimit > grouplimits_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::google::protobuf::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.Model";
  }
  protected:
  explicit Model(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 2,
    kJobsFieldNumber = 3,
    kVehiclesFieldNumber = 4,
    kVehicleClassesFieldNumber = 5,
    kVehicleCostClassesFieldNumber = 6,
    kTransitRulesFieldNumber = 7,
    kTransitGeneratorsFieldNumber = 8,
    kTaskSequenceFieldNumber = 9,
    kCompartmentsFieldNumber = 10,
    kCompartmentSetsFieldNumber = 11,
    kDimensionsFieldNumber = 1,
  };
  // repeated .IVR8.Location locations = 2;
  int locations_size() const;
  private:
  int _internal_locations_size() const;

  public:
  void clear_locations() ;
  ::IVR8::Location* mutable_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Location >*
      mutable_locations();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Location>& _internal_locations() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Location>* _internal_mutable_locations();
  public:
  const ::IVR8::Location& locations(int index) const;
  ::IVR8::Location* add_locations();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Location >&
      locations() const;
  // repeated .IVR8.Job jobs = 3;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;

  public:
  void clear_jobs() ;
  ::IVR8::Job* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Job >*
      mutable_jobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Job>& _internal_jobs() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Job>* _internal_mutable_jobs();
  public:
  const ::IVR8::Job& jobs(int index) const;
  ::IVR8::Job* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Job >&
      jobs() const;
  // repeated .IVR8.Vehicle vehicles = 4;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;

  public:
  void clear_vehicles() ;
  ::IVR8::Vehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle >*
      mutable_vehicles();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle>& _internal_vehicles() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle>* _internal_mutable_vehicles();
  public:
  const ::IVR8::Vehicle& vehicles(int index) const;
  ::IVR8::Vehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle >&
      vehicles() const;
  // repeated .IVR8.VehicleClass vehicleClasses = 5;
  int vehicleclasses_size() const;
  private:
  int _internal_vehicleclasses_size() const;

  public:
  void clear_vehicleclasses() ;
  ::IVR8::VehicleClass* mutable_vehicleclasses(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass >*
      mutable_vehicleclasses();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass>& _internal_vehicleclasses() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass>* _internal_mutable_vehicleclasses();
  public:
  const ::IVR8::VehicleClass& vehicleclasses(int index) const;
  ::IVR8::VehicleClass* add_vehicleclasses();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass >&
      vehicleclasses() const;
  // repeated .IVR8.VehicleCostClass vehicleCostClasses = 6;
  int vehiclecostclasses_size() const;
  private:
  int _internal_vehiclecostclasses_size() const;

  public:
  void clear_vehiclecostclasses() ;
  ::IVR8::VehicleCostClass* mutable_vehiclecostclasses(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass >*
      mutable_vehiclecostclasses();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass>& _internal_vehiclecostclasses() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass>* _internal_mutable_vehiclecostclasses();
  public:
  const ::IVR8::VehicleCostClass& vehiclecostclasses(int index) const;
  ::IVR8::VehicleCostClass* add_vehiclecostclasses();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass >&
      vehiclecostclasses() const;
  // repeated .IVR8.TransitRule transitRules = 7;
  int transitrules_size() const;
  private:
  int _internal_transitrules_size() const;

  public:
  void clear_transitrules() ;
  ::IVR8::TransitRule* mutable_transitrules(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule >*
      mutable_transitrules();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule>& _internal_transitrules() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule>* _internal_mutable_transitrules();
  public:
  const ::IVR8::TransitRule& transitrules(int index) const;
  ::IVR8::TransitRule* add_transitrules();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule >&
      transitrules() const;
  // repeated .IVR8.TransitGenerator transitGenerators = 8;
  int transitgenerators_size() const;
  private:
  int _internal_transitgenerators_size() const;

  public:
  void clear_transitgenerators() ;
  ::IVR8::TransitGenerator* mutable_transitgenerators(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::TransitGenerator >*
      mutable_transitgenerators();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::TransitGenerator>& _internal_transitgenerators() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::TransitGenerator>* _internal_mutable_transitgenerators();
  public:
  const ::IVR8::TransitGenerator& transitgenerators(int index) const;
  ::IVR8::TransitGenerator* add_transitgenerators();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitGenerator >&
      transitgenerators() const;
  // repeated .IVR8.TaskSequence taskSequence = 9;
  int tasksequence_size() const;
  private:
  int _internal_tasksequence_size() const;

  public:
  void clear_tasksequence() ;
  ::IVR8::TaskSequence* mutable_tasksequence(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >*
      mutable_tasksequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>& _internal_tasksequence() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>* _internal_mutable_tasksequence();
  public:
  const ::IVR8::TaskSequence& tasksequence(int index) const;
  ::IVR8::TaskSequence* add_tasksequence();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >&
      tasksequence() const;
  // repeated .IVR8.Compartment compartments = 10;
  int compartments_size() const;
  private:
  int _internal_compartments_size() const;

  public:
  void clear_compartments() ;
  ::IVR8::Compartment* mutable_compartments(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment >*
      mutable_compartments();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Compartment>& _internal_compartments() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Compartment>* _internal_mutable_compartments();
  public:
  const ::IVR8::Compartment& compartments(int index) const;
  ::IVR8::Compartment* add_compartments();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment >&
      compartments() const;
  // repeated .IVR8.CompartmentSet compartmentSets = 11;
  int compartmentsets_size() const;
  private:
  int _internal_compartmentsets_size() const;

  public:
  void clear_compartmentsets() ;
  ::IVR8::CompartmentSet* mutable_compartmentsets(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet >*
      mutable_compartmentsets();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet>& _internal_compartmentsets() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet>* _internal_mutable_compartmentsets();
  public:
  const ::IVR8::CompartmentSet& compartmentsets(int index) const;
  ::IVR8::CompartmentSet* add_compartmentsets();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet >&
      compartmentsets() const;
  // required .IVR8.DimensionConfiguration dimensions = 1;
  bool has_dimensions() const;
  void clear_dimensions() ;
  const ::IVR8::DimensionConfiguration& dimensions() const;
  PROTOBUF_NODISCARD ::IVR8::DimensionConfiguration* release_dimensions();
  ::IVR8::DimensionConfiguration* mutable_dimensions();
  void set_allocated_dimensions(::IVR8::DimensionConfiguration* value);
  void unsafe_arena_set_allocated_dimensions(::IVR8::DimensionConfiguration* value);
  ::IVR8::DimensionConfiguration* unsafe_arena_release_dimensions();

  private:
  const ::IVR8::DimensionConfiguration& _internal_dimensions() const;
  ::IVR8::DimensionConfiguration* _internal_mutable_dimensions();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.Model)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11, 11, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Location > locations_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Job > jobs_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle > vehicles_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass > vehicleclasses_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass > vehiclecostclasses_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule > transitrules_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::TransitGenerator > transitgenerators_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence > tasksequence_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment > compartments_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet > compartmentsets_;
    ::IVR8::DimensionConfiguration* dimensions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated .IVR8.TaskSequence routes = 3;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::IVR8::TaskSequence* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>* _internal_mutable_routes();
  public:
  const ::IVR8::TaskSequence& routes(int index) const;
  ::IVR8::TaskSequence* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >&
      routes() const;
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .IVR8.Model model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::IVR8::Model& model() const;
  PROTOBUF_NODISCARD ::IVR8::Model* release_model();
  ::IVR8::Model* mutable_model();
  void set_allocated_model(::IVR8::Model* value);
  void unsafe_arena_set_allocated_model(::IVR8::Model* value);
  ::IVR8::Model* unsafe_arena_release_model();

  private:
  const ::IVR8::Model& _internal_model() const;
  ::IVR8::Model* _internal_mutable_model();

  public:
  // optional .IVR8.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::IVR8::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::IVR8::SolveRequest_SolveType value);

  private:
  ::IVR8::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::IVR8::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 3, 33, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence > routes_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::IVR8::Model* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_StopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.StopAttribute) */ {
 public:
  inline SolutionResponse_StopAttribute() : SolutionResponse_StopAttribute(nullptr) {}
  ~SolutionResponse_StopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_StopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_StopAttribute(const SolutionResponse_StopAttribute& from);
  SolutionResponse_StopAttribute(SolutionResponse_StopAttribute&& from) noexcept
    : SolutionResponse_StopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_StopAttribute& operator=(const SolutionResponse_StopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_StopAttribute& operator=(SolutionResponse_StopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_StopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_StopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_StopAttribute*>(
               &_SolutionResponse_StopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SolutionResponse_StopAttribute& a, SolutionResponse_StopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_StopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_StopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_StopAttribute& from) {
    SolutionResponse_StopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_StopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.StopAttribute";
  }
  protected:
  explicit SolutionResponse_StopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
    kSlackValueFieldNumber = 5,
    kSlackCostFieldNumber = 6,
    kTardyValueFieldNumber = 7,
    kTardyCostFieldNumber = 8,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // required float slackValue = 5;
  bool has_slackvalue() const;
  void clear_slackvalue() ;
  float slackvalue() const;
  void set_slackvalue(float value);

  private:
  float _internal_slackvalue() const;
  void _internal_set_slackvalue(float value);

  public:
  // required float slackCost = 6;
  bool has_slackcost() const;
  void clear_slackcost() ;
  float slackcost() const;
  void set_slackcost(float value);

  private:
  float _internal_slackcost() const;
  void _internal_set_slackcost(float value);

  public:
  // required float tardyValue = 7;
  bool has_tardyvalue() const;
  void clear_tardyvalue() ;
  float tardyvalue() const;
  void set_tardyvalue(float value);

  private:
  float _internal_tardyvalue() const;
  void _internal_set_tardyvalue(float value);

  public:
  // required float tardyCost = 8;
  bool has_tardycost() const;
  void clear_tardycost() ;
  float tardycost() const;
  void set_tardycost(float value);

  private:
  float _internal_tardycost() const;
  void _internal_set_tardycost(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.StopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8, 0, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    float slackvalue_;
    float slackcost_;
    float tardyvalue_;
    float tardycost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.InterStopAttribute) */ {
 public:
  inline SolutionResponse_InterStopAttribute() : SolutionResponse_InterStopAttribute(nullptr) {}
  ~SolutionResponse_InterStopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStopAttribute(const SolutionResponse_InterStopAttribute& from);
  SolutionResponse_InterStopAttribute(SolutionResponse_InterStopAttribute&& from) noexcept
    : SolutionResponse_InterStopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStopAttribute& operator=(const SolutionResponse_InterStopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStopAttribute& operator=(SolutionResponse_InterStopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStopAttribute*>(
               &_SolutionResponse_InterStopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SolutionResponse_InterStopAttribute& a, SolutionResponse_InterStopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStopAttribute& from) {
    SolutionResponse_InterStopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.InterStopAttribute";
  }
  protected:
  explicit SolutionResponse_InterStopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.InterStopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 54, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Stop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.Stop) */ {
 public:
  inline SolutionResponse_Stop() : SolutionResponse_Stop(nullptr) {}
  ~SolutionResponse_Stop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Stop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Stop(const SolutionResponse_Stop& from);
  SolutionResponse_Stop(SolutionResponse_Stop&& from) noexcept
    : SolutionResponse_Stop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Stop& operator=(const SolutionResponse_Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Stop& operator=(SolutionResponse_Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Stop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Stop*>(
               &_SolutionResponse_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SolutionResponse_Stop& a, SolutionResponse_Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Stop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Stop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Stop& from) {
    SolutionResponse_Stop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Stop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.Stop";
  }
  protected:
  explicit SolutionResponse_Stop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 6,
    kLocationIdFieldNumber = 3,
    kTaskIdFieldNumber = 4,
    kJobIdFieldNumber = 5,
    kCompartmentIdFieldNumber = 7,
    kIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
  };
  // repeated .IVR8.SolutionResponse.StopAttribute attributes = 6;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::SolutionResponse_StopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_StopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_StopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_StopAttribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::SolutionResponse_StopAttribute& attributes(int index) const;
  ::IVR8::SolutionResponse_StopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_StopAttribute >&
      attributes() const;
  // required string locationId = 3;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // required string taskId = 4;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // required string jobId = 5;
  bool has_jobid() const;
  void clear_jobid() ;
  const std::string& jobid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jobid(Arg_&& arg, Args_... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* ptr);

  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(
      const std::string& value);
  std::string* _internal_mutable_jobid();

  public:
  // optional string compartmentId = 7;
  bool has_compartmentid() const;
  void clear_compartmentid() ;
  const std::string& compartmentid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compartmentid(Arg_&& arg, Args_... args);
  std::string* mutable_compartmentid();
  PROTOBUF_NODISCARD std::string* release_compartmentid();
  void set_allocated_compartmentid(std::string* ptr);

  private:
  const std::string& _internal_compartmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compartmentid(
      const std::string& value);
  std::string* _internal_mutable_compartmentid();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence() ;
  ::int32_t sequence() const;
  void set_sequence(::int32_t value);

  private:
  ::int32_t _internal_sequence() const;
  void _internal_set_sequence(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.Stop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 1, 69, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_StopAttribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    ::google::protobuf::internal::ArenaStringPtr jobid_;
    ::google::protobuf::internal::ArenaStringPtr compartmentid_;
    ::int32_t id_;
    ::int32_t sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.InterStop) */ {
 public:
  inline SolutionResponse_InterStop() : SolutionResponse_InterStop(nullptr) {}
  ~SolutionResponse_InterStop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStop(const SolutionResponse_InterStop& from);
  SolutionResponse_InterStop(SolutionResponse_InterStop&& from) noexcept
    : SolutionResponse_InterStop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStop& operator=(const SolutionResponse_InterStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStop& operator=(SolutionResponse_InterStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStop*>(
               &_SolutionResponse_InterStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SolutionResponse_InterStop& a, SolutionResponse_InterStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStop& from) {
    SolutionResponse_InterStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.InterStop";
  }
  protected:
  explicit SolutionResponse_InterStop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kRouteSegmentsFieldNumber = 4,
    kFromStopIdFieldNumber = 1,
    kToStopIdFieldNumber = 2,
  };
  // repeated .IVR8.SolutionResponse.InterStopAttribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::IVR8::SolutionResponse_InterStopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStopAttribute>* _internal_mutable_attributes();
  public:
  const ::IVR8::SolutionResponse_InterStopAttribute& attributes(int index) const;
  ::IVR8::SolutionResponse_InterStopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStopAttribute >&
      attributes() const;
  // repeated .IVR8.Geocode routeSegments = 4;
  int routesegments_size() const;
  private:
  int _internal_routesegments_size() const;

  public:
  void clear_routesegments() ;
  ::IVR8::Geocode* mutable_routesegments(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::Geocode >*
      mutable_routesegments();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::Geocode>& _internal_routesegments() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::Geocode>* _internal_mutable_routesegments();
  public:
  const ::IVR8::Geocode& routesegments(int index) const;
  ::IVR8::Geocode* add_routesegments();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::Geocode >&
      routesegments() const;
  // required int32 fromStopId = 1;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 2;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.InterStop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStopAttribute > attributes_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::Geocode > routesegments_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_TransitRuleAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.TransitRuleAttribute) */ {
 public:
  inline SolutionResponse_TransitRuleAttribute() : SolutionResponse_TransitRuleAttribute(nullptr) {}
  ~SolutionResponse_TransitRuleAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_TransitRuleAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_TransitRuleAttribute(const SolutionResponse_TransitRuleAttribute& from);
  SolutionResponse_TransitRuleAttribute(SolutionResponse_TransitRuleAttribute&& from) noexcept
    : SolutionResponse_TransitRuleAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_TransitRuleAttribute& operator=(const SolutionResponse_TransitRuleAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_TransitRuleAttribute& operator=(SolutionResponse_TransitRuleAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_TransitRuleAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_TransitRuleAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_TransitRuleAttribute*>(
               &_SolutionResponse_TransitRuleAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SolutionResponse_TransitRuleAttribute& a, SolutionResponse_TransitRuleAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_TransitRuleAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_TransitRuleAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_TransitRuleAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_TransitRuleAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_TransitRuleAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_TransitRuleAttribute& from) {
    SolutionResponse_TransitRuleAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_TransitRuleAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.TransitRuleAttribute";
  }
  protected:
  explicit SolutionResponse_TransitRuleAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleIdFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kFromStopIdFieldNumber = 3,
    kToStopIdFieldNumber = 4,
    kStartValueFieldNumber = 5,
    kEndValueFieldNumber = 6,
    kCostFieldNumber = 7,
  };
  // required string ruleId = 1;
  bool has_ruleid() const;
  void clear_ruleid() ;
  const std::string& ruleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ruleid(Arg_&& arg, Args_... args);
  std::string* mutable_ruleid();
  PROTOBUF_NODISCARD std::string* release_ruleid();
  void set_allocated_ruleid(std::string* ptr);

  private:
  const std::string& _internal_ruleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruleid(
      const std::string& value);
  std::string* _internal_mutable_ruleid();

  public:
  // required string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required int32 fromStopId = 3;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 4;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // required float startValue = 5;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 6;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 7;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.TransitRuleAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 62, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ruleid_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Route final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.Route) */ {
 public:
  inline SolutionResponse_Route() : SolutionResponse_Route(nullptr) {}
  ~SolutionResponse_Route() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Route(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Route(const SolutionResponse_Route& from);
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Route* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Route* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Route& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Route& from) {
    SolutionResponse_Route::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.Route";
  }
  protected:
  explicit SolutionResponse_Route(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 2,
    kInterStopsFieldNumber = 3,
    kFixedCostFieldNumber = 4,
    kTransitRuleAttributesFieldNumber = 5,
    kVehicleIdFieldNumber = 1,
  };
  // repeated .IVR8.SolutionResponse.Stop stops = 2;
  int stops_size() const;
  private:
  int _internal_stops_size() const;

  public:
  void clear_stops() ;
  ::IVR8::SolutionResponse_Stop* mutable_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Stop >*
      mutable_stops();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Stop>& _internal_stops() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Stop>* _internal_mutable_stops();
  public:
  const ::IVR8::SolutionResponse_Stop& stops(int index) const;
  ::IVR8::SolutionResponse_Stop* add_stops();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Stop >&
      stops() const;
  // repeated .IVR8.SolutionResponse.InterStop interStops = 3;
  int interstops_size() const;
  private:
  int _internal_interstops_size() const;

  public:
  void clear_interstops() ;
  ::IVR8::SolutionResponse_InterStop* mutable_interstops(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStop >*
      mutable_interstops();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStop>& _internal_interstops() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStop>* _internal_mutable_interstops();
  public:
  const ::IVR8::SolutionResponse_InterStop& interstops(int index) const;
  ::IVR8::SolutionResponse_InterStop* add_interstops();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStop >&
      interstops() const;
  // repeated float fixedCost = 4;
  int fixedcost_size() const;
  private:
  int _internal_fixedcost_size() const;

  public:
  void clear_fixedcost() ;
  float fixedcost(int index) const;
  void set_fixedcost(int index, float value);
  void add_fixedcost(float value);
  const ::google::protobuf::RepeatedField<float>& fixedcost() const;
  ::google::protobuf::RepeatedField<float>* mutable_fixedcost();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_fixedcost() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_fixedcost();

  public:
  // repeated .IVR8.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
  int transitruleattributes_size() const;
  private:
  int _internal_transitruleattributes_size() const;

  public:
  void clear_transitruleattributes() ;
  ::IVR8::SolutionResponse_TransitRuleAttribute* mutable_transitruleattributes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_TransitRuleAttribute >*
      mutable_transitruleattributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_TransitRuleAttribute>& _internal_transitruleattributes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_TransitRuleAttribute>* _internal_mutable_transitruleattributes();
  public:
  const ::IVR8::SolutionResponse_TransitRuleAttribute& transitruleattributes(int index) const;
  ::IVR8::SolutionResponse_TransitRuleAttribute* add_transitruleattributes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_TransitRuleAttribute >&
      transitruleattributes() const;
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.Route)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Stop > stops_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStop > interstops_;
    ::google::protobuf::RepeatedField<float> fixedcost_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_TransitRuleAttribute > transitruleattributes_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility_Info final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.Infeasibility.Info) */ {
 public:
  inline SolutionResponse_Infeasibility_Info() : SolutionResponse_Infeasibility_Info(nullptr) {}
  ~SolutionResponse_Infeasibility_Info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility_Info(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility_Info(const SolutionResponse_Infeasibility_Info& from);
  SolutionResponse_Infeasibility_Info(SolutionResponse_Infeasibility_Info&& from) noexcept
    : SolutionResponse_Infeasibility_Info() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility_Info& operator=(const SolutionResponse_Infeasibility_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility_Info& operator=(SolutionResponse_Infeasibility_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility_Info* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility_Info*>(
               &_SolutionResponse_Infeasibility_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SolutionResponse_Infeasibility_Info& a, SolutionResponse_Infeasibility_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility_Info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility_Info& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility_Info& from) {
    SolutionResponse_Infeasibility_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility_Info* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.Infeasibility.Info";
  }
  protected:
  explicit SolutionResponse_Infeasibility_Info(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstrainingTaskIdsFieldNumber = 6,
    kMessageFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kLimitFieldNumber = 3,
    kValueFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // repeated string constrainingTaskIds = 6;
  int constrainingtaskids_size() const;
  private:
  int _internal_constrainingtaskids_size() const;

  public:
  void clear_constrainingtaskids() ;
  const std::string& constrainingtaskids(int index) const;
  std::string* mutable_constrainingtaskids(int index);
  void set_constrainingtaskids(int index, const std::string& value);
  void set_constrainingtaskids(int index, std::string&& value);
  void set_constrainingtaskids(int index, const char* value);
  void set_constrainingtaskids(int index, const char* value, std::size_t size);
  void set_constrainingtaskids(int index, absl::string_view value);
  std::string* add_constrainingtaskids();
  void add_constrainingtaskids(const std::string& value);
  void add_constrainingtaskids(std::string&& value);
  void add_constrainingtaskids(const char* value);
  void add_constrainingtaskids(const char* value, std::size_t size);
  void add_constrainingtaskids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_constrainingtaskids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_constrainingtaskids();

  public:
  // required string message = 1;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // optional float limit = 3;
  bool has_limit() const;
  void clear_limit() ;
  float limit() const;
  void set_limit(float value);

  private:
  float _internal_limit() const;
  void _internal_set_limit(float value);

  public:
  // optional float value = 4;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // optional int64 count = 5;
  bool has_count() const;
  void clear_count() ;
  ::int64_t count() const;
  void set_count(::int64_t value);

  private:
  ::int64_t _internal_count() const;
  void _internal_set_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.Infeasibility.Info)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 80, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> constrainingtaskids_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float limit_;
    float value_;
    ::int64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse.Infeasibility) */ {
 public:
  inline SolutionResponse_Infeasibility() : SolutionResponse_Infeasibility(nullptr) {}
  ~SolutionResponse_Infeasibility() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility(const SolutionResponse_Infeasibility& from);
  SolutionResponse_Infeasibility(SolutionResponse_Infeasibility&& from) noexcept
    : SolutionResponse_Infeasibility() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility& operator=(const SolutionResponse_Infeasibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility& operator=(SolutionResponse_Infeasibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility*>(
               &_SolutionResponse_Infeasibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SolutionResponse_Infeasibility& a, SolutionResponse_Infeasibility& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility& from) {
    SolutionResponse_Infeasibility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse.Infeasibility";
  }
  protected:
  explicit SolutionResponse_Infeasibility(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Infeasibility_Info Info;

  // accessors -------------------------------------------------------

  enum : int {
    kInfeasibilityInfoFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // repeated .IVR8.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
  int infeasibilityinfo_size() const;
  private:
  int _internal_infeasibilityinfo_size() const;

  public:
  void clear_infeasibilityinfo() ;
  ::IVR8::SolutionResponse_Infeasibility_Info* mutable_infeasibilityinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility_Info >*
      mutable_infeasibilityinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility_Info>& _internal_infeasibilityinfo() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility_Info>* _internal_mutable_infeasibilityinfo();
  public:
  const ::IVR8::SolutionResponse_Infeasibility_Info& infeasibilityinfo(int index) const;
  ::IVR8::SolutionResponse_Infeasibility_Info* add_infeasibilityinfo();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility_Info >&
      infeasibilityinfo() const;
  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse.Infeasibility)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility_Info > infeasibilityinfo_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IVR8.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IVR8.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_StopAttribute StopAttribute;
  typedef SolutionResponse_InterStopAttribute InterStopAttribute;
  typedef SolutionResponse_Stop Stop;
  typedef SolutionResponse_InterStop InterStop;
  typedef SolutionResponse_TransitRuleAttribute TransitRuleAttribute;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_Infeasibility Infeasibility;

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 2,
    kInfeasibilitiesFieldNumber = 3,
    kObjectiveFieldNumber = 1,
  };
  // repeated .IVR8.SolutionResponse.Route routes = 2;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::IVR8::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Route >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Route>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Route>* _internal_mutable_routes();
  public:
  const ::IVR8::SolutionResponse_Route& routes(int index) const;
  ::IVR8::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Route >&
      routes() const;
  // repeated .IVR8.SolutionResponse.Infeasibility infeasibilities = 3;
  int infeasibilities_size() const;
  private:
  int _internal_infeasibilities_size() const;

  public:
  void clear_infeasibilities() ;
  ::IVR8::SolutionResponse_Infeasibility* mutable_infeasibilities(int index);
  ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility >*
      mutable_infeasibilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility>& _internal_infeasibilities() const;
  ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility>* _internal_mutable_infeasibilities();
  public:
  const ::IVR8::SolutionResponse_Infeasibility& infeasibilities(int index) const;
  ::IVR8::SolutionResponse_Infeasibility* add_infeasibilities();
  const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility >&
      infeasibilities() const;
  // required float objective = 1;
  bool has_objective() const;
  void clear_objective() ;
  float objective() const;
  void set_objective(float value);

  private:
  float _internal_objective() const;
  void _internal_set_objective(float value);

  public:
  // @@protoc_insertion_point(class_scope:IVR8.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Route > routes_;
    ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility > infeasibilities_;
    float objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ivr8_2dyni1c9k2swof_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InternalDimension

// required string id = 1;
inline bool InternalDimension::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InternalDimension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InternalDimension::id() const {
  // @@protoc_insertion_point(field_get:IVR8.InternalDimension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InternalDimension::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.InternalDimension.id)
}
inline std::string* InternalDimension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.InternalDimension.id)
  return _s;
}
inline const std::string& InternalDimension::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void InternalDimension::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalDimension::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* InternalDimension::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.InternalDimension.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InternalDimension::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.InternalDimension.id)
}

// required .IVR8.InternalDimension.eMeasurementUnit measurementUnit = 2;
inline bool InternalDimension::has_measurementunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InternalDimension::clear_measurementunit() {
  _impl_.measurementunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::IVR8::InternalDimension_eMeasurementUnit InternalDimension::measurementunit() const {
  // @@protoc_insertion_point(field_get:IVR8.InternalDimension.measurementUnit)
  return _internal_measurementunit();
}
inline void InternalDimension::set_measurementunit(::IVR8::InternalDimension_eMeasurementUnit value) {
  _internal_set_measurementunit(value);
  // @@protoc_insertion_point(field_set:IVR8.InternalDimension.measurementUnit)
}
inline ::IVR8::InternalDimension_eMeasurementUnit InternalDimension::_internal_measurementunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IVR8::InternalDimension_eMeasurementUnit>(_impl_.measurementunit_);
}
inline void InternalDimension::_internal_set_measurementunit(::IVR8::InternalDimension_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::IVR8::InternalDimension_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.measurementunit_ = value;
}

// optional float slackMax = 3 [default = 0];
inline bool InternalDimension::has_slackmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InternalDimension::clear_slackmax() {
  _impl_.slackmax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float InternalDimension::slackmax() const {
  // @@protoc_insertion_point(field_get:IVR8.InternalDimension.slackMax)
  return _internal_slackmax();
}
inline void InternalDimension::set_slackmax(float value) {
  _internal_set_slackmax(value);
  // @@protoc_insertion_point(field_set:IVR8.InternalDimension.slackMax)
}
inline float InternalDimension::_internal_slackmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackmax_;
}
inline void InternalDimension::_internal_set_slackmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.slackmax_ = value;
}

// optional float tardyMax = 4 [default = 0];
inline bool InternalDimension::has_tardymax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InternalDimension::clear_tardymax() {
  _impl_.tardymax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float InternalDimension::tardymax() const {
  // @@protoc_insertion_point(field_get:IVR8.InternalDimension.tardyMax)
  return _internal_tardymax();
}
inline void InternalDimension::set_tardymax(float value) {
  _internal_set_tardymax(value);
  // @@protoc_insertion_point(field_set:IVR8.InternalDimension.tardyMax)
}
inline float InternalDimension::_internal_tardymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardymax_;
}
inline void InternalDimension::_internal_set_tardymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tardymax_ = value;
}

// -------------------------------------------------------------------

// CapacityDimension

// required string id = 1;
inline bool CapacityDimension::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CapacityDimension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CapacityDimension::id() const {
  // @@protoc_insertion_point(field_get:IVR8.CapacityDimension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacityDimension::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.CapacityDimension.id)
}
inline std::string* CapacityDimension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.CapacityDimension.id)
  return _s;
}
inline const std::string& CapacityDimension::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CapacityDimension::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CapacityDimension::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* CapacityDimension::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.CapacityDimension.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CapacityDimension::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.CapacityDimension.id)
}

// required string units = 2;
inline bool CapacityDimension::has_units() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CapacityDimension::clear_units() {
  _impl_.units_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CapacityDimension::units() const {
  // @@protoc_insertion_point(field_get:IVR8.CapacityDimension.units)
  return _internal_units();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacityDimension::set_units(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.units_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.CapacityDimension.units)
}
inline std::string* CapacityDimension::mutable_units() {
  std::string* _s = _internal_mutable_units();
  // @@protoc_insertion_point(field_mutable:IVR8.CapacityDimension.units)
  return _s;
}
inline const std::string& CapacityDimension::_internal_units() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.units_.Get();
}
inline void CapacityDimension::_internal_set_units(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.units_.Set(value, GetArenaForAllocation());
}
inline std::string* CapacityDimension::_internal_mutable_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.units_.Mutable( GetArenaForAllocation());
}
inline std::string* CapacityDimension::release_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.CapacityDimension.units)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.units_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.units_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CapacityDimension::set_allocated_units(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.units_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.units_.IsDefault()) {
          _impl_.units_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.CapacityDimension.units)
}

// optional float slackMax = 3 [default = 0];
inline bool CapacityDimension::has_slackmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CapacityDimension::clear_slackmax() {
  _impl_.slackmax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CapacityDimension::slackmax() const {
  // @@protoc_insertion_point(field_get:IVR8.CapacityDimension.slackMax)
  return _internal_slackmax();
}
inline void CapacityDimension::set_slackmax(float value) {
  _internal_set_slackmax(value);
  // @@protoc_insertion_point(field_set:IVR8.CapacityDimension.slackMax)
}
inline float CapacityDimension::_internal_slackmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackmax_;
}
inline void CapacityDimension::_internal_set_slackmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.slackmax_ = value;
}

// optional float tardyMax = 4 [default = 0];
inline bool CapacityDimension::has_tardymax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CapacityDimension::clear_tardymax() {
  _impl_.tardymax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CapacityDimension::tardymax() const {
  // @@protoc_insertion_point(field_get:IVR8.CapacityDimension.tardyMax)
  return _internal_tardymax();
}
inline void CapacityDimension::set_tardymax(float value) {
  _internal_set_tardymax(value);
  // @@protoc_insertion_point(field_set:IVR8.CapacityDimension.tardyMax)
}
inline float CapacityDimension::_internal_tardymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardymax_;
}
inline void CapacityDimension::_internal_set_tardymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tardymax_ = value;
}

// -------------------------------------------------------------------

// DimensionConfiguration

// optional .IVR8.InternalDimension timeConfig = 1;
inline bool DimensionConfiguration::has_timeconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timeconfig_ != nullptr);
  return value;
}
inline void DimensionConfiguration::clear_timeconfig() {
  if (_impl_.timeconfig_ != nullptr) _impl_.timeconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::IVR8::InternalDimension& DimensionConfiguration::_internal_timeconfig() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::InternalDimension* p = _impl_.timeconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::InternalDimension&>(::IVR8::_InternalDimension_default_instance_);
}
inline const ::IVR8::InternalDimension& DimensionConfiguration::timeconfig() const {
  // @@protoc_insertion_point(field_get:IVR8.DimensionConfiguration.timeConfig)
  return _internal_timeconfig();
}
inline void DimensionConfiguration::unsafe_arena_set_allocated_timeconfig(::IVR8::InternalDimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeconfig_);
  }
  _impl_.timeconfig_ = reinterpret_cast<::IVR8::InternalDimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.DimensionConfiguration.timeConfig)
}
inline ::IVR8::InternalDimension* DimensionConfiguration::release_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::IVR8::InternalDimension* released = _impl_.timeconfig_;
  _impl_.timeconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::InternalDimension* DimensionConfiguration::unsafe_arena_release_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.DimensionConfiguration.timeConfig)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::IVR8::InternalDimension* temp = _impl_.timeconfig_;
  _impl_.timeconfig_ = nullptr;
  return temp;
}
inline ::IVR8::InternalDimension* DimensionConfiguration::_internal_mutable_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timeconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::InternalDimension>(GetArenaForAllocation());
    _impl_.timeconfig_ = reinterpret_cast<::IVR8::InternalDimension*>(p);
  }
  return _impl_.timeconfig_;
}
inline ::IVR8::InternalDimension* DimensionConfiguration::mutable_timeconfig() {
  ::IVR8::InternalDimension* _msg = _internal_mutable_timeconfig();
  // @@protoc_insertion_point(field_mutable:IVR8.DimensionConfiguration.timeConfig)
  return _msg;
}
inline void DimensionConfiguration::set_allocated_timeconfig(::IVR8::InternalDimension* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::InternalDimension*>(_impl_.timeconfig_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::InternalDimension*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timeconfig_ = reinterpret_cast<::IVR8::InternalDimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.DimensionConfiguration.timeConfig)
}

// optional .IVR8.InternalDimension distanceConfig = 2;
inline bool DimensionConfiguration::has_distanceconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distanceconfig_ != nullptr);
  return value;
}
inline void DimensionConfiguration::clear_distanceconfig() {
  if (_impl_.distanceconfig_ != nullptr) _impl_.distanceconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::IVR8::InternalDimension& DimensionConfiguration::_internal_distanceconfig() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::InternalDimension* p = _impl_.distanceconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::InternalDimension&>(::IVR8::_InternalDimension_default_instance_);
}
inline const ::IVR8::InternalDimension& DimensionConfiguration::distanceconfig() const {
  // @@protoc_insertion_point(field_get:IVR8.DimensionConfiguration.distanceConfig)
  return _internal_distanceconfig();
}
inline void DimensionConfiguration::unsafe_arena_set_allocated_distanceconfig(::IVR8::InternalDimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distanceconfig_);
  }
  _impl_.distanceconfig_ = reinterpret_cast<::IVR8::InternalDimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.DimensionConfiguration.distanceConfig)
}
inline ::IVR8::InternalDimension* DimensionConfiguration::release_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::InternalDimension* released = _impl_.distanceconfig_;
  _impl_.distanceconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::InternalDimension* DimensionConfiguration::unsafe_arena_release_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.DimensionConfiguration.distanceConfig)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::InternalDimension* temp = _impl_.distanceconfig_;
  _impl_.distanceconfig_ = nullptr;
  return temp;
}
inline ::IVR8::InternalDimension* DimensionConfiguration::_internal_mutable_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.distanceconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::InternalDimension>(GetArenaForAllocation());
    _impl_.distanceconfig_ = reinterpret_cast<::IVR8::InternalDimension*>(p);
  }
  return _impl_.distanceconfig_;
}
inline ::IVR8::InternalDimension* DimensionConfiguration::mutable_distanceconfig() {
  ::IVR8::InternalDimension* _msg = _internal_mutable_distanceconfig();
  // @@protoc_insertion_point(field_mutable:IVR8.DimensionConfiguration.distanceConfig)
  return _msg;
}
inline void DimensionConfiguration::set_allocated_distanceconfig(::IVR8::InternalDimension* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::InternalDimension*>(_impl_.distanceconfig_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::InternalDimension*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.distanceconfig_ = reinterpret_cast<::IVR8::InternalDimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.DimensionConfiguration.distanceConfig)
}

// repeated .IVR8.CapacityDimension capacityDimensions = 3;
inline int DimensionConfiguration::_internal_capacitydimensions_size() const {
  return _internal_capacitydimensions().size();
}
inline int DimensionConfiguration::capacitydimensions_size() const {
  return _internal_capacitydimensions_size();
}
inline void DimensionConfiguration::clear_capacitydimensions() {
  _internal_mutable_capacitydimensions()->Clear();
}
inline ::IVR8::CapacityDimension* DimensionConfiguration::mutable_capacitydimensions(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.DimensionConfiguration.capacityDimensions)
  return _internal_mutable_capacitydimensions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::CapacityDimension >*
DimensionConfiguration::mutable_capacitydimensions() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.DimensionConfiguration.capacityDimensions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capacitydimensions();
}
inline const ::IVR8::CapacityDimension& DimensionConfiguration::capacitydimensions(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.DimensionConfiguration.capacityDimensions)
    return _internal_capacitydimensions().Get(index);
}
inline ::IVR8::CapacityDimension* DimensionConfiguration::add_capacitydimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::CapacityDimension* _add = _internal_mutable_capacitydimensions()->Add();
  // @@protoc_insertion_point(field_add:IVR8.DimensionConfiguration.capacityDimensions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::CapacityDimension >&
DimensionConfiguration::capacitydimensions() const {
  // @@protoc_insertion_point(field_list:IVR8.DimensionConfiguration.capacityDimensions)
  return _internal_capacitydimensions();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::CapacityDimension>&
DimensionConfiguration::_internal_capacitydimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacitydimensions_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::CapacityDimension>*
DimensionConfiguration::_internal_mutable_capacitydimensions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capacitydimensions_;
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:IVR8.Geocode.longitude)
  return _internal_longitude();
}
inline void Geocode::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:IVR8.Geocode.longitude)
}
inline float Geocode::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Geocode::_internal_set_longitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_ = value;
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:IVR8.Geocode.latitude)
  return _internal_latitude();
}
inline void Geocode::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:IVR8.Geocode.latitude)
}
inline float Geocode::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Geocode::_internal_set_latitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// Window

// required float start = 1;
inline bool Window::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Window::clear_start() {
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Window::start() const {
  // @@protoc_insertion_point(field_get:IVR8.Window.start)
  return _internal_start();
}
inline void Window::set_start(float value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:IVR8.Window.start)
}
inline float Window::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void Window::_internal_set_start(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}

// required float end = 2;
inline bool Window::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Window::clear_end() {
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Window::end() const {
  // @@protoc_insertion_point(field_get:IVR8.Window.end)
  return _internal_end();
}
inline void Window::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:IVR8.Window.end)
}
inline float Window::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_;
}
inline void Window::_internal_set_end(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}

// optional float slackCostCoef = 3 [default = 0];
inline bool Window::has_slackcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Window::clear_slackcostcoef() {
  _impl_.slackcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Window::slackcostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.Window.slackCostCoef)
  return _internal_slackcostcoef();
}
inline void Window::set_slackcostcoef(float value) {
  _internal_set_slackcostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.Window.slackCostCoef)
}
inline float Window::_internal_slackcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcostcoef_;
}
inline void Window::_internal_set_slackcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.slackcostcoef_ = value;
}

// optional float tardyCostCoef = 4 [default = 0];
inline bool Window::has_tardycostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Window::clear_tardycostcoef() {
  _impl_.tardycostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Window::tardycostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.Window.tardyCostCoef)
  return _internal_tardycostcoef();
}
inline void Window::set_tardycostcoef(float value) {
  _internal_set_tardycostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.Window.tardyCostCoef)
}
inline float Window::_internal_tardycostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycostcoef_;
}
inline void Window::_internal_set_tardycostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tardycostcoef_ = value;
}

// optional float slackMax = 5 [default = -1];
inline bool Window::has_slackmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Window::clear_slackmax() {
  _impl_.slackmax_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Window::slackmax() const {
  // @@protoc_insertion_point(field_get:IVR8.Window.slackMax)
  return _internal_slackmax();
}
inline void Window::set_slackmax(float value) {
  _internal_set_slackmax(value);
  // @@protoc_insertion_point(field_set:IVR8.Window.slackMax)
}
inline float Window::_internal_slackmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackmax_;
}
inline void Window::_internal_set_slackmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackmax_ = value;
}

// optional float tardyMax = 6 [default = -1];
inline bool Window::has_tardymax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Window::clear_tardymax() {
  _impl_.tardymax_ = -1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Window::tardymax() const {
  // @@protoc_insertion_point(field_get:IVR8.Window.tardyMax)
  return _internal_tardymax();
}
inline void Window::set_tardymax(float value) {
  _internal_set_tardymax(value);
  // @@protoc_insertion_point(field_set:IVR8.Window.tardyMax)
}
inline float Window::_internal_tardymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardymax_;
}
inline void Window::_internal_set_tardymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tardymax_ = value;
}

// -------------------------------------------------------------------

// Location_Attribute

// required string dimensionId = 1;
inline bool Location_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Location_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.Location.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Location.Attribute.dimensionId)
}
inline std::string* Location_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.Location.Attribute.dimensionId)
  return _s;
}
inline const std::string& Location_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Location_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Location_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Location_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Location.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Location.Attribute.dimensionId)
}

// optional string vehicleId = 2;
inline bool Location_Attribute::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Location_Attribute::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Location_Attribute::vehicleid() const {
  // @@protoc_insertion_point(field_get:IVR8.Location.Attribute.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location_Attribute::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Location.Attribute.vehicleId)
}
inline std::string* Location_Attribute::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:IVR8.Location.Attribute.vehicleId)
  return _s;
}
inline const std::string& Location_Attribute::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void Location_Attribute::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* Location_Attribute::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* Location_Attribute::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Location.Attribute.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location_Attribute::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Location.Attribute.vehicleId)
}

// optional float quantity = 3;
inline bool Location_Attribute::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Location_Attribute::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Location_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:IVR8.Location.Attribute.quantity)
  return _internal_quantity();
}
inline void Location_Attribute::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:IVR8.Location.Attribute.quantity)
}
inline float Location_Attribute::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Location_Attribute::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.quantity_ = value;
}

// repeated .IVR8.Window arrivalWindows = 4;
inline int Location_Attribute::_internal_arrivalwindows_size() const {
  return _internal_arrivalwindows().size();
}
inline int Location_Attribute::arrivalwindows_size() const {
  return _internal_arrivalwindows_size();
}
inline void Location_Attribute::clear_arrivalwindows() {
  _internal_mutable_arrivalwindows()->Clear();
}
inline ::IVR8::Window* Location_Attribute::mutable_arrivalwindows(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Location.Attribute.arrivalWindows)
  return _internal_mutable_arrivalwindows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
Location_Attribute::mutable_arrivalwindows() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Location.Attribute.arrivalWindows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arrivalwindows();
}
inline const ::IVR8::Window& Location_Attribute::arrivalwindows(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Location.Attribute.arrivalWindows)
    return _internal_arrivalwindows().Get(index);
}
inline ::IVR8::Window* Location_Attribute::add_arrivalwindows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Window* _add = _internal_mutable_arrivalwindows()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Location.Attribute.arrivalWindows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
Location_Attribute::arrivalwindows() const {
  // @@protoc_insertion_point(field_list:IVR8.Location.Attribute.arrivalWindows)
  return _internal_arrivalwindows();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Window>&
Location_Attribute::_internal_arrivalwindows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrivalwindows_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Window>*
Location_Attribute::_internal_mutable_arrivalwindows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arrivalwindows_;
}

// repeated .IVR8.Window departureWindows = 5;
inline int Location_Attribute::_internal_departurewindows_size() const {
  return _internal_departurewindows().size();
}
inline int Location_Attribute::departurewindows_size() const {
  return _internal_departurewindows_size();
}
inline void Location_Attribute::clear_departurewindows() {
  _internal_mutable_departurewindows()->Clear();
}
inline ::IVR8::Window* Location_Attribute::mutable_departurewindows(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Location.Attribute.departureWindows)
  return _internal_mutable_departurewindows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
Location_Attribute::mutable_departurewindows() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Location.Attribute.departureWindows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_departurewindows();
}
inline const ::IVR8::Window& Location_Attribute::departurewindows(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Location.Attribute.departureWindows)
    return _internal_departurewindows().Get(index);
}
inline ::IVR8::Window* Location_Attribute::add_departurewindows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Window* _add = _internal_mutable_departurewindows()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Location.Attribute.departureWindows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
Location_Attribute::departurewindows() const {
  // @@protoc_insertion_point(field_list:IVR8.Location.Attribute.departureWindows)
  return _internal_departurewindows();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Window>&
Location_Attribute::_internal_departurewindows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.departurewindows_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Window>*
Location_Attribute::_internal_mutable_departurewindows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.departurewindows_;
}

// -------------------------------------------------------------------

// Location

// required string id = 1;
inline bool Location::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Location::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:IVR8.Location.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Location.id)
}
inline std::string* Location::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.Location.id)
  return _s;
}
inline const std::string& Location::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Location::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Location::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Location.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Location.id)
}

// optional .IVR8.Geocode geocode = 2;
inline bool Location::has_geocode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geocode_ != nullptr);
  return value;
}
inline void Location::clear_geocode() {
  if (_impl_.geocode_ != nullptr) _impl_.geocode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::IVR8::Geocode& Location::_internal_geocode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Geocode* p = _impl_.geocode_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Geocode&>(::IVR8::_Geocode_default_instance_);
}
inline const ::IVR8::Geocode& Location::geocode() const {
  // @@protoc_insertion_point(field_get:IVR8.Location.geocode)
  return _internal_geocode();
}
inline void Location::unsafe_arena_set_allocated_geocode(::IVR8::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geocode_);
  }
  _impl_.geocode_ = reinterpret_cast<::IVR8::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Location.geocode)
}
inline ::IVR8::Geocode* Location::release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Geocode* released = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Geocode* Location::unsafe_arena_release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Location.geocode)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Geocode* temp = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
  return temp;
}
inline ::IVR8::Geocode* Location::_internal_mutable_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.geocode_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Geocode>(GetArenaForAllocation());
    _impl_.geocode_ = reinterpret_cast<::IVR8::Geocode*>(p);
  }
  return _impl_.geocode_;
}
inline ::IVR8::Geocode* Location::mutable_geocode() {
  ::IVR8::Geocode* _msg = _internal_mutable_geocode();
  // @@protoc_insertion_point(field_mutable:IVR8.Location.geocode)
  return _msg;
}
inline void Location::set_allocated_geocode(::IVR8::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Geocode*>(_impl_.geocode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.geocode_ = reinterpret_cast<::IVR8::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Location.geocode)
}

// repeated .IVR8.Location.Attribute attributes = 3;
inline int Location::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int Location::attributes_size() const {
  return _internal_attributes_size();
}
inline void Location::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::Location_Attribute* Location::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Location.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Location_Attribute >*
Location::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Location.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::Location_Attribute& Location::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Location.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::Location_Attribute* Location::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Location_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Location.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Location_Attribute >&
Location::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.Location.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Location_Attribute>&
Location::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Location_Attribute>*
Location::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Job_VehicleRelation

// required .IVR8.Job.VehicleRelation.Type type = 1;
inline bool Job_VehicleRelation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_VehicleRelation::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::IVR8::Job_VehicleRelation_Type Job_VehicleRelation::type() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.VehicleRelation.type)
  return _internal_type();
}
inline void Job_VehicleRelation::set_type(::IVR8::Job_VehicleRelation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.VehicleRelation.type)
}
inline ::IVR8::Job_VehicleRelation_Type Job_VehicleRelation::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IVR8::Job_VehicleRelation_Type>(_impl_.type_);
}
inline void Job_VehicleRelation::_internal_set_type(::IVR8::Job_VehicleRelation_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::IVR8::Job_VehicleRelation_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// repeated string vehicleIds = 2;
inline int Job_VehicleRelation::_internal_vehicleids_size() const {
  return _internal_vehicleids().size();
}
inline int Job_VehicleRelation::vehicleids_size() const {
  return _internal_vehicleids_size();
}
inline void Job_VehicleRelation::clear_vehicleids() {
  _internal_mutable_vehicleids()->Clear();
}
inline std::string* Job_VehicleRelation::add_vehicleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_vehicleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.Job.VehicleRelation.vehicleIds)
  return _s;
}
inline const std::string& Job_VehicleRelation::vehicleids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.VehicleRelation.vehicleIds)
  return _internal_vehicleids().Get(index);
}
inline std::string* Job_VehicleRelation::mutable_vehicleids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Job.VehicleRelation.vehicleIds)
  return _internal_mutable_vehicleids()->Mutable(index);
}
inline void Job_VehicleRelation::set_vehicleids(int index, const std::string& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, std::string&& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, absl::string_view value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.Job.VehicleRelation.vehicleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_VehicleRelation::vehicleids() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.VehicleRelation.vehicleIds)
  return _internal_vehicleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Job_VehicleRelation::mutable_vehicleids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.VehicleRelation.vehicleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_VehicleRelation::_internal_vehicleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Job_VehicleRelation::_internal_mutable_vehicleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicleids_;
}

// -------------------------------------------------------------------

// Job_CompartmentRelation

// required .IVR8.Job.CompartmentRelation.Type type = 1;
inline bool Job_CompartmentRelation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_CompartmentRelation::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::IVR8::Job_CompartmentRelation_Type Job_CompartmentRelation::type() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.CompartmentRelation.type)
  return _internal_type();
}
inline void Job_CompartmentRelation::set_type(::IVR8::Job_CompartmentRelation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.CompartmentRelation.type)
}
inline ::IVR8::Job_CompartmentRelation_Type Job_CompartmentRelation::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IVR8::Job_CompartmentRelation_Type>(_impl_.type_);
}
inline void Job_CompartmentRelation::_internal_set_type(::IVR8::Job_CompartmentRelation_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::IVR8::Job_CompartmentRelation_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// repeated string compartmentIds = 2;
inline int Job_CompartmentRelation::_internal_compartmentids_size() const {
  return _internal_compartmentids().size();
}
inline int Job_CompartmentRelation::compartmentids_size() const {
  return _internal_compartmentids_size();
}
inline void Job_CompartmentRelation::clear_compartmentids() {
  _internal_mutable_compartmentids()->Clear();
}
inline std::string* Job_CompartmentRelation::add_compartmentids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_compartmentids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.Job.CompartmentRelation.compartmentIds)
  return _s;
}
inline const std::string& Job_CompartmentRelation::compartmentids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.CompartmentRelation.compartmentIds)
  return _internal_compartmentids().Get(index);
}
inline std::string* Job_CompartmentRelation::mutable_compartmentids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Job.CompartmentRelation.compartmentIds)
  return _internal_mutable_compartmentids()->Mutable(index);
}
inline void Job_CompartmentRelation::set_compartmentids(int index, const std::string& value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::set_compartmentids(int index, std::string&& value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::set_compartmentids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_compartmentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::set_compartmentids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::set_compartmentids(int index, absl::string_view value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::add_compartmentids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::add_compartmentids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::add_compartmentids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::add_compartmentids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline void Job_CompartmentRelation::add_compartmentids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.Job.CompartmentRelation.compartmentIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_CompartmentRelation::compartmentids() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.CompartmentRelation.compartmentIds)
  return _internal_compartmentids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Job_CompartmentRelation::mutable_compartmentids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.CompartmentRelation.compartmentIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compartmentids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_CompartmentRelation::_internal_compartmentids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Job_CompartmentRelation::_internal_mutable_compartmentids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compartmentids_;
}

// -------------------------------------------------------------------

// Job_Task_Attribute

// required string dimensionId = 1;
inline bool Job_Task_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_Task_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job_Task_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job_Task_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.Attribute.dimensionId)
}
inline std::string* Job_Task_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.Attribute.dimensionId)
  return _s;
}
inline const std::string& Job_Task_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Job_Task_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job_Task_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Job_Task_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.Task.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job_Task_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.Task.Attribute.dimensionId)
}

// optional float quantity = 2;
inline bool Job_Task_Attribute::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Job_Task_Attribute::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Job_Task_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.Attribute.quantity)
  return _internal_quantity();
}
inline void Job_Task_Attribute::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.Attribute.quantity)
}
inline float Job_Task_Attribute::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Job_Task_Attribute::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quantity_ = value;
}

// repeated .IVR8.Window windows = 3;
inline int Job_Task_Attribute::_internal_windows_size() const {
  return _internal_windows().size();
}
inline int Job_Task_Attribute::windows_size() const {
  return _internal_windows_size();
}
inline void Job_Task_Attribute::clear_windows() {
  _internal_mutable_windows()->Clear();
}
inline ::IVR8::Window* Job_Task_Attribute::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.Attribute.windows)
  return _internal_mutable_windows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
Job_Task_Attribute::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.Task.Attribute.windows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_windows();
}
inline const ::IVR8::Window& Job_Task_Attribute::windows(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.Attribute.windows)
    return _internal_windows().Get(index);
}
inline ::IVR8::Window* Job_Task_Attribute::add_windows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Window* _add = _internal_mutable_windows()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.Attribute.windows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
Job_Task_Attribute::windows() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.Task.Attribute.windows)
  return _internal_windows();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Window>&
Job_Task_Attribute::_internal_windows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windows_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Window>*
Job_Task_Attribute::_internal_mutable_windows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.windows_;
}

// repeated string vehicleIds = 4;
inline int Job_Task_Attribute::_internal_vehicleids_size() const {
  return _internal_vehicleids().size();
}
inline int Job_Task_Attribute::vehicleids_size() const {
  return _internal_vehicleids_size();
}
inline void Job_Task_Attribute::clear_vehicleids() {
  _internal_mutable_vehicleids()->Clear();
}
inline std::string* Job_Task_Attribute::add_vehicleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_vehicleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.Job.Task.Attribute.vehicleIds)
  return _s;
}
inline const std::string& Job_Task_Attribute::vehicleids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.Attribute.vehicleIds)
  return _internal_vehicleids().Get(index);
}
inline std::string* Job_Task_Attribute::mutable_vehicleids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.Attribute.vehicleIds)
  return _internal_mutable_vehicleids()->Mutable(index);
}
inline void Job_Task_Attribute::set_vehicleids(int index, const std::string& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, std::string&& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, absl::string_view value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.Job.Task.Attribute.vehicleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_Task_Attribute::vehicleids() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.Task.Attribute.vehicleIds)
  return _internal_vehicleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Job_Task_Attribute::mutable_vehicleids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.Task.Attribute.vehicleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_Task_Attribute::_internal_vehicleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Job_Task_Attribute::_internal_mutable_vehicleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicleids_;
}

// -------------------------------------------------------------------

// Job_Task_TaskRelation

// required .IVR8.Job.Task.TaskRelation.Type type = 1;
inline bool Job_Task_TaskRelation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_Task_TaskRelation::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::IVR8::Job_Task_TaskRelation_Type Job_Task_TaskRelation::type() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.TaskRelation.type)
  return _internal_type();
}
inline void Job_Task_TaskRelation::set_type(::IVR8::Job_Task_TaskRelation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.TaskRelation.type)
}
inline ::IVR8::Job_Task_TaskRelation_Type Job_Task_TaskRelation::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IVR8::Job_Task_TaskRelation_Type>(_impl_.type_);
}
inline void Job_Task_TaskRelation::_internal_set_type(::IVR8::Job_Task_TaskRelation_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::IVR8::Job_Task_TaskRelation_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// repeated string taskIds = 2;
inline int Job_Task_TaskRelation::_internal_taskids_size() const {
  return _internal_taskids().size();
}
inline int Job_Task_TaskRelation::taskids_size() const {
  return _internal_taskids_size();
}
inline void Job_Task_TaskRelation::clear_taskids() {
  _internal_mutable_taskids()->Clear();
}
inline std::string* Job_Task_TaskRelation::add_taskids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_taskids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.Job.Task.TaskRelation.taskIds)
  return _s;
}
inline const std::string& Job_Task_TaskRelation::taskids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.TaskRelation.taskIds)
  return _internal_taskids().Get(index);
}
inline std::string* Job_Task_TaskRelation::mutable_taskids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.TaskRelation.taskIds)
  return _internal_mutable_taskids()->Mutable(index);
}
inline void Job_Task_TaskRelation::set_taskids(int index, const std::string& value) {
  _internal_mutable_taskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::set_taskids(int index, std::string&& value) {
  _internal_mutable_taskids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::set_taskids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_taskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::set_taskids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_taskids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::set_taskids(int index, absl::string_view value) {
  _internal_mutable_taskids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::add_taskids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::add_taskids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::add_taskids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::add_taskids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.Job.Task.TaskRelation.taskIds)
}
inline void Job_Task_TaskRelation::add_taskids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.Job.Task.TaskRelation.taskIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_Task_TaskRelation::taskids() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.Task.TaskRelation.taskIds)
  return _internal_taskids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Job_Task_TaskRelation::mutable_taskids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.Task.TaskRelation.taskIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_taskids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_Task_TaskRelation::_internal_taskids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Job_Task_TaskRelation::_internal_mutable_taskids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.taskids_;
}

// -------------------------------------------------------------------

// Job_Task

// required string taskId = 1;
inline bool Job_Task::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_Task::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job_Task::taskid() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job_Task::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.taskId)
}
inline std::string* Job_Task::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.taskId)
  return _s;
}
inline const std::string& Job_Task::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void Job_Task::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job_Task::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* Job_Task::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.Task.taskId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job_Task::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.Task.taskId)
}

// required string locationId = 2;
inline bool Job_Task::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Job_Task::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Job_Task::locationid() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job_Task::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.locationId)
}
inline std::string* Job_Task::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.locationId)
  return _s;
}
inline const std::string& Job_Task::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void Job_Task::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job_Task::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* Job_Task::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.Task.locationId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job_Task::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.Task.locationId)
}

// repeated .IVR8.Job.Task.Attribute attributes = 3;
inline int Job_Task::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int Job_Task::attributes_size() const {
  return _internal_attributes_size();
}
inline void Job_Task::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::Job_Task_Attribute* Job_Task::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Job_Task_Attribute >*
Job_Task::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.Task.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::Job_Task_Attribute& Job_Task::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::Job_Task_Attribute* Job_Task::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Job_Task_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Job_Task_Attribute >&
Job_Task::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.Task.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Job_Task_Attribute>&
Job_Task::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Job_Task_Attribute>*
Job_Task::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .IVR8.Job.Task.TripConstraint tripConstraints = 4;
inline int Job_Task::_internal_tripconstraints_size() const {
  return _internal_tripconstraints().size();
}
inline int Job_Task::tripconstraints_size() const {
  return _internal_tripconstraints_size();
}
inline void Job_Task::clear_tripconstraints() {
  _internal_mutable_tripconstraints()->Clear();
}
inline ::IVR8::Job_Task_TripConstraint Job_Task::tripconstraints(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.tripConstraints)
  return static_cast<::IVR8::Job_Task_TripConstraint>(_internal_tripconstraints().Get(index));
}
inline void Job_Task::set_tripconstraints(int index, ::IVR8::Job_Task_TripConstraint value) {
  assert(::IVR8::Job_Task_TripConstraint_IsValid(value));
  _internal_mutable_tripconstraints()->Set(index, value);
  // @@protoc_insertion_point(field_set:IVR8.Job.Task.tripConstraints)
}
inline void Job_Task::add_tripconstraints(::IVR8::Job_Task_TripConstraint value) {
  assert(::IVR8::Job_Task_TripConstraint_IsValid(value));
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tripconstraints()->Add(value);
  // @@protoc_insertion_point(field_add:IVR8.Job.Task.tripConstraints)
}
inline const ::google::protobuf::RepeatedField<int>& Job_Task::tripconstraints() const {
  // @@protoc_insertion_point(field_list:IVR8.Job.Task.tripConstraints)
  return _internal_tripconstraints();
}
inline ::google::protobuf::RepeatedField<int>* Job_Task::mutable_tripconstraints() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Job.Task.tripConstraints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tripconstraints();
}
inline const ::google::protobuf::RepeatedField<int>& Job_Task::_internal_tripconstraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tripconstraints_;
}
inline ::google::protobuf::RepeatedField<int>* Job_Task::_internal_mutable_tripconstraints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tripconstraints_;
}

// optional .IVR8.Job.Task.TaskRelation predecessors = 5;
inline bool Job_Task::has_predecessors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predecessors_ != nullptr);
  return value;
}
inline void Job_Task::clear_predecessors() {
  if (_impl_.predecessors_ != nullptr) _impl_.predecessors_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::IVR8::Job_Task_TaskRelation& Job_Task::_internal_predecessors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Job_Task_TaskRelation* p = _impl_.predecessors_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Job_Task_TaskRelation&>(::IVR8::_Job_Task_TaskRelation_default_instance_);
}
inline const ::IVR8::Job_Task_TaskRelation& Job_Task::predecessors() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.predecessors)
  return _internal_predecessors();
}
inline void Job_Task::unsafe_arena_set_allocated_predecessors(::IVR8::Job_Task_TaskRelation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predecessors_);
  }
  _impl_.predecessors_ = reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Job.Task.predecessors)
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::release_predecessors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::IVR8::Job_Task_TaskRelation* released = _impl_.predecessors_;
  _impl_.predecessors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::unsafe_arena_release_predecessors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.Task.predecessors)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::IVR8::Job_Task_TaskRelation* temp = _impl_.predecessors_;
  _impl_.predecessors_ = nullptr;
  return temp;
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::_internal_mutable_predecessors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.predecessors_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Job_Task_TaskRelation>(GetArenaForAllocation());
    _impl_.predecessors_ = reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(p);
  }
  return _impl_.predecessors_;
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::mutable_predecessors() {
  ::IVR8::Job_Task_TaskRelation* _msg = _internal_mutable_predecessors();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.predecessors)
  return _msg;
}
inline void Job_Task::set_allocated_predecessors(::IVR8::Job_Task_TaskRelation* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(_impl_.predecessors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.predecessors_ = reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.Task.predecessors)
}

// optional .IVR8.Job.Task.TaskRelation successors = 6;
inline bool Job_Task::has_successors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.successors_ != nullptr);
  return value;
}
inline void Job_Task::clear_successors() {
  if (_impl_.successors_ != nullptr) _impl_.successors_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::IVR8::Job_Task_TaskRelation& Job_Task::_internal_successors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Job_Task_TaskRelation* p = _impl_.successors_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Job_Task_TaskRelation&>(::IVR8::_Job_Task_TaskRelation_default_instance_);
}
inline const ::IVR8::Job_Task_TaskRelation& Job_Task::successors() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.Task.successors)
  return _internal_successors();
}
inline void Job_Task::unsafe_arena_set_allocated_successors(::IVR8::Job_Task_TaskRelation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.successors_);
  }
  _impl_.successors_ = reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Job.Task.successors)
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::release_successors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::IVR8::Job_Task_TaskRelation* released = _impl_.successors_;
  _impl_.successors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::unsafe_arena_release_successors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.Task.successors)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::IVR8::Job_Task_TaskRelation* temp = _impl_.successors_;
  _impl_.successors_ = nullptr;
  return temp;
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::_internal_mutable_successors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.successors_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Job_Task_TaskRelation>(GetArenaForAllocation());
    _impl_.successors_ = reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(p);
  }
  return _impl_.successors_;
}
inline ::IVR8::Job_Task_TaskRelation* Job_Task::mutable_successors() {
  ::IVR8::Job_Task_TaskRelation* _msg = _internal_mutable_successors();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.Task.successors)
  return _msg;
}
inline void Job_Task::set_allocated_successors(::IVR8::Job_Task_TaskRelation* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(_impl_.successors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.successors_ = reinterpret_cast<::IVR8::Job_Task_TaskRelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.Task.successors)
}

// -------------------------------------------------------------------

// Job

// required string id = 1;
inline bool Job::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job::id() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Job.id)
}
inline std::string* Job::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.id)
  return _s;
}
inline const std::string& Job::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Job::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Job::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.id)
}

// optional .IVR8.Job.Task pickupTask = 2;
inline bool Job::has_pickuptask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pickuptask_ != nullptr);
  return value;
}
inline void Job::clear_pickuptask() {
  if (_impl_.pickuptask_ != nullptr) _impl_.pickuptask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::IVR8::Job_Task& Job::_internal_pickuptask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Job_Task* p = _impl_.pickuptask_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Job_Task&>(::IVR8::_Job_Task_default_instance_);
}
inline const ::IVR8::Job_Task& Job::pickuptask() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.pickupTask)
  return _internal_pickuptask();
}
inline void Job::unsafe_arena_set_allocated_pickuptask(::IVR8::Job_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pickuptask_);
  }
  _impl_.pickuptask_ = reinterpret_cast<::IVR8::Job_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Job.pickupTask)
}
inline ::IVR8::Job_Task* Job::release_pickuptask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Job_Task* released = _impl_.pickuptask_;
  _impl_.pickuptask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Job_Task* Job::unsafe_arena_release_pickuptask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.pickupTask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Job_Task* temp = _impl_.pickuptask_;
  _impl_.pickuptask_ = nullptr;
  return temp;
}
inline ::IVR8::Job_Task* Job::_internal_mutable_pickuptask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pickuptask_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Job_Task>(GetArenaForAllocation());
    _impl_.pickuptask_ = reinterpret_cast<::IVR8::Job_Task*>(p);
  }
  return _impl_.pickuptask_;
}
inline ::IVR8::Job_Task* Job::mutable_pickuptask() {
  ::IVR8::Job_Task* _msg = _internal_mutable_pickuptask();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.pickupTask)
  return _msg;
}
inline void Job::set_allocated_pickuptask(::IVR8::Job_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Job_Task*>(_impl_.pickuptask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Job_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pickuptask_ = reinterpret_cast<::IVR8::Job_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.pickupTask)
}

// optional .IVR8.Job.Task dropoffTask = 3;
inline bool Job::has_dropofftask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dropofftask_ != nullptr);
  return value;
}
inline void Job::clear_dropofftask() {
  if (_impl_.dropofftask_ != nullptr) _impl_.dropofftask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::IVR8::Job_Task& Job::_internal_dropofftask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Job_Task* p = _impl_.dropofftask_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Job_Task&>(::IVR8::_Job_Task_default_instance_);
}
inline const ::IVR8::Job_Task& Job::dropofftask() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.dropoffTask)
  return _internal_dropofftask();
}
inline void Job::unsafe_arena_set_allocated_dropofftask(::IVR8::Job_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dropofftask_);
  }
  _impl_.dropofftask_ = reinterpret_cast<::IVR8::Job_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Job.dropoffTask)
}
inline ::IVR8::Job_Task* Job::release_dropofftask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::IVR8::Job_Task* released = _impl_.dropofftask_;
  _impl_.dropofftask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Job_Task* Job::unsafe_arena_release_dropofftask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.dropoffTask)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::IVR8::Job_Task* temp = _impl_.dropofftask_;
  _impl_.dropofftask_ = nullptr;
  return temp;
}
inline ::IVR8::Job_Task* Job::_internal_mutable_dropofftask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.dropofftask_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Job_Task>(GetArenaForAllocation());
    _impl_.dropofftask_ = reinterpret_cast<::IVR8::Job_Task*>(p);
  }
  return _impl_.dropofftask_;
}
inline ::IVR8::Job_Task* Job::mutable_dropofftask() {
  ::IVR8::Job_Task* _msg = _internal_mutable_dropofftask();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.dropoffTask)
  return _msg;
}
inline void Job::set_allocated_dropofftask(::IVR8::Job_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Job_Task*>(_impl_.dropofftask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Job_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dropofftask_ = reinterpret_cast<::IVR8::Job_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.dropoffTask)
}

// required float penalty = 4;
inline bool Job::has_penalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Job::clear_penalty() {
  _impl_.penalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Job::penalty() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.penalty)
  return _internal_penalty();
}
inline void Job::set_penalty(float value) {
  _internal_set_penalty(value);
  // @@protoc_insertion_point(field_set:IVR8.Job.penalty)
}
inline float Job::_internal_penalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penalty_;
}
inline void Job::_internal_set_penalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.penalty_ = value;
}

// optional .IVR8.Job.VehicleRelation vehicleRelations = 5;
inline bool Job::has_vehiclerelations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehiclerelations_ != nullptr);
  return value;
}
inline void Job::clear_vehiclerelations() {
  if (_impl_.vehiclerelations_ != nullptr) _impl_.vehiclerelations_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::IVR8::Job_VehicleRelation& Job::_internal_vehiclerelations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Job_VehicleRelation* p = _impl_.vehiclerelations_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Job_VehicleRelation&>(::IVR8::_Job_VehicleRelation_default_instance_);
}
inline const ::IVR8::Job_VehicleRelation& Job::vehiclerelations() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.vehicleRelations)
  return _internal_vehiclerelations();
}
inline void Job::unsafe_arena_set_allocated_vehiclerelations(::IVR8::Job_VehicleRelation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehiclerelations_);
  }
  _impl_.vehiclerelations_ = reinterpret_cast<::IVR8::Job_VehicleRelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Job.vehicleRelations)
}
inline ::IVR8::Job_VehicleRelation* Job::release_vehiclerelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::IVR8::Job_VehicleRelation* released = _impl_.vehiclerelations_;
  _impl_.vehiclerelations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Job_VehicleRelation* Job::unsafe_arena_release_vehiclerelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.vehicleRelations)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::IVR8::Job_VehicleRelation* temp = _impl_.vehiclerelations_;
  _impl_.vehiclerelations_ = nullptr;
  return temp;
}
inline ::IVR8::Job_VehicleRelation* Job::_internal_mutable_vehiclerelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vehiclerelations_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Job_VehicleRelation>(GetArenaForAllocation());
    _impl_.vehiclerelations_ = reinterpret_cast<::IVR8::Job_VehicleRelation*>(p);
  }
  return _impl_.vehiclerelations_;
}
inline ::IVR8::Job_VehicleRelation* Job::mutable_vehiclerelations() {
  ::IVR8::Job_VehicleRelation* _msg = _internal_mutable_vehiclerelations();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.vehicleRelations)
  return _msg;
}
inline void Job::set_allocated_vehiclerelations(::IVR8::Job_VehicleRelation* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Job_VehicleRelation*>(_impl_.vehiclerelations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Job_VehicleRelation*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.vehiclerelations_ = reinterpret_cast<::IVR8::Job_VehicleRelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.vehicleRelations)
}

// optional .IVR8.Job.CompartmentRelation compartmentRelations = 6;
inline bool Job::has_compartmentrelations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.compartmentrelations_ != nullptr);
  return value;
}
inline void Job::clear_compartmentrelations() {
  if (_impl_.compartmentrelations_ != nullptr) _impl_.compartmentrelations_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::IVR8::Job_CompartmentRelation& Job::_internal_compartmentrelations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Job_CompartmentRelation* p = _impl_.compartmentrelations_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Job_CompartmentRelation&>(::IVR8::_Job_CompartmentRelation_default_instance_);
}
inline const ::IVR8::Job_CompartmentRelation& Job::compartmentrelations() const {
  // @@protoc_insertion_point(field_get:IVR8.Job.compartmentRelations)
  return _internal_compartmentrelations();
}
inline void Job::unsafe_arena_set_allocated_compartmentrelations(::IVR8::Job_CompartmentRelation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.compartmentrelations_);
  }
  _impl_.compartmentrelations_ = reinterpret_cast<::IVR8::Job_CompartmentRelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Job.compartmentRelations)
}
inline ::IVR8::Job_CompartmentRelation* Job::release_compartmentrelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::IVR8::Job_CompartmentRelation* released = _impl_.compartmentrelations_;
  _impl_.compartmentrelations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Job_CompartmentRelation* Job::unsafe_arena_release_compartmentrelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Job.compartmentRelations)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::IVR8::Job_CompartmentRelation* temp = _impl_.compartmentrelations_;
  _impl_.compartmentrelations_ = nullptr;
  return temp;
}
inline ::IVR8::Job_CompartmentRelation* Job::_internal_mutable_compartmentrelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.compartmentrelations_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Job_CompartmentRelation>(GetArenaForAllocation());
    _impl_.compartmentrelations_ = reinterpret_cast<::IVR8::Job_CompartmentRelation*>(p);
  }
  return _impl_.compartmentrelations_;
}
inline ::IVR8::Job_CompartmentRelation* Job::mutable_compartmentrelations() {
  ::IVR8::Job_CompartmentRelation* _msg = _internal_mutable_compartmentrelations();
  // @@protoc_insertion_point(field_mutable:IVR8.Job.compartmentRelations)
  return _msg;
}
inline void Job::set_allocated_compartmentrelations(::IVR8::Job_CompartmentRelation* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Job_CompartmentRelation*>(_impl_.compartmentrelations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Job_CompartmentRelation*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.compartmentrelations_ = reinterpret_cast<::IVR8::Job_CompartmentRelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Job.compartmentRelations)
}

// -------------------------------------------------------------------

// TransitSet_TransitValue

// required string fromId = 1;
inline bool TransitSet_TransitValue::has_fromid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitSet_TransitValue::clear_fromid() {
  _impl_.fromid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitSet_TransitValue::fromid() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitSet.TransitValue.fromId)
  return _internal_fromid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitSet_TransitValue::set_fromid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitSet.TransitValue.fromId)
}
inline std::string* TransitSet_TransitValue::mutable_fromid() {
  std::string* _s = _internal_mutable_fromid();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitSet.TransitValue.fromId)
  return _s;
}
inline const std::string& TransitSet_TransitValue::_internal_fromid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromid_.Get();
}
inline void TransitSet_TransitValue::_internal_set_fromid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::_internal_mutable_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fromid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::release_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitSet.TransitValue.fromId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fromid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fromid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitSet_TransitValue::set_allocated_fromid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fromid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromid_.IsDefault()) {
          _impl_.fromid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitSet.TransitValue.fromId)
}

// required string toId = 2;
inline bool TransitSet_TransitValue::has_toid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitSet_TransitValue::clear_toid() {
  _impl_.toid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitSet_TransitValue::toid() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitSet.TransitValue.toId)
  return _internal_toid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitSet_TransitValue::set_toid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitSet.TransitValue.toId)
}
inline std::string* TransitSet_TransitValue::mutable_toid() {
  std::string* _s = _internal_mutable_toid();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitSet.TransitValue.toId)
  return _s;
}
inline const std::string& TransitSet_TransitValue::_internal_toid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.toid_.Get();
}
inline void TransitSet_TransitValue::_internal_set_toid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::_internal_mutable_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.toid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::release_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitSet.TransitValue.toId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.toid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.toid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitSet_TransitValue::set_allocated_toid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.toid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.toid_.IsDefault()) {
          _impl_.toid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitSet.TransitValue.toId)
}

// required float value = 3;
inline bool TransitSet_TransitValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TransitSet_TransitValue::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float TransitSet_TransitValue::value() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitSet.TransitValue.value)
  return _internal_value();
}
inline void TransitSet_TransitValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IVR8.TransitSet.TransitValue.value)
}
inline float TransitSet_TransitValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TransitSet_TransitValue::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TransitSet

// repeated .IVR8.TransitSet.TransitValue transits = 1;
inline int TransitSet::_internal_transits_size() const {
  return _internal_transits().size();
}
inline int TransitSet::transits_size() const {
  return _internal_transits_size();
}
inline void TransitSet::clear_transits() {
  _internal_mutable_transits()->Clear();
}
inline ::IVR8::TransitSet_TransitValue* TransitSet::mutable_transits(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.TransitSet.transits)
  return _internal_mutable_transits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::TransitSet_TransitValue >*
TransitSet::mutable_transits() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.TransitSet.transits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transits();
}
inline const ::IVR8::TransitSet_TransitValue& TransitSet::transits(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.TransitSet.transits)
    return _internal_transits().Get(index);
}
inline ::IVR8::TransitSet_TransitValue* TransitSet::add_transits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::TransitSet_TransitValue* _add = _internal_mutable_transits()->Add();
  // @@protoc_insertion_point(field_add:IVR8.TransitSet.transits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitSet_TransitValue >&
TransitSet::transits() const {
  // @@protoc_insertion_point(field_list:IVR8.TransitSet.transits)
  return _internal_transits();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::TransitSet_TransitValue>&
TransitSet::_internal_transits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transits_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::TransitSet_TransitValue>*
TransitSet::_internal_mutable_transits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transits_;
}

// -------------------------------------------------------------------

// TransitGenerator

// required string id = 1;
inline bool TransitGenerator::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitGenerator::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitGenerator::id() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitGenerator.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitGenerator::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitGenerator.id)
}
inline std::string* TransitGenerator::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitGenerator.id)
  return _s;
}
inline const std::string& TransitGenerator::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TransitGenerator::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitGenerator::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitGenerator::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitGenerator.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitGenerator::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitGenerator.id)
}

// optional string requestId = 2;
inline bool TransitGenerator::has_requestid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitGenerator::clear_requestid() {
  _impl_.requestid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitGenerator::requestid() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitGenerator.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitGenerator::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitGenerator.requestId)
}
inline std::string* TransitGenerator::mutable_requestid() {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitGenerator.requestId)
  return _s;
}
inline const std::string& TransitGenerator::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void TransitGenerator::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitGenerator::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.requestid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitGenerator::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitGenerator.requestId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.requestid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.requestid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitGenerator::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.requestid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitGenerator.requestId)
}

// optional .IVR8.TransitSet transitSet = 3;
inline bool TransitGenerator::has_transitset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transitset_ != nullptr);
  return value;
}
inline void TransitGenerator::clear_transitset() {
  if (_impl_.transitset_ != nullptr) _impl_.transitset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::IVR8::TransitSet& TransitGenerator::_internal_transitset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::TransitSet* p = _impl_.transitset_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::TransitSet&>(::IVR8::_TransitSet_default_instance_);
}
inline const ::IVR8::TransitSet& TransitGenerator::transitset() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitGenerator.transitSet)
  return _internal_transitset();
}
inline void TransitGenerator::unsafe_arena_set_allocated_transitset(::IVR8::TransitSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transitset_);
  }
  _impl_.transitset_ = reinterpret_cast<::IVR8::TransitSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.TransitGenerator.transitSet)
}
inline ::IVR8::TransitSet* TransitGenerator::release_transitset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::IVR8::TransitSet* released = _impl_.transitset_;
  _impl_.transitset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::TransitSet* TransitGenerator::unsafe_arena_release_transitset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitGenerator.transitSet)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::IVR8::TransitSet* temp = _impl_.transitset_;
  _impl_.transitset_ = nullptr;
  return temp;
}
inline ::IVR8::TransitSet* TransitGenerator::_internal_mutable_transitset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.transitset_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::TransitSet>(GetArenaForAllocation());
    _impl_.transitset_ = reinterpret_cast<::IVR8::TransitSet*>(p);
  }
  return _impl_.transitset_;
}
inline ::IVR8::TransitSet* TransitGenerator::mutable_transitset() {
  ::IVR8::TransitSet* _msg = _internal_mutable_transitset();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitGenerator.transitSet)
  return _msg;
}
inline void TransitGenerator::set_allocated_transitset(::IVR8::TransitSet* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::TransitSet*>(_impl_.transitset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::TransitSet*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.transitset_ = reinterpret_cast<::IVR8::TransitSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitGenerator.transitSet)
}

// -------------------------------------------------------------------

// VehicleClass_Attribute

// required string dimensionId = 1;
inline bool VehicleClass_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleClass_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.Attribute.dimensionId)
}
inline std::string* VehicleClass_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleClass.Attribute.dimensionId)
  return _s;
}
inline const std::string& VehicleClass_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void VehicleClass_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.VehicleClass.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.VehicleClass.Attribute.dimensionId)
}

// optional string transitGeneratorId = 2;
inline bool VehicleClass_Attribute::has_transitgeneratorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_transitgeneratorid() {
  _impl_.transitgeneratorid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehicleClass_Attribute::transitgeneratorid() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.Attribute.transitGeneratorId)
  return _internal_transitgeneratorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass_Attribute::set_transitgeneratorid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transitgeneratorid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.Attribute.transitGeneratorId)
}
inline std::string* VehicleClass_Attribute::mutable_transitgeneratorid() {
  std::string* _s = _internal_mutable_transitgeneratorid();
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleClass.Attribute.transitGeneratorId)
  return _s;
}
inline const std::string& VehicleClass_Attribute::_internal_transitgeneratorid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitgeneratorid_.Get();
}
inline void VehicleClass_Attribute::_internal_set_transitgeneratorid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transitgeneratorid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::_internal_mutable_transitgeneratorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.transitgeneratorid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::release_transitgeneratorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.VehicleClass.Attribute.transitGeneratorId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.transitgeneratorid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transitgeneratorid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass_Attribute::set_allocated_transitgeneratorid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transitgeneratorid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transitgeneratorid_.IsDefault()) {
          _impl_.transitgeneratorid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.VehicleClass.Attribute.transitGeneratorId)
}

// optional float transitCoef = 3;
inline bool VehicleClass_Attribute::has_transitcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_transitcoef() {
  _impl_.transitcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float VehicleClass_Attribute::transitcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.Attribute.transitCoef)
  return _internal_transitcoef();
}
inline void VehicleClass_Attribute::set_transitcoef(float value) {
  _internal_set_transitcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.Attribute.transitCoef)
}
inline float VehicleClass_Attribute::_internal_transitcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitcoef_;
}
inline void VehicleClass_Attribute::_internal_set_transitcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transitcoef_ = value;
}

// optional float taskCoef = 4;
inline bool VehicleClass_Attribute::has_taskcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_taskcoef() {
  _impl_.taskcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float VehicleClass_Attribute::taskcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.Attribute.taskCoef)
  return _internal_taskcoef();
}
inline void VehicleClass_Attribute::set_taskcoef(float value) {
  _internal_set_taskcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.Attribute.taskCoef)
}
inline float VehicleClass_Attribute::_internal_taskcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskcoef_;
}
inline void VehicleClass_Attribute::_internal_set_taskcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.taskcoef_ = value;
}

// optional float locationCoef = 5;
inline bool VehicleClass_Attribute::has_locationcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_locationcoef() {
  _impl_.locationcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VehicleClass_Attribute::locationcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.Attribute.locationCoef)
  return _internal_locationcoef();
}
inline void VehicleClass_Attribute::set_locationcoef(float value) {
  _internal_set_locationcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.Attribute.locationCoef)
}
inline float VehicleClass_Attribute::_internal_locationcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationcoef_;
}
inline void VehicleClass_Attribute::_internal_set_locationcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.locationcoef_ = value;
}

// -------------------------------------------------------------------

// VehicleClass

// required string id = 1;
inline bool VehicleClass::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleClass::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleClass::id() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.id)
}
inline std::string* VehicleClass::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleClass.id)
  return _s;
}
inline const std::string& VehicleClass::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void VehicleClass::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.VehicleClass.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.VehicleClass.id)
}

// repeated .IVR8.VehicleClass.Attribute attributes = 2;
inline int VehicleClass::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int VehicleClass::attributes_size() const {
  return _internal_attributes_size();
}
inline void VehicleClass::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::VehicleClass_Attribute* VehicleClass::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleClass.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass_Attribute >*
VehicleClass::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.VehicleClass.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::VehicleClass_Attribute& VehicleClass::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::VehicleClass_Attribute* VehicleClass::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::VehicleClass_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.VehicleClass.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass_Attribute >&
VehicleClass::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.VehicleClass.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass_Attribute>&
VehicleClass::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass_Attribute>*
VehicleClass::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated string transitRuleIds = 3;
inline int VehicleClass::_internal_transitruleids_size() const {
  return _internal_transitruleids().size();
}
inline int VehicleClass::transitruleids_size() const {
  return _internal_transitruleids_size();
}
inline void VehicleClass::clear_transitruleids() {
  _internal_mutable_transitruleids()->Clear();
}
inline std::string* VehicleClass::add_transitruleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_transitruleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.VehicleClass.transitRuleIds)
  return _s;
}
inline const std::string& VehicleClass::transitruleids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.transitRuleIds)
  return _internal_transitruleids().Get(index);
}
inline std::string* VehicleClass::mutable_transitruleids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleClass.transitRuleIds)
  return _internal_mutable_transitruleids()->Mutable(index);
}
inline void VehicleClass::set_transitruleids(int index, const std::string& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, std::string&& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, absl::string_view value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.VehicleClass.transitRuleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VehicleClass::transitruleids() const {
  // @@protoc_insertion_point(field_list:IVR8.VehicleClass.transitRuleIds)
  return _internal_transitruleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* VehicleClass::mutable_transitruleids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.VehicleClass.transitRuleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VehicleClass::_internal_transitruleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VehicleClass::_internal_mutable_transitruleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleids_;
}

// optional string compartmentSetId = 4;
inline bool VehicleClass::has_compartmentsetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleClass::clear_compartmentsetid() {
  _impl_.compartmentsetid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehicleClass::compartmentsetid() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleClass.compartmentSetId)
  return _internal_compartmentsetid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass::set_compartmentsetid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.compartmentsetid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.VehicleClass.compartmentSetId)
}
inline std::string* VehicleClass::mutable_compartmentsetid() {
  std::string* _s = _internal_mutable_compartmentsetid();
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleClass.compartmentSetId)
  return _s;
}
inline const std::string& VehicleClass::_internal_compartmentsetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentsetid_.Get();
}
inline void VehicleClass::_internal_set_compartmentsetid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.compartmentsetid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass::_internal_mutable_compartmentsetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.compartmentsetid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass::release_compartmentsetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.VehicleClass.compartmentSetId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.compartmentsetid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.compartmentsetid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass::set_allocated_compartmentsetid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.compartmentsetid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.compartmentsetid_.IsDefault()) {
          _impl_.compartmentsetid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.VehicleClass.compartmentSetId)
}

// -------------------------------------------------------------------

// VehicleCostClass_Attribute

// required string dimensionId = 1;
inline bool VehicleCostClass_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleCostClass_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleCostClass_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.Attribute.dimensionId)
}
inline std::string* VehicleCostClass_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleCostClass.Attribute.dimensionId)
  return _s;
}
inline const std::string& VehicleCostClass_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void VehicleCostClass_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleCostClass_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleCostClass_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.VehicleCostClass.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleCostClass_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.VehicleCostClass.Attribute.dimensionId)
}

// optional float transitCostCoef = 2;
inline bool VehicleCostClass_Attribute::has_transitcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_transitcostcoef() {
  _impl_.transitcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float VehicleCostClass_Attribute::transitcostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.Attribute.transitCostCoef)
  return _internal_transitcostcoef();
}
inline void VehicleCostClass_Attribute::set_transitcostcoef(float value) {
  _internal_set_transitcostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.Attribute.transitCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_transitcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_transitcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transitcostcoef_ = value;
}

// optional float taskCostCoef = 3;
inline bool VehicleCostClass_Attribute::has_taskcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_taskcostcoef() {
  _impl_.taskcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float VehicleCostClass_Attribute::taskcostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.Attribute.taskCostCoef)
  return _internal_taskcostcoef();
}
inline void VehicleCostClass_Attribute::set_taskcostcoef(float value) {
  _internal_set_taskcostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.Attribute.taskCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_taskcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_taskcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.taskcostcoef_ = value;
}

// optional float locationCostCoef = 4;
inline bool VehicleCostClass_Attribute::has_locationcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_locationcostcoef() {
  _impl_.locationcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float VehicleCostClass_Attribute::locationcostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.Attribute.locationCostCoef)
  return _internal_locationcostcoef();
}
inline void VehicleCostClass_Attribute::set_locationcostcoef(float value) {
  _internal_set_locationcostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.Attribute.locationCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_locationcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_locationcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.locationcostcoef_ = value;
}

// optional float slackCostCoef = 5;
inline bool VehicleCostClass_Attribute::has_slackcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_slackcostcoef() {
  _impl_.slackcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VehicleCostClass_Attribute::slackcostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.Attribute.slackCostCoef)
  return _internal_slackcostcoef();
}
inline void VehicleCostClass_Attribute::set_slackcostcoef(float value) {
  _internal_set_slackcostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.Attribute.slackCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_slackcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_slackcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackcostcoef_ = value;
}

// optional float tardyCostCoef = 6;
inline bool VehicleCostClass_Attribute::has_tardycostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_tardycostcoef() {
  _impl_.tardycostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float VehicleCostClass_Attribute::tardycostcoef() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.Attribute.tardyCostCoef)
  return _internal_tardycostcoef();
}
inline void VehicleCostClass_Attribute::set_tardycostcoef(float value) {
  _internal_set_tardycostcoef(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.Attribute.tardyCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_tardycostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_tardycostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tardycostcoef_ = value;
}

// -------------------------------------------------------------------

// VehicleCostClass

// required string id = 1;
inline bool VehicleCostClass::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleCostClass::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleCostClass::id() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleCostClass::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.id)
}
inline std::string* VehicleCostClass::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleCostClass.id)
  return _s;
}
inline const std::string& VehicleCostClass::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void VehicleCostClass::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleCostClass::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleCostClass::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.VehicleCostClass.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleCostClass::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.VehicleCostClass.id)
}

// required float fixedCost = 2;
inline bool VehicleCostClass::has_fixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleCostClass::clear_fixedcost() {
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float VehicleCostClass::fixedcost() const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.fixedCost)
  return _internal_fixedcost();
}
inline void VehicleCostClass::set_fixedcost(float value) {
  _internal_set_fixedcost(value);
  // @@protoc_insertion_point(field_set:IVR8.VehicleCostClass.fixedCost)
}
inline float VehicleCostClass::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline void VehicleCostClass::_internal_set_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fixedcost_ = value;
}

// repeated .IVR8.VehicleCostClass.Attribute attributes = 3;
inline int VehicleCostClass::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int VehicleCostClass::attributes_size() const {
  return _internal_attributes_size();
}
inline void VehicleCostClass::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::VehicleCostClass_Attribute* VehicleCostClass::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.VehicleCostClass.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass_Attribute >*
VehicleCostClass::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.VehicleCostClass.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::VehicleCostClass_Attribute& VehicleCostClass::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.VehicleCostClass.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::VehicleCostClass_Attribute* VehicleCostClass::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::VehicleCostClass_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.VehicleCostClass.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass_Attribute >&
VehicleCostClass::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.VehicleCostClass.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass_Attribute>&
VehicleCostClass::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass_Attribute>*
VehicleCostClass::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Vehicle_Task_Attribute

// required string dimensionId = 1;
inline bool Vehicle_Task_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle_Task_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle_Task_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Task.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle_Task_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.Task.Attribute.dimensionId)
}
inline std::string* Vehicle_Task_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Task.Attribute.dimensionId)
  return _s;
}
inline const std::string& Vehicle_Task_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Vehicle_Task_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle_Task_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle_Task_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.Task.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle_Task_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.Task.Attribute.dimensionId)
}

// optional float quantity = 2;
inline bool Vehicle_Task_Attribute::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vehicle_Task_Attribute::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vehicle_Task_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Task.Attribute.quantity)
  return _internal_quantity();
}
inline void Vehicle_Task_Attribute::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.Task.Attribute.quantity)
}
inline float Vehicle_Task_Attribute::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Vehicle_Task_Attribute::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quantity_ = value;
}

// repeated .IVR8.Window windows = 3;
inline int Vehicle_Task_Attribute::_internal_windows_size() const {
  return _internal_windows().size();
}
inline int Vehicle_Task_Attribute::windows_size() const {
  return _internal_windows_size();
}
inline void Vehicle_Task_Attribute::clear_windows() {
  _internal_mutable_windows()->Clear();
}
inline ::IVR8::Window* Vehicle_Task_Attribute::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Task.Attribute.windows)
  return _internal_mutable_windows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Window >*
Vehicle_Task_Attribute::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Vehicle.Task.Attribute.windows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_windows();
}
inline const ::IVR8::Window& Vehicle_Task_Attribute::windows(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Task.Attribute.windows)
    return _internal_windows().Get(index);
}
inline ::IVR8::Window* Vehicle_Task_Attribute::add_windows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Window* _add = _internal_mutable_windows()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Vehicle.Task.Attribute.windows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Window >&
Vehicle_Task_Attribute::windows() const {
  // @@protoc_insertion_point(field_list:IVR8.Vehicle.Task.Attribute.windows)
  return _internal_windows();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Window>&
Vehicle_Task_Attribute::_internal_windows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windows_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Window>*
Vehicle_Task_Attribute::_internal_mutable_windows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.windows_;
}

// -------------------------------------------------------------------

// Vehicle_Task

// required string locationId = 1;
inline bool Vehicle_Task::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle_Task::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle_Task::locationid() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Task.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle_Task::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.Task.locationId)
}
inline std::string* Vehicle_Task::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Task.locationId)
  return _s;
}
inline const std::string& Vehicle_Task::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void Vehicle_Task::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle_Task::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle_Task::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.Task.locationId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle_Task::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.Task.locationId)
}

// repeated .IVR8.Vehicle.Task.Attribute attributes = 2;
inline int Vehicle_Task::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int Vehicle_Task::attributes_size() const {
  return _internal_attributes_size();
}
inline void Vehicle_Task::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::Vehicle_Task_Attribute* Vehicle_Task::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Task.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Task_Attribute >*
Vehicle_Task::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Vehicle.Task.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::Vehicle_Task_Attribute& Vehicle_Task::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Task.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::Vehicle_Task_Attribute* Vehicle_Task::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Vehicle_Task_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Vehicle.Task.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Task_Attribute >&
Vehicle_Task::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.Vehicle.Task.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Task_Attribute>&
Vehicle_Task::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Task_Attribute>*
Vehicle_Task::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Vehicle_Shift

// required .IVR8.Vehicle.Task shiftStart = 1;
inline bool Vehicle_Shift::has_shiftstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shiftstart_ != nullptr);
  return value;
}
inline void Vehicle_Shift::clear_shiftstart() {
  if (_impl_.shiftstart_ != nullptr) _impl_.shiftstart_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::IVR8::Vehicle_Task& Vehicle_Shift::_internal_shiftstart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Vehicle_Task* p = _impl_.shiftstart_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Vehicle_Task&>(::IVR8::_Vehicle_Task_default_instance_);
}
inline const ::IVR8::Vehicle_Task& Vehicle_Shift::shiftstart() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Shift.shiftStart)
  return _internal_shiftstart();
}
inline void Vehicle_Shift::unsafe_arena_set_allocated_shiftstart(::IVR8::Vehicle_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shiftstart_);
  }
  _impl_.shiftstart_ = reinterpret_cast<::IVR8::Vehicle_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Vehicle.Shift.shiftStart)
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::release_shiftstart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::IVR8::Vehicle_Task* released = _impl_.shiftstart_;
  _impl_.shiftstart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::unsafe_arena_release_shiftstart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.Shift.shiftStart)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::IVR8::Vehicle_Task* temp = _impl_.shiftstart_;
  _impl_.shiftstart_ = nullptr;
  return temp;
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::_internal_mutable_shiftstart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.shiftstart_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Vehicle_Task>(GetArenaForAllocation());
    _impl_.shiftstart_ = reinterpret_cast<::IVR8::Vehicle_Task*>(p);
  }
  return _impl_.shiftstart_;
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::mutable_shiftstart() {
  ::IVR8::Vehicle_Task* _msg = _internal_mutable_shiftstart();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Shift.shiftStart)
  return _msg;
}
inline void Vehicle_Shift::set_allocated_shiftstart(::IVR8::Vehicle_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Vehicle_Task*>(_impl_.shiftstart_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Vehicle_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shiftstart_ = reinterpret_cast<::IVR8::Vehicle_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.Shift.shiftStart)
}

// optional .IVR8.Vehicle.Task shiftEnd = 2;
inline bool Vehicle_Shift::has_shiftend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shiftend_ != nullptr);
  return value;
}
inline void Vehicle_Shift::clear_shiftend() {
  if (_impl_.shiftend_ != nullptr) _impl_.shiftend_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::IVR8::Vehicle_Task& Vehicle_Shift::_internal_shiftend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Vehicle_Task* p = _impl_.shiftend_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Vehicle_Task&>(::IVR8::_Vehicle_Task_default_instance_);
}
inline const ::IVR8::Vehicle_Task& Vehicle_Shift::shiftend() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Shift.shiftEnd)
  return _internal_shiftend();
}
inline void Vehicle_Shift::unsafe_arena_set_allocated_shiftend(::IVR8::Vehicle_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shiftend_);
  }
  _impl_.shiftend_ = reinterpret_cast<::IVR8::Vehicle_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Vehicle.Shift.shiftEnd)
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::release_shiftend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Vehicle_Task* released = _impl_.shiftend_;
  _impl_.shiftend_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::unsafe_arena_release_shiftend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.Shift.shiftEnd)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Vehicle_Task* temp = _impl_.shiftend_;
  _impl_.shiftend_ = nullptr;
  return temp;
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::_internal_mutable_shiftend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shiftend_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Vehicle_Task>(GetArenaForAllocation());
    _impl_.shiftend_ = reinterpret_cast<::IVR8::Vehicle_Task*>(p);
  }
  return _impl_.shiftend_;
}
inline ::IVR8::Vehicle_Task* Vehicle_Shift::mutable_shiftend() {
  ::IVR8::Vehicle_Task* _msg = _internal_mutable_shiftend();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Shift.shiftEnd)
  return _msg;
}
inline void Vehicle_Shift::set_allocated_shiftend(::IVR8::Vehicle_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Vehicle_Task*>(_impl_.shiftend_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Vehicle_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.shiftend_ = reinterpret_cast<::IVR8::Vehicle_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.Shift.shiftEnd)
}

// -------------------------------------------------------------------

// Vehicle_Capacity

// required string dimensionId = 1;
inline bool Vehicle_Capacity::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle_Capacity::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle_Capacity::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Capacity.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle_Capacity::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.Capacity.dimensionId)
}
inline std::string* Vehicle_Capacity::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.Capacity.dimensionId)
  return _s;
}
inline const std::string& Vehicle_Capacity::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Vehicle_Capacity::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle_Capacity::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle_Capacity::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.Capacity.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle_Capacity::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.Capacity.dimensionId)
}

// required float capacity = 2;
inline bool Vehicle_Capacity::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vehicle_Capacity::clear_capacity() {
  _impl_.capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vehicle_Capacity::capacity() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.Capacity.capacity)
  return _internal_capacity();
}
inline void Vehicle_Capacity::set_capacity(float value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.Capacity.capacity)
}
inline float Vehicle_Capacity::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void Vehicle_Capacity::_internal_set_capacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.capacity_ = value;
}

// -------------------------------------------------------------------

// Vehicle

// required string id = 1;
inline bool Vehicle::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle::id() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.id)
}
inline std::string* Vehicle::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.id)
  return _s;
}
inline const std::string& Vehicle::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Vehicle::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.id)
}

// required string classId = 2;
inline bool Vehicle::has_classid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vehicle::clear_classid() {
  _impl_.classid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Vehicle::classid() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.classId)
  return _internal_classid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_classid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.classid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.classId)
}
inline std::string* Vehicle::mutable_classid() {
  std::string* _s = _internal_mutable_classid();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.classId)
  return _s;
}
inline const std::string& Vehicle::_internal_classid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.classid_.Get();
}
inline void Vehicle::_internal_set_classid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.classid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_classid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.classid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_classid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.classId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.classid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.classid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_classid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.classid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.classid_.IsDefault()) {
          _impl_.classid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.classId)
}

// required string costClassId = 3;
inline bool Vehicle::has_costclassid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Vehicle::clear_costclassid() {
  _impl_.costclassid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Vehicle::costclassid() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.costClassId)
  return _internal_costclassid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_costclassid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.costclassid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.costClassId)
}
inline std::string* Vehicle::mutable_costclassid() {
  std::string* _s = _internal_mutable_costclassid();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.costClassId)
  return _s;
}
inline const std::string& Vehicle::_internal_costclassid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costclassid_.Get();
}
inline void Vehicle::_internal_set_costclassid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.costclassid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_costclassid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.costclassid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_costclassid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.costClassId)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.costclassid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.costclassid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_costclassid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.costclassid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.costclassid_.IsDefault()) {
          _impl_.costclassid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.costClassId)
}

// required .IVR8.Vehicle.Shift shift = 4;
inline bool Vehicle::has_shift() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shift_ != nullptr);
  return value;
}
inline void Vehicle::clear_shift() {
  if (_impl_.shift_ != nullptr) _impl_.shift_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::IVR8::Vehicle_Shift& Vehicle::_internal_shift() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Vehicle_Shift* p = _impl_.shift_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Vehicle_Shift&>(::IVR8::_Vehicle_Shift_default_instance_);
}
inline const ::IVR8::Vehicle_Shift& Vehicle::shift() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.shift)
  return _internal_shift();
}
inline void Vehicle::unsafe_arena_set_allocated_shift(::IVR8::Vehicle_Shift* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shift_);
  }
  _impl_.shift_ = reinterpret_cast<::IVR8::Vehicle_Shift*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Vehicle.shift)
}
inline ::IVR8::Vehicle_Shift* Vehicle::release_shift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::IVR8::Vehicle_Shift* released = _impl_.shift_;
  _impl_.shift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Vehicle_Shift* Vehicle::unsafe_arena_release_shift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.shift)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::IVR8::Vehicle_Shift* temp = _impl_.shift_;
  _impl_.shift_ = nullptr;
  return temp;
}
inline ::IVR8::Vehicle_Shift* Vehicle::_internal_mutable_shift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.shift_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Vehicle_Shift>(GetArenaForAllocation());
    _impl_.shift_ = reinterpret_cast<::IVR8::Vehicle_Shift*>(p);
  }
  return _impl_.shift_;
}
inline ::IVR8::Vehicle_Shift* Vehicle::mutable_shift() {
  ::IVR8::Vehicle_Shift* _msg = _internal_mutable_shift();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.shift)
  return _msg;
}
inline void Vehicle::set_allocated_shift(::IVR8::Vehicle_Shift* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Vehicle_Shift*>(_impl_.shift_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Vehicle_Shift*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.shift_ = reinterpret_cast<::IVR8::Vehicle_Shift*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.shift)
}

// repeated .IVR8.Vehicle.Capacity capacities = 5;
inline int Vehicle::_internal_capacities_size() const {
  return _internal_capacities().size();
}
inline int Vehicle::capacities_size() const {
  return _internal_capacities_size();
}
inline void Vehicle::clear_capacities() {
  _internal_mutable_capacities()->Clear();
}
inline ::IVR8::Vehicle_Capacity* Vehicle::mutable_capacities(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.capacities)
  return _internal_mutable_capacities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Capacity >*
Vehicle::mutable_capacities() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Vehicle.capacities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capacities();
}
inline const ::IVR8::Vehicle_Capacity& Vehicle::capacities(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.capacities)
    return _internal_capacities().Get(index);
}
inline ::IVR8::Vehicle_Capacity* Vehicle::add_capacities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Vehicle_Capacity* _add = _internal_mutable_capacities()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Vehicle.capacities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle_Capacity >&
Vehicle::capacities() const {
  // @@protoc_insertion_point(field_list:IVR8.Vehicle.capacities)
  return _internal_capacities();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Capacity>&
Vehicle::_internal_capacities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacities_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle_Capacity>*
Vehicle::_internal_mutable_capacities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capacities_;
}

// repeated string transitRuleIds = 6;
inline int Vehicle::_internal_transitruleids_size() const {
  return _internal_transitruleids().size();
}
inline int Vehicle::transitruleids_size() const {
  return _internal_transitruleids_size();
}
inline void Vehicle::clear_transitruleids() {
  _internal_mutable_transitruleids()->Clear();
}
inline std::string* Vehicle::add_transitruleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_transitruleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.Vehicle.transitRuleIds)
  return _s;
}
inline const std::string& Vehicle::transitruleids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.transitRuleIds)
  return _internal_transitruleids().Get(index);
}
inline std::string* Vehicle::mutable_transitruleids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.transitRuleIds)
  return _internal_mutable_transitruleids()->Mutable(index);
}
inline void Vehicle::set_transitruleids(int index, const std::string& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, std::string&& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, absl::string_view value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.Vehicle.transitRuleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Vehicle::transitruleids() const {
  // @@protoc_insertion_point(field_list:IVR8.Vehicle.transitRuleIds)
  return _internal_transitruleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Vehicle::mutable_transitruleids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Vehicle.transitRuleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Vehicle::_internal_transitruleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Vehicle::_internal_mutable_transitruleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleids_;
}

// optional string compartmentSetId = 7;
inline bool Vehicle::has_compartmentsetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Vehicle::clear_compartmentsetid() {
  _impl_.compartmentsetid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Vehicle::compartmentsetid() const {
  // @@protoc_insertion_point(field_get:IVR8.Vehicle.compartmentSetId)
  return _internal_compartmentsetid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_compartmentsetid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compartmentsetid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Vehicle.compartmentSetId)
}
inline std::string* Vehicle::mutable_compartmentsetid() {
  std::string* _s = _internal_mutable_compartmentsetid();
  // @@protoc_insertion_point(field_mutable:IVR8.Vehicle.compartmentSetId)
  return _s;
}
inline const std::string& Vehicle::_internal_compartmentsetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentsetid_.Get();
}
inline void Vehicle::_internal_set_compartmentsetid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compartmentsetid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_compartmentsetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.compartmentsetid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_compartmentsetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Vehicle.compartmentSetId)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.compartmentsetid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.compartmentsetid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_compartmentsetid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.compartmentsetid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.compartmentsetid_.IsDefault()) {
          _impl_.compartmentsetid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Vehicle.compartmentSetId)
}

// -------------------------------------------------------------------

// TaskSequence

// required string vehicleId = 1;
inline bool TaskSequence::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TaskSequence::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskSequence::vehicleid() const {
  // @@protoc_insertion_point(field_get:IVR8.TaskSequence.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSequence::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TaskSequence.vehicleId)
}
inline std::string* TaskSequence::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:IVR8.TaskSequence.vehicleId)
  return _s;
}
inline const std::string& TaskSequence::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void TaskSequence::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskSequence::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskSequence::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TaskSequence.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskSequence::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TaskSequence.vehicleId)
}

// repeated string taskId = 2;
inline int TaskSequence::_internal_taskid_size() const {
  return _internal_taskid().size();
}
inline int TaskSequence::taskid_size() const {
  return _internal_taskid_size();
}
inline void TaskSequence::clear_taskid() {
  _internal_mutable_taskid()->Clear();
}
inline std::string* TaskSequence::add_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_taskid()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.TaskSequence.taskId)
  return _s;
}
inline const std::string& TaskSequence::taskid(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.TaskSequence.taskId)
  return _internal_taskid().Get(index);
}
inline std::string* TaskSequence::mutable_taskid(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.TaskSequence.taskId)
  return _internal_mutable_taskid()->Mutable(index);
}
inline void TaskSequence::set_taskid(int index, const std::string& value) {
  _internal_mutable_taskid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, std::string&& value) {
  _internal_mutable_taskid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_taskid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_taskid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, absl::string_view value) {
  _internal_mutable_taskid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.TaskSequence.taskId)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskSequence::taskid() const {
  // @@protoc_insertion_point(field_list:IVR8.TaskSequence.taskId)
  return _internal_taskid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* TaskSequence::mutable_taskid() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.TaskSequence.taskId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_taskid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskSequence::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TaskSequence::_internal_mutable_taskid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.taskid_;
}

// repeated string compartmentId = 3;
inline int TaskSequence::_internal_compartmentid_size() const {
  return _internal_compartmentid().size();
}
inline int TaskSequence::compartmentid_size() const {
  return _internal_compartmentid_size();
}
inline void TaskSequence::clear_compartmentid() {
  _internal_mutable_compartmentid()->Clear();
}
inline std::string* TaskSequence::add_compartmentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_compartmentid()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.TaskSequence.compartmentId)
  return _s;
}
inline const std::string& TaskSequence::compartmentid(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.TaskSequence.compartmentId)
  return _internal_compartmentid().Get(index);
}
inline std::string* TaskSequence::mutable_compartmentid(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.TaskSequence.compartmentId)
  return _internal_mutable_compartmentid()->Mutable(index);
}
inline void TaskSequence::set_compartmentid(int index, const std::string& value) {
  _internal_mutable_compartmentid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::set_compartmentid(int index, std::string&& value) {
  _internal_mutable_compartmentid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::set_compartmentid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_compartmentid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::set_compartmentid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_compartmentid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::set_compartmentid(int index, absl::string_view value) {
  _internal_mutable_compartmentid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::add_compartmentid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::add_compartmentid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::add_compartmentid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::add_compartmentid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.TaskSequence.compartmentId)
}
inline void TaskSequence::add_compartmentid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.TaskSequence.compartmentId)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskSequence::compartmentid() const {
  // @@protoc_insertion_point(field_list:IVR8.TaskSequence.compartmentId)
  return _internal_compartmentid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* TaskSequence::mutable_compartmentid() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.TaskSequence.compartmentId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compartmentid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskSequence::_internal_compartmentid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TaskSequence::_internal_mutable_compartmentid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compartmentid_;
}

// -------------------------------------------------------------------

// TransitRule_Trigger

// required float value = 1;
inline bool TransitRule_Trigger::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitRule_Trigger::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TransitRule_Trigger::value() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.Trigger.value)
  return _internal_value();
}
inline void TransitRule_Trigger::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.Trigger.value)
}
inline float TransitRule_Trigger::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TransitRule_Trigger::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}

// required float quantity = 2;
inline bool TransitRule_Trigger::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitRule_Trigger::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TransitRule_Trigger::quantity() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.Trigger.quantity)
  return _internal_quantity();
}
inline void TransitRule_Trigger::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.Trigger.quantity)
}
inline float TransitRule_Trigger::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void TransitRule_Trigger::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// TransitRule

// required string id = 1;
inline bool TransitRule::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitRule::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitRule::id() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRule::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.id)
}
inline std::string* TransitRule::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitRule.id)
  return _s;
}
inline const std::string& TransitRule::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TransitRule::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitRule::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitRule::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitRule.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitRule::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitRule.id)
}

// required string dimensionId = 2;
inline bool TransitRule::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitRule::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitRule::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRule::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.dimensionId)
}
inline std::string* TransitRule::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitRule.dimensionId)
  return _s;
}
inline const std::string& TransitRule::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void TransitRule::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitRule::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitRule::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitRule.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitRule::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitRule.dimensionId)
}

// optional bool useStandingState = 3 [default = true];
inline bool TransitRule::has_usestandingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TransitRule::clear_usestandingstate() {
  _impl_.usestandingstate_ = true;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TransitRule::usestandingstate() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.useStandingState)
  return _internal_usestandingstate();
}
inline void TransitRule::set_usestandingstate(bool value) {
  _internal_set_usestandingstate(value);
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.useStandingState)
}
inline bool TransitRule::_internal_usestandingstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usestandingstate_;
}
inline void TransitRule::_internal_set_usestandingstate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.usestandingstate_ = value;
}

// optional bool useTransitState = 4 [default = false];
inline bool TransitRule::has_usetransitstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TransitRule::clear_usetransitstate() {
  _impl_.usetransitstate_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TransitRule::usetransitstate() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.useTransitState)
  return _internal_usetransitstate();
}
inline void TransitRule::set_usetransitstate(bool value) {
  _internal_set_usetransitstate(value);
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.useTransitState)
}
inline bool TransitRule::_internal_usetransitstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usetransitstate_;
}
inline void TransitRule::_internal_set_usetransitstate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.usetransitstate_ = value;
}

// required string ruleIdPrefix = 5;
inline bool TransitRule::has_ruleidprefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TransitRule::clear_ruleidprefix() {
  _impl_.ruleidprefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TransitRule::ruleidprefix() const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.ruleIdPrefix)
  return _internal_ruleidprefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRule::set_ruleidprefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ruleidprefix_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.TransitRule.ruleIdPrefix)
}
inline std::string* TransitRule::mutable_ruleidprefix() {
  std::string* _s = _internal_mutable_ruleidprefix();
  // @@protoc_insertion_point(field_mutable:IVR8.TransitRule.ruleIdPrefix)
  return _s;
}
inline const std::string& TransitRule::_internal_ruleidprefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ruleidprefix_.Get();
}
inline void TransitRule::_internal_set_ruleidprefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ruleidprefix_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitRule::_internal_mutable_ruleidprefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ruleidprefix_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitRule::release_ruleidprefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.TransitRule.ruleIdPrefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ruleidprefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ruleidprefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitRule::set_allocated_ruleidprefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ruleidprefix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ruleidprefix_.IsDefault()) {
          _impl_.ruleidprefix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.TransitRule.ruleIdPrefix)
}

// repeated .IVR8.TransitRule.Trigger triggers = 6;
inline int TransitRule::_internal_triggers_size() const {
  return _internal_triggers().size();
}
inline int TransitRule::triggers_size() const {
  return _internal_triggers_size();
}
inline void TransitRule::clear_triggers() {
  _internal_mutable_triggers()->Clear();
}
inline ::IVR8::TransitRule_Trigger* TransitRule::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.TransitRule.triggers)
  return _internal_mutable_triggers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule_Trigger >*
TransitRule::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.TransitRule.triggers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_triggers();
}
inline const ::IVR8::TransitRule_Trigger& TransitRule::triggers(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.TransitRule.triggers)
    return _internal_triggers().Get(index);
}
inline ::IVR8::TransitRule_Trigger* TransitRule::add_triggers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::TransitRule_Trigger* _add = _internal_mutable_triggers()->Add();
  // @@protoc_insertion_point(field_add:IVR8.TransitRule.triggers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule_Trigger >&
TransitRule::triggers() const {
  // @@protoc_insertion_point(field_list:IVR8.TransitRule.triggers)
  return _internal_triggers();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule_Trigger>&
TransitRule::_internal_triggers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.triggers_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule_Trigger>*
TransitRule::_internal_mutable_triggers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.triggers_;
}

// -------------------------------------------------------------------

// Compartment_Capacity

// required string dimensionId = 1;
inline bool Compartment_Capacity::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Compartment_Capacity::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Compartment_Capacity::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.Compartment.Capacity.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Compartment_Capacity::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Compartment.Capacity.dimensionId)
}
inline std::string* Compartment_Capacity::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.Compartment.Capacity.dimensionId)
  return _s;
}
inline const std::string& Compartment_Capacity::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Compartment_Capacity::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Compartment_Capacity::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Compartment_Capacity::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Compartment.Capacity.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Compartment_Capacity::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Compartment.Capacity.dimensionId)
}

// required float capacity = 2;
inline bool Compartment_Capacity::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Compartment_Capacity::clear_capacity() {
  _impl_.capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Compartment_Capacity::capacity() const {
  // @@protoc_insertion_point(field_get:IVR8.Compartment.Capacity.capacity)
  return _internal_capacity();
}
inline void Compartment_Capacity::set_capacity(float value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:IVR8.Compartment.Capacity.capacity)
}
inline float Compartment_Capacity::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void Compartment_Capacity::_internal_set_capacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.capacity_ = value;
}

// -------------------------------------------------------------------

// Compartment

// required string id = 1;
inline bool Compartment::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Compartment::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Compartment::id() const {
  // @@protoc_insertion_point(field_get:IVR8.Compartment.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Compartment::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.Compartment.id)
}
inline std::string* Compartment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.Compartment.id)
  return _s;
}
inline const std::string& Compartment::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Compartment::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Compartment::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Compartment::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Compartment.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Compartment::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.Compartment.id)
}

// repeated .IVR8.Compartment.Capacity capacities = 2;
inline int Compartment::_internal_capacities_size() const {
  return _internal_capacities().size();
}
inline int Compartment::capacities_size() const {
  return _internal_capacities_size();
}
inline void Compartment::clear_capacities() {
  _internal_mutable_capacities()->Clear();
}
inline ::IVR8::Compartment_Capacity* Compartment::mutable_capacities(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Compartment.capacities)
  return _internal_mutable_capacities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment_Capacity >*
Compartment::mutable_capacities() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Compartment.capacities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capacities();
}
inline const ::IVR8::Compartment_Capacity& Compartment::capacities(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Compartment.capacities)
    return _internal_capacities().Get(index);
}
inline ::IVR8::Compartment_Capacity* Compartment::add_capacities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Compartment_Capacity* _add = _internal_mutable_capacities()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Compartment.capacities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment_Capacity >&
Compartment::capacities() const {
  // @@protoc_insertion_point(field_list:IVR8.Compartment.capacities)
  return _internal_capacities();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Compartment_Capacity>&
Compartment::_internal_capacities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacities_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Compartment_Capacity>*
Compartment::_internal_mutable_capacities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capacities_;
}

// -------------------------------------------------------------------

// CompartmentSet_GroupLimit

// repeated string compartmentIds = 1;
inline int CompartmentSet_GroupLimit::_internal_compartmentids_size() const {
  return _internal_compartmentids().size();
}
inline int CompartmentSet_GroupLimit::compartmentids_size() const {
  return _internal_compartmentids_size();
}
inline void CompartmentSet_GroupLimit::clear_compartmentids() {
  _internal_mutable_compartmentids()->Clear();
}
inline std::string* CompartmentSet_GroupLimit::add_compartmentids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_compartmentids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.CompartmentSet.GroupLimit.compartmentIds)
  return _s;
}
inline const std::string& CompartmentSet_GroupLimit::compartmentids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.GroupLimit.compartmentIds)
  return _internal_compartmentids().Get(index);
}
inline std::string* CompartmentSet_GroupLimit::mutable_compartmentids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.CompartmentSet.GroupLimit.compartmentIds)
  return _internal_mutable_compartmentids()->Mutable(index);
}
inline void CompartmentSet_GroupLimit::set_compartmentids(int index, const std::string& value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::set_compartmentids(int index, std::string&& value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::set_compartmentids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_compartmentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::set_compartmentids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::set_compartmentids(int index, absl::string_view value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::add_compartmentids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::add_compartmentids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::add_compartmentids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::add_compartmentids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline void CompartmentSet_GroupLimit::add_compartmentids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.CompartmentSet.GroupLimit.compartmentIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CompartmentSet_GroupLimit::compartmentids() const {
  // @@protoc_insertion_point(field_list:IVR8.CompartmentSet.GroupLimit.compartmentIds)
  return _internal_compartmentids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* CompartmentSet_GroupLimit::mutable_compartmentids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.CompartmentSet.GroupLimit.compartmentIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compartmentids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CompartmentSet_GroupLimit::_internal_compartmentids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CompartmentSet_GroupLimit::_internal_mutable_compartmentids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compartmentids_;
}

// repeated float coefficients = 2;
inline int CompartmentSet_GroupLimit::_internal_coefficients_size() const {
  return _internal_coefficients().size();
}
inline int CompartmentSet_GroupLimit::coefficients_size() const {
  return _internal_coefficients_size();
}
inline void CompartmentSet_GroupLimit::clear_coefficients() {
  _internal_mutable_coefficients()->Clear();
}
inline float CompartmentSet_GroupLimit::coefficients(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.GroupLimit.coefficients)
  return _internal_coefficients().Get(index);
}
inline void CompartmentSet_GroupLimit::set_coefficients(int index, float value) {
  _internal_mutable_coefficients()->Set(index, value);
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.GroupLimit.coefficients)
}
inline void CompartmentSet_GroupLimit::add_coefficients(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_coefficients()->Add(value);
  // @@protoc_insertion_point(field_add:IVR8.CompartmentSet.GroupLimit.coefficients)
}
inline const ::google::protobuf::RepeatedField<float>& CompartmentSet_GroupLimit::coefficients() const {
  // @@protoc_insertion_point(field_list:IVR8.CompartmentSet.GroupLimit.coefficients)
  return _internal_coefficients();
}
inline ::google::protobuf::RepeatedField<float>* CompartmentSet_GroupLimit::mutable_coefficients() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.CompartmentSet.GroupLimit.coefficients)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_coefficients();
}

inline const ::google::protobuf::RepeatedField<float>& CompartmentSet_GroupLimit::_internal_coefficients() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coefficients_;
}
inline ::google::protobuf::RepeatedField<float>* CompartmentSet_GroupLimit::_internal_mutable_coefficients() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.coefficients_;
}

// required string dimensionId = 3;
inline bool CompartmentSet_GroupLimit::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CompartmentSet_GroupLimit::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompartmentSet_GroupLimit::dimensionid() const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.GroupLimit.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompartmentSet_GroupLimit::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.GroupLimit.dimensionId)
}
inline std::string* CompartmentSet_GroupLimit::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:IVR8.CompartmentSet.GroupLimit.dimensionId)
  return _s;
}
inline const std::string& CompartmentSet_GroupLimit::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void CompartmentSet_GroupLimit::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* CompartmentSet_GroupLimit::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* CompartmentSet_GroupLimit::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.CompartmentSet.GroupLimit.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CompartmentSet_GroupLimit::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.CompartmentSet.GroupLimit.dimensionId)
}

// required float limit = 4;
inline bool CompartmentSet_GroupLimit::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CompartmentSet_GroupLimit::clear_limit() {
  _impl_.limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CompartmentSet_GroupLimit::limit() const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.GroupLimit.limit)
  return _internal_limit();
}
inline void CompartmentSet_GroupLimit::set_limit(float value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.GroupLimit.limit)
}
inline float CompartmentSet_GroupLimit::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void CompartmentSet_GroupLimit::_internal_set_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.limit_ = value;
}

// optional bool checkStandingState = 5 [default = false];
inline bool CompartmentSet_GroupLimit::has_checkstandingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CompartmentSet_GroupLimit::clear_checkstandingstate() {
  _impl_.checkstandingstate_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CompartmentSet_GroupLimit::checkstandingstate() const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.GroupLimit.checkStandingState)
  return _internal_checkstandingstate();
}
inline void CompartmentSet_GroupLimit::set_checkstandingstate(bool value) {
  _internal_set_checkstandingstate(value);
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.GroupLimit.checkStandingState)
}
inline bool CompartmentSet_GroupLimit::_internal_checkstandingstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.checkstandingstate_;
}
inline void CompartmentSet_GroupLimit::_internal_set_checkstandingstate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.checkstandingstate_ = value;
}

// -------------------------------------------------------------------

// CompartmentSet

// required string id = 1;
inline bool CompartmentSet::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CompartmentSet::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompartmentSet::id() const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompartmentSet::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.id)
}
inline std::string* CompartmentSet::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:IVR8.CompartmentSet.id)
  return _s;
}
inline const std::string& CompartmentSet::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CompartmentSet::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompartmentSet::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* CompartmentSet::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.CompartmentSet.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CompartmentSet::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.CompartmentSet.id)
}

// repeated string compartmentIds = 2;
inline int CompartmentSet::_internal_compartmentids_size() const {
  return _internal_compartmentids().size();
}
inline int CompartmentSet::compartmentids_size() const {
  return _internal_compartmentids_size();
}
inline void CompartmentSet::clear_compartmentids() {
  _internal_mutable_compartmentids()->Clear();
}
inline std::string* CompartmentSet::add_compartmentids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_compartmentids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.CompartmentSet.compartmentIds)
  return _s;
}
inline const std::string& CompartmentSet::compartmentids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.compartmentIds)
  return _internal_compartmentids().Get(index);
}
inline std::string* CompartmentSet::mutable_compartmentids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.CompartmentSet.compartmentIds)
  return _internal_mutable_compartmentids()->Mutable(index);
}
inline void CompartmentSet::set_compartmentids(int index, const std::string& value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::set_compartmentids(int index, std::string&& value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::set_compartmentids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_compartmentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::set_compartmentids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::set_compartmentids(int index, absl::string_view value) {
  _internal_mutable_compartmentids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::add_compartmentids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::add_compartmentids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::add_compartmentids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::add_compartmentids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.CompartmentSet.compartmentIds)
}
inline void CompartmentSet::add_compartmentids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_compartmentids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.CompartmentSet.compartmentIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CompartmentSet::compartmentids() const {
  // @@protoc_insertion_point(field_list:IVR8.CompartmentSet.compartmentIds)
  return _internal_compartmentids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* CompartmentSet::mutable_compartmentids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.CompartmentSet.compartmentIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compartmentids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CompartmentSet::_internal_compartmentids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CompartmentSet::_internal_mutable_compartmentids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compartmentids_;
}

// repeated .IVR8.CompartmentSet.GroupLimit groupLimits = 3;
inline int CompartmentSet::_internal_grouplimits_size() const {
  return _internal_grouplimits().size();
}
inline int CompartmentSet::grouplimits_size() const {
  return _internal_grouplimits_size();
}
inline void CompartmentSet::clear_grouplimits() {
  _internal_mutable_grouplimits()->Clear();
}
inline ::IVR8::CompartmentSet_GroupLimit* CompartmentSet::mutable_grouplimits(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.CompartmentSet.groupLimits)
  return _internal_mutable_grouplimits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet_GroupLimit >*
CompartmentSet::mutable_grouplimits() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.CompartmentSet.groupLimits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_grouplimits();
}
inline const ::IVR8::CompartmentSet_GroupLimit& CompartmentSet::grouplimits(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.CompartmentSet.groupLimits)
    return _internal_grouplimits().Get(index);
}
inline ::IVR8::CompartmentSet_GroupLimit* CompartmentSet::add_grouplimits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::CompartmentSet_GroupLimit* _add = _internal_mutable_grouplimits()->Add();
  // @@protoc_insertion_point(field_add:IVR8.CompartmentSet.groupLimits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet_GroupLimit >&
CompartmentSet::grouplimits() const {
  // @@protoc_insertion_point(field_list:IVR8.CompartmentSet.groupLimits)
  return _internal_grouplimits();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet_GroupLimit>&
CompartmentSet::_internal_grouplimits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.grouplimits_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet_GroupLimit>*
CompartmentSet::_internal_mutable_grouplimits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.grouplimits_;
}

// -------------------------------------------------------------------

// Model

// required .IVR8.DimensionConfiguration dimensions = 1;
inline bool Model::has_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimensions_ != nullptr);
  return value;
}
inline void Model::clear_dimensions() {
  if (_impl_.dimensions_ != nullptr) _impl_.dimensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::IVR8::DimensionConfiguration& Model::_internal_dimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::DimensionConfiguration* p = _impl_.dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::DimensionConfiguration&>(::IVR8::_DimensionConfiguration_default_instance_);
}
inline const ::IVR8::DimensionConfiguration& Model::dimensions() const {
  // @@protoc_insertion_point(field_get:IVR8.Model.dimensions)
  return _internal_dimensions();
}
inline void Model::unsafe_arena_set_allocated_dimensions(::IVR8::DimensionConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }
  _impl_.dimensions_ = reinterpret_cast<::IVR8::DimensionConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.Model.dimensions)
}
inline ::IVR8::DimensionConfiguration* Model::release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::IVR8::DimensionConfiguration* released = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::DimensionConfiguration* Model::unsafe_arena_release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.Model.dimensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::IVR8::DimensionConfiguration* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  return temp;
}
inline ::IVR8::DimensionConfiguration* Model::_internal_mutable_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dimensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::DimensionConfiguration>(GetArenaForAllocation());
    _impl_.dimensions_ = reinterpret_cast<::IVR8::DimensionConfiguration*>(p);
  }
  return _impl_.dimensions_;
}
inline ::IVR8::DimensionConfiguration* Model::mutable_dimensions() {
  ::IVR8::DimensionConfiguration* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:IVR8.Model.dimensions)
  return _msg;
}
inline void Model::set_allocated_dimensions(::IVR8::DimensionConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::DimensionConfiguration*>(_impl_.dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::DimensionConfiguration*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimensions_ = reinterpret_cast<::IVR8::DimensionConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.Model.dimensions)
}

// repeated .IVR8.Location locations = 2;
inline int Model::_internal_locations_size() const {
  return _internal_locations().size();
}
inline int Model::locations_size() const {
  return _internal_locations_size();
}
inline void Model::clear_locations() {
  _internal_mutable_locations()->Clear();
}
inline ::IVR8::Location* Model::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.locations)
  return _internal_mutable_locations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Location >*
Model::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.locations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_locations();
}
inline const ::IVR8::Location& Model::locations(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.locations)
    return _internal_locations().Get(index);
}
inline ::IVR8::Location* Model::add_locations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Location* _add = _internal_mutable_locations()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.locations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Location >&
Model::locations() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.locations)
  return _internal_locations();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Location>&
Model::_internal_locations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locations_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Location>*
Model::_internal_mutable_locations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.locations_;
}

// repeated .IVR8.Job jobs = 3;
inline int Model::_internal_jobs_size() const {
  return _internal_jobs().size();
}
inline int Model::jobs_size() const {
  return _internal_jobs_size();
}
inline void Model::clear_jobs() {
  _internal_mutable_jobs()->Clear();
}
inline ::IVR8::Job* Model::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.jobs)
  return _internal_mutable_jobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Job >*
Model::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.jobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jobs();
}
inline const ::IVR8::Job& Model::jobs(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.jobs)
    return _internal_jobs().Get(index);
}
inline ::IVR8::Job* Model::add_jobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Job* _add = _internal_mutable_jobs()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.jobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Job >&
Model::jobs() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.jobs)
  return _internal_jobs();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Job>&
Model::_internal_jobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobs_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Job>*
Model::_internal_mutable_jobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jobs_;
}

// repeated .IVR8.Vehicle vehicles = 4;
inline int Model::_internal_vehicles_size() const {
  return _internal_vehicles().size();
}
inline int Model::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void Model::clear_vehicles() {
  _internal_mutable_vehicles()->Clear();
}
inline ::IVR8::Vehicle* Model::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.vehicles)
  return _internal_mutable_vehicles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle >*
Model::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.vehicles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicles();
}
inline const ::IVR8::Vehicle& Model::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.vehicles)
    return _internal_vehicles().Get(index);
}
inline ::IVR8::Vehicle* Model::add_vehicles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Vehicle* _add = _internal_mutable_vehicles()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.vehicles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Vehicle >&
Model::vehicles() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.vehicles)
  return _internal_vehicles();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle>&
Model::_internal_vehicles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicles_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Vehicle>*
Model::_internal_mutable_vehicles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicles_;
}

// repeated .IVR8.VehicleClass vehicleClasses = 5;
inline int Model::_internal_vehicleclasses_size() const {
  return _internal_vehicleclasses().size();
}
inline int Model::vehicleclasses_size() const {
  return _internal_vehicleclasses_size();
}
inline void Model::clear_vehicleclasses() {
  _internal_mutable_vehicleclasses()->Clear();
}
inline ::IVR8::VehicleClass* Model::mutable_vehicleclasses(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.vehicleClasses)
  return _internal_mutable_vehicleclasses()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass >*
Model::mutable_vehicleclasses() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.vehicleClasses)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicleclasses();
}
inline const ::IVR8::VehicleClass& Model::vehicleclasses(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.vehicleClasses)
    return _internal_vehicleclasses().Get(index);
}
inline ::IVR8::VehicleClass* Model::add_vehicleclasses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::VehicleClass* _add = _internal_mutable_vehicleclasses()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.vehicleClasses)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleClass >&
Model::vehicleclasses() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.vehicleClasses)
  return _internal_vehicleclasses();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass>&
Model::_internal_vehicleclasses() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleclasses_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::VehicleClass>*
Model::_internal_mutable_vehicleclasses() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicleclasses_;
}

// repeated .IVR8.VehicleCostClass vehicleCostClasses = 6;
inline int Model::_internal_vehiclecostclasses_size() const {
  return _internal_vehiclecostclasses().size();
}
inline int Model::vehiclecostclasses_size() const {
  return _internal_vehiclecostclasses_size();
}
inline void Model::clear_vehiclecostclasses() {
  _internal_mutable_vehiclecostclasses()->Clear();
}
inline ::IVR8::VehicleCostClass* Model::mutable_vehiclecostclasses(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.vehicleCostClasses)
  return _internal_mutable_vehiclecostclasses()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass >*
Model::mutable_vehiclecostclasses() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.vehicleCostClasses)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehiclecostclasses();
}
inline const ::IVR8::VehicleCostClass& Model::vehiclecostclasses(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.vehicleCostClasses)
    return _internal_vehiclecostclasses().Get(index);
}
inline ::IVR8::VehicleCostClass* Model::add_vehiclecostclasses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::VehicleCostClass* _add = _internal_mutable_vehiclecostclasses()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.vehicleCostClasses)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::VehicleCostClass >&
Model::vehiclecostclasses() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.vehicleCostClasses)
  return _internal_vehiclecostclasses();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass>&
Model::_internal_vehiclecostclasses() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehiclecostclasses_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::VehicleCostClass>*
Model::_internal_mutable_vehiclecostclasses() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehiclecostclasses_;
}

// repeated .IVR8.TransitRule transitRules = 7;
inline int Model::_internal_transitrules_size() const {
  return _internal_transitrules().size();
}
inline int Model::transitrules_size() const {
  return _internal_transitrules_size();
}
inline void Model::clear_transitrules() {
  _internal_mutable_transitrules()->Clear();
}
inline ::IVR8::TransitRule* Model::mutable_transitrules(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.transitRules)
  return _internal_mutable_transitrules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule >*
Model::mutable_transitrules() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.transitRules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitrules();
}
inline const ::IVR8::TransitRule& Model::transitrules(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.transitRules)
    return _internal_transitrules().Get(index);
}
inline ::IVR8::TransitRule* Model::add_transitrules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::TransitRule* _add = _internal_mutable_transitrules()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.transitRules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitRule >&
Model::transitrules() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.transitRules)
  return _internal_transitrules();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule>&
Model::_internal_transitrules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitrules_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::TransitRule>*
Model::_internal_mutable_transitrules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitrules_;
}

// repeated .IVR8.TransitGenerator transitGenerators = 8;
inline int Model::_internal_transitgenerators_size() const {
  return _internal_transitgenerators().size();
}
inline int Model::transitgenerators_size() const {
  return _internal_transitgenerators_size();
}
inline void Model::clear_transitgenerators() {
  _internal_mutable_transitgenerators()->Clear();
}
inline ::IVR8::TransitGenerator* Model::mutable_transitgenerators(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.transitGenerators)
  return _internal_mutable_transitgenerators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::TransitGenerator >*
Model::mutable_transitgenerators() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.transitGenerators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitgenerators();
}
inline const ::IVR8::TransitGenerator& Model::transitgenerators(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.transitGenerators)
    return _internal_transitgenerators().Get(index);
}
inline ::IVR8::TransitGenerator* Model::add_transitgenerators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::TransitGenerator* _add = _internal_mutable_transitgenerators()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.transitGenerators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::TransitGenerator >&
Model::transitgenerators() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.transitGenerators)
  return _internal_transitgenerators();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::TransitGenerator>&
Model::_internal_transitgenerators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitgenerators_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::TransitGenerator>*
Model::_internal_mutable_transitgenerators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitgenerators_;
}

// repeated .IVR8.TaskSequence taskSequence = 9;
inline int Model::_internal_tasksequence_size() const {
  return _internal_tasksequence().size();
}
inline int Model::tasksequence_size() const {
  return _internal_tasksequence_size();
}
inline void Model::clear_tasksequence() {
  _internal_mutable_tasksequence()->Clear();
}
inline ::IVR8::TaskSequence* Model::mutable_tasksequence(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.taskSequence)
  return _internal_mutable_tasksequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >*
Model::mutable_tasksequence() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.taskSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasksequence();
}
inline const ::IVR8::TaskSequence& Model::tasksequence(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.taskSequence)
    return _internal_tasksequence().Get(index);
}
inline ::IVR8::TaskSequence* Model::add_tasksequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::TaskSequence* _add = _internal_mutable_tasksequence()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.taskSequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >&
Model::tasksequence() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.taskSequence)
  return _internal_tasksequence();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>&
Model::_internal_tasksequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasksequence_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>*
Model::_internal_mutable_tasksequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasksequence_;
}

// repeated .IVR8.Compartment compartments = 10;
inline int Model::_internal_compartments_size() const {
  return _internal_compartments().size();
}
inline int Model::compartments_size() const {
  return _internal_compartments_size();
}
inline void Model::clear_compartments() {
  _internal_mutable_compartments()->Clear();
}
inline ::IVR8::Compartment* Model::mutable_compartments(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.compartments)
  return _internal_mutable_compartments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment >*
Model::mutable_compartments() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.compartments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compartments();
}
inline const ::IVR8::Compartment& Model::compartments(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.compartments)
    return _internal_compartments().Get(index);
}
inline ::IVR8::Compartment* Model::add_compartments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Compartment* _add = _internal_mutable_compartments()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.compartments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Compartment >&
Model::compartments() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.compartments)
  return _internal_compartments();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Compartment>&
Model::_internal_compartments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartments_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Compartment>*
Model::_internal_mutable_compartments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compartments_;
}

// repeated .IVR8.CompartmentSet compartmentSets = 11;
inline int Model::_internal_compartmentsets_size() const {
  return _internal_compartmentsets().size();
}
inline int Model::compartmentsets_size() const {
  return _internal_compartmentsets_size();
}
inline void Model::clear_compartmentsets() {
  _internal_mutable_compartmentsets()->Clear();
}
inline ::IVR8::CompartmentSet* Model::mutable_compartmentsets(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.Model.compartmentSets)
  return _internal_mutable_compartmentsets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet >*
Model::mutable_compartmentsets() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.Model.compartmentSets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compartmentsets();
}
inline const ::IVR8::CompartmentSet& Model::compartmentsets(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.Model.compartmentSets)
    return _internal_compartmentsets().Get(index);
}
inline ::IVR8::CompartmentSet* Model::add_compartmentsets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::CompartmentSet* _add = _internal_mutable_compartmentsets()->Add();
  // @@protoc_insertion_point(field_add:IVR8.Model.compartmentSets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::CompartmentSet >&
Model::compartmentsets() const {
  // @@protoc_insertion_point(field_list:IVR8.Model.compartmentSets)
  return _internal_compartmentsets();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet>&
Model::_internal_compartmentsets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentsets_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::CompartmentSet>*
Model::_internal_mutable_compartmentsets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compartmentsets_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .IVR8.Model model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::IVR8::Model& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::IVR8::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::IVR8::Model&>(::IVR8::_Model_default_instance_);
}
inline const ::IVR8::Model& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:IVR8.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::IVR8::Model* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::IVR8::Model*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IVR8.SolveRequest.model)
}
inline ::IVR8::Model* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Model* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::IVR8::Model* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::IVR8::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::IVR8::Model* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::IVR8::Model>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::IVR8::Model*>(p);
  }
  return _impl_.model_;
}
inline ::IVR8::Model* SolveRequest::mutable_model() {
  ::IVR8::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:IVR8.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::IVR8::Model* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::IVR8::Model*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::IVR8::Model*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::IVR8::Model*>(value);
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolveRequest.modelID)
}

// repeated .IVR8.TaskSequence routes = 3;
inline int SolveRequest::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolveRequest::routes_size() const {
  return _internal_routes_size();
}
inline void SolveRequest::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::IVR8::TaskSequence* SolveRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolveRequest.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >*
SolveRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolveRequest.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::IVR8::TaskSequence& SolveRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolveRequest.routes)
    return _internal_routes().Get(index);
}
inline ::IVR8::TaskSequence* SolveRequest::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::TaskSequence* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolveRequest.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::TaskSequence >&
SolveRequest::routes() const {
  // @@protoc_insertion_point(field_list:IVR8.SolveRequest.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>&
SolveRequest::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::TaskSequence>*
SolveRequest::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// optional .IVR8.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::IVR8::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:IVR8.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::IVR8::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:IVR8.SolveRequest.solveType)
}
inline ::IVR8::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IVR8::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::IVR8::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::IVR8::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_StopAttribute

// required string dimId = 1;
inline bool SolutionResponse_StopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_StopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_StopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.dimId)
}
inline std::string* SolutionResponse_StopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.StopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_StopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_StopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.StopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_StopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.StopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_StopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_StopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_StopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.startValue)
}
inline float SolutionResponse_StopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_StopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_StopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_StopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.endValue)
}
inline float SolutionResponse_StopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_StopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_StopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_StopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.cost)
}
inline float SolutionResponse_StopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// required float slackValue = 5;
inline bool SolutionResponse_StopAttribute::has_slackvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_slackvalue() {
  _impl_.slackvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_StopAttribute::slackvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.slackValue)
  return _internal_slackvalue();
}
inline void SolutionResponse_StopAttribute::set_slackvalue(float value) {
  _internal_set_slackvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.slackValue)
}
inline float SolutionResponse_StopAttribute::_internal_slackvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_slackvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackvalue_ = value;
}

// required float slackCost = 6;
inline bool SolutionResponse_StopAttribute::has_slackcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_slackcost() {
  _impl_.slackcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_StopAttribute::slackcost() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.slackCost)
  return _internal_slackcost();
}
inline void SolutionResponse_StopAttribute::set_slackcost(float value) {
  _internal_set_slackcost(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.slackCost)
}
inline float SolutionResponse_StopAttribute::_internal_slackcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_slackcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.slackcost_ = value;
}

// required float tardyValue = 7;
inline bool SolutionResponse_StopAttribute::has_tardyvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_tardyvalue() {
  _impl_.tardyvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_StopAttribute::tardyvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.tardyValue)
  return _internal_tardyvalue();
}
inline void SolutionResponse_StopAttribute::set_tardyvalue(float value) {
  _internal_set_tardyvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.tardyValue)
}
inline float SolutionResponse_StopAttribute::_internal_tardyvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardyvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_tardyvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tardyvalue_ = value;
}

// required float tardyCost = 8;
inline bool SolutionResponse_StopAttribute::has_tardycost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_tardycost() {
  _impl_.tardycost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float SolutionResponse_StopAttribute::tardycost() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.StopAttribute.tardyCost)
  return _internal_tardycost();
}
inline void SolutionResponse_StopAttribute::set_tardycost(float value) {
  _internal_set_tardycost(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.StopAttribute.tardyCost)
}
inline float SolutionResponse_StopAttribute::_internal_tardycost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_tardycost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.tardycost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStopAttribute

// required string dimId = 1;
inline bool SolutionResponse_InterStopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_InterStopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_InterStopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.InterStopAttribute.dimId)
}
inline std::string* SolutionResponse_InterStopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.InterStopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_InterStopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_InterStopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.InterStopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_InterStopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.InterStopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_InterStopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_InterStopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_InterStopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.InterStopAttribute.startValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_InterStopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_InterStopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_InterStopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.InterStopAttribute.endValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_InterStopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_InterStopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_InterStopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.InterStopAttribute.cost)
}
inline float SolutionResponse_InterStopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Stop

// required int32 id = 1;
inline bool SolutionResponse_Stop::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SolutionResponse_Stop::id() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.id)
  return _internal_id();
}
inline void SolutionResponse_Stop::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Stop.id)
}
inline ::int32_t SolutionResponse_Stop::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SolutionResponse_Stop::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}

// required int32 sequence = 2;
inline bool SolutionResponse_Stop::has_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_sequence() {
  _impl_.sequence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t SolutionResponse_Stop::sequence() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.sequence)
  return _internal_sequence();
}
inline void SolutionResponse_Stop::set_sequence(::int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Stop.sequence)
}
inline ::int32_t SolutionResponse_Stop::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline void SolutionResponse_Stop::_internal_set_sequence(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sequence_ = value;
}

// required string locationId = 3;
inline bool SolutionResponse_Stop::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Stop::locationid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Stop.locationId)
}
inline std::string* SolutionResponse_Stop::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Stop.locationId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Stop.locationId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Stop.locationId)
}

// required string taskId = 4;
inline bool SolutionResponse_Stop::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Stop::taskid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Stop.taskId)
}
inline std::string* SolutionResponse_Stop::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Stop.taskId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Stop.taskId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Stop.taskId)
}

// required string jobId = 5;
inline bool SolutionResponse_Stop::has_jobid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_jobid() {
  _impl_.jobid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SolutionResponse_Stop::jobid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.jobId)
  return _internal_jobid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_jobid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.jobid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Stop.jobId)
}
inline std::string* SolutionResponse_Stop::mutable_jobid() {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Stop.jobId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_jobid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_jobid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.jobid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.jobid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Stop.jobId)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.jobid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.jobid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_jobid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.jobid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jobid_.IsDefault()) {
          _impl_.jobid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Stop.jobId)
}

// repeated .IVR8.SolutionResponse.StopAttribute attributes = 6;
inline int SolutionResponse_Stop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_Stop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_Stop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::SolutionResponse_StopAttribute* SolutionResponse_Stop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Stop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_StopAttribute >*
SolutionResponse_Stop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Stop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::SolutionResponse_StopAttribute& SolutionResponse_Stop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::SolutionResponse_StopAttribute* SolutionResponse_Stop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_StopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Stop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_StopAttribute >&
SolutionResponse_Stop::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Stop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_StopAttribute>&
SolutionResponse_Stop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_StopAttribute>*
SolutionResponse_Stop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// optional string compartmentId = 7;
inline bool SolutionResponse_Stop::has_compartmentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_compartmentid() {
  _impl_.compartmentid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SolutionResponse_Stop::compartmentid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Stop.compartmentId)
  return _internal_compartmentid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_compartmentid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compartmentid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Stop.compartmentId)
}
inline std::string* SolutionResponse_Stop::mutable_compartmentid() {
  std::string* _s = _internal_mutable_compartmentid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Stop.compartmentId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_compartmentid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compartmentid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_compartmentid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compartmentid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_compartmentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.compartmentid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_compartmentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Stop.compartmentId)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.compartmentid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.compartmentid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_compartmentid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.compartmentid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.compartmentid_.IsDefault()) {
          _impl_.compartmentid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Stop.compartmentId)
}

// -------------------------------------------------------------------

// SolutionResponse_InterStop

// required int32 fromStopId = 1;
inline bool SolutionResponse_InterStop::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SolutionResponse_InterStop::fromstopid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStop.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_InterStop::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.InterStop.fromStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_InterStop::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 2;
inline bool SolutionResponse_InterStop::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_InterStop::tostopid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStop.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_InterStop::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.InterStop.toStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_InterStop::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tostopid_ = value;
}

// repeated .IVR8.SolutionResponse.InterStopAttribute attributes = 3;
inline int SolutionResponse_InterStop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_InterStop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_InterStop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::IVR8::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.InterStop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStopAttribute >*
SolutionResponse_InterStop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.InterStop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::IVR8::SolutionResponse_InterStopAttribute& SolutionResponse_InterStop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStop.attributes)
    return _internal_attributes().Get(index);
}
inline ::IVR8::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_InterStopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.InterStop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStopAttribute >&
SolutionResponse_InterStop::attributes() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.InterStop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStopAttribute>&
SolutionResponse_InterStop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStopAttribute>*
SolutionResponse_InterStop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .IVR8.Geocode routeSegments = 4;
inline int SolutionResponse_InterStop::_internal_routesegments_size() const {
  return _internal_routesegments().size();
}
inline int SolutionResponse_InterStop::routesegments_size() const {
  return _internal_routesegments_size();
}
inline void SolutionResponse_InterStop::clear_routesegments() {
  _internal_mutable_routesegments()->Clear();
}
inline ::IVR8::Geocode* SolutionResponse_InterStop::mutable_routesegments(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.InterStop.routeSegments)
  return _internal_mutable_routesegments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::Geocode >*
SolutionResponse_InterStop::mutable_routesegments() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.InterStop.routeSegments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routesegments();
}
inline const ::IVR8::Geocode& SolutionResponse_InterStop::routesegments(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.InterStop.routeSegments)
    return _internal_routesegments().Get(index);
}
inline ::IVR8::Geocode* SolutionResponse_InterStop::add_routesegments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::Geocode* _add = _internal_mutable_routesegments()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.InterStop.routeSegments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::Geocode >&
SolutionResponse_InterStop::routesegments() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.InterStop.routeSegments)
  return _internal_routesegments();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::Geocode>&
SolutionResponse_InterStop::_internal_routesegments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routesegments_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::Geocode>*
SolutionResponse_InterStop::_internal_mutable_routesegments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routesegments_;
}

// -------------------------------------------------------------------

// SolutionResponse_TransitRuleAttribute

// required string ruleId = 1;
inline bool SolutionResponse_TransitRuleAttribute::has_ruleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_ruleid() {
  _impl_.ruleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::ruleid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.ruleId)
  return _internal_ruleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_TransitRuleAttribute::set_ruleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.ruleId)
}
inline std::string* SolutionResponse_TransitRuleAttribute::mutable_ruleid() {
  std::string* _s = _internal_mutable_ruleid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.TransitRuleAttribute.ruleId)
  return _s;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::_internal_ruleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ruleid_.Get();
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_ruleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::_internal_mutable_ruleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ruleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::release_ruleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.TransitRuleAttribute.ruleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ruleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ruleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_ruleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ruleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ruleid_.IsDefault()) {
          _impl_.ruleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.TransitRuleAttribute.ruleId)
}

// required string dimId = 2;
inline bool SolutionResponse_TransitRuleAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_TransitRuleAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.dimId)
}
inline std::string* SolutionResponse_TransitRuleAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.TransitRuleAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.TransitRuleAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.TransitRuleAttribute.dimId)
}

// required int32 fromStopId = 3;
inline bool SolutionResponse_TransitRuleAttribute::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::fromstopid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_TransitRuleAttribute::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.fromStopId)
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 4;
inline bool SolutionResponse_TransitRuleAttribute::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::tostopid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_TransitRuleAttribute::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.toStopId)
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tostopid_ = value;
}

// required float startValue = 5;
inline bool SolutionResponse_TransitRuleAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_TransitRuleAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_TransitRuleAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.startValue)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.startvalue_ = value;
}

// required float endValue = 6;
inline bool SolutionResponse_TransitRuleAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_TransitRuleAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_TransitRuleAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.endValue)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.endvalue_ = value;
}

// required float cost = 7;
inline bool SolutionResponse_TransitRuleAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_TransitRuleAttribute::cost() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.TransitRuleAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_TransitRuleAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.TransitRuleAttribute.cost)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string vehicleId = 1;
inline bool SolutionResponse_Route::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Route::vehicleid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Route.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Route::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Route.vehicleId)
}
inline std::string* SolutionResponse_Route::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Route.vehicleId)
  return _s;
}
inline const std::string& SolutionResponse_Route::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void SolutionResponse_Route::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Route.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Route::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Route.vehicleId)
}

// repeated .IVR8.SolutionResponse.Stop stops = 2;
inline int SolutionResponse_Route::_internal_stops_size() const {
  return _internal_stops().size();
}
inline int SolutionResponse_Route::stops_size() const {
  return _internal_stops_size();
}
inline void SolutionResponse_Route::clear_stops() {
  _internal_mutable_stops()->Clear();
}
inline ::IVR8::SolutionResponse_Stop* SolutionResponse_Route::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Route.stops)
  return _internal_mutable_stops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Stop >*
SolutionResponse_Route::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Route.stops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stops();
}
inline const ::IVR8::SolutionResponse_Stop& SolutionResponse_Route::stops(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Route.stops)
    return _internal_stops().Get(index);
}
inline ::IVR8::SolutionResponse_Stop* SolutionResponse_Route::add_stops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_Stop* _add = _internal_mutable_stops()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Route.stops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Stop >&
SolutionResponse_Route::stops() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Route.stops)
  return _internal_stops();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Stop>&
SolutionResponse_Route::_internal_stops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stops_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Stop>*
SolutionResponse_Route::_internal_mutable_stops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stops_;
}

// repeated .IVR8.SolutionResponse.InterStop interStops = 3;
inline int SolutionResponse_Route::_internal_interstops_size() const {
  return _internal_interstops().size();
}
inline int SolutionResponse_Route::interstops_size() const {
  return _internal_interstops_size();
}
inline void SolutionResponse_Route::clear_interstops() {
  _internal_mutable_interstops()->Clear();
}
inline ::IVR8::SolutionResponse_InterStop* SolutionResponse_Route::mutable_interstops(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Route.interStops)
  return _internal_mutable_interstops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStop >*
SolutionResponse_Route::mutable_interstops() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Route.interStops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_interstops();
}
inline const ::IVR8::SolutionResponse_InterStop& SolutionResponse_Route::interstops(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Route.interStops)
    return _internal_interstops().Get(index);
}
inline ::IVR8::SolutionResponse_InterStop* SolutionResponse_Route::add_interstops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_InterStop* _add = _internal_mutable_interstops()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Route.interStops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_InterStop >&
SolutionResponse_Route::interstops() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Route.interStops)
  return _internal_interstops();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStop>&
SolutionResponse_Route::_internal_interstops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interstops_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_InterStop>*
SolutionResponse_Route::_internal_mutable_interstops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.interstops_;
}

// repeated float fixedCost = 4;
inline int SolutionResponse_Route::_internal_fixedcost_size() const {
  return _internal_fixedcost().size();
}
inline int SolutionResponse_Route::fixedcost_size() const {
  return _internal_fixedcost_size();
}
inline void SolutionResponse_Route::clear_fixedcost() {
  _internal_mutable_fixedcost()->Clear();
}
inline float SolutionResponse_Route::fixedcost(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Route.fixedCost)
  return _internal_fixedcost().Get(index);
}
inline void SolutionResponse_Route::set_fixedcost(int index, float value) {
  _internal_mutable_fixedcost()->Set(index, value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Route.fixedCost)
}
inline void SolutionResponse_Route::add_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fixedcost()->Add(value);
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Route.fixedCost)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::fixedcost() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Route.fixedCost)
  return _internal_fixedcost();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::mutable_fixedcost() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Route.fixedCost)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fixedcost();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::_internal_mutable_fixedcost() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fixedcost_;
}

// repeated .IVR8.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
inline int SolutionResponse_Route::_internal_transitruleattributes_size() const {
  return _internal_transitruleattributes().size();
}
inline int SolutionResponse_Route::transitruleattributes_size() const {
  return _internal_transitruleattributes_size();
}
inline void SolutionResponse_Route::clear_transitruleattributes() {
  _internal_mutable_transitruleattributes()->Clear();
}
inline ::IVR8::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::mutable_transitruleattributes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Route.transitRuleAttributes)
  return _internal_mutable_transitruleattributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_TransitRuleAttribute >*
SolutionResponse_Route::mutable_transitruleattributes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Route.transitRuleAttributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleattributes();
}
inline const ::IVR8::SolutionResponse_TransitRuleAttribute& SolutionResponse_Route::transitruleattributes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Route.transitRuleAttributes)
    return _internal_transitruleattributes().Get(index);
}
inline ::IVR8::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::add_transitruleattributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_TransitRuleAttribute* _add = _internal_mutable_transitruleattributes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Route.transitRuleAttributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_TransitRuleAttribute >&
SolutionResponse_Route::transitruleattributes() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Route.transitRuleAttributes)
  return _internal_transitruleattributes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_TransitRuleAttribute>&
SolutionResponse_Route::_internal_transitruleattributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleattributes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_TransitRuleAttribute>*
SolutionResponse_Route::_internal_mutable_transitruleattributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleattributes_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility_Info

// required string message = 1;
inline bool SolutionResponse_Infeasibility_Info::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::message() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.Info.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.message)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Infeasibility.Info.message)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Infeasibility.Info.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Infeasibility.Info.message)
}

// optional string dimId = 2;
inline bool SolutionResponse_Infeasibility_Info::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::dimid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.Info.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.dimId)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Infeasibility.Info.dimId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Infeasibility.Info.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Infeasibility.Info.dimId)
}

// optional float limit = 3;
inline bool SolutionResponse_Infeasibility_Info::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_limit() {
  _impl_.limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_Infeasibility_Info::limit() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.Info.limit)
  return _internal_limit();
}
inline void SolutionResponse_Infeasibility_Info::set_limit(float value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.limit)
}
inline float SolutionResponse_Infeasibility_Info::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.limit_ = value;
}

// optional float value = 4;
inline bool SolutionResponse_Infeasibility_Info::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_Infeasibility_Info::value() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.Info.value)
  return _internal_value();
}
inline void SolutionResponse_Infeasibility_Info::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.value)
}
inline float SolutionResponse_Infeasibility_Info::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.value_ = value;
}

// optional int64 count = 5;
inline bool SolutionResponse_Infeasibility_Info::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_count() {
  _impl_.count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SolutionResponse_Infeasibility_Info::count() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.Info.count)
  return _internal_count();
}
inline void SolutionResponse_Infeasibility_Info::set_count(::int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.count)
}
inline ::int64_t SolutionResponse_Infeasibility_Info::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_count(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_ = value;
}

// repeated string constrainingTaskIds = 6;
inline int SolutionResponse_Infeasibility_Info::_internal_constrainingtaskids_size() const {
  return _internal_constrainingtaskids().size();
}
inline int SolutionResponse_Infeasibility_Info::constrainingtaskids_size() const {
  return _internal_constrainingtaskids_size();
}
inline void SolutionResponse_Infeasibility_Info::clear_constrainingtaskids() {
  _internal_mutable_constrainingtaskids()->Clear();
}
inline std::string* SolutionResponse_Infeasibility_Info::add_constrainingtaskids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_constrainingtaskids()->Add();
  // @@protoc_insertion_point(field_add_mutable:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::constrainingtaskids(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_constrainingtaskids().Get(index);
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_mutable_constrainingtaskids()->Mutable(index);
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const std::string& value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, std::string&& value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, absl::string_view value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::constrainingtaskids() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_constrainingtaskids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_constrainingtaskids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::_internal_constrainingtaskids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.constrainingtaskids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_Infeasibility_Info::_internal_mutable_constrainingtaskids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.constrainingtaskids_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility

// required string taskId = 1;
inline bool SolutionResponse_Infeasibility::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility::taskid() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.Infeasibility.taskId)
}
inline std::string* SolutionResponse_Infeasibility::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Infeasibility.taskId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void SolutionResponse_Infeasibility::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IVR8.SolutionResponse.Infeasibility.taskId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IVR8.SolutionResponse.Infeasibility.taskId)
}

// repeated .IVR8.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
inline int SolutionResponse_Infeasibility::_internal_infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo().size();
}
inline int SolutionResponse_Infeasibility::infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo_size();
}
inline void SolutionResponse_Infeasibility::clear_infeasibilityinfo() {
  _internal_mutable_infeasibilityinfo()->Clear();
}
inline ::IVR8::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::mutable_infeasibilityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_mutable_infeasibilityinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility_Info >*
SolutionResponse_Infeasibility::mutable_infeasibilityinfo() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.Infeasibility.infeasibilityInfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilityinfo();
}
inline const ::IVR8::SolutionResponse_Infeasibility_Info& SolutionResponse_Infeasibility::infeasibilityinfo(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.Infeasibility.infeasibilityInfo)
    return _internal_infeasibilityinfo().Get(index);
}
inline ::IVR8::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::add_infeasibilityinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_Infeasibility_Info* _add = _internal_mutable_infeasibilityinfo()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility_Info >&
SolutionResponse_Infeasibility::infeasibilityinfo() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_infeasibilityinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility_Info>&
SolutionResponse_Infeasibility::_internal_infeasibilityinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilityinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility_Info>*
SolutionResponse_Infeasibility::_internal_mutable_infeasibilityinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilityinfo_;
}

// -------------------------------------------------------------------

// SolutionResponse

// required float objective = 1;
inline bool SolutionResponse::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse::clear_objective() {
  _impl_.objective_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.objective)
  return _internal_objective();
}
inline void SolutionResponse::set_objective(float value) {
  _internal_set_objective(value);
  // @@protoc_insertion_point(field_set:IVR8.SolutionResponse.objective)
}
inline float SolutionResponse::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objective_;
}
inline void SolutionResponse::_internal_set_objective(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.objective_ = value;
}

// repeated .IVR8.SolutionResponse.Route routes = 2;
inline int SolutionResponse::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolutionResponse::routes_size() const {
  return _internal_routes_size();
}
inline void SolutionResponse::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::IVR8::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::IVR8::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.routes)
    return _internal_routes().Get(index);
}
inline ::IVR8::SolutionResponse_Route* SolutionResponse::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_Route* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Route>&
SolutionResponse::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Route>*
SolutionResponse::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// repeated .IVR8.SolutionResponse.Infeasibility infeasibilities = 3;
inline int SolutionResponse::_internal_infeasibilities_size() const {
  return _internal_infeasibilities().size();
}
inline int SolutionResponse::infeasibilities_size() const {
  return _internal_infeasibilities_size();
}
inline void SolutionResponse::clear_infeasibilities() {
  _internal_mutable_infeasibilities()->Clear();
}
inline ::IVR8::SolutionResponse_Infeasibility* SolutionResponse::mutable_infeasibilities(int index) {
  // @@protoc_insertion_point(field_mutable:IVR8.SolutionResponse.infeasibilities)
  return _internal_mutable_infeasibilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility >*
SolutionResponse::mutable_infeasibilities() {
  // @@protoc_insertion_point(field_mutable_list:IVR8.SolutionResponse.infeasibilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilities();
}
inline const ::IVR8::SolutionResponse_Infeasibility& SolutionResponse::infeasibilities(int index) const {
  // @@protoc_insertion_point(field_get:IVR8.SolutionResponse.infeasibilities)
    return _internal_infeasibilities().Get(index);
}
inline ::IVR8::SolutionResponse_Infeasibility* SolutionResponse::add_infeasibilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IVR8::SolutionResponse_Infeasibility* _add = _internal_mutable_infeasibilities()->Add();
  // @@protoc_insertion_point(field_add:IVR8.SolutionResponse.infeasibilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IVR8::SolutionResponse_Infeasibility >&
SolutionResponse::infeasibilities() const {
  // @@protoc_insertion_point(field_list:IVR8.SolutionResponse.infeasibilities)
  return _internal_infeasibilities();
}
inline const ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility>&
SolutionResponse::_internal_infeasibilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilities_;
}
inline ::google::protobuf::RepeatedPtrField<::IVR8::SolutionResponse_Infeasibility>*
SolutionResponse::_internal_mutable_infeasibilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilities_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace IVR8


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::IVR8::InternalDimension_eMeasurementUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IVR8::InternalDimension_eMeasurementUnit>() {
  return ::IVR8::InternalDimension_eMeasurementUnit_descriptor();
}
template <>
struct is_proto_enum<::IVR8::Job_VehicleRelation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IVR8::Job_VehicleRelation_Type>() {
  return ::IVR8::Job_VehicleRelation_Type_descriptor();
}
template <>
struct is_proto_enum<::IVR8::Job_CompartmentRelation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IVR8::Job_CompartmentRelation_Type>() {
  return ::IVR8::Job_CompartmentRelation_Type_descriptor();
}
template <>
struct is_proto_enum<::IVR8::Job_Task_TaskRelation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IVR8::Job_Task_TaskRelation_Type>() {
  return ::IVR8::Job_Task_TaskRelation_Type_descriptor();
}
template <>
struct is_proto_enum<::IVR8::Job_Task_TripConstraint> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IVR8::Job_Task_TripConstraint>() {
  return ::IVR8::Job_Task_TripConstraint_descriptor();
}
template <>
struct is_proto_enum<::IVR8::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IVR8::SolveRequest_SolveType>() {
  return ::IVR8::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ivr8_2dyni1c9k2swof_2eproto_2epb_2eh
