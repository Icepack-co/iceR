// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: isr-z4foi53qznrv.proto

#ifndef PROTOBUF_INCLUDED_isr_2dz4foi53qznrv_2eproto
#define PROTOBUF_INCLUDED_isr_2dz4foi53qznrv_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_isr_2dz4foi53qznrv_2eproto 

namespace protobuf_isr_2dz4foi53qznrv_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_isr_2dz4foi53qznrv_2eproto
namespace ISR {
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class CollectionSequence;
class CollectionSequenceDefaultTypeInternal;
extern CollectionSequenceDefaultTypeInternal _CollectionSequence_default_instance_;
class Configuration;
class ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
class Geocode;
class GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class OffloadSite;
class OffloadSiteDefaultTypeInternal;
extern OffloadSiteDefaultTypeInternal _OffloadSite_default_instance_;
class SolutionResponse;
class SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Infeasibility;
class SolutionResponse_InfeasibilityDefaultTypeInternal;
extern SolutionResponse_InfeasibilityDefaultTypeInternal _SolutionResponse_Infeasibility_default_instance_;
class SolutionResponse_Infeasibility_Info;
class SolutionResponse_Infeasibility_InfoDefaultTypeInternal;
extern SolutionResponse_Infeasibility_InfoDefaultTypeInternal _SolutionResponse_Infeasibility_Info_default_instance_;
class SolutionResponse_InterStop;
class SolutionResponse_InterStopDefaultTypeInternal;
extern SolutionResponse_InterStopDefaultTypeInternal _SolutionResponse_InterStop_default_instance_;
class SolutionResponse_InterStopAttribute;
class SolutionResponse_InterStopAttributeDefaultTypeInternal;
extern SolutionResponse_InterStopAttributeDefaultTypeInternal _SolutionResponse_InterStopAttribute_default_instance_;
class SolutionResponse_Matching;
class SolutionResponse_MatchingDefaultTypeInternal;
extern SolutionResponse_MatchingDefaultTypeInternal _SolutionResponse_Matching_default_instance_;
class SolutionResponse_Route;
class SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolutionResponse_Segment;
class SolutionResponse_SegmentDefaultTypeInternal;
extern SolutionResponse_SegmentDefaultTypeInternal _SolutionResponse_Segment_default_instance_;
class SolutionResponse_Stop;
class SolutionResponse_StopDefaultTypeInternal;
extern SolutionResponse_StopDefaultTypeInternal _SolutionResponse_Stop_default_instance_;
class SolutionResponse_StopAttribute;
class SolutionResponse_StopAttributeDefaultTypeInternal;
extern SolutionResponse_StopAttributeDefaultTypeInternal _SolutionResponse_StopAttribute_default_instance_;
class SolveRequest;
class SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class Vehicle;
class VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace ISR
namespace google {
namespace protobuf {
template<> ::ISR::Collection* Arena::CreateMaybeMessage<::ISR::Collection>(Arena*);
template<> ::ISR::CollectionSequence* Arena::CreateMaybeMessage<::ISR::CollectionSequence>(Arena*);
template<> ::ISR::Configuration* Arena::CreateMaybeMessage<::ISR::Configuration>(Arena*);
template<> ::ISR::Geocode* Arena::CreateMaybeMessage<::ISR::Geocode>(Arena*);
template<> ::ISR::Model* Arena::CreateMaybeMessage<::ISR::Model>(Arena*);
template<> ::ISR::OffloadSite* Arena::CreateMaybeMessage<::ISR::OffloadSite>(Arena*);
template<> ::ISR::SolutionResponse* Arena::CreateMaybeMessage<::ISR::SolutionResponse>(Arena*);
template<> ::ISR::SolutionResponse_Infeasibility* Arena::CreateMaybeMessage<::ISR::SolutionResponse_Infeasibility>(Arena*);
template<> ::ISR::SolutionResponse_Infeasibility_Info* Arena::CreateMaybeMessage<::ISR::SolutionResponse_Infeasibility_Info>(Arena*);
template<> ::ISR::SolutionResponse_InterStop* Arena::CreateMaybeMessage<::ISR::SolutionResponse_InterStop>(Arena*);
template<> ::ISR::SolutionResponse_InterStopAttribute* Arena::CreateMaybeMessage<::ISR::SolutionResponse_InterStopAttribute>(Arena*);
template<> ::ISR::SolutionResponse_Matching* Arena::CreateMaybeMessage<::ISR::SolutionResponse_Matching>(Arena*);
template<> ::ISR::SolutionResponse_Route* Arena::CreateMaybeMessage<::ISR::SolutionResponse_Route>(Arena*);
template<> ::ISR::SolutionResponse_Segment* Arena::CreateMaybeMessage<::ISR::SolutionResponse_Segment>(Arena*);
template<> ::ISR::SolutionResponse_Stop* Arena::CreateMaybeMessage<::ISR::SolutionResponse_Stop>(Arena*);
template<> ::ISR::SolutionResponse_StopAttribute* Arena::CreateMaybeMessage<::ISR::SolutionResponse_StopAttribute>(Arena*);
template<> ::ISR::SolveRequest* Arena::CreateMaybeMessage<::ISR::SolveRequest>(Arena*);
template<> ::ISR::Vehicle* Arena::CreateMaybeMessage<::ISR::Vehicle>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ISR {

enum Configuration_eMeasurementUnit {
  Configuration_eMeasurementUnit_SECONDS = 0,
  Configuration_eMeasurementUnit_MINUTES = 1,
  Configuration_eMeasurementUnit_HOURS = 2,
  Configuration_eMeasurementUnit_DAYS = 3,
  Configuration_eMeasurementUnit_KILOMETRES = 4,
  Configuration_eMeasurementUnit_MILES = 5
};
bool Configuration_eMeasurementUnit_IsValid(int value);
const Configuration_eMeasurementUnit Configuration_eMeasurementUnit_eMeasurementUnit_MIN = Configuration_eMeasurementUnit_SECONDS;
const Configuration_eMeasurementUnit Configuration_eMeasurementUnit_eMeasurementUnit_MAX = Configuration_eMeasurementUnit_MILES;
const int Configuration_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = Configuration_eMeasurementUnit_eMeasurementUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Configuration_eMeasurementUnit_descriptor();
inline const ::std::string& Configuration_eMeasurementUnit_Name(Configuration_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Configuration_eMeasurementUnit_descriptor(), value);
}
inline bool Configuration_eMeasurementUnit_Parse(
    const ::std::string& name, Configuration_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eMeasurementUnit>(
    Configuration_eMeasurementUnit_descriptor(), name, value);
}
enum Configuration_eDrivingSide {
  Configuration_eDrivingSide_LEFT = 0,
  Configuration_eDrivingSide_RIGHT = 1
};
bool Configuration_eDrivingSide_IsValid(int value);
const Configuration_eDrivingSide Configuration_eDrivingSide_eDrivingSide_MIN = Configuration_eDrivingSide_LEFT;
const Configuration_eDrivingSide Configuration_eDrivingSide_eDrivingSide_MAX = Configuration_eDrivingSide_RIGHT;
const int Configuration_eDrivingSide_eDrivingSide_ARRAYSIZE = Configuration_eDrivingSide_eDrivingSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* Configuration_eDrivingSide_descriptor();
inline const ::std::string& Configuration_eDrivingSide_Name(Configuration_eDrivingSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    Configuration_eDrivingSide_descriptor(), value);
}
inline bool Configuration_eDrivingSide_Parse(
    const ::std::string& name, Configuration_eDrivingSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eDrivingSide>(
    Configuration_eDrivingSide_descriptor(), name, value);
}
enum Configuration_eCollectionSide {
  Configuration_eCollectionSide_DRIVINGSIDE_ONLY = 0,
  Configuration_eCollectionSide_BOTH = 1
};
bool Configuration_eCollectionSide_IsValid(int value);
const Configuration_eCollectionSide Configuration_eCollectionSide_eCollectionSide_MIN = Configuration_eCollectionSide_DRIVINGSIDE_ONLY;
const Configuration_eCollectionSide Configuration_eCollectionSide_eCollectionSide_MAX = Configuration_eCollectionSide_BOTH;
const int Configuration_eCollectionSide_eCollectionSide_ARRAYSIZE = Configuration_eCollectionSide_eCollectionSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* Configuration_eCollectionSide_descriptor();
inline const ::std::string& Configuration_eCollectionSide_Name(Configuration_eCollectionSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    Configuration_eCollectionSide_descriptor(), value);
}
inline bool Configuration_eCollectionSide_Parse(
    const ::std::string& name, Configuration_eCollectionSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eCollectionSide>(
    Configuration_eCollectionSide_descriptor(), name, value);
}
enum SolveRequest_SolveType {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
  SolveRequest_SolveType_NetworkMatchings = 3
};
bool SolveRequest_SolveType_IsValid(int value);
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = SolveRequest_SolveType_Optimise;
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = SolveRequest_SolveType_NetworkMatchings;
const int SolveRequest_SolveType_SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor();
inline const ::std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_SolveType_descriptor(), value);
}
inline bool SolveRequest_SolveType_Parse(
    const ::std::string& name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
    SolveRequest_SolveType_descriptor(), name, value);
}
// ===================================================================

class Configuration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Configuration) */ {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(Configuration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Configuration* other);
  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Configuration* New() const final {
    return CreateMaybeMessage<Configuration>(NULL);
  }

  Configuration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Configuration_eMeasurementUnit eMeasurementUnit;
  static const eMeasurementUnit SECONDS =
    Configuration_eMeasurementUnit_SECONDS;
  static const eMeasurementUnit MINUTES =
    Configuration_eMeasurementUnit_MINUTES;
  static const eMeasurementUnit HOURS =
    Configuration_eMeasurementUnit_HOURS;
  static const eMeasurementUnit DAYS =
    Configuration_eMeasurementUnit_DAYS;
  static const eMeasurementUnit KILOMETRES =
    Configuration_eMeasurementUnit_KILOMETRES;
  static const eMeasurementUnit MILES =
    Configuration_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return Configuration_eMeasurementUnit_IsValid(value);
  }
  static const eMeasurementUnit eMeasurementUnit_MIN =
    Configuration_eMeasurementUnit_eMeasurementUnit_MIN;
  static const eMeasurementUnit eMeasurementUnit_MAX =
    Configuration_eMeasurementUnit_eMeasurementUnit_MAX;
  static const int eMeasurementUnit_ARRAYSIZE =
    Configuration_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eMeasurementUnit_descriptor() {
    return Configuration_eMeasurementUnit_descriptor();
  }
  static inline const ::std::string& eMeasurementUnit_Name(eMeasurementUnit value) {
    return Configuration_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(const ::std::string& name,
      eMeasurementUnit* value) {
    return Configuration_eMeasurementUnit_Parse(name, value);
  }

  typedef Configuration_eDrivingSide eDrivingSide;
  static const eDrivingSide LEFT =
    Configuration_eDrivingSide_LEFT;
  static const eDrivingSide RIGHT =
    Configuration_eDrivingSide_RIGHT;
  static inline bool eDrivingSide_IsValid(int value) {
    return Configuration_eDrivingSide_IsValid(value);
  }
  static const eDrivingSide eDrivingSide_MIN =
    Configuration_eDrivingSide_eDrivingSide_MIN;
  static const eDrivingSide eDrivingSide_MAX =
    Configuration_eDrivingSide_eDrivingSide_MAX;
  static const int eDrivingSide_ARRAYSIZE =
    Configuration_eDrivingSide_eDrivingSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eDrivingSide_descriptor() {
    return Configuration_eDrivingSide_descriptor();
  }
  static inline const ::std::string& eDrivingSide_Name(eDrivingSide value) {
    return Configuration_eDrivingSide_Name(value);
  }
  static inline bool eDrivingSide_Parse(const ::std::string& name,
      eDrivingSide* value) {
    return Configuration_eDrivingSide_Parse(name, value);
  }

  typedef Configuration_eCollectionSide eCollectionSide;
  static const eCollectionSide DRIVINGSIDE_ONLY =
    Configuration_eCollectionSide_DRIVINGSIDE_ONLY;
  static const eCollectionSide BOTH =
    Configuration_eCollectionSide_BOTH;
  static inline bool eCollectionSide_IsValid(int value) {
    return Configuration_eCollectionSide_IsValid(value);
  }
  static const eCollectionSide eCollectionSide_MIN =
    Configuration_eCollectionSide_eCollectionSide_MIN;
  static const eCollectionSide eCollectionSide_MAX =
    Configuration_eCollectionSide_eCollectionSide_MAX;
  static const int eCollectionSide_ARRAYSIZE =
    Configuration_eCollectionSide_eCollectionSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCollectionSide_descriptor() {
    return Configuration_eCollectionSide_descriptor();
  }
  static inline const ::std::string& eCollectionSide_Name(eCollectionSide value) {
    return Configuration_eCollectionSide_Name(value);
  }
  static inline bool eCollectionSide_Parse(const ::std::string& name,
      eCollectionSide* value) {
    return Configuration_eCollectionSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ISR.Configuration.eDrivingSide drivingSide = 6;
  bool has_drivingside() const;
  void clear_drivingside();
  static const int kDrivingSideFieldNumber = 6;
  ::ISR::Configuration_eDrivingSide drivingside() const;
  void set_drivingside(::ISR::Configuration_eDrivingSide value);

  // required .ISR.Configuration.eCollectionSide collectionSide = 7;
  bool has_collectionside() const;
  void clear_collectionside();
  static const int kCollectionSideFieldNumber = 7;
  ::ISR::Configuration_eCollectionSide collectionside() const;
  void set_collectionside(::ISR::Configuration_eCollectionSide value);

  // required float distanceCostCoef = 5 [default = 1];
  bool has_distancecostcoef() const;
  void clear_distancecostcoef();
  static const int kDistanceCostCoefFieldNumber = 5;
  float distancecostcoef() const;
  void set_distancecostcoef(float value);

  // required .ISR.Configuration.eMeasurementUnit timeUnit = 1 [default = MINUTES];
  bool has_timeunit() const;
  void clear_timeunit();
  static const int kTimeUnitFieldNumber = 1;
  ::ISR::Configuration_eMeasurementUnit timeunit() const;
  void set_timeunit(::ISR::Configuration_eMeasurementUnit value);

  // required float timeCoef = 2 [default = 1];
  bool has_timecoef() const;
  void clear_timecoef();
  static const int kTimeCoefFieldNumber = 2;
  float timecoef() const;
  void set_timecoef(float value);

  // required float timeCostCoef = 3 [default = 1];
  bool has_timecostcoef() const;
  void clear_timecostcoef();
  static const int kTimeCostCoefFieldNumber = 3;
  float timecostcoef() const;
  void set_timecostcoef(float value);

  // required .ISR.Configuration.eMeasurementUnit distanceUnit = 4 [default = KILOMETRES];
  bool has_distanceunit() const;
  void clear_distanceunit();
  static const int kDistanceUnitFieldNumber = 4;
  ::ISR::Configuration_eMeasurementUnit distanceunit() const;
  void set_distanceunit(::ISR::Configuration_eMeasurementUnit value);

  // @@protoc_insertion_point(class_scope:ISR.Configuration)
 private:
  void set_has_timeunit();
  void clear_has_timeunit();
  void set_has_timecoef();
  void clear_has_timecoef();
  void set_has_timecostcoef();
  void clear_has_timecostcoef();
  void set_has_distanceunit();
  void clear_has_distanceunit();
  void set_has_distancecostcoef();
  void clear_has_distancecostcoef();
  void set_has_drivingside();
  void clear_has_drivingside();
  void set_has_collectionside();
  void clear_has_collectionside();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int drivingside_;
  int collectionside_;
  float distancecostcoef_;
  int timeunit_;
  float timecoef_;
  float timecostcoef_;
  int distanceunit_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geocode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Geocode) */ {
 public:
  Geocode();
  virtual ~Geocode();

  Geocode(const Geocode& from);

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(Geocode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geocode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Geocode* other);
  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geocode* New() const final {
    return CreateMaybeMessage<Geocode>(NULL);
  }

  Geocode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geocode& from);
  void MergeFrom(const Geocode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  float longitude() const;
  void set_longitude(float value);

  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  float latitude() const;
  void set_latitude(float value);

  // @@protoc_insertion_point(class_scope:ISR.Geocode)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float longitude_;
  float latitude_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OffloadSite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.OffloadSite) */ {
 public:
  OffloadSite();
  virtual ~OffloadSite();

  OffloadSite(const OffloadSite& from);

  inline OffloadSite& operator=(const OffloadSite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OffloadSite(OffloadSite&& from) noexcept
    : OffloadSite() {
    *this = ::std::move(from);
  }

  inline OffloadSite& operator=(OffloadSite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffloadSite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OffloadSite* internal_default_instance() {
    return reinterpret_cast<const OffloadSite*>(
               &_OffloadSite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(OffloadSite* other);
  friend void swap(OffloadSite& a, OffloadSite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OffloadSite* New() const final {
    return CreateMaybeMessage<OffloadSite>(NULL);
  }

  OffloadSite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OffloadSite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OffloadSite& from);
  void MergeFrom(const OffloadSite& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OffloadSite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ISR.Geocode location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  private:
  const ::ISR::Geocode& _internal_location() const;
  public:
  const ::ISR::Geocode& location() const;
  ::ISR::Geocode* release_location();
  ::ISR::Geocode* mutable_location();
  void set_allocated_location(::ISR::Geocode* location);

  // required float fixedOffloadTime = 3 [default = 0];
  bool has_fixedoffloadtime() const;
  void clear_fixedoffloadtime();
  static const int kFixedOffloadTimeFieldNumber = 3;
  float fixedoffloadtime() const;
  void set_fixedoffloadtime(float value);

  // required float offloadTimePerQuantity = 4 [default = 0];
  bool has_offloadtimeperquantity() const;
  void clear_offloadtimeperquantity();
  static const int kOffloadTimePerQuantityFieldNumber = 4;
  float offloadtimeperquantity() const;
  void set_offloadtimeperquantity(float value);

  // @@protoc_insertion_point(class_scope:ISR.OffloadSite)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_location();
  void clear_has_location();
  void set_has_fixedoffloadtime();
  void clear_has_fixedoffloadtime();
  void set_has_offloadtimeperquantity();
  void clear_has_offloadtimeperquantity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ISR::Geocode* location_;
  float fixedoffloadtime_;
  float offloadtimeperquantity_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Collection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(Collection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Collection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Collection* other);
  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const final {
    return CreateMaybeMessage<Collection>(NULL);
  }

  Collection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string offloadSiteId = 5;
  bool has_offloadsiteid() const;
  void clear_offloadsiteid();
  static const int kOffloadSiteIdFieldNumber = 5;
  const ::std::string& offloadsiteid() const;
  void set_offloadsiteid(const ::std::string& value);
  #if LANG_CXX11
  void set_offloadsiteid(::std::string&& value);
  #endif
  void set_offloadsiteid(const char* value);
  void set_offloadsiteid(const char* value, size_t size);
  ::std::string* mutable_offloadsiteid();
  ::std::string* release_offloadsiteid();
  void set_allocated_offloadsiteid(::std::string* offloadsiteid);

  // required .ISR.Geocode location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  private:
  const ::ISR::Geocode& _internal_location() const;
  public:
  const ::ISR::Geocode& location() const;
  ::ISR::Geocode* release_location();
  ::ISR::Geocode* mutable_location();
  void set_allocated_location(::ISR::Geocode* location);

  // required float stopTime = 3 [default = 0];
  bool has_stoptime() const;
  void clear_stoptime();
  static const int kStopTimeFieldNumber = 3;
  float stoptime() const;
  void set_stoptime(float value);

  // required float quantity = 4 [default = 0];
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:ISR.Collection)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_location();
  void clear_has_location();
  void set_has_stoptime();
  void clear_has_stoptime();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_offloadsiteid();
  void clear_has_offloadsiteid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr offloadsiteid_;
  ::ISR::Geocode* location_;
  float stoptime_;
  float quantity_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Vehicle) */ {
 public:
  Vehicle();
  virtual ~Vehicle();

  Vehicle(const Vehicle& from);

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Vehicle* other);
  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle* New() const final {
    return CreateMaybeMessage<Vehicle>(NULL);
  }

  Vehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle& from);
  void MergeFrom(const Vehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ISR.Geocode startLocation = 2;
  bool has_startlocation() const;
  void clear_startlocation();
  static const int kStartLocationFieldNumber = 2;
  private:
  const ::ISR::Geocode& _internal_startlocation() const;
  public:
  const ::ISR::Geocode& startlocation() const;
  ::ISR::Geocode* release_startlocation();
  ::ISR::Geocode* mutable_startlocation();
  void set_allocated_startlocation(::ISR::Geocode* startlocation);

  // required .ISR.Geocode endLocation = 3;
  bool has_endlocation() const;
  void clear_endlocation();
  static const int kEndLocationFieldNumber = 3;
  private:
  const ::ISR::Geocode& _internal_endlocation() const;
  public:
  const ::ISR::Geocode& endlocation() const;
  ::ISR::Geocode* release_endlocation();
  ::ISR::Geocode* mutable_endlocation();
  void set_allocated_endlocation(::ISR::Geocode* endlocation);

  // required float startTime = 4;
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 4;
  float starttime() const;
  void set_starttime(float value);

  // required float endTime = 5;
  bool has_endtime() const;
  void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  float endtime() const;
  void set_endtime(float value);

  // required float capacity = 6;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 6;
  float capacity() const;
  void set_capacity(float value);

  // @@protoc_insertion_point(class_scope:ISR.Vehicle)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_startlocation();
  void clear_has_startlocation();
  void set_has_endlocation();
  void clear_has_endlocation();
  void set_has_starttime();
  void clear_has_starttime();
  void set_has_endtime();
  void clear_has_endtime();
  void set_has_capacity();
  void clear_has_capacity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ISR::Geocode* startlocation_;
  ::ISR::Geocode* endlocation_;
  float starttime_;
  float endtime_;
  float capacity_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionSequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.CollectionSequence) */ {
 public:
  CollectionSequence();
  virtual ~CollectionSequence();

  CollectionSequence(const CollectionSequence& from);

  inline CollectionSequence& operator=(const CollectionSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionSequence(CollectionSequence&& from) noexcept
    : CollectionSequence() {
    *this = ::std::move(from);
  }

  inline CollectionSequence& operator=(CollectionSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CollectionSequence* internal_default_instance() {
    return reinterpret_cast<const CollectionSequence*>(
               &_CollectionSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CollectionSequence* other);
  friend void swap(CollectionSequence& a, CollectionSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionSequence* New() const final {
    return CreateMaybeMessage<CollectionSequence>(NULL);
  }

  CollectionSequence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CollectionSequence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CollectionSequence& from);
  void MergeFrom(const CollectionSequence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectionSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string collectionId = 2;
  int collectionid_size() const;
  void clear_collectionid();
  static const int kCollectionIdFieldNumber = 2;
  const ::std::string& collectionid(int index) const;
  ::std::string* mutable_collectionid(int index);
  void set_collectionid(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_collectionid(int index, ::std::string&& value);
  #endif
  void set_collectionid(int index, const char* value);
  void set_collectionid(int index, const char* value, size_t size);
  ::std::string* add_collectionid();
  void add_collectionid(const ::std::string& value);
  #if LANG_CXX11
  void add_collectionid(::std::string&& value);
  #endif
  void add_collectionid(const char* value);
  void add_collectionid(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& collectionid() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_collectionid();

  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid();
  static const int kVehicleIdFieldNumber = 1;
  const ::std::string& vehicleid() const;
  void set_vehicleid(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleid(::std::string&& value);
  #endif
  void set_vehicleid(const char* value);
  void set_vehicleid(const char* value, size_t size);
  ::std::string* mutable_vehicleid();
  ::std::string* release_vehicleid();
  void set_allocated_vehicleid(::std::string* vehicleid);

  // @@protoc_insertion_point(class_scope:ISR.CollectionSequence)
 private:
  void set_has_vehicleid();
  void clear_has_vehicleid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> collectionid_;
  ::google::protobuf::internal::ArenaStringPtr vehicleid_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(NULL);
  }

  Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ISR.Collection collections = 2;
  int collections_size() const;
  void clear_collections();
  static const int kCollectionsFieldNumber = 2;
  ::ISR::Collection* mutable_collections(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Collection >*
      mutable_collections();
  const ::ISR::Collection& collections(int index) const;
  ::ISR::Collection* add_collections();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Collection >&
      collections() const;

  // repeated .ISR.OffloadSite offloadSites = 3;
  int offloadsites_size() const;
  void clear_offloadsites();
  static const int kOffloadSitesFieldNumber = 3;
  ::ISR::OffloadSite* mutable_offloadsites(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >*
      mutable_offloadsites();
  const ::ISR::OffloadSite& offloadsites(int index) const;
  ::ISR::OffloadSite* add_offloadsites();
  const ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >&
      offloadsites() const;

  // repeated .ISR.Vehicle vehicles = 4;
  int vehicles_size() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 4;
  ::ISR::Vehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >*
      mutable_vehicles();
  const ::ISR::Vehicle& vehicles(int index) const;
  ::ISR::Vehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >&
      vehicles() const;

  // repeated .ISR.CollectionSequence collectionSequence = 5;
  int collectionsequence_size() const;
  void clear_collectionsequence();
  static const int kCollectionSequenceFieldNumber = 5;
  ::ISR::CollectionSequence* mutable_collectionsequence(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
      mutable_collectionsequence();
  const ::ISR::CollectionSequence& collectionsequence(int index) const;
  ::ISR::CollectionSequence* add_collectionsequence();
  const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
      collectionsequence() const;

  // required .ISR.Configuration configuration = 1;
  bool has_configuration() const;
  void clear_configuration();
  static const int kConfigurationFieldNumber = 1;
  private:
  const ::ISR::Configuration& _internal_configuration() const;
  public:
  const ::ISR::Configuration& configuration() const;
  ::ISR::Configuration* release_configuration();
  ::ISR::Configuration* mutable_configuration();
  void set_allocated_configuration(::ISR::Configuration* configuration);

  // @@protoc_insertion_point(class_scope:ISR.Model)
 private:
  void set_has_configuration();
  void clear_has_configuration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::Collection > collections_;
  ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite > offloadsites_;
  ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence > collectionsequence_;
  ::ISR::Configuration* configuration_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolveRequest) */ {
 public:
  SolveRequest();
  virtual ~SolveRequest();

  SolveRequest(const SolveRequest& from);

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SolveRequest* other);
  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolveRequest* New() const final {
    return CreateMaybeMessage<SolveRequest>(NULL);
  }

  SolveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolveRequest& from);
  void MergeFrom(const SolveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolveRequest_SolveType SolveType;
  static const SolveType Optimise =
    SolveRequest_SolveType_Optimise;
  static const SolveType Evaluate =
    SolveRequest_SolveType_Evaluate;
  static const SolveType ReOptimise =
    SolveRequest_SolveType_ReOptimise;
  static const SolveType NetworkMatchings =
    SolveRequest_SolveType_NetworkMatchings;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static const SolveType SolveType_MIN =
    SolveRequest_SolveType_SolveType_MIN;
  static const SolveType SolveType_MAX =
    SolveRequest_SolveType_SolveType_MAX;
  static const int SolveType_ARRAYSIZE =
    SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  static inline const ::std::string& SolveType_Name(SolveType value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(const ::std::string& name,
      SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ISR.CollectionSequence routes = 3;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 3;
  ::ISR::CollectionSequence* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
      mutable_routes();
  const ::ISR::CollectionSequence& routes(int index) const;
  ::ISR::CollectionSequence* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
      routes() const;

  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIDFieldNumber = 2;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // optional .ISR.Model model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  private:
  const ::ISR::Model& _internal_model() const;
  public:
  const ::ISR::Model& model() const;
  ::ISR::Model* release_model();
  ::ISR::Model* mutable_model();
  void set_allocated_model(::ISR::Model* model);

  // optional .ISR.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype();
  static const int kSolveTypeFieldNumber = 4;
  ::ISR::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::ISR::SolveRequest_SolveType value);

  // @@protoc_insertion_point(class_scope:ISR.SolveRequest)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_modelid();
  void clear_has_modelid();
  void set_has_solvetype();
  void clear_has_solvetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence > routes_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  ::ISR::Model* model_;
  int solvetype_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_StopAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.StopAttribute) */ {
 public:
  SolutionResponse_StopAttribute();
  virtual ~SolutionResponse_StopAttribute();

  SolutionResponse_StopAttribute(const SolutionResponse_StopAttribute& from);

  inline SolutionResponse_StopAttribute& operator=(const SolutionResponse_StopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_StopAttribute(SolutionResponse_StopAttribute&& from) noexcept
    : SolutionResponse_StopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_StopAttribute& operator=(SolutionResponse_StopAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_StopAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_StopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_StopAttribute*>(
               &_SolutionResponse_StopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SolutionResponse_StopAttribute* other);
  friend void swap(SolutionResponse_StopAttribute& a, SolutionResponse_StopAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_StopAttribute* New() const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(NULL);
  }

  SolutionResponse_StopAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_StopAttribute& from);
  void MergeFrom(const SolutionResponse_StopAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_StopAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 1;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue();
  static const int kStartValueFieldNumber = 2;
  float startvalue() const;
  void set_startvalue(float value);

  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue();
  static const int kEndValueFieldNumber = 3;
  float endvalue() const;
  void set_endvalue(float value);

  // required float cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  float cost() const;
  void set_cost(float value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.StopAttribute)
 private:
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_startvalue();
  void clear_has_startvalue();
  void set_has_endvalue();
  void clear_has_endvalue();
  void set_has_cost();
  void clear_has_cost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  float startvalue_;
  float endvalue_;
  float cost_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_InterStopAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.InterStopAttribute) */ {
 public:
  SolutionResponse_InterStopAttribute();
  virtual ~SolutionResponse_InterStopAttribute();

  SolutionResponse_InterStopAttribute(const SolutionResponse_InterStopAttribute& from);

  inline SolutionResponse_InterStopAttribute& operator=(const SolutionResponse_InterStopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_InterStopAttribute(SolutionResponse_InterStopAttribute&& from) noexcept
    : SolutionResponse_InterStopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStopAttribute& operator=(SolutionResponse_InterStopAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_InterStopAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_InterStopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStopAttribute*>(
               &_SolutionResponse_InterStopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SolutionResponse_InterStopAttribute* other);
  friend void swap(SolutionResponse_InterStopAttribute& a, SolutionResponse_InterStopAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_InterStopAttribute* New() const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(NULL);
  }

  SolutionResponse_InterStopAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_InterStopAttribute& from);
  void MergeFrom(const SolutionResponse_InterStopAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStopAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 1;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue();
  static const int kStartValueFieldNumber = 2;
  float startvalue() const;
  void set_startvalue(float value);

  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue();
  static const int kEndValueFieldNumber = 3;
  float endvalue() const;
  void set_endvalue(float value);

  // required float cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  float cost() const;
  void set_cost(float value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.InterStopAttribute)
 private:
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_startvalue();
  void clear_has_startvalue();
  void set_has_endvalue();
  void clear_has_endvalue();
  void set_has_cost();
  void clear_has_cost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  float startvalue_;
  float endvalue_;
  float cost_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Stop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Stop) */ {
 public:
  SolutionResponse_Stop();
  virtual ~SolutionResponse_Stop();

  SolutionResponse_Stop(const SolutionResponse_Stop& from);

  inline SolutionResponse_Stop& operator=(const SolutionResponse_Stop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Stop(SolutionResponse_Stop&& from) noexcept
    : SolutionResponse_Stop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Stop& operator=(SolutionResponse_Stop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Stop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Stop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Stop*>(
               &_SolutionResponse_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SolutionResponse_Stop* other);
  friend void swap(SolutionResponse_Stop& a, SolutionResponse_Stop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Stop* New() const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(NULL);
  }

  SolutionResponse_Stop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Stop& from);
  void MergeFrom(const SolutionResponse_Stop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Stop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ISR.SolutionResponse.StopAttribute attributes = 5;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  ::ISR::SolutionResponse_StopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >*
      mutable_attributes();
  const ::ISR::SolutionResponse_StopAttribute& attributes(int index) const;
  ::ISR::SolutionResponse_StopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >&
      attributes() const;

  // optional string collectionId = 3;
  bool has_collectionid() const;
  void clear_collectionid();
  static const int kCollectionIdFieldNumber = 3;
  const ::std::string& collectionid() const;
  void set_collectionid(const ::std::string& value);
  #if LANG_CXX11
  void set_collectionid(::std::string&& value);
  #endif
  void set_collectionid(const char* value);
  void set_collectionid(const char* value, size_t size);
  ::std::string* mutable_collectionid();
  ::std::string* release_collectionid();
  void set_allocated_collectionid(::std::string* collectionid);

  // optional string offloadSiteId = 4;
  bool has_offloadsiteid() const;
  void clear_offloadsiteid();
  static const int kOffloadSiteIdFieldNumber = 4;
  const ::std::string& offloadsiteid() const;
  void set_offloadsiteid(const ::std::string& value);
  #if LANG_CXX11
  void set_offloadsiteid(::std::string&& value);
  #endif
  void set_offloadsiteid(const char* value);
  void set_offloadsiteid(const char* value, size_t size);
  ::std::string* mutable_offloadsiteid();
  ::std::string* release_offloadsiteid();
  void set_allocated_offloadsiteid(::std::string* offloadsiteid);

  // required .ISR.Geocode location = 7;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 7;
  private:
  const ::ISR::Geocode& _internal_location() const;
  public:
  const ::ISR::Geocode& location() const;
  ::ISR::Geocode* release_location();
  ::ISR::Geocode* mutable_location();
  void set_allocated_location(::ISR::Geocode* location);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int32 sequence() const;
  void set_sequence(::google::protobuf::int32 value);

  // optional int32 segmentId = 6;
  bool has_segmentid() const;
  void clear_segmentid();
  static const int kSegmentIdFieldNumber = 6;
  ::google::protobuf::int32 segmentid() const;
  void set_segmentid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Stop)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_collectionid();
  void clear_has_collectionid();
  void set_has_offloadsiteid();
  void clear_has_offloadsiteid();
  void set_has_segmentid();
  void clear_has_segmentid();
  void set_has_location();
  void clear_has_location();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr collectionid_;
  ::google::protobuf::internal::ArenaStringPtr offloadsiteid_;
  ::ISR::Geocode* location_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 segmentid_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_InterStop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.InterStop) */ {
 public:
  SolutionResponse_InterStop();
  virtual ~SolutionResponse_InterStop();

  SolutionResponse_InterStop(const SolutionResponse_InterStop& from);

  inline SolutionResponse_InterStop& operator=(const SolutionResponse_InterStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_InterStop(SolutionResponse_InterStop&& from) noexcept
    : SolutionResponse_InterStop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStop& operator=(SolutionResponse_InterStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_InterStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_InterStop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStop*>(
               &_SolutionResponse_InterStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SolutionResponse_InterStop* other);
  friend void swap(SolutionResponse_InterStop& a, SolutionResponse_InterStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_InterStop* New() const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(NULL);
  }

  SolutionResponse_InterStop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_InterStop& from);
  void MergeFrom(const SolutionResponse_InterStop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ISR.SolutionResponse.InterStopAttribute attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::ISR::SolutionResponse_InterStopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >*
      mutable_attributes();
  const ::ISR::SolutionResponse_InterStopAttribute& attributes(int index) const;
  ::ISR::SolutionResponse_InterStopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >&
      attributes() const;

  // repeated .ISR.Geocode geometry = 4;
  int geometry_size() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 4;
  ::ISR::Geocode* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
      mutable_geometry();
  const ::ISR::Geocode& geometry(int index) const;
  ::ISR::Geocode* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
      geometry() const;

  // required int32 fromStopId = 1;
  bool has_fromstopid() const;
  void clear_fromstopid();
  static const int kFromStopIdFieldNumber = 1;
  ::google::protobuf::int32 fromstopid() const;
  void set_fromstopid(::google::protobuf::int32 value);

  // required int32 toStopId = 2;
  bool has_tostopid() const;
  void clear_tostopid();
  static const int kToStopIdFieldNumber = 2;
  ::google::protobuf::int32 tostopid() const;
  void set_tostopid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.InterStop)
 private:
  void set_has_fromstopid();
  void clear_has_fromstopid();
  void set_has_tostopid();
  void clear_has_tostopid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::ISR::Geocode > geometry_;
  ::google::protobuf::int32 fromstopid_;
  ::google::protobuf::int32 tostopid_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Route) */ {
 public:
  SolutionResponse_Route();
  virtual ~SolutionResponse_Route();

  SolutionResponse_Route(const SolutionResponse_Route& from);

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Route& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SolutionResponse_Route* other);
  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Route* New() const final {
    return CreateMaybeMessage<SolutionResponse_Route>(NULL);
  }

  SolutionResponse_Route* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Route& from);
  void MergeFrom(const SolutionResponse_Route& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ISR.SolutionResponse.Stop stops = 2;
  int stops_size() const;
  void clear_stops();
  static const int kStopsFieldNumber = 2;
  ::ISR::SolutionResponse_Stop* mutable_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >*
      mutable_stops();
  const ::ISR::SolutionResponse_Stop& stops(int index) const;
  ::ISR::SolutionResponse_Stop* add_stops();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >&
      stops() const;

  // repeated .ISR.SolutionResponse.InterStop interStops = 3;
  int interstops_size() const;
  void clear_interstops();
  static const int kInterStopsFieldNumber = 3;
  ::ISR::SolutionResponse_InterStop* mutable_interstops(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >*
      mutable_interstops();
  const ::ISR::SolutionResponse_InterStop& interstops(int index) const;
  ::ISR::SolutionResponse_InterStop* add_interstops();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >&
      interstops() const;

  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid();
  static const int kVehicleIdFieldNumber = 1;
  const ::std::string& vehicleid() const;
  void set_vehicleid(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleid(::std::string&& value);
  #endif
  void set_vehicleid(const char* value);
  void set_vehicleid(const char* value, size_t size);
  ::std::string* mutable_vehicleid();
  ::std::string* release_vehicleid();
  void set_allocated_vehicleid(::std::string* vehicleid);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Route)
 private:
  void set_has_vehicleid();
  void clear_has_vehicleid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop > stops_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop > interstops_;
  ::google::protobuf::internal::ArenaStringPtr vehicleid_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Infeasibility_Info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Infeasibility.Info) */ {
 public:
  SolutionResponse_Infeasibility_Info();
  virtual ~SolutionResponse_Infeasibility_Info();

  SolutionResponse_Infeasibility_Info(const SolutionResponse_Infeasibility_Info& from);

  inline SolutionResponse_Infeasibility_Info& operator=(const SolutionResponse_Infeasibility_Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Infeasibility_Info(SolutionResponse_Infeasibility_Info&& from) noexcept
    : SolutionResponse_Infeasibility_Info() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility_Info& operator=(SolutionResponse_Infeasibility_Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Infeasibility_Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Infeasibility_Info* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility_Info*>(
               &_SolutionResponse_Infeasibility_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SolutionResponse_Infeasibility_Info* other);
  friend void swap(SolutionResponse_Infeasibility_Info& a, SolutionResponse_Infeasibility_Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Infeasibility_Info* New() const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(NULL);
  }

  SolutionResponse_Infeasibility_Info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Infeasibility_Info& from);
  void MergeFrom(const SolutionResponse_Infeasibility_Info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility_Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string constrainingCollectionIds = 6;
  int constrainingcollectionids_size() const;
  void clear_constrainingcollectionids();
  static const int kConstrainingCollectionIdsFieldNumber = 6;
  const ::std::string& constrainingcollectionids(int index) const;
  ::std::string* mutable_constrainingcollectionids(int index);
  void set_constrainingcollectionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_constrainingcollectionids(int index, ::std::string&& value);
  #endif
  void set_constrainingcollectionids(int index, const char* value);
  void set_constrainingcollectionids(int index, const char* value, size_t size);
  ::std::string* add_constrainingcollectionids();
  void add_constrainingcollectionids(const ::std::string& value);
  #if LANG_CXX11
  void add_constrainingcollectionids(::std::string&& value);
  #endif
  void add_constrainingcollectionids(const char* value);
  void add_constrainingcollectionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& constrainingcollectionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_constrainingcollectionids();

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string dimId = 2;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 2;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // optional float limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  float limit() const;
  void set_limit(float value);

  // optional float value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  float value() const;
  void set_value(float value);

  // optional int64 count = 5;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 5;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Infeasibility.Info)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_limit();
  void clear_has_limit();
  void set_has_value();
  void clear_has_value();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> constrainingcollectionids_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  float limit_;
  float value_;
  ::google::protobuf::int64 count_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Infeasibility : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Infeasibility) */ {
 public:
  SolutionResponse_Infeasibility();
  virtual ~SolutionResponse_Infeasibility();

  SolutionResponse_Infeasibility(const SolutionResponse_Infeasibility& from);

  inline SolutionResponse_Infeasibility& operator=(const SolutionResponse_Infeasibility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Infeasibility(SolutionResponse_Infeasibility&& from) noexcept
    : SolutionResponse_Infeasibility() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility& operator=(SolutionResponse_Infeasibility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Infeasibility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Infeasibility* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility*>(
               &_SolutionResponse_Infeasibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(SolutionResponse_Infeasibility* other);
  friend void swap(SolutionResponse_Infeasibility& a, SolutionResponse_Infeasibility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Infeasibility* New() const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(NULL);
  }

  SolutionResponse_Infeasibility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Infeasibility& from);
  void MergeFrom(const SolutionResponse_Infeasibility& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Infeasibility_Info Info;

  // accessors -------------------------------------------------------

  // repeated .ISR.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
  int infeasibilityinfo_size() const;
  void clear_infeasibilityinfo();
  static const int kInfeasibilityInfoFieldNumber = 2;
  ::ISR::SolutionResponse_Infeasibility_Info* mutable_infeasibilityinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >*
      mutable_infeasibilityinfo();
  const ::ISR::SolutionResponse_Infeasibility_Info& infeasibilityinfo(int index) const;
  ::ISR::SolutionResponse_Infeasibility_Info* add_infeasibilityinfo();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >&
      infeasibilityinfo() const;

  // required string collectionId = 1;
  bool has_collectionid() const;
  void clear_collectionid();
  static const int kCollectionIdFieldNumber = 1;
  const ::std::string& collectionid() const;
  void set_collectionid(const ::std::string& value);
  #if LANG_CXX11
  void set_collectionid(::std::string&& value);
  #endif
  void set_collectionid(const char* value);
  void set_collectionid(const char* value, size_t size);
  ::std::string* mutable_collectionid();
  ::std::string* release_collectionid();
  void set_allocated_collectionid(::std::string* collectionid);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Infeasibility)
 private:
  void set_has_collectionid();
  void clear_has_collectionid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info > infeasibilityinfo_;
  ::google::protobuf::internal::ArenaStringPtr collectionid_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Matching : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Matching) */ {
 public:
  SolutionResponse_Matching();
  virtual ~SolutionResponse_Matching();

  SolutionResponse_Matching(const SolutionResponse_Matching& from);

  inline SolutionResponse_Matching& operator=(const SolutionResponse_Matching& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Matching(SolutionResponse_Matching&& from) noexcept
    : SolutionResponse_Matching() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Matching& operator=(SolutionResponse_Matching&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Matching& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Matching* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Matching*>(
               &_SolutionResponse_Matching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SolutionResponse_Matching* other);
  friend void swap(SolutionResponse_Matching& a, SolutionResponse_Matching& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Matching* New() const final {
    return CreateMaybeMessage<SolutionResponse_Matching>(NULL);
  }

  SolutionResponse_Matching* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Matching>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Matching& from);
  void MergeFrom(const SolutionResponse_Matching& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Matching* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string collectionId = 1;
  bool has_collectionid() const;
  void clear_collectionid();
  static const int kCollectionIdFieldNumber = 1;
  const ::std::string& collectionid() const;
  void set_collectionid(const ::std::string& value);
  #if LANG_CXX11
  void set_collectionid(::std::string&& value);
  #endif
  void set_collectionid(const char* value);
  void set_collectionid(const char* value, size_t size);
  ::std::string* mutable_collectionid();
  ::std::string* release_collectionid();
  void set_allocated_collectionid(::std::string* collectionid);

  // required .ISR.Geocode collectionPoint = 2;
  bool has_collectionpoint() const;
  void clear_collectionpoint();
  static const int kCollectionPointFieldNumber = 2;
  private:
  const ::ISR::Geocode& _internal_collectionpoint() const;
  public:
  const ::ISR::Geocode& collectionpoint() const;
  ::ISR::Geocode* release_collectionpoint();
  ::ISR::Geocode* mutable_collectionpoint();
  void set_allocated_collectionpoint(::ISR::Geocode* collectionpoint);

  // required int32 segmentId = 3;
  bool has_segmentid() const;
  void clear_segmentid();
  static const int kSegmentIdFieldNumber = 3;
  ::google::protobuf::int32 segmentid() const;
  void set_segmentid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Matching)
 private:
  void set_has_collectionid();
  void clear_has_collectionid();
  void set_has_collectionpoint();
  void clear_has_collectionpoint();
  void set_has_segmentid();
  void clear_has_segmentid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr collectionid_;
  ::ISR::Geocode* collectionpoint_;
  ::google::protobuf::int32 segmentid_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Segment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Segment) */ {
 public:
  SolutionResponse_Segment();
  virtual ~SolutionResponse_Segment();

  SolutionResponse_Segment(const SolutionResponse_Segment& from);

  inline SolutionResponse_Segment& operator=(const SolutionResponse_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Segment(SolutionResponse_Segment&& from) noexcept
    : SolutionResponse_Segment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Segment& operator=(SolutionResponse_Segment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Segment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Segment*>(
               &_SolutionResponse_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SolutionResponse_Segment* other);
  friend void swap(SolutionResponse_Segment& a, SolutionResponse_Segment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Segment* New() const final {
    return CreateMaybeMessage<SolutionResponse_Segment>(NULL);
  }

  SolutionResponse_Segment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Segment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Segment& from);
  void MergeFrom(const SolutionResponse_Segment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Segment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ISR.Geocode geometry = 5;
  int geometry_size() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 5;
  ::ISR::Geocode* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
      mutable_geometry();
  const ::ISR::Geocode& geometry(int index) const;
  ::ISR::Geocode* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
      geometry() const;

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required float weight = 3;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 3;
  float weight() const;
  void set_weight(float value);

  // required float duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Segment)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_weight();
  void clear_has_weight();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::Geocode > geometry_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  float weight_;
  float duration_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse) */ {
 public:
  SolutionResponse();
  virtual ~SolutionResponse();

  SolutionResponse(const SolutionResponse& from);

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(SolutionResponse* other);
  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse* New() const final {
    return CreateMaybeMessage<SolutionResponse>(NULL);
  }

  SolutionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse& from);
  void MergeFrom(const SolutionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_StopAttribute StopAttribute;
  typedef SolutionResponse_InterStopAttribute InterStopAttribute;
  typedef SolutionResponse_Stop Stop;
  typedef SolutionResponse_InterStop InterStop;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_Infeasibility Infeasibility;
  typedef SolutionResponse_Matching Matching;
  typedef SolutionResponse_Segment Segment;

  // accessors -------------------------------------------------------

  // repeated .ISR.SolutionResponse.Route routes = 2;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 2;
  ::ISR::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >*
      mutable_routes();
  const ::ISR::SolutionResponse_Route& routes(int index) const;
  ::ISR::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >&
      routes() const;

  // repeated .ISR.SolutionResponse.Infeasibility infeasibilities = 3;
  int infeasibilities_size() const;
  void clear_infeasibilities();
  static const int kInfeasibilitiesFieldNumber = 3;
  ::ISR::SolutionResponse_Infeasibility* mutable_infeasibilities(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >*
      mutable_infeasibilities();
  const ::ISR::SolutionResponse_Infeasibility& infeasibilities(int index) const;
  ::ISR::SolutionResponse_Infeasibility* add_infeasibilities();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >&
      infeasibilities() const;

  // repeated .ISR.SolutionResponse.Matching matchings = 4;
  int matchings_size() const;
  void clear_matchings();
  static const int kMatchingsFieldNumber = 4;
  ::ISR::SolutionResponse_Matching* mutable_matchings(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >*
      mutable_matchings();
  const ::ISR::SolutionResponse_Matching& matchings(int index) const;
  ::ISR::SolutionResponse_Matching* add_matchings();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >&
      matchings() const;

  // repeated .ISR.SolutionResponse.Segment segments = 5;
  int segments_size() const;
  void clear_segments();
  static const int kSegmentsFieldNumber = 5;
  ::ISR::SolutionResponse_Segment* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >*
      mutable_segments();
  const ::ISR::SolutionResponse_Segment& segments(int index) const;
  ::ISR::SolutionResponse_Segment* add_segments();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >&
      segments() const;

  // required float objective = 1;
  bool has_objective() const;
  void clear_objective();
  static const int kObjectiveFieldNumber = 1;
  float objective() const;
  void set_objective(float value);

  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse)
 private:
  void set_has_objective();
  void clear_has_objective();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route > routes_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility > infeasibilities_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching > matchings_;
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment > segments_;
  float objective_;
  friend struct ::protobuf_isr_2dz4foi53qznrv_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Configuration

// required .ISR.Configuration.eMeasurementUnit timeUnit = 1 [default = MINUTES];
inline bool Configuration::has_timeunit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_timeunit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_timeunit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_timeunit() {
  timeunit_ = 1;
  clear_has_timeunit();
}
inline ::ISR::Configuration_eMeasurementUnit Configuration::timeunit() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.timeUnit)
  return static_cast< ::ISR::Configuration_eMeasurementUnit >(timeunit_);
}
inline void Configuration::set_timeunit(::ISR::Configuration_eMeasurementUnit value) {
  assert(::ISR::Configuration_eMeasurementUnit_IsValid(value));
  set_has_timeunit();
  timeunit_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.timeUnit)
}

// required float timeCoef = 2 [default = 1];
inline bool Configuration::has_timecoef() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_timecoef() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_timecoef() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_timecoef() {
  timecoef_ = 1;
  clear_has_timecoef();
}
inline float Configuration::timecoef() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.timeCoef)
  return timecoef_;
}
inline void Configuration::set_timecoef(float value) {
  set_has_timecoef();
  timecoef_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.timeCoef)
}

// required float timeCostCoef = 3 [default = 1];
inline bool Configuration::has_timecostcoef() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Configuration::set_has_timecostcoef() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Configuration::clear_has_timecostcoef() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Configuration::clear_timecostcoef() {
  timecostcoef_ = 1;
  clear_has_timecostcoef();
}
inline float Configuration::timecostcoef() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.timeCostCoef)
  return timecostcoef_;
}
inline void Configuration::set_timecostcoef(float value) {
  set_has_timecostcoef();
  timecostcoef_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.timeCostCoef)
}

// required .ISR.Configuration.eMeasurementUnit distanceUnit = 4 [default = KILOMETRES];
inline bool Configuration::has_distanceunit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Configuration::set_has_distanceunit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Configuration::clear_has_distanceunit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Configuration::clear_distanceunit() {
  distanceunit_ = 4;
  clear_has_distanceunit();
}
inline ::ISR::Configuration_eMeasurementUnit Configuration::distanceunit() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.distanceUnit)
  return static_cast< ::ISR::Configuration_eMeasurementUnit >(distanceunit_);
}
inline void Configuration::set_distanceunit(::ISR::Configuration_eMeasurementUnit value) {
  assert(::ISR::Configuration_eMeasurementUnit_IsValid(value));
  set_has_distanceunit();
  distanceunit_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.distanceUnit)
}

// required float distanceCostCoef = 5 [default = 1];
inline bool Configuration::has_distancecostcoef() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_distancecostcoef() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_distancecostcoef() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_distancecostcoef() {
  distancecostcoef_ = 1;
  clear_has_distancecostcoef();
}
inline float Configuration::distancecostcoef() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.distanceCostCoef)
  return distancecostcoef_;
}
inline void Configuration::set_distancecostcoef(float value) {
  set_has_distancecostcoef();
  distancecostcoef_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.distanceCostCoef)
}

// required .ISR.Configuration.eDrivingSide drivingSide = 6;
inline bool Configuration::has_drivingside() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_drivingside() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_drivingside() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_drivingside() {
  drivingside_ = 0;
  clear_has_drivingside();
}
inline ::ISR::Configuration_eDrivingSide Configuration::drivingside() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.drivingSide)
  return static_cast< ::ISR::Configuration_eDrivingSide >(drivingside_);
}
inline void Configuration::set_drivingside(::ISR::Configuration_eDrivingSide value) {
  assert(::ISR::Configuration_eDrivingSide_IsValid(value));
  set_has_drivingside();
  drivingside_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.drivingSide)
}

// required .ISR.Configuration.eCollectionSide collectionSide = 7;
inline bool Configuration::has_collectionside() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_collectionside() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_collectionside() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_collectionside() {
  collectionside_ = 0;
  clear_has_collectionside();
}
inline ::ISR::Configuration_eCollectionSide Configuration::collectionside() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.collectionSide)
  return static_cast< ::ISR::Configuration_eCollectionSide >(collectionside_);
}
inline void Configuration::set_collectionside(::ISR::Configuration_eCollectionSide value) {
  assert(::ISR::Configuration_eCollectionSide_IsValid(value));
  set_has_collectionside();
  collectionside_ = value;
  // @@protoc_insertion_point(field_set:ISR.Configuration.collectionSide)
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geocode::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geocode::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geocode::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:ISR.Geocode.longitude)
  return longitude_;
}
inline void Geocode::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ISR.Geocode.longitude)
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geocode::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geocode::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geocode::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:ISR.Geocode.latitude)
  return latitude_;
}
inline void Geocode::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ISR.Geocode.latitude)
}

// -------------------------------------------------------------------

// OffloadSite

// required string id = 1;
inline bool OffloadSite::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OffloadSite::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OffloadSite::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OffloadSite::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& OffloadSite::id() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.id)
  return id_.GetNoArena();
}
inline void OffloadSite::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.OffloadSite.id)
}
#if LANG_CXX11
inline void OffloadSite::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.OffloadSite.id)
}
#endif
inline void OffloadSite::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.OffloadSite.id)
}
inline void OffloadSite::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.OffloadSite.id)
}
inline ::std::string* OffloadSite::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ISR.OffloadSite.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OffloadSite::release_id() {
  // @@protoc_insertion_point(field_release:ISR.OffloadSite.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OffloadSite::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ISR.OffloadSite.id)
}

// required .ISR.Geocode location = 2;
inline bool OffloadSite::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OffloadSite::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OffloadSite::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OffloadSite::clear_location() {
  if (location_ != NULL) location_->Clear();
  clear_has_location();
}
inline const ::ISR::Geocode& OffloadSite::_internal_location() const {
  return *location_;
}
inline const ::ISR::Geocode& OffloadSite::location() const {
  const ::ISR::Geocode* p = location_;
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.location)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Geocode*>(
      &::ISR::_Geocode_default_instance_);
}
inline ::ISR::Geocode* OffloadSite::release_location() {
  // @@protoc_insertion_point(field_release:ISR.OffloadSite.location)
  clear_has_location();
  ::ISR::Geocode* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::ISR::Geocode* OffloadSite::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.OffloadSite.location)
  return location_;
}
inline void OffloadSite::set_allocated_location(::ISR::Geocode* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ISR.OffloadSite.location)
}

// required float fixedOffloadTime = 3 [default = 0];
inline bool OffloadSite::has_fixedoffloadtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OffloadSite::set_has_fixedoffloadtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OffloadSite::clear_has_fixedoffloadtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OffloadSite::clear_fixedoffloadtime() {
  fixedoffloadtime_ = 0;
  clear_has_fixedoffloadtime();
}
inline float OffloadSite::fixedoffloadtime() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.fixedOffloadTime)
  return fixedoffloadtime_;
}
inline void OffloadSite::set_fixedoffloadtime(float value) {
  set_has_fixedoffloadtime();
  fixedoffloadtime_ = value;
  // @@protoc_insertion_point(field_set:ISR.OffloadSite.fixedOffloadTime)
}

// required float offloadTimePerQuantity = 4 [default = 0];
inline bool OffloadSite::has_offloadtimeperquantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OffloadSite::set_has_offloadtimeperquantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OffloadSite::clear_has_offloadtimeperquantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OffloadSite::clear_offloadtimeperquantity() {
  offloadtimeperquantity_ = 0;
  clear_has_offloadtimeperquantity();
}
inline float OffloadSite::offloadtimeperquantity() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.offloadTimePerQuantity)
  return offloadtimeperquantity_;
}
inline void OffloadSite::set_offloadtimeperquantity(float value) {
  set_has_offloadtimeperquantity();
  offloadtimeperquantity_ = value;
  // @@protoc_insertion_point(field_set:ISR.OffloadSite.offloadTimePerQuantity)
}

// -------------------------------------------------------------------

// Collection

// required string id = 1;
inline bool Collection::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Collection::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Collection::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Collection::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Collection::id() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.id)
  return id_.GetNoArena();
}
inline void Collection::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.Collection.id)
}
#if LANG_CXX11
inline void Collection::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.Collection.id)
}
#endif
inline void Collection::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.Collection.id)
}
inline void Collection::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.Collection.id)
}
inline ::std::string* Collection::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ISR.Collection.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Collection::release_id() {
  // @@protoc_insertion_point(field_release:ISR.Collection.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ISR.Collection.id)
}

// required .ISR.Geocode location = 2;
inline bool Collection::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Collection::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Collection::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Collection::clear_location() {
  if (location_ != NULL) location_->Clear();
  clear_has_location();
}
inline const ::ISR::Geocode& Collection::_internal_location() const {
  return *location_;
}
inline const ::ISR::Geocode& Collection::location() const {
  const ::ISR::Geocode* p = location_;
  // @@protoc_insertion_point(field_get:ISR.Collection.location)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Geocode*>(
      &::ISR::_Geocode_default_instance_);
}
inline ::ISR::Geocode* Collection::release_location() {
  // @@protoc_insertion_point(field_release:ISR.Collection.location)
  clear_has_location();
  ::ISR::Geocode* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::ISR::Geocode* Collection::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.Collection.location)
  return location_;
}
inline void Collection::set_allocated_location(::ISR::Geocode* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ISR.Collection.location)
}

// required float stopTime = 3 [default = 0];
inline bool Collection::has_stoptime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Collection::set_has_stoptime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Collection::clear_has_stoptime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Collection::clear_stoptime() {
  stoptime_ = 0;
  clear_has_stoptime();
}
inline float Collection::stoptime() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.stopTime)
  return stoptime_;
}
inline void Collection::set_stoptime(float value) {
  set_has_stoptime();
  stoptime_ = value;
  // @@protoc_insertion_point(field_set:ISR.Collection.stopTime)
}

// required float quantity = 4 [default = 0];
inline bool Collection::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Collection::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Collection::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Collection::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float Collection::quantity() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.quantity)
  return quantity_;
}
inline void Collection::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:ISR.Collection.quantity)
}

// required string offloadSiteId = 5;
inline bool Collection::has_offloadsiteid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Collection::set_has_offloadsiteid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Collection::clear_has_offloadsiteid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Collection::clear_offloadsiteid() {
  offloadsiteid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_offloadsiteid();
}
inline const ::std::string& Collection::offloadsiteid() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.offloadSiteId)
  return offloadsiteid_.GetNoArena();
}
inline void Collection::set_offloadsiteid(const ::std::string& value) {
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.Collection.offloadSiteId)
}
#if LANG_CXX11
inline void Collection::set_offloadsiteid(::std::string&& value) {
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.Collection.offloadSiteId)
}
#endif
inline void Collection::set_offloadsiteid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.Collection.offloadSiteId)
}
inline void Collection::set_offloadsiteid(const char* value, size_t size) {
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.Collection.offloadSiteId)
}
inline ::std::string* Collection::mutable_offloadsiteid() {
  set_has_offloadsiteid();
  // @@protoc_insertion_point(field_mutable:ISR.Collection.offloadSiteId)
  return offloadsiteid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Collection::release_offloadsiteid() {
  // @@protoc_insertion_point(field_release:ISR.Collection.offloadSiteId)
  if (!has_offloadsiteid()) {
    return NULL;
  }
  clear_has_offloadsiteid();
  return offloadsiteid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_offloadsiteid(::std::string* offloadsiteid) {
  if (offloadsiteid != NULL) {
    set_has_offloadsiteid();
  } else {
    clear_has_offloadsiteid();
  }
  offloadsiteid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), offloadsiteid);
  // @@protoc_insertion_point(field_set_allocated:ISR.Collection.offloadSiteId)
}

// -------------------------------------------------------------------

// Vehicle

// required string id = 1;
inline bool Vehicle::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Vehicle::id() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.id)
  return id_.GetNoArena();
}
inline void Vehicle::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.Vehicle.id)
}
#if LANG_CXX11
inline void Vehicle::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.Vehicle.id)
}
#endif
inline void Vehicle::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.Vehicle.id)
}
inline void Vehicle::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.Vehicle.id)
}
inline ::std::string* Vehicle::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ISR.Vehicle.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle::release_id() {
  // @@protoc_insertion_point(field_release:ISR.Vehicle.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ISR.Vehicle.id)
}

// required .ISR.Geocode startLocation = 2;
inline bool Vehicle::has_startlocation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle::set_has_startlocation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle::clear_has_startlocation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle::clear_startlocation() {
  if (startlocation_ != NULL) startlocation_->Clear();
  clear_has_startlocation();
}
inline const ::ISR::Geocode& Vehicle::_internal_startlocation() const {
  return *startlocation_;
}
inline const ::ISR::Geocode& Vehicle::startlocation() const {
  const ::ISR::Geocode* p = startlocation_;
  // @@protoc_insertion_point(field_get:ISR.Vehicle.startLocation)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Geocode*>(
      &::ISR::_Geocode_default_instance_);
}
inline ::ISR::Geocode* Vehicle::release_startlocation() {
  // @@protoc_insertion_point(field_release:ISR.Vehicle.startLocation)
  clear_has_startlocation();
  ::ISR::Geocode* temp = startlocation_;
  startlocation_ = NULL;
  return temp;
}
inline ::ISR::Geocode* Vehicle::mutable_startlocation() {
  set_has_startlocation();
  if (startlocation_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaNoVirtual());
    startlocation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.Vehicle.startLocation)
  return startlocation_;
}
inline void Vehicle::set_allocated_startlocation(::ISR::Geocode* startlocation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete startlocation_;
  }
  if (startlocation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      startlocation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, startlocation, submessage_arena);
    }
    set_has_startlocation();
  } else {
    clear_has_startlocation();
  }
  startlocation_ = startlocation;
  // @@protoc_insertion_point(field_set_allocated:ISR.Vehicle.startLocation)
}

// required .ISR.Geocode endLocation = 3;
inline bool Vehicle::has_endlocation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vehicle::set_has_endlocation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vehicle::clear_has_endlocation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vehicle::clear_endlocation() {
  if (endlocation_ != NULL) endlocation_->Clear();
  clear_has_endlocation();
}
inline const ::ISR::Geocode& Vehicle::_internal_endlocation() const {
  return *endlocation_;
}
inline const ::ISR::Geocode& Vehicle::endlocation() const {
  const ::ISR::Geocode* p = endlocation_;
  // @@protoc_insertion_point(field_get:ISR.Vehicle.endLocation)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Geocode*>(
      &::ISR::_Geocode_default_instance_);
}
inline ::ISR::Geocode* Vehicle::release_endlocation() {
  // @@protoc_insertion_point(field_release:ISR.Vehicle.endLocation)
  clear_has_endlocation();
  ::ISR::Geocode* temp = endlocation_;
  endlocation_ = NULL;
  return temp;
}
inline ::ISR::Geocode* Vehicle::mutable_endlocation() {
  set_has_endlocation();
  if (endlocation_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaNoVirtual());
    endlocation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.Vehicle.endLocation)
  return endlocation_;
}
inline void Vehicle::set_allocated_endlocation(::ISR::Geocode* endlocation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete endlocation_;
  }
  if (endlocation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      endlocation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endlocation, submessage_arena);
    }
    set_has_endlocation();
  } else {
    clear_has_endlocation();
  }
  endlocation_ = endlocation;
  // @@protoc_insertion_point(field_set_allocated:ISR.Vehicle.endLocation)
}

// required float startTime = 4;
inline bool Vehicle::has_starttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vehicle::set_has_starttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vehicle::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vehicle::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float Vehicle::starttime() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.startTime)
  return starttime_;
}
inline void Vehicle::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:ISR.Vehicle.startTime)
}

// required float endTime = 5;
inline bool Vehicle::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vehicle::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vehicle::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vehicle::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline float Vehicle::endtime() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.endTime)
  return endtime_;
}
inline void Vehicle::set_endtime(float value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:ISR.Vehicle.endTime)
}

// required float capacity = 6;
inline bool Vehicle::has_capacity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vehicle::set_has_capacity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vehicle::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vehicle::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline float Vehicle::capacity() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.capacity)
  return capacity_;
}
inline void Vehicle::set_capacity(float value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:ISR.Vehicle.capacity)
}

// -------------------------------------------------------------------

// CollectionSequence

// required string vehicleId = 1;
inline bool CollectionSequence::has_vehicleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectionSequence::set_has_vehicleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectionSequence::clear_has_vehicleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectionSequence::clear_vehicleid() {
  vehicleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicleid();
}
inline const ::std::string& CollectionSequence::vehicleid() const {
  // @@protoc_insertion_point(field_get:ISR.CollectionSequence.vehicleId)
  return vehicleid_.GetNoArena();
}
inline void CollectionSequence::set_vehicleid(const ::std::string& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.CollectionSequence.vehicleId)
}
#if LANG_CXX11
inline void CollectionSequence::set_vehicleid(::std::string&& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.CollectionSequence.vehicleId)
}
#endif
inline void CollectionSequence::set_vehicleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.CollectionSequence.vehicleId)
}
inline void CollectionSequence::set_vehicleid(const char* value, size_t size) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.CollectionSequence.vehicleId)
}
inline ::std::string* CollectionSequence::mutable_vehicleid() {
  set_has_vehicleid();
  // @@protoc_insertion_point(field_mutable:ISR.CollectionSequence.vehicleId)
  return vehicleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CollectionSequence::release_vehicleid() {
  // @@protoc_insertion_point(field_release:ISR.CollectionSequence.vehicleId)
  if (!has_vehicleid()) {
    return NULL;
  }
  clear_has_vehicleid();
  return vehicleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CollectionSequence::set_allocated_vehicleid(::std::string* vehicleid) {
  if (vehicleid != NULL) {
    set_has_vehicleid();
  } else {
    clear_has_vehicleid();
  }
  vehicleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicleid);
  // @@protoc_insertion_point(field_set_allocated:ISR.CollectionSequence.vehicleId)
}

// repeated string collectionId = 2;
inline int CollectionSequence::collectionid_size() const {
  return collectionid_.size();
}
inline void CollectionSequence::clear_collectionid() {
  collectionid_.Clear();
}
inline const ::std::string& CollectionSequence::collectionid(int index) const {
  // @@protoc_insertion_point(field_get:ISR.CollectionSequence.collectionId)
  return collectionid_.Get(index);
}
inline ::std::string* CollectionSequence::mutable_collectionid(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.CollectionSequence.collectionId)
  return collectionid_.Mutable(index);
}
inline void CollectionSequence::set_collectionid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ISR.CollectionSequence.collectionId)
  collectionid_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CollectionSequence::set_collectionid(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ISR.CollectionSequence.collectionId)
  collectionid_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CollectionSequence::set_collectionid(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  collectionid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::set_collectionid(int index, const char* value, size_t size) {
  collectionid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ISR.CollectionSequence.collectionId)
}
inline ::std::string* CollectionSequence::add_collectionid() {
  // @@protoc_insertion_point(field_add_mutable:ISR.CollectionSequence.collectionId)
  return collectionid_.Add();
}
inline void CollectionSequence::add_collectionid(const ::std::string& value) {
  collectionid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ISR.CollectionSequence.collectionId)
}
#if LANG_CXX11
inline void CollectionSequence::add_collectionid(::std::string&& value) {
  collectionid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ISR.CollectionSequence.collectionId)
}
#endif
inline void CollectionSequence::add_collectionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  collectionid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::add_collectionid(const char* value, size_t size) {
  collectionid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ISR.CollectionSequence.collectionId)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollectionSequence::collectionid() const {
  // @@protoc_insertion_point(field_list:ISR.CollectionSequence.collectionId)
  return collectionid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollectionSequence::mutable_collectionid() {
  // @@protoc_insertion_point(field_mutable_list:ISR.CollectionSequence.collectionId)
  return &collectionid_;
}

// -------------------------------------------------------------------

// Model

// required .ISR.Configuration configuration = 1;
inline bool Model::has_configuration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_configuration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_configuration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_configuration() {
  if (configuration_ != NULL) configuration_->Clear();
  clear_has_configuration();
}
inline const ::ISR::Configuration& Model::_internal_configuration() const {
  return *configuration_;
}
inline const ::ISR::Configuration& Model::configuration() const {
  const ::ISR::Configuration* p = configuration_;
  // @@protoc_insertion_point(field_get:ISR.Model.configuration)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Configuration*>(
      &::ISR::_Configuration_default_instance_);
}
inline ::ISR::Configuration* Model::release_configuration() {
  // @@protoc_insertion_point(field_release:ISR.Model.configuration)
  clear_has_configuration();
  ::ISR::Configuration* temp = configuration_;
  configuration_ = NULL;
  return temp;
}
inline ::ISR::Configuration* Model::mutable_configuration() {
  set_has_configuration();
  if (configuration_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Configuration>(GetArenaNoVirtual());
    configuration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.Model.configuration)
  return configuration_;
}
inline void Model::set_allocated_configuration(::ISR::Configuration* configuration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete configuration_;
  }
  if (configuration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      configuration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    set_has_configuration();
  } else {
    clear_has_configuration();
  }
  configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:ISR.Model.configuration)
}

// repeated .ISR.Collection collections = 2;
inline int Model::collections_size() const {
  return collections_.size();
}
inline void Model::clear_collections() {
  collections_.Clear();
}
inline ::ISR::Collection* Model::mutable_collections(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.collections)
  return collections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Collection >*
Model::mutable_collections() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.collections)
  return &collections_;
}
inline const ::ISR::Collection& Model::collections(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.collections)
  return collections_.Get(index);
}
inline ::ISR::Collection* Model::add_collections() {
  // @@protoc_insertion_point(field_add:ISR.Model.collections)
  return collections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Collection >&
Model::collections() const {
  // @@protoc_insertion_point(field_list:ISR.Model.collections)
  return collections_;
}

// repeated .ISR.OffloadSite offloadSites = 3;
inline int Model::offloadsites_size() const {
  return offloadsites_.size();
}
inline void Model::clear_offloadsites() {
  offloadsites_.Clear();
}
inline ::ISR::OffloadSite* Model::mutable_offloadsites(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.offloadSites)
  return offloadsites_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >*
Model::mutable_offloadsites() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.offloadSites)
  return &offloadsites_;
}
inline const ::ISR::OffloadSite& Model::offloadsites(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.offloadSites)
  return offloadsites_.Get(index);
}
inline ::ISR::OffloadSite* Model::add_offloadsites() {
  // @@protoc_insertion_point(field_add:ISR.Model.offloadSites)
  return offloadsites_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >&
Model::offloadsites() const {
  // @@protoc_insertion_point(field_list:ISR.Model.offloadSites)
  return offloadsites_;
}

// repeated .ISR.Vehicle vehicles = 4;
inline int Model::vehicles_size() const {
  return vehicles_.size();
}
inline void Model::clear_vehicles() {
  vehicles_.Clear();
}
inline ::ISR::Vehicle* Model::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.vehicles)
  return vehicles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >*
Model::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.vehicles)
  return &vehicles_;
}
inline const ::ISR::Vehicle& Model::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.vehicles)
  return vehicles_.Get(index);
}
inline ::ISR::Vehicle* Model::add_vehicles() {
  // @@protoc_insertion_point(field_add:ISR.Model.vehicles)
  return vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >&
Model::vehicles() const {
  // @@protoc_insertion_point(field_list:ISR.Model.vehicles)
  return vehicles_;
}

// repeated .ISR.CollectionSequence collectionSequence = 5;
inline int Model::collectionsequence_size() const {
  return collectionsequence_.size();
}
inline void Model::clear_collectionsequence() {
  collectionsequence_.Clear();
}
inline ::ISR::CollectionSequence* Model::mutable_collectionsequence(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.collectionSequence)
  return collectionsequence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
Model::mutable_collectionsequence() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.collectionSequence)
  return &collectionsequence_;
}
inline const ::ISR::CollectionSequence& Model::collectionsequence(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.collectionSequence)
  return collectionsequence_.Get(index);
}
inline ::ISR::CollectionSequence* Model::add_collectionsequence() {
  // @@protoc_insertion_point(field_add:ISR.Model.collectionSequence)
  return collectionsequence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
Model::collectionsequence() const {
  // @@protoc_insertion_point(field_list:ISR.Model.collectionSequence)
  return collectionsequence_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .ISR.Model model = 1;
inline bool SolveRequest::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolveRequest::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolveRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolveRequest::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::ISR::Model& SolveRequest::_internal_model() const {
  return *model_;
}
inline const ::ISR::Model& SolveRequest::model() const {
  const ::ISR::Model* p = model_;
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.model)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Model*>(
      &::ISR::_Model_default_instance_);
}
inline ::ISR::Model* SolveRequest::release_model() {
  // @@protoc_insertion_point(field_release:ISR.SolveRequest.model)
  clear_has_model();
  ::ISR::Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::ISR::Model* SolveRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.SolveRequest.model)
  return model_;
}
inline void SolveRequest::set_allocated_model(::ISR::Model* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:ISR.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolveRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolveRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolveRequest::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.modelID)
  return modelid_.GetNoArena();
}
inline void SolveRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolveRequest.modelID)
}
#if LANG_CXX11
inline void SolveRequest::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolveRequest.modelID)
}
#endif
inline void SolveRequest::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolveRequest.modelID)
}
inline void SolveRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolveRequest.modelID)
}
inline ::std::string* SolveRequest::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:ISR.SolveRequest.modelID)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolveRequest::release_modelid() {
  // @@protoc_insertion_point(field_release:ISR.SolveRequest.modelID)
  if (!has_modelid()) {
    return NULL;
  }
  clear_has_modelid();
  return modelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolveRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolveRequest.modelID)
}

// repeated .ISR.CollectionSequence routes = 3;
inline int SolveRequest::routes_size() const {
  return routes_.size();
}
inline void SolveRequest::clear_routes() {
  routes_.Clear();
}
inline ::ISR::CollectionSequence* SolveRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolveRequest.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
SolveRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolveRequest.routes)
  return &routes_;
}
inline const ::ISR::CollectionSequence& SolveRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.routes)
  return routes_.Get(index);
}
inline ::ISR::CollectionSequence* SolveRequest::add_routes() {
  // @@protoc_insertion_point(field_add:ISR.SolveRequest.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
SolveRequest::routes() const {
  // @@protoc_insertion_point(field_list:ISR.SolveRequest.routes)
  return routes_;
}

// optional .ISR.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolveRequest::set_has_solvetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolveRequest::clear_has_solvetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolveRequest::clear_solvetype() {
  solvetype_ = 0;
  clear_has_solvetype();
}
inline ::ISR::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.solveType)
  return static_cast< ::ISR::SolveRequest_SolveType >(solvetype_);
}
inline void SolveRequest::set_solvetype(::ISR::SolveRequest_SolveType value) {
  assert(::ISR::SolveRequest_SolveType_IsValid(value));
  set_has_solvetype();
  solvetype_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolveRequest.solveType)
}

// -------------------------------------------------------------------

// SolutionResponse_StopAttribute

// required string dimId = 1;
inline bool SolutionResponse_StopAttribute::has_dimid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_dimid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_StopAttribute::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_StopAttribute::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_StopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_StopAttribute::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_StopAttribute::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.StopAttribute.dimId)
}
#endif
inline void SolutionResponse_StopAttribute::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.StopAttribute.dimId)
}
inline void SolutionResponse_StopAttribute::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.StopAttribute.dimId)
}
inline ::std::string* SolutionResponse_StopAttribute::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.StopAttribute.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_StopAttribute::release_dimid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.StopAttribute.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_StopAttribute::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.StopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_StopAttribute::has_startvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_startvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_StopAttribute::clear_has_startvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_StopAttribute::clear_startvalue() {
  startvalue_ = 0;
  clear_has_startvalue();
}
inline float SolutionResponse_StopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.startValue)
  return startvalue_;
}
inline void SolutionResponse_StopAttribute::set_startvalue(float value) {
  set_has_startvalue();
  startvalue_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.startValue)
}

// required float endValue = 3;
inline bool SolutionResponse_StopAttribute::has_endvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_endvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_StopAttribute::clear_has_endvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_StopAttribute::clear_endvalue() {
  endvalue_ = 0;
  clear_has_endvalue();
}
inline float SolutionResponse_StopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.endValue)
  return endvalue_;
}
inline void SolutionResponse_StopAttribute::set_endvalue(float value) {
  set_has_endvalue();
  endvalue_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.endValue)
}

// required float cost = 4;
inline bool SolutionResponse_StopAttribute::has_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_StopAttribute::clear_has_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_StopAttribute::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_StopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.cost)
  return cost_;
}
inline void SolutionResponse_StopAttribute::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.cost)
}

// -------------------------------------------------------------------

// SolutionResponse_InterStopAttribute

// required string dimId = 1;
inline bool SolutionResponse_InterStopAttribute::has_dimid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_dimid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_InterStopAttribute::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_InterStopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_InterStopAttribute::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_InterStopAttribute::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.InterStopAttribute.dimId)
}
#endif
inline void SolutionResponse_InterStopAttribute::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.InterStopAttribute.dimId)
}
inline void SolutionResponse_InterStopAttribute::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.InterStopAttribute.dimId)
}
inline ::std::string* SolutionResponse_InterStopAttribute::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.InterStopAttribute.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_InterStopAttribute::release_dimid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.InterStopAttribute.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_InterStopAttribute::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.InterStopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_InterStopAttribute::has_startvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_startvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_startvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_InterStopAttribute::clear_startvalue() {
  startvalue_ = 0;
  clear_has_startvalue();
}
inline float SolutionResponse_InterStopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.startValue)
  return startvalue_;
}
inline void SolutionResponse_InterStopAttribute::set_startvalue(float value) {
  set_has_startvalue();
  startvalue_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.startValue)
}

// required float endValue = 3;
inline bool SolutionResponse_InterStopAttribute::has_endvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_endvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_endvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_InterStopAttribute::clear_endvalue() {
  endvalue_ = 0;
  clear_has_endvalue();
}
inline float SolutionResponse_InterStopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.endValue)
  return endvalue_;
}
inline void SolutionResponse_InterStopAttribute::set_endvalue(float value) {
  set_has_endvalue();
  endvalue_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.endValue)
}

// required float cost = 4;
inline bool SolutionResponse_InterStopAttribute::has_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_InterStopAttribute::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_InterStopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.cost)
  return cost_;
}
inline void SolutionResponse_InterStopAttribute::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.cost)
}

// -------------------------------------------------------------------

// SolutionResponse_Stop

// required int32 id = 1;
inline bool SolutionResponse_Stop::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Stop::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Stop::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Stop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SolutionResponse_Stop::id() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.id)
  return id_;
}
inline void SolutionResponse_Stop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.id)
}

// required int32 sequence = 2;
inline bool SolutionResponse_Stop::has_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_Stop::set_has_sequence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_Stop::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_Stop::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 SolutionResponse_Stop::sequence() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.sequence)
  return sequence_;
}
inline void SolutionResponse_Stop::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.sequence)
}

// optional string collectionId = 3;
inline bool SolutionResponse_Stop::has_collectionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Stop::set_has_collectionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Stop::clear_has_collectionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Stop::clear_collectionid() {
  collectionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_collectionid();
}
inline const ::std::string& SolutionResponse_Stop::collectionid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.collectionId)
  return collectionid_.GetNoArena();
}
inline void SolutionResponse_Stop::set_collectionid(const ::std::string& value) {
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.collectionId)
}
#if LANG_CXX11
inline void SolutionResponse_Stop::set_collectionid(::std::string&& value) {
  set_has_collectionid();
  collectionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Stop.collectionId)
}
#endif
inline void SolutionResponse_Stop::set_collectionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Stop.collectionId)
}
inline void SolutionResponse_Stop::set_collectionid(const char* value, size_t size) {
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Stop.collectionId)
}
inline ::std::string* SolutionResponse_Stop::mutable_collectionid() {
  set_has_collectionid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.collectionId)
  return collectionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Stop::release_collectionid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Stop.collectionId)
  if (!has_collectionid()) {
    return NULL;
  }
  clear_has_collectionid();
  return collectionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Stop::set_allocated_collectionid(::std::string* collectionid) {
  if (collectionid != NULL) {
    set_has_collectionid();
  } else {
    clear_has_collectionid();
  }
  collectionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collectionid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Stop.collectionId)
}

// optional string offloadSiteId = 4;
inline bool SolutionResponse_Stop::has_offloadsiteid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Stop::set_has_offloadsiteid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Stop::clear_has_offloadsiteid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Stop::clear_offloadsiteid() {
  offloadsiteid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_offloadsiteid();
}
inline const ::std::string& SolutionResponse_Stop::offloadsiteid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.offloadSiteId)
  return offloadsiteid_.GetNoArena();
}
inline void SolutionResponse_Stop::set_offloadsiteid(const ::std::string& value) {
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.offloadSiteId)
}
#if LANG_CXX11
inline void SolutionResponse_Stop::set_offloadsiteid(::std::string&& value) {
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Stop.offloadSiteId)
}
#endif
inline void SolutionResponse_Stop::set_offloadsiteid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Stop.offloadSiteId)
}
inline void SolutionResponse_Stop::set_offloadsiteid(const char* value, size_t size) {
  set_has_offloadsiteid();
  offloadsiteid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Stop.offloadSiteId)
}
inline ::std::string* SolutionResponse_Stop::mutable_offloadsiteid() {
  set_has_offloadsiteid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.offloadSiteId)
  return offloadsiteid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Stop::release_offloadsiteid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Stop.offloadSiteId)
  if (!has_offloadsiteid()) {
    return NULL;
  }
  clear_has_offloadsiteid();
  return offloadsiteid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Stop::set_allocated_offloadsiteid(::std::string* offloadsiteid) {
  if (offloadsiteid != NULL) {
    set_has_offloadsiteid();
  } else {
    clear_has_offloadsiteid();
  }
  offloadsiteid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), offloadsiteid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Stop.offloadSiteId)
}

// repeated .ISR.SolutionResponse.StopAttribute attributes = 5;
inline int SolutionResponse_Stop::attributes_size() const {
  return attributes_.size();
}
inline void SolutionResponse_Stop::clear_attributes() {
  attributes_.Clear();
}
inline ::ISR::SolutionResponse_StopAttribute* SolutionResponse_Stop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >*
SolutionResponse_Stop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Stop.attributes)
  return &attributes_;
}
inline const ::ISR::SolutionResponse_StopAttribute& SolutionResponse_Stop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.attributes)
  return attributes_.Get(index);
}
inline ::ISR::SolutionResponse_StopAttribute* SolutionResponse_Stop::add_attributes() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Stop.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >&
SolutionResponse_Stop::attributes() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Stop.attributes)
  return attributes_;
}

// optional int32 segmentId = 6;
inline bool SolutionResponse_Stop::has_segmentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_Stop::set_has_segmentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_Stop::clear_has_segmentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_Stop::clear_segmentid() {
  segmentid_ = 0;
  clear_has_segmentid();
}
inline ::google::protobuf::int32 SolutionResponse_Stop::segmentid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.segmentId)
  return segmentid_;
}
inline void SolutionResponse_Stop::set_segmentid(::google::protobuf::int32 value) {
  set_has_segmentid();
  segmentid_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.segmentId)
}

// required .ISR.Geocode location = 7;
inline bool SolutionResponse_Stop::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Stop::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Stop::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Stop::clear_location() {
  if (location_ != NULL) location_->Clear();
  clear_has_location();
}
inline const ::ISR::Geocode& SolutionResponse_Stop::_internal_location() const {
  return *location_;
}
inline const ::ISR::Geocode& SolutionResponse_Stop::location() const {
  const ::ISR::Geocode* p = location_;
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.location)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Geocode*>(
      &::ISR::_Geocode_default_instance_);
}
inline ::ISR::Geocode* SolutionResponse_Stop::release_location() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Stop.location)
  clear_has_location();
  ::ISR::Geocode* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::ISR::Geocode* SolutionResponse_Stop::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.location)
  return location_;
}
inline void SolutionResponse_Stop::set_allocated_location(::ISR::Geocode* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Stop.location)
}

// -------------------------------------------------------------------

// SolutionResponse_InterStop

// required int32 fromStopId = 1;
inline bool SolutionResponse_InterStop::has_fromstopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_InterStop::set_has_fromstopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_InterStop::clear_has_fromstopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_InterStop::clear_fromstopid() {
  fromstopid_ = 0;
  clear_has_fromstopid();
}
inline ::google::protobuf::int32 SolutionResponse_InterStop::fromstopid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.fromStopId)
  return fromstopid_;
}
inline void SolutionResponse_InterStop::set_fromstopid(::google::protobuf::int32 value) {
  set_has_fromstopid();
  fromstopid_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStop.fromStopId)
}

// required int32 toStopId = 2;
inline bool SolutionResponse_InterStop::has_tostopid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_InterStop::set_has_tostopid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_InterStop::clear_has_tostopid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_InterStop::clear_tostopid() {
  tostopid_ = 0;
  clear_has_tostopid();
}
inline ::google::protobuf::int32 SolutionResponse_InterStop::tostopid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.toStopId)
  return tostopid_;
}
inline void SolutionResponse_InterStop::set_tostopid(::google::protobuf::int32 value) {
  set_has_tostopid();
  tostopid_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStop.toStopId)
}

// repeated .ISR.SolutionResponse.InterStopAttribute attributes = 3;
inline int SolutionResponse_InterStop::attributes_size() const {
  return attributes_.size();
}
inline void SolutionResponse_InterStop::clear_attributes() {
  attributes_.Clear();
}
inline ::ISR::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.InterStop.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >*
SolutionResponse_InterStop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.InterStop.attributes)
  return &attributes_;
}
inline const ::ISR::SolutionResponse_InterStopAttribute& SolutionResponse_InterStop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.attributes)
  return attributes_.Get(index);
}
inline ::ISR::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::add_attributes() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.InterStop.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >&
SolutionResponse_InterStop::attributes() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.InterStop.attributes)
  return attributes_;
}

// repeated .ISR.Geocode geometry = 4;
inline int SolutionResponse_InterStop::geometry_size() const {
  return geometry_.size();
}
inline void SolutionResponse_InterStop::clear_geometry() {
  geometry_.Clear();
}
inline ::ISR::Geocode* SolutionResponse_InterStop::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.InterStop.geometry)
  return geometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
SolutionResponse_InterStop::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.InterStop.geometry)
  return &geometry_;
}
inline const ::ISR::Geocode& SolutionResponse_InterStop::geometry(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.geometry)
  return geometry_.Get(index);
}
inline ::ISR::Geocode* SolutionResponse_InterStop::add_geometry() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.InterStop.geometry)
  return geometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
SolutionResponse_InterStop::geometry() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.InterStop.geometry)
  return geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string vehicleId = 1;
inline bool SolutionResponse_Route::has_vehicleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Route::set_has_vehicleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Route::clear_has_vehicleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Route::clear_vehicleid() {
  vehicleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicleid();
}
inline const ::std::string& SolutionResponse_Route::vehicleid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Route.vehicleId)
  return vehicleid_.GetNoArena();
}
inline void SolutionResponse_Route::set_vehicleid(const ::std::string& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Route.vehicleId)
}
#if LANG_CXX11
inline void SolutionResponse_Route::set_vehicleid(::std::string&& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Route.vehicleId)
}
#endif
inline void SolutionResponse_Route::set_vehicleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Route.vehicleId)
}
inline void SolutionResponse_Route::set_vehicleid(const char* value, size_t size) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Route.vehicleId)
}
inline ::std::string* SolutionResponse_Route::mutable_vehicleid() {
  set_has_vehicleid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Route.vehicleId)
  return vehicleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Route::release_vehicleid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Route.vehicleId)
  if (!has_vehicleid()) {
    return NULL;
  }
  clear_has_vehicleid();
  return vehicleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Route::set_allocated_vehicleid(::std::string* vehicleid) {
  if (vehicleid != NULL) {
    set_has_vehicleid();
  } else {
    clear_has_vehicleid();
  }
  vehicleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicleid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Route.vehicleId)
}

// repeated .ISR.SolutionResponse.Stop stops = 2;
inline int SolutionResponse_Route::stops_size() const {
  return stops_.size();
}
inline void SolutionResponse_Route::clear_stops() {
  stops_.Clear();
}
inline ::ISR::SolutionResponse_Stop* SolutionResponse_Route::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Route.stops)
  return stops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >*
SolutionResponse_Route::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Route.stops)
  return &stops_;
}
inline const ::ISR::SolutionResponse_Stop& SolutionResponse_Route::stops(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Route.stops)
  return stops_.Get(index);
}
inline ::ISR::SolutionResponse_Stop* SolutionResponse_Route::add_stops() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Route.stops)
  return stops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >&
SolutionResponse_Route::stops() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Route.stops)
  return stops_;
}

// repeated .ISR.SolutionResponse.InterStop interStops = 3;
inline int SolutionResponse_Route::interstops_size() const {
  return interstops_.size();
}
inline void SolutionResponse_Route::clear_interstops() {
  interstops_.Clear();
}
inline ::ISR::SolutionResponse_InterStop* SolutionResponse_Route::mutable_interstops(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Route.interStops)
  return interstops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >*
SolutionResponse_Route::mutable_interstops() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Route.interStops)
  return &interstops_;
}
inline const ::ISR::SolutionResponse_InterStop& SolutionResponse_Route::interstops(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Route.interStops)
  return interstops_.Get(index);
}
inline ::ISR::SolutionResponse_InterStop* SolutionResponse_Route::add_interstops() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Route.interStops)
  return interstops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >&
SolutionResponse_Route::interstops() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Route.interStops)
  return interstops_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility_Info

// required string message = 1;
inline bool SolutionResponse_Infeasibility_Info::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Infeasibility_Info::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& SolutionResponse_Infeasibility_Info::message() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.message)
  return message_.GetNoArena();
}
inline void SolutionResponse_Infeasibility_Info::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.message)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Infeasibility.Info.message)
}
#endif
inline void SolutionResponse_Infeasibility_Info::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Infeasibility.Info.message)
}
inline void SolutionResponse_Infeasibility_Info::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Infeasibility.Info.message)
}
inline ::std::string* SolutionResponse_Infeasibility_Info::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.Info.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Infeasibility_Info::release_message() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Infeasibility.Info.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Infeasibility.Info.message)
}

// optional string dimId = 2;
inline bool SolutionResponse_Infeasibility_Info::has_dimid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_dimid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Infeasibility_Info::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_Infeasibility_Info::dimid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_Infeasibility_Info::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Infeasibility.Info.dimId)
}
#endif
inline void SolutionResponse_Infeasibility_Info::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Infeasibility.Info.dimId)
}
inline void SolutionResponse_Infeasibility_Info::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Infeasibility.Info.dimId)
}
inline ::std::string* SolutionResponse_Infeasibility_Info::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.Info.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Infeasibility_Info::release_dimid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Infeasibility.Info.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Infeasibility.Info.dimId)
}

// optional float limit = 3;
inline bool SolutionResponse_Infeasibility_Info::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Infeasibility_Info::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline float SolutionResponse_Infeasibility_Info::limit() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.limit)
  return limit_;
}
inline void SolutionResponse_Infeasibility_Info::set_limit(float value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.limit)
}

// optional float value = 4;
inline bool SolutionResponse_Infeasibility_Info::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Infeasibility_Info::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float SolutionResponse_Infeasibility_Info::value() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.value)
  return value_;
}
inline void SolutionResponse_Infeasibility_Info::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.value)
}

// optional int64 count = 5;
inline bool SolutionResponse_Infeasibility_Info::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_Infeasibility_Info::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::int64 SolutionResponse_Infeasibility_Info::count() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.count)
  return count_;
}
inline void SolutionResponse_Infeasibility_Info::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.count)
}

// repeated string constrainingCollectionIds = 6;
inline int SolutionResponse_Infeasibility_Info::constrainingcollectionids_size() const {
  return constrainingcollectionids_.size();
}
inline void SolutionResponse_Infeasibility_Info::clear_constrainingcollectionids() {
  constrainingcollectionids_.Clear();
}
inline const ::std::string& SolutionResponse_Infeasibility_Info::constrainingcollectionids(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return constrainingcollectionids_.Get(index);
}
inline ::std::string* SolutionResponse_Infeasibility_Info::mutable_constrainingcollectionids(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return constrainingcollectionids_.Mutable(index);
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  constrainingcollectionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  constrainingcollectionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  constrainingcollectionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, const char* value, size_t size) {
  constrainingcollectionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline ::std::string* SolutionResponse_Infeasibility_Info::add_constrainingcollectionids() {
  // @@protoc_insertion_point(field_add_mutable:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return constrainingcollectionids_.Add();
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(const ::std::string& value) {
  constrainingcollectionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(::std::string&& value) {
  constrainingcollectionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
#endif
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  constrainingcollectionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(const char* value, size_t size) {
  constrainingcollectionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolutionResponse_Infeasibility_Info::constrainingcollectionids() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return constrainingcollectionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolutionResponse_Infeasibility_Info::mutable_constrainingcollectionids() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return &constrainingcollectionids_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility

// required string collectionId = 1;
inline bool SolutionResponse_Infeasibility::has_collectionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Infeasibility::set_has_collectionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Infeasibility::clear_has_collectionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Infeasibility::clear_collectionid() {
  collectionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_collectionid();
}
inline const ::std::string& SolutionResponse_Infeasibility::collectionid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.collectionId)
  return collectionid_.GetNoArena();
}
inline void SolutionResponse_Infeasibility::set_collectionid(const ::std::string& value) {
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.collectionId)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility::set_collectionid(::std::string&& value) {
  set_has_collectionid();
  collectionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Infeasibility.collectionId)
}
#endif
inline void SolutionResponse_Infeasibility::set_collectionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Infeasibility.collectionId)
}
inline void SolutionResponse_Infeasibility::set_collectionid(const char* value, size_t size) {
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Infeasibility.collectionId)
}
inline ::std::string* SolutionResponse_Infeasibility::mutable_collectionid() {
  set_has_collectionid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.collectionId)
  return collectionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Infeasibility::release_collectionid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Infeasibility.collectionId)
  if (!has_collectionid()) {
    return NULL;
  }
  clear_has_collectionid();
  return collectionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Infeasibility::set_allocated_collectionid(::std::string* collectionid) {
  if (collectionid != NULL) {
    set_has_collectionid();
  } else {
    clear_has_collectionid();
  }
  collectionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collectionid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Infeasibility.collectionId)
}

// repeated .ISR.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
inline int SolutionResponse_Infeasibility::infeasibilityinfo_size() const {
  return infeasibilityinfo_.size();
}
inline void SolutionResponse_Infeasibility::clear_infeasibilityinfo() {
  infeasibilityinfo_.Clear();
}
inline ::ISR::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::mutable_infeasibilityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >*
SolutionResponse_Infeasibility::mutable_infeasibilityinfo() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return &infeasibilityinfo_;
}
inline const ::ISR::SolutionResponse_Infeasibility_Info& SolutionResponse_Infeasibility::infeasibilityinfo(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_.Get(index);
}
inline ::ISR::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::add_infeasibilityinfo() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >&
SolutionResponse_Infeasibility::infeasibilityinfo() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_;
}

// -------------------------------------------------------------------

// SolutionResponse_Matching

// required string collectionId = 1;
inline bool SolutionResponse_Matching::has_collectionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Matching::set_has_collectionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Matching::clear_has_collectionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Matching::clear_collectionid() {
  collectionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_collectionid();
}
inline const ::std::string& SolutionResponse_Matching::collectionid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Matching.collectionId)
  return collectionid_.GetNoArena();
}
inline void SolutionResponse_Matching::set_collectionid(const ::std::string& value) {
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Matching.collectionId)
}
#if LANG_CXX11
inline void SolutionResponse_Matching::set_collectionid(::std::string&& value) {
  set_has_collectionid();
  collectionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Matching.collectionId)
}
#endif
inline void SolutionResponse_Matching::set_collectionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Matching.collectionId)
}
inline void SolutionResponse_Matching::set_collectionid(const char* value, size_t size) {
  set_has_collectionid();
  collectionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Matching.collectionId)
}
inline ::std::string* SolutionResponse_Matching::mutable_collectionid() {
  set_has_collectionid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Matching.collectionId)
  return collectionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Matching::release_collectionid() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Matching.collectionId)
  if (!has_collectionid()) {
    return NULL;
  }
  clear_has_collectionid();
  return collectionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Matching::set_allocated_collectionid(::std::string* collectionid) {
  if (collectionid != NULL) {
    set_has_collectionid();
  } else {
    clear_has_collectionid();
  }
  collectionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collectionid);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Matching.collectionId)
}

// required .ISR.Geocode collectionPoint = 2;
inline bool SolutionResponse_Matching::has_collectionpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Matching::set_has_collectionpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Matching::clear_has_collectionpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Matching::clear_collectionpoint() {
  if (collectionpoint_ != NULL) collectionpoint_->Clear();
  clear_has_collectionpoint();
}
inline const ::ISR::Geocode& SolutionResponse_Matching::_internal_collectionpoint() const {
  return *collectionpoint_;
}
inline const ::ISR::Geocode& SolutionResponse_Matching::collectionpoint() const {
  const ::ISR::Geocode* p = collectionpoint_;
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Matching.collectionPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::ISR::Geocode*>(
      &::ISR::_Geocode_default_instance_);
}
inline ::ISR::Geocode* SolutionResponse_Matching::release_collectionpoint() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Matching.collectionPoint)
  clear_has_collectionpoint();
  ::ISR::Geocode* temp = collectionpoint_;
  collectionpoint_ = NULL;
  return temp;
}
inline ::ISR::Geocode* SolutionResponse_Matching::mutable_collectionpoint() {
  set_has_collectionpoint();
  if (collectionpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaNoVirtual());
    collectionpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Matching.collectionPoint)
  return collectionpoint_;
}
inline void SolutionResponse_Matching::set_allocated_collectionpoint(::ISR::Geocode* collectionpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete collectionpoint_;
  }
  if (collectionpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collectionpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collectionpoint, submessage_arena);
    }
    set_has_collectionpoint();
  } else {
    clear_has_collectionpoint();
  }
  collectionpoint_ = collectionpoint;
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Matching.collectionPoint)
}

// required int32 segmentId = 3;
inline bool SolutionResponse_Matching::has_segmentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Matching::set_has_segmentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Matching::clear_has_segmentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Matching::clear_segmentid() {
  segmentid_ = 0;
  clear_has_segmentid();
}
inline ::google::protobuf::int32 SolutionResponse_Matching::segmentid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Matching.segmentId)
  return segmentid_;
}
inline void SolutionResponse_Matching::set_segmentid(::google::protobuf::int32 value) {
  set_has_segmentid();
  segmentid_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Matching.segmentId)
}

// -------------------------------------------------------------------

// SolutionResponse_Segment

// required int32 id = 1;
inline bool SolutionResponse_Segment::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Segment::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Segment::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Segment::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SolutionResponse_Segment::id() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.id)
  return id_;
}
inline void SolutionResponse_Segment::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.id)
}

// required string name = 2;
inline bool SolutionResponse_Segment::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Segment::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Segment::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Segment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SolutionResponse_Segment::name() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.name)
  return name_.GetNoArena();
}
inline void SolutionResponse_Segment::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.name)
}
#if LANG_CXX11
inline void SolutionResponse_Segment::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISR.SolutionResponse.Segment.name)
}
#endif
inline void SolutionResponse_Segment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Segment.name)
}
inline void SolutionResponse_Segment::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Segment.name)
}
inline ::std::string* SolutionResponse_Segment::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Segment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Segment::release_name() {
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Segment.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Segment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Segment.name)
}

// required float weight = 3;
inline bool SolutionResponse_Segment::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Segment::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Segment::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Segment::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline float SolutionResponse_Segment::weight() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.weight)
  return weight_;
}
inline void SolutionResponse_Segment::set_weight(float value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.weight)
}

// required float duration = 4;
inline bool SolutionResponse_Segment::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Segment::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Segment::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Segment::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float SolutionResponse_Segment::duration() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.duration)
  return duration_;
}
inline void SolutionResponse_Segment::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.duration)
}

// repeated .ISR.Geocode geometry = 5;
inline int SolutionResponse_Segment::geometry_size() const {
  return geometry_.size();
}
inline void SolutionResponse_Segment::clear_geometry() {
  geometry_.Clear();
}
inline ::ISR::Geocode* SolutionResponse_Segment::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Segment.geometry)
  return geometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
SolutionResponse_Segment::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Segment.geometry)
  return &geometry_;
}
inline const ::ISR::Geocode& SolutionResponse_Segment::geometry(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.geometry)
  return geometry_.Get(index);
}
inline ::ISR::Geocode* SolutionResponse_Segment::add_geometry() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Segment.geometry)
  return geometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
SolutionResponse_Segment::geometry() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Segment.geometry)
  return geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse

// required float objective = 1;
inline bool SolutionResponse::has_objective() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse::set_has_objective() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse::clear_has_objective() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse::clear_objective() {
  objective_ = 0;
  clear_has_objective();
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.objective)
  return objective_;
}
inline void SolutionResponse::set_objective(float value) {
  set_has_objective();
  objective_ = value;
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.objective)
}

// repeated .ISR.SolutionResponse.Route routes = 2;
inline int SolutionResponse::routes_size() const {
  return routes_.size();
}
inline void SolutionResponse::clear_routes() {
  routes_.Clear();
}
inline ::ISR::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.routes)
  return &routes_;
}
inline const ::ISR::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.routes)
  return routes_.Get(index);
}
inline ::ISR::SolutionResponse_Route* SolutionResponse::add_routes() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.routes)
  return routes_;
}

// repeated .ISR.SolutionResponse.Infeasibility infeasibilities = 3;
inline int SolutionResponse::infeasibilities_size() const {
  return infeasibilities_.size();
}
inline void SolutionResponse::clear_infeasibilities() {
  infeasibilities_.Clear();
}
inline ::ISR::SolutionResponse_Infeasibility* SolutionResponse::mutable_infeasibilities(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.infeasibilities)
  return infeasibilities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >*
SolutionResponse::mutable_infeasibilities() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.infeasibilities)
  return &infeasibilities_;
}
inline const ::ISR::SolutionResponse_Infeasibility& SolutionResponse::infeasibilities(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.infeasibilities)
  return infeasibilities_.Get(index);
}
inline ::ISR::SolutionResponse_Infeasibility* SolutionResponse::add_infeasibilities() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.infeasibilities)
  return infeasibilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >&
SolutionResponse::infeasibilities() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.infeasibilities)
  return infeasibilities_;
}

// repeated .ISR.SolutionResponse.Matching matchings = 4;
inline int SolutionResponse::matchings_size() const {
  return matchings_.size();
}
inline void SolutionResponse::clear_matchings() {
  matchings_.Clear();
}
inline ::ISR::SolutionResponse_Matching* SolutionResponse::mutable_matchings(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.matchings)
  return matchings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >*
SolutionResponse::mutable_matchings() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.matchings)
  return &matchings_;
}
inline const ::ISR::SolutionResponse_Matching& SolutionResponse::matchings(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.matchings)
  return matchings_.Get(index);
}
inline ::ISR::SolutionResponse_Matching* SolutionResponse::add_matchings() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.matchings)
  return matchings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >&
SolutionResponse::matchings() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.matchings)
  return matchings_;
}

// repeated .ISR.SolutionResponse.Segment segments = 5;
inline int SolutionResponse::segments_size() const {
  return segments_.size();
}
inline void SolutionResponse::clear_segments() {
  segments_.Clear();
}
inline ::ISR::SolutionResponse_Segment* SolutionResponse::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.segments)
  return segments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >*
SolutionResponse::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.segments)
  return &segments_;
}
inline const ::ISR::SolutionResponse_Segment& SolutionResponse::segments(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.segments)
  return segments_.Get(index);
}
inline ::ISR::SolutionResponse_Segment* SolutionResponse::add_segments() {
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.segments)
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >&
SolutionResponse::segments() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.segments)
  return segments_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ISR

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ISR::Configuration_eMeasurementUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ISR::Configuration_eMeasurementUnit>() {
  return ::ISR::Configuration_eMeasurementUnit_descriptor();
}
template <> struct is_proto_enum< ::ISR::Configuration_eDrivingSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ISR::Configuration_eDrivingSide>() {
  return ::ISR::Configuration_eDrivingSide_descriptor();
}
template <> struct is_proto_enum< ::ISR::Configuration_eCollectionSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ISR::Configuration_eCollectionSide>() {
  return ::ISR::Configuration_eCollectionSide_descriptor();
}
template <> struct is_proto_enum< ::ISR::SolveRequest_SolveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ISR::SolveRequest_SolveType>() {
  return ::ISR::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_isr_2dz4foi53qznrv_2eproto
