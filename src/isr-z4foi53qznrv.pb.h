// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: isr-z4foi53qznrv.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_isr_2dz4foi53qznrv_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_isr_2dz4foi53qznrv_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_isr_2dz4foi53qznrv_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_isr_2dz4foi53qznrv_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_isr_2dz4foi53qznrv_2eproto;
namespace ISR {
class Collection;
struct CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class CollectionSequence;
struct CollectionSequenceDefaultTypeInternal;
extern CollectionSequenceDefaultTypeInternal _CollectionSequence_default_instance_;
class Configuration;
struct ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class OffloadSite;
struct OffloadSiteDefaultTypeInternal;
extern OffloadSiteDefaultTypeInternal _OffloadSite_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Infeasibility;
struct SolutionResponse_InfeasibilityDefaultTypeInternal;
extern SolutionResponse_InfeasibilityDefaultTypeInternal _SolutionResponse_Infeasibility_default_instance_;
class SolutionResponse_Infeasibility_Info;
struct SolutionResponse_Infeasibility_InfoDefaultTypeInternal;
extern SolutionResponse_Infeasibility_InfoDefaultTypeInternal _SolutionResponse_Infeasibility_Info_default_instance_;
class SolutionResponse_InterStop;
struct SolutionResponse_InterStopDefaultTypeInternal;
extern SolutionResponse_InterStopDefaultTypeInternal _SolutionResponse_InterStop_default_instance_;
class SolutionResponse_InterStopAttribute;
struct SolutionResponse_InterStopAttributeDefaultTypeInternal;
extern SolutionResponse_InterStopAttributeDefaultTypeInternal _SolutionResponse_InterStopAttribute_default_instance_;
class SolutionResponse_Matching;
struct SolutionResponse_MatchingDefaultTypeInternal;
extern SolutionResponse_MatchingDefaultTypeInternal _SolutionResponse_Matching_default_instance_;
class SolutionResponse_Route;
struct SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolutionResponse_Segment;
struct SolutionResponse_SegmentDefaultTypeInternal;
extern SolutionResponse_SegmentDefaultTypeInternal _SolutionResponse_Segment_default_instance_;
class SolutionResponse_Stop;
struct SolutionResponse_StopDefaultTypeInternal;
extern SolutionResponse_StopDefaultTypeInternal _SolutionResponse_Stop_default_instance_;
class SolutionResponse_StopAttribute;
struct SolutionResponse_StopAttributeDefaultTypeInternal;
extern SolutionResponse_StopAttributeDefaultTypeInternal _SolutionResponse_StopAttribute_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace ISR
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ISR {
enum Configuration_eMeasurementUnit : int {
  Configuration_eMeasurementUnit_SECONDS = 0,
  Configuration_eMeasurementUnit_MINUTES = 1,
  Configuration_eMeasurementUnit_HOURS = 2,
  Configuration_eMeasurementUnit_DAYS = 3,
  Configuration_eMeasurementUnit_KILOMETRES = 4,
  Configuration_eMeasurementUnit_MILES = 5,
};

bool Configuration_eMeasurementUnit_IsValid(int value);
constexpr Configuration_eMeasurementUnit Configuration_eMeasurementUnit_eMeasurementUnit_MIN = static_cast<Configuration_eMeasurementUnit>(0);
constexpr Configuration_eMeasurementUnit Configuration_eMeasurementUnit_eMeasurementUnit_MAX = static_cast<Configuration_eMeasurementUnit>(5);
constexpr int Configuration_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Configuration_eMeasurementUnit_descriptor();
template <typename T>
const std::string& Configuration_eMeasurementUnit_Name(T value) {
  static_assert(std::is_same<T, Configuration_eMeasurementUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eMeasurementUnit_Name().");
  return Configuration_eMeasurementUnit_Name(static_cast<Configuration_eMeasurementUnit>(value));
}
template <>
inline const std::string& Configuration_eMeasurementUnit_Name(Configuration_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Configuration_eMeasurementUnit_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Configuration_eMeasurementUnit_Parse(absl::string_view name, Configuration_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eMeasurementUnit>(
      Configuration_eMeasurementUnit_descriptor(), name, value);
}
enum Configuration_eDrivingSide : int {
  Configuration_eDrivingSide_LEFT = 0,
  Configuration_eDrivingSide_RIGHT = 1,
};

bool Configuration_eDrivingSide_IsValid(int value);
constexpr Configuration_eDrivingSide Configuration_eDrivingSide_eDrivingSide_MIN = static_cast<Configuration_eDrivingSide>(0);
constexpr Configuration_eDrivingSide Configuration_eDrivingSide_eDrivingSide_MAX = static_cast<Configuration_eDrivingSide>(1);
constexpr int Configuration_eDrivingSide_eDrivingSide_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Configuration_eDrivingSide_descriptor();
template <typename T>
const std::string& Configuration_eDrivingSide_Name(T value) {
  static_assert(std::is_same<T, Configuration_eDrivingSide>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eDrivingSide_Name().");
  return Configuration_eDrivingSide_Name(static_cast<Configuration_eDrivingSide>(value));
}
template <>
inline const std::string& Configuration_eDrivingSide_Name(Configuration_eDrivingSide value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Configuration_eDrivingSide_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Configuration_eDrivingSide_Parse(absl::string_view name, Configuration_eDrivingSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eDrivingSide>(
      Configuration_eDrivingSide_descriptor(), name, value);
}
enum Configuration_eCollectionSide : int {
  Configuration_eCollectionSide_DRIVINGSIDE_ONLY = 0,
  Configuration_eCollectionSide_BOTH = 1,
};

bool Configuration_eCollectionSide_IsValid(int value);
constexpr Configuration_eCollectionSide Configuration_eCollectionSide_eCollectionSide_MIN = static_cast<Configuration_eCollectionSide>(0);
constexpr Configuration_eCollectionSide Configuration_eCollectionSide_eCollectionSide_MAX = static_cast<Configuration_eCollectionSide>(1);
constexpr int Configuration_eCollectionSide_eCollectionSide_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Configuration_eCollectionSide_descriptor();
template <typename T>
const std::string& Configuration_eCollectionSide_Name(T value) {
  static_assert(std::is_same<T, Configuration_eCollectionSide>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eCollectionSide_Name().");
  return Configuration_eCollectionSide_Name(static_cast<Configuration_eCollectionSide>(value));
}
template <>
inline const std::string& Configuration_eCollectionSide_Name(Configuration_eCollectionSide value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Configuration_eCollectionSide_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Configuration_eCollectionSide_Parse(absl::string_view name, Configuration_eCollectionSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eCollectionSide>(
      Configuration_eCollectionSide_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
  SolveRequest_SolveType_NetworkMatchings = 3,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(3);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Configuration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Configuration) */ {
 public:
  inline Configuration() : Configuration(nullptr) {}
  ~Configuration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Configuration(::google::protobuf::internal::ConstantInitialized);

  Configuration(const Configuration& from);
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Configuration& operator=(Configuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Configuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(Configuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Configuration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Configuration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Configuration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Configuration& from) {
    Configuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.Configuration";
  }
  protected:
  explicit Configuration(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eMeasurementUnit = Configuration_eMeasurementUnit;
  static constexpr eMeasurementUnit SECONDS = Configuration_eMeasurementUnit_SECONDS;
  static constexpr eMeasurementUnit MINUTES = Configuration_eMeasurementUnit_MINUTES;
  static constexpr eMeasurementUnit HOURS = Configuration_eMeasurementUnit_HOURS;
  static constexpr eMeasurementUnit DAYS = Configuration_eMeasurementUnit_DAYS;
  static constexpr eMeasurementUnit KILOMETRES = Configuration_eMeasurementUnit_KILOMETRES;
  static constexpr eMeasurementUnit MILES = Configuration_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return Configuration_eMeasurementUnit_IsValid(value);
  }
  static constexpr eMeasurementUnit eMeasurementUnit_MIN = Configuration_eMeasurementUnit_eMeasurementUnit_MIN;
  static constexpr eMeasurementUnit eMeasurementUnit_MAX = Configuration_eMeasurementUnit_eMeasurementUnit_MAX;
  static constexpr int eMeasurementUnit_ARRAYSIZE = Configuration_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eMeasurementUnit_descriptor() {
    return Configuration_eMeasurementUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eMeasurementUnit_Name(T value) {
    return Configuration_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(absl::string_view name, eMeasurementUnit* value) {
    return Configuration_eMeasurementUnit_Parse(name, value);
  }

  using eDrivingSide = Configuration_eDrivingSide;
  static constexpr eDrivingSide LEFT = Configuration_eDrivingSide_LEFT;
  static constexpr eDrivingSide RIGHT = Configuration_eDrivingSide_RIGHT;
  static inline bool eDrivingSide_IsValid(int value) {
    return Configuration_eDrivingSide_IsValid(value);
  }
  static constexpr eDrivingSide eDrivingSide_MIN = Configuration_eDrivingSide_eDrivingSide_MIN;
  static constexpr eDrivingSide eDrivingSide_MAX = Configuration_eDrivingSide_eDrivingSide_MAX;
  static constexpr int eDrivingSide_ARRAYSIZE = Configuration_eDrivingSide_eDrivingSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eDrivingSide_descriptor() {
    return Configuration_eDrivingSide_descriptor();
  }
  template <typename T>
  static inline const std::string& eDrivingSide_Name(T value) {
    return Configuration_eDrivingSide_Name(value);
  }
  static inline bool eDrivingSide_Parse(absl::string_view name, eDrivingSide* value) {
    return Configuration_eDrivingSide_Parse(name, value);
  }

  using eCollectionSide = Configuration_eCollectionSide;
  static constexpr eCollectionSide DRIVINGSIDE_ONLY = Configuration_eCollectionSide_DRIVINGSIDE_ONLY;
  static constexpr eCollectionSide BOTH = Configuration_eCollectionSide_BOTH;
  static inline bool eCollectionSide_IsValid(int value) {
    return Configuration_eCollectionSide_IsValid(value);
  }
  static constexpr eCollectionSide eCollectionSide_MIN = Configuration_eCollectionSide_eCollectionSide_MIN;
  static constexpr eCollectionSide eCollectionSide_MAX = Configuration_eCollectionSide_eCollectionSide_MAX;
  static constexpr int eCollectionSide_ARRAYSIZE = Configuration_eCollectionSide_eCollectionSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eCollectionSide_descriptor() {
    return Configuration_eCollectionSide_descriptor();
  }
  template <typename T>
  static inline const std::string& eCollectionSide_Name(T value) {
    return Configuration_eCollectionSide_Name(value);
  }
  static inline bool eCollectionSide_Parse(absl::string_view name, eCollectionSide* value) {
    return Configuration_eCollectionSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDrivingSideFieldNumber = 6,
    kCollectionSideFieldNumber = 7,
    kDistanceCostCoefFieldNumber = 5,
    kTimeUnitFieldNumber = 1,
    kTimeCoefFieldNumber = 2,
    kTimeCostCoefFieldNumber = 3,
    kDistanceUnitFieldNumber = 4,
  };
  // required .ISR.Configuration.eDrivingSide drivingSide = 6;
  bool has_drivingside() const;
  void clear_drivingside() ;
  ::ISR::Configuration_eDrivingSide drivingside() const;
  void set_drivingside(::ISR::Configuration_eDrivingSide value);

  private:
  ::ISR::Configuration_eDrivingSide _internal_drivingside() const;
  void _internal_set_drivingside(::ISR::Configuration_eDrivingSide value);

  public:
  // required .ISR.Configuration.eCollectionSide collectionSide = 7;
  bool has_collectionside() const;
  void clear_collectionside() ;
  ::ISR::Configuration_eCollectionSide collectionside() const;
  void set_collectionside(::ISR::Configuration_eCollectionSide value);

  private:
  ::ISR::Configuration_eCollectionSide _internal_collectionside() const;
  void _internal_set_collectionside(::ISR::Configuration_eCollectionSide value);

  public:
  // required float distanceCostCoef = 5 [default = 1];
  bool has_distancecostcoef() const;
  void clear_distancecostcoef() ;
  float distancecostcoef() const;
  void set_distancecostcoef(float value);

  private:
  float _internal_distancecostcoef() const;
  void _internal_set_distancecostcoef(float value);

  public:
  // required .ISR.Configuration.eMeasurementUnit timeUnit = 1 [default = MINUTES];
  bool has_timeunit() const;
  void clear_timeunit() ;
  ::ISR::Configuration_eMeasurementUnit timeunit() const;
  void set_timeunit(::ISR::Configuration_eMeasurementUnit value);

  private:
  ::ISR::Configuration_eMeasurementUnit _internal_timeunit() const;
  void _internal_set_timeunit(::ISR::Configuration_eMeasurementUnit value);

  public:
  // required float timeCoef = 2 [default = 1];
  bool has_timecoef() const;
  void clear_timecoef() ;
  float timecoef() const;
  void set_timecoef(float value);

  private:
  float _internal_timecoef() const;
  void _internal_set_timecoef(float value);

  public:
  // required float timeCostCoef = 3 [default = 1];
  bool has_timecostcoef() const;
  void clear_timecostcoef() ;
  float timecostcoef() const;
  void set_timecostcoef(float value);

  private:
  float _internal_timecostcoef() const;
  void _internal_set_timecostcoef(float value);

  public:
  // required .ISR.Configuration.eMeasurementUnit distanceUnit = 4 [default = KILOMETRES];
  bool has_distanceunit() const;
  void clear_distanceunit() ;
  ::ISR::Configuration_eMeasurementUnit distanceunit() const;
  void set_distanceunit(::ISR::Configuration_eMeasurementUnit value);

  private:
  ::ISR::Configuration_eMeasurementUnit _internal_distanceunit() const;
  void _internal_set_distanceunit(::ISR::Configuration_eMeasurementUnit value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.Configuration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 4, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int drivingside_;
    int collectionside_;
    float distancecostcoef_;
    int timeunit_;
    float timecoef_;
    float timecostcoef_;
    int distanceunit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float longitude_;
    float latitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class OffloadSite final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.OffloadSite) */ {
 public:
  inline OffloadSite() : OffloadSite(nullptr) {}
  ~OffloadSite() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OffloadSite(::google::protobuf::internal::ConstantInitialized);

  OffloadSite(const OffloadSite& from);
  OffloadSite(OffloadSite&& from) noexcept
    : OffloadSite() {
    *this = ::std::move(from);
  }

  inline OffloadSite& operator=(const OffloadSite& from) {
    CopyFrom(from);
    return *this;
  }
  inline OffloadSite& operator=(OffloadSite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OffloadSite& default_instance() {
    return *internal_default_instance();
  }
  static inline const OffloadSite* internal_default_instance() {
    return reinterpret_cast<const OffloadSite*>(
               &_OffloadSite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OffloadSite& a, OffloadSite& b) {
    a.Swap(&b);
  }
  inline void Swap(OffloadSite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OffloadSite* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OffloadSite* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OffloadSite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OffloadSite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OffloadSite& from) {
    OffloadSite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OffloadSite* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.OffloadSite";
  }
  protected:
  explicit OffloadSite(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLocationFieldNumber = 2,
    kFixedOffloadTimeFieldNumber = 3,
    kOffloadTimePerQuantityFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .ISR.Geocode location = 2;
  bool has_location() const;
  void clear_location() ;
  const ::ISR::Geocode& location() const;
  PROTOBUF_NODISCARD ::ISR::Geocode* release_location();
  ::ISR::Geocode* mutable_location();
  void set_allocated_location(::ISR::Geocode* value);
  void unsafe_arena_set_allocated_location(::ISR::Geocode* value);
  ::ISR::Geocode* unsafe_arena_release_location();

  private:
  const ::ISR::Geocode& _internal_location() const;
  ::ISR::Geocode* _internal_mutable_location();

  public:
  // required float fixedOffloadTime = 3 [default = 0];
  bool has_fixedoffloadtime() const;
  void clear_fixedoffloadtime() ;
  float fixedoffloadtime() const;
  void set_fixedoffloadtime(float value);

  private:
  float _internal_fixedoffloadtime() const;
  void _internal_set_fixedoffloadtime(float value);

  public:
  // required float offloadTimePerQuantity = 4 [default = 0];
  bool has_offloadtimeperquantity() const;
  void clear_offloadtimeperquantity() ;
  float offloadtimeperquantity() const;
  void set_offloadtimeperquantity(float value);

  private:
  float _internal_offloadtimeperquantity() const;
  void _internal_set_offloadtimeperquantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.OffloadSite)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 26, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::ISR::Geocode* location_;
    float fixedoffloadtime_;
    float offloadtimeperquantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class Collection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Collection) */ {
 public:
  inline Collection() : Collection(nullptr) {}
  ~Collection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Collection(::google::protobuf::internal::ConstantInitialized);

  Collection(const Collection& from);
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collection& operator=(Collection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }
  inline void Swap(Collection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Collection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Collection& from) {
    Collection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collection* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.Collection";
  }
  protected:
  explicit Collection(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kOffloadSiteIdFieldNumber = 5,
    kLocationFieldNumber = 2,
    kStopTimeFieldNumber = 3,
    kQuantityFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string offloadSiteId = 5;
  bool has_offloadsiteid() const;
  void clear_offloadsiteid() ;
  const std::string& offloadsiteid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_offloadsiteid(Arg_&& arg, Args_... args);
  std::string* mutable_offloadsiteid();
  PROTOBUF_NODISCARD std::string* release_offloadsiteid();
  void set_allocated_offloadsiteid(std::string* ptr);

  private:
  const std::string& _internal_offloadsiteid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offloadsiteid(
      const std::string& value);
  std::string* _internal_mutable_offloadsiteid();

  public:
  // required .ISR.Geocode location = 2;
  bool has_location() const;
  void clear_location() ;
  const ::ISR::Geocode& location() const;
  PROTOBUF_NODISCARD ::ISR::Geocode* release_location();
  ::ISR::Geocode* mutable_location();
  void set_allocated_location(::ISR::Geocode* value);
  void unsafe_arena_set_allocated_location(::ISR::Geocode* value);
  ::ISR::Geocode* unsafe_arena_release_location();

  private:
  const ::ISR::Geocode& _internal_location() const;
  ::ISR::Geocode* _internal_mutable_location();

  public:
  // required float stopTime = 3 [default = 0];
  bool has_stoptime() const;
  void clear_stoptime() ;
  float stoptime() const;
  void set_stoptime(float value);

  private:
  float _internal_stoptime() const;
  void _internal_set_stoptime(float value);

  public:
  // required float quantity = 4 [default = 0];
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.Collection)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 1, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr offloadsiteid_;
    ::ISR::Geocode* location_;
    float stoptime_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class Vehicle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle(::google::protobuf::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.Vehicle";
  }
  protected:
  explicit Vehicle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStartLocationFieldNumber = 2,
    kEndLocationFieldNumber = 3,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
    kCapacityFieldNumber = 6,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .ISR.Geocode startLocation = 2;
  bool has_startlocation() const;
  void clear_startlocation() ;
  const ::ISR::Geocode& startlocation() const;
  PROTOBUF_NODISCARD ::ISR::Geocode* release_startlocation();
  ::ISR::Geocode* mutable_startlocation();
  void set_allocated_startlocation(::ISR::Geocode* value);
  void unsafe_arena_set_allocated_startlocation(::ISR::Geocode* value);
  ::ISR::Geocode* unsafe_arena_release_startlocation();

  private:
  const ::ISR::Geocode& _internal_startlocation() const;
  ::ISR::Geocode* _internal_mutable_startlocation();

  public:
  // required .ISR.Geocode endLocation = 3;
  bool has_endlocation() const;
  void clear_endlocation() ;
  const ::ISR::Geocode& endlocation() const;
  PROTOBUF_NODISCARD ::ISR::Geocode* release_endlocation();
  ::ISR::Geocode* mutable_endlocation();
  void set_allocated_endlocation(::ISR::Geocode* value);
  void unsafe_arena_set_allocated_endlocation(::ISR::Geocode* value);
  ::ISR::Geocode* unsafe_arena_release_endlocation();

  private:
  const ::ISR::Geocode& _internal_endlocation() const;
  ::ISR::Geocode* _internal_mutable_endlocation();

  public:
  // required float startTime = 4;
  bool has_starttime() const;
  void clear_starttime() ;
  float starttime() const;
  void set_starttime(float value);

  private:
  float _internal_starttime() const;
  void _internal_set_starttime(float value);

  public:
  // required float endTime = 5;
  bool has_endtime() const;
  void clear_endtime() ;
  float endtime() const;
  void set_endtime(float value);

  private:
  float _internal_endtime() const;
  void _internal_set_endtime(float value);

  public:
  // required float capacity = 6;
  bool has_capacity() const;
  void clear_capacity() ;
  float capacity() const;
  void set_capacity(float value);

  private:
  float _internal_capacity() const;
  void _internal_set_capacity(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.Vehicle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 2, 22, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::ISR::Geocode* startlocation_;
    ::ISR::Geocode* endlocation_;
    float starttime_;
    float endtime_;
    float capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class CollectionSequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.CollectionSequence) */ {
 public:
  inline CollectionSequence() : CollectionSequence(nullptr) {}
  ~CollectionSequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionSequence(::google::protobuf::internal::ConstantInitialized);

  CollectionSequence(const CollectionSequence& from);
  CollectionSequence(CollectionSequence&& from) noexcept
    : CollectionSequence() {
    *this = ::std::move(from);
  }

  inline CollectionSequence& operator=(const CollectionSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionSequence& operator=(CollectionSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionSequence* internal_default_instance() {
    return reinterpret_cast<const CollectionSequence*>(
               &_CollectionSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CollectionSequence& a, CollectionSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectionSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionSequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionSequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectionSequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionSequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollectionSequence& from) {
    CollectionSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectionSequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.CollectionSequence";
  }
  protected:
  explicit CollectionSequence(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionIdFieldNumber = 2,
    kVehicleIdFieldNumber = 1,
  };
  // repeated string collectionId = 2;
  int collectionid_size() const;
  private:
  int _internal_collectionid_size() const;

  public:
  void clear_collectionid() ;
  const std::string& collectionid(int index) const;
  std::string* mutable_collectionid(int index);
  void set_collectionid(int index, const std::string& value);
  void set_collectionid(int index, std::string&& value);
  void set_collectionid(int index, const char* value);
  void set_collectionid(int index, const char* value, std::size_t size);
  void set_collectionid(int index, absl::string_view value);
  std::string* add_collectionid();
  void add_collectionid(const std::string& value);
  void add_collectionid(std::string&& value);
  void add_collectionid(const char* value);
  void add_collectionid(const char* value, std::size_t size);
  void add_collectionid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& collectionid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_collectionid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_collectionid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_collectionid();

  public:
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // @@protoc_insertion_point(class_scope:ISR.CollectionSequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> collectionid_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::google::protobuf::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.Model";
  }
  protected:
  explicit Model(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionsFieldNumber = 2,
    kOffloadSitesFieldNumber = 3,
    kVehiclesFieldNumber = 4,
    kCollectionSequenceFieldNumber = 5,
    kConfigurationFieldNumber = 1,
  };
  // repeated .ISR.Collection collections = 2;
  int collections_size() const;
  private:
  int _internal_collections_size() const;

  public:
  void clear_collections() ;
  ::ISR::Collection* mutable_collections(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Collection >*
      mutable_collections();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::Collection>& _internal_collections() const;
  ::google::protobuf::RepeatedPtrField<::ISR::Collection>* _internal_mutable_collections();
  public:
  const ::ISR::Collection& collections(int index) const;
  ::ISR::Collection* add_collections();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Collection >&
      collections() const;
  // repeated .ISR.OffloadSite offloadSites = 3;
  int offloadsites_size() const;
  private:
  int _internal_offloadsites_size() const;

  public:
  void clear_offloadsites() ;
  ::ISR::OffloadSite* mutable_offloadsites(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >*
      mutable_offloadsites();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::OffloadSite>& _internal_offloadsites() const;
  ::google::protobuf::RepeatedPtrField<::ISR::OffloadSite>* _internal_mutable_offloadsites();
  public:
  const ::ISR::OffloadSite& offloadsites(int index) const;
  ::ISR::OffloadSite* add_offloadsites();
  const ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >&
      offloadsites() const;
  // repeated .ISR.Vehicle vehicles = 4;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;

  public:
  void clear_vehicles() ;
  ::ISR::Vehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >*
      mutable_vehicles();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::Vehicle>& _internal_vehicles() const;
  ::google::protobuf::RepeatedPtrField<::ISR::Vehicle>* _internal_mutable_vehicles();
  public:
  const ::ISR::Vehicle& vehicles(int index) const;
  ::ISR::Vehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >&
      vehicles() const;
  // repeated .ISR.CollectionSequence collectionSequence = 5;
  int collectionsequence_size() const;
  private:
  int _internal_collectionsequence_size() const;

  public:
  void clear_collectionsequence() ;
  ::ISR::CollectionSequence* mutable_collectionsequence(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
      mutable_collectionsequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>& _internal_collectionsequence() const;
  ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>* _internal_mutable_collectionsequence();
  public:
  const ::ISR::CollectionSequence& collectionsequence(int index) const;
  ::ISR::CollectionSequence* add_collectionsequence();
  const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
      collectionsequence() const;
  // required .ISR.Configuration configuration = 1;
  bool has_configuration() const;
  void clear_configuration() ;
  const ::ISR::Configuration& configuration() const;
  PROTOBUF_NODISCARD ::ISR::Configuration* release_configuration();
  ::ISR::Configuration* mutable_configuration();
  void set_allocated_configuration(::ISR::Configuration* value);
  void unsafe_arena_set_allocated_configuration(::ISR::Configuration* value);
  ::ISR::Configuration* unsafe_arena_release_configuration();

  private:
  const ::ISR::Configuration& _internal_configuration() const;
  ::ISR::Configuration* _internal_mutable_configuration();

  public:
  // @@protoc_insertion_point(class_scope:ISR.Model)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 5, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::Collection > collections_;
    ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite > offloadsites_;
    ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle > vehicles_;
    ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence > collectionsequence_;
    ::ISR::Configuration* configuration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static constexpr SolveType NetworkMatchings = SolveRequest_SolveType_NetworkMatchings;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated .ISR.CollectionSequence routes = 3;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::ISR::CollectionSequence* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>* _internal_mutable_routes();
  public:
  const ::ISR::CollectionSequence& routes(int index) const;
  ::ISR::CollectionSequence* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
      routes() const;
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .ISR.Model model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::ISR::Model& model() const;
  PROTOBUF_NODISCARD ::ISR::Model* release_model();
  ::ISR::Model* mutable_model();
  void set_allocated_model(::ISR::Model* value);
  void unsafe_arena_set_allocated_model(::ISR::Model* value);
  ::ISR::Model* unsafe_arena_release_model();

  private:
  const ::ISR::Model& _internal_model() const;
  ::ISR::Model* _internal_mutable_model();

  public:
  // optional .ISR.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::ISR::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::ISR::SolveRequest_SolveType value);

  private:
  ::ISR::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::ISR::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 3, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence > routes_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::ISR::Model* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_StopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.StopAttribute) */ {
 public:
  inline SolutionResponse_StopAttribute() : SolutionResponse_StopAttribute(nullptr) {}
  ~SolutionResponse_StopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_StopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_StopAttribute(const SolutionResponse_StopAttribute& from);
  SolutionResponse_StopAttribute(SolutionResponse_StopAttribute&& from) noexcept
    : SolutionResponse_StopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_StopAttribute& operator=(const SolutionResponse_StopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_StopAttribute& operator=(SolutionResponse_StopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_StopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_StopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_StopAttribute*>(
               &_SolutionResponse_StopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SolutionResponse_StopAttribute& a, SolutionResponse_StopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_StopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_StopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_StopAttribute& from) {
    SolutionResponse_StopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_StopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.StopAttribute";
  }
  protected:
  explicit SolutionResponse_StopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.StopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.InterStopAttribute) */ {
 public:
  inline SolutionResponse_InterStopAttribute() : SolutionResponse_InterStopAttribute(nullptr) {}
  ~SolutionResponse_InterStopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStopAttribute(const SolutionResponse_InterStopAttribute& from);
  SolutionResponse_InterStopAttribute(SolutionResponse_InterStopAttribute&& from) noexcept
    : SolutionResponse_InterStopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStopAttribute& operator=(const SolutionResponse_InterStopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStopAttribute& operator=(SolutionResponse_InterStopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStopAttribute*>(
               &_SolutionResponse_InterStopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SolutionResponse_InterStopAttribute& a, SolutionResponse_InterStopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStopAttribute& from) {
    SolutionResponse_InterStopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.InterStopAttribute";
  }
  protected:
  explicit SolutionResponse_InterStopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.InterStopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Stop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Stop) */ {
 public:
  inline SolutionResponse_Stop() : SolutionResponse_Stop(nullptr) {}
  ~SolutionResponse_Stop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Stop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Stop(const SolutionResponse_Stop& from);
  SolutionResponse_Stop(SolutionResponse_Stop&& from) noexcept
    : SolutionResponse_Stop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Stop& operator=(const SolutionResponse_Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Stop& operator=(SolutionResponse_Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Stop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Stop*>(
               &_SolutionResponse_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SolutionResponse_Stop& a, SolutionResponse_Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Stop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Stop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Stop& from) {
    SolutionResponse_Stop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Stop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.Stop";
  }
  protected:
  explicit SolutionResponse_Stop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kCollectionIdFieldNumber = 3,
    kOffloadSiteIdFieldNumber = 4,
    kLocationFieldNumber = 7,
    kIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
    kSegmentIdFieldNumber = 6,
  };
  // repeated .ISR.SolutionResponse.StopAttribute attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::ISR::SolutionResponse_StopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_StopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_StopAttribute>* _internal_mutable_attributes();
  public:
  const ::ISR::SolutionResponse_StopAttribute& attributes(int index) const;
  ::ISR::SolutionResponse_StopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >&
      attributes() const;
  // optional string collectionId = 3;
  bool has_collectionid() const;
  void clear_collectionid() ;
  const std::string& collectionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_collectionid(Arg_&& arg, Args_... args);
  std::string* mutable_collectionid();
  PROTOBUF_NODISCARD std::string* release_collectionid();
  void set_allocated_collectionid(std::string* ptr);

  private:
  const std::string& _internal_collectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collectionid(
      const std::string& value);
  std::string* _internal_mutable_collectionid();

  public:
  // optional string offloadSiteId = 4;
  bool has_offloadsiteid() const;
  void clear_offloadsiteid() ;
  const std::string& offloadsiteid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_offloadsiteid(Arg_&& arg, Args_... args);
  std::string* mutable_offloadsiteid();
  PROTOBUF_NODISCARD std::string* release_offloadsiteid();
  void set_allocated_offloadsiteid(std::string* ptr);

  private:
  const std::string& _internal_offloadsiteid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offloadsiteid(
      const std::string& value);
  std::string* _internal_mutable_offloadsiteid();

  public:
  // required .ISR.Geocode location = 7;
  bool has_location() const;
  void clear_location() ;
  const ::ISR::Geocode& location() const;
  PROTOBUF_NODISCARD ::ISR::Geocode* release_location();
  ::ISR::Geocode* mutable_location();
  void set_allocated_location(::ISR::Geocode* value);
  void unsafe_arena_set_allocated_location(::ISR::Geocode* value);
  ::ISR::Geocode* unsafe_arena_release_location();

  private:
  const ::ISR::Geocode& _internal_location() const;
  ::ISR::Geocode* _internal_mutable_location();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence() ;
  ::int32_t sequence() const;
  void set_sequence(::int32_t value);

  private:
  ::int32_t _internal_sequence() const;
  void _internal_set_sequence(::int32_t value);

  public:
  // optional int32 segmentId = 6;
  bool has_segmentid() const;
  void clear_segmentid() ;
  ::int32_t segmentid() const;
  void set_segmentid(::int32_t value);

  private:
  ::int32_t _internal_segmentid() const;
  void _internal_set_segmentid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Stop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 2, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr collectionid_;
    ::google::protobuf::internal::ArenaStringPtr offloadsiteid_;
    ::ISR::Geocode* location_;
    ::int32_t id_;
    ::int32_t sequence_;
    ::int32_t segmentid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.InterStop) */ {
 public:
  inline SolutionResponse_InterStop() : SolutionResponse_InterStop(nullptr) {}
  ~SolutionResponse_InterStop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStop(const SolutionResponse_InterStop& from);
  SolutionResponse_InterStop(SolutionResponse_InterStop&& from) noexcept
    : SolutionResponse_InterStop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStop& operator=(const SolutionResponse_InterStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStop& operator=(SolutionResponse_InterStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStop*>(
               &_SolutionResponse_InterStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SolutionResponse_InterStop& a, SolutionResponse_InterStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStop& from) {
    SolutionResponse_InterStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.InterStop";
  }
  protected:
  explicit SolutionResponse_InterStop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kGeometryFieldNumber = 4,
    kFromStopIdFieldNumber = 1,
    kToStopIdFieldNumber = 2,
  };
  // repeated .ISR.SolutionResponse.InterStopAttribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::ISR::SolutionResponse_InterStopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStopAttribute>* _internal_mutable_attributes();
  public:
  const ::ISR::SolutionResponse_InterStopAttribute& attributes(int index) const;
  ::ISR::SolutionResponse_InterStopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >&
      attributes() const;
  // repeated .ISR.Geocode geometry = 4;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;

  public:
  void clear_geometry() ;
  ::ISR::Geocode* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
      mutable_geometry();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::Geocode>& _internal_geometry() const;
  ::google::protobuf::RepeatedPtrField<::ISR::Geocode>* _internal_mutable_geometry();
  public:
  const ::ISR::Geocode& geometry(int index) const;
  ::ISR::Geocode* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
      geometry() const;
  // required int32 fromStopId = 1;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 2;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.InterStop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute > attributes_;
    ::google::protobuf::RepeatedPtrField< ::ISR::Geocode > geometry_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Route final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Route) */ {
 public:
  inline SolutionResponse_Route() : SolutionResponse_Route(nullptr) {}
  ~SolutionResponse_Route() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Route(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Route(const SolutionResponse_Route& from);
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Route* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Route* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Route& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Route& from) {
    SolutionResponse_Route::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.Route";
  }
  protected:
  explicit SolutionResponse_Route(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 2,
    kInterStopsFieldNumber = 3,
    kVehicleIdFieldNumber = 1,
  };
  // repeated .ISR.SolutionResponse.Stop stops = 2;
  int stops_size() const;
  private:
  int _internal_stops_size() const;

  public:
  void clear_stops() ;
  ::ISR::SolutionResponse_Stop* mutable_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >*
      mutable_stops();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Stop>& _internal_stops() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Stop>* _internal_mutable_stops();
  public:
  const ::ISR::SolutionResponse_Stop& stops(int index) const;
  ::ISR::SolutionResponse_Stop* add_stops();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >&
      stops() const;
  // repeated .ISR.SolutionResponse.InterStop interStops = 3;
  int interstops_size() const;
  private:
  int _internal_interstops_size() const;

  public:
  void clear_interstops() ;
  ::ISR::SolutionResponse_InterStop* mutable_interstops(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >*
      mutable_interstops();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStop>& _internal_interstops() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStop>* _internal_mutable_interstops();
  public:
  const ::ISR::SolutionResponse_InterStop& interstops(int index) const;
  ::ISR::SolutionResponse_InterStop* add_interstops();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >&
      interstops() const;
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Route)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop > stops_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop > interstops_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility_Info final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Infeasibility.Info) */ {
 public:
  inline SolutionResponse_Infeasibility_Info() : SolutionResponse_Infeasibility_Info(nullptr) {}
  ~SolutionResponse_Infeasibility_Info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility_Info(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility_Info(const SolutionResponse_Infeasibility_Info& from);
  SolutionResponse_Infeasibility_Info(SolutionResponse_Infeasibility_Info&& from) noexcept
    : SolutionResponse_Infeasibility_Info() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility_Info& operator=(const SolutionResponse_Infeasibility_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility_Info& operator=(SolutionResponse_Infeasibility_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility_Info* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility_Info*>(
               &_SolutionResponse_Infeasibility_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SolutionResponse_Infeasibility_Info& a, SolutionResponse_Infeasibility_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility_Info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility_Info& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility_Info& from) {
    SolutionResponse_Infeasibility_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility_Info* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.Infeasibility.Info";
  }
  protected:
  explicit SolutionResponse_Infeasibility_Info(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstrainingCollectionIdsFieldNumber = 6,
    kMessageFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kLimitFieldNumber = 3,
    kValueFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // repeated string constrainingCollectionIds = 6;
  int constrainingcollectionids_size() const;
  private:
  int _internal_constrainingcollectionids_size() const;

  public:
  void clear_constrainingcollectionids() ;
  const std::string& constrainingcollectionids(int index) const;
  std::string* mutable_constrainingcollectionids(int index);
  void set_constrainingcollectionids(int index, const std::string& value);
  void set_constrainingcollectionids(int index, std::string&& value);
  void set_constrainingcollectionids(int index, const char* value);
  void set_constrainingcollectionids(int index, const char* value, std::size_t size);
  void set_constrainingcollectionids(int index, absl::string_view value);
  std::string* add_constrainingcollectionids();
  void add_constrainingcollectionids(const std::string& value);
  void add_constrainingcollectionids(std::string&& value);
  void add_constrainingcollectionids(const char* value);
  void add_constrainingcollectionids(const char* value, std::size_t size);
  void add_constrainingcollectionids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& constrainingcollectionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_constrainingcollectionids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_constrainingcollectionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_constrainingcollectionids();

  public:
  // required string message = 1;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // optional float limit = 3;
  bool has_limit() const;
  void clear_limit() ;
  float limit() const;
  void set_limit(float value);

  private:
  float _internal_limit() const;
  void _internal_set_limit(float value);

  public:
  // optional float value = 4;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // optional int64 count = 5;
  bool has_count() const;
  void clear_count() ;
  ::int64_t count() const;
  void set_count(::int64_t value);

  private:
  ::int64_t _internal_count() const;
  void _internal_set_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Infeasibility.Info)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 85, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> constrainingcollectionids_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float limit_;
    float value_;
    ::int64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Infeasibility) */ {
 public:
  inline SolutionResponse_Infeasibility() : SolutionResponse_Infeasibility(nullptr) {}
  ~SolutionResponse_Infeasibility() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility(const SolutionResponse_Infeasibility& from);
  SolutionResponse_Infeasibility(SolutionResponse_Infeasibility&& from) noexcept
    : SolutionResponse_Infeasibility() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility& operator=(const SolutionResponse_Infeasibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility& operator=(SolutionResponse_Infeasibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility*>(
               &_SolutionResponse_Infeasibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SolutionResponse_Infeasibility& a, SolutionResponse_Infeasibility& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility& from) {
    SolutionResponse_Infeasibility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.Infeasibility";
  }
  protected:
  explicit SolutionResponse_Infeasibility(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Infeasibility_Info Info;

  // accessors -------------------------------------------------------

  enum : int {
    kInfeasibilityInfoFieldNumber = 2,
    kCollectionIdFieldNumber = 1,
  };
  // repeated .ISR.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
  int infeasibilityinfo_size() const;
  private:
  int _internal_infeasibilityinfo_size() const;

  public:
  void clear_infeasibilityinfo() ;
  ::ISR::SolutionResponse_Infeasibility_Info* mutable_infeasibilityinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >*
      mutable_infeasibilityinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility_Info>& _internal_infeasibilityinfo() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility_Info>* _internal_mutable_infeasibilityinfo();
  public:
  const ::ISR::SolutionResponse_Infeasibility_Info& infeasibilityinfo(int index) const;
  ::ISR::SolutionResponse_Infeasibility_Info* add_infeasibilityinfo();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >&
      infeasibilityinfo() const;
  // required string collectionId = 1;
  bool has_collectionid() const;
  void clear_collectionid() ;
  const std::string& collectionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_collectionid(Arg_&& arg, Args_... args);
  std::string* mutable_collectionid();
  PROTOBUF_NODISCARD std::string* release_collectionid();
  void set_allocated_collectionid(std::string* ptr);

  private:
  const std::string& _internal_collectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collectionid(
      const std::string& value);
  std::string* _internal_mutable_collectionid();

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Infeasibility)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 55, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info > infeasibilityinfo_;
    ::google::protobuf::internal::ArenaStringPtr collectionid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Matching final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Matching) */ {
 public:
  inline SolutionResponse_Matching() : SolutionResponse_Matching(nullptr) {}
  ~SolutionResponse_Matching() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Matching(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Matching(const SolutionResponse_Matching& from);
  SolutionResponse_Matching(SolutionResponse_Matching&& from) noexcept
    : SolutionResponse_Matching() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Matching& operator=(const SolutionResponse_Matching& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Matching& operator=(SolutionResponse_Matching&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Matching& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Matching* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Matching*>(
               &_SolutionResponse_Matching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SolutionResponse_Matching& a, SolutionResponse_Matching& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Matching* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Matching* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Matching* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Matching>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Matching& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Matching& from) {
    SolutionResponse_Matching::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Matching* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.Matching";
  }
  protected:
  explicit SolutionResponse_Matching(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionIdFieldNumber = 1,
    kCollectionPointFieldNumber = 2,
    kSegmentIdFieldNumber = 3,
  };
  // required string collectionId = 1;
  bool has_collectionid() const;
  void clear_collectionid() ;
  const std::string& collectionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_collectionid(Arg_&& arg, Args_... args);
  std::string* mutable_collectionid();
  PROTOBUF_NODISCARD std::string* release_collectionid();
  void set_allocated_collectionid(std::string* ptr);

  private:
  const std::string& _internal_collectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collectionid(
      const std::string& value);
  std::string* _internal_mutable_collectionid();

  public:
  // required .ISR.Geocode collectionPoint = 2;
  bool has_collectionpoint() const;
  void clear_collectionpoint() ;
  const ::ISR::Geocode& collectionpoint() const;
  PROTOBUF_NODISCARD ::ISR::Geocode* release_collectionpoint();
  ::ISR::Geocode* mutable_collectionpoint();
  void set_allocated_collectionpoint(::ISR::Geocode* value);
  void unsafe_arena_set_allocated_collectionpoint(::ISR::Geocode* value);
  ::ISR::Geocode* unsafe_arena_release_collectionpoint();

  private:
  const ::ISR::Geocode& _internal_collectionpoint() const;
  ::ISR::Geocode* _internal_mutable_collectionpoint();

  public:
  // required int32 segmentId = 3;
  bool has_segmentid() const;
  void clear_segmentid() ;
  ::int32_t segmentid() const;
  void set_segmentid(::int32_t value);

  private:
  ::int32_t _internal_segmentid() const;
  void _internal_set_segmentid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Matching)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collectionid_;
    ::ISR::Geocode* collectionpoint_;
    ::int32_t segmentid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Segment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse.Segment) */ {
 public:
  inline SolutionResponse_Segment() : SolutionResponse_Segment(nullptr) {}
  ~SolutionResponse_Segment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Segment(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Segment(const SolutionResponse_Segment& from);
  SolutionResponse_Segment(SolutionResponse_Segment&& from) noexcept
    : SolutionResponse_Segment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Segment& operator=(const SolutionResponse_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Segment& operator=(SolutionResponse_Segment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Segment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Segment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Segment*>(
               &_SolutionResponse_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SolutionResponse_Segment& a, SolutionResponse_Segment& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Segment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Segment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Segment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Segment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Segment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Segment& from) {
    SolutionResponse_Segment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Segment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse.Segment";
  }
  protected:
  explicit SolutionResponse_Segment(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeometryFieldNumber = 5,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kWeightFieldNumber = 3,
    kDurationFieldNumber = 4,
  };
  // repeated .ISR.Geocode geometry = 5;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;

  public:
  void clear_geometry() ;
  ::ISR::Geocode* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
      mutable_geometry();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::Geocode>& _internal_geometry() const;
  ::google::protobuf::RepeatedPtrField<::ISR::Geocode>* _internal_mutable_geometry();
  public:
  const ::ISR::Geocode& geometry(int index) const;
  ::ISR::Geocode* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
      geometry() const;
  // required string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required float weight = 3;
  bool has_weight() const;
  void clear_weight() ;
  float weight() const;
  void set_weight(float value);

  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);

  public:
  // required float duration = 4;
  bool has_duration() const;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse.Segment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 1, 41, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::Geocode > geometry_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t id_;
    float weight_;
    float duration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISR.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ISR.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_StopAttribute StopAttribute;
  typedef SolutionResponse_InterStopAttribute InterStopAttribute;
  typedef SolutionResponse_Stop Stop;
  typedef SolutionResponse_InterStop InterStop;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_Infeasibility Infeasibility;
  typedef SolutionResponse_Matching Matching;
  typedef SolutionResponse_Segment Segment;

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 2,
    kInfeasibilitiesFieldNumber = 3,
    kMatchingsFieldNumber = 4,
    kSegmentsFieldNumber = 5,
    kObjectiveFieldNumber = 1,
  };
  // repeated .ISR.SolutionResponse.Route routes = 2;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::ISR::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Route>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Route>* _internal_mutable_routes();
  public:
  const ::ISR::SolutionResponse_Route& routes(int index) const;
  ::ISR::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >&
      routes() const;
  // repeated .ISR.SolutionResponse.Infeasibility infeasibilities = 3;
  int infeasibilities_size() const;
  private:
  int _internal_infeasibilities_size() const;

  public:
  void clear_infeasibilities() ;
  ::ISR::SolutionResponse_Infeasibility* mutable_infeasibilities(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >*
      mutable_infeasibilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility>& _internal_infeasibilities() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility>* _internal_mutable_infeasibilities();
  public:
  const ::ISR::SolutionResponse_Infeasibility& infeasibilities(int index) const;
  ::ISR::SolutionResponse_Infeasibility* add_infeasibilities();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >&
      infeasibilities() const;
  // repeated .ISR.SolutionResponse.Matching matchings = 4;
  int matchings_size() const;
  private:
  int _internal_matchings_size() const;

  public:
  void clear_matchings() ;
  ::ISR::SolutionResponse_Matching* mutable_matchings(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >*
      mutable_matchings();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Matching>& _internal_matchings() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Matching>* _internal_mutable_matchings();
  public:
  const ::ISR::SolutionResponse_Matching& matchings(int index) const;
  ::ISR::SolutionResponse_Matching* add_matchings();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >&
      matchings() const;
  // repeated .ISR.SolutionResponse.Segment segments = 5;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  ::ISR::SolutionResponse_Segment* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >*
      mutable_segments();
  private:
  const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Segment>& _internal_segments() const;
  ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Segment>* _internal_mutable_segments();
  public:
  const ::ISR::SolutionResponse_Segment& segments(int index) const;
  ::ISR::SolutionResponse_Segment* add_segments();
  const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >&
      segments() const;
  // required float objective = 1;
  bool has_objective() const;
  void clear_objective() ;
  float objective() const;
  void set_objective(float value);

  private:
  float _internal_objective() const;
  void _internal_set_objective(float value);

  public:
  // @@protoc_insertion_point(class_scope:ISR.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 4, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route > routes_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility > infeasibilities_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching > matchings_;
    ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment > segments_;
    float objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_isr_2dz4foi53qznrv_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Configuration

// required .ISR.Configuration.eMeasurementUnit timeUnit = 1 [default = MINUTES];
inline bool Configuration::has_timeunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Configuration::clear_timeunit() {
  _impl_.timeunit_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ISR::Configuration_eMeasurementUnit Configuration::timeunit() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.timeUnit)
  return _internal_timeunit();
}
inline void Configuration::set_timeunit(::ISR::Configuration_eMeasurementUnit value) {
  _internal_set_timeunit(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.timeUnit)
}
inline ::ISR::Configuration_eMeasurementUnit Configuration::_internal_timeunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ISR::Configuration_eMeasurementUnit>(_impl_.timeunit_);
}
inline void Configuration::_internal_set_timeunit(::ISR::Configuration_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ISR::Configuration_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timeunit_ = value;
}

// required float timeCoef = 2 [default = 1];
inline bool Configuration::has_timecoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Configuration::clear_timecoef() {
  _impl_.timecoef_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Configuration::timecoef() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.timeCoef)
  return _internal_timecoef();
}
inline void Configuration::set_timecoef(float value) {
  _internal_set_timecoef(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.timeCoef)
}
inline float Configuration::_internal_timecoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timecoef_;
}
inline void Configuration::_internal_set_timecoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timecoef_ = value;
}

// required float timeCostCoef = 3 [default = 1];
inline bool Configuration::has_timecostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Configuration::clear_timecostcoef() {
  _impl_.timecostcoef_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Configuration::timecostcoef() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.timeCostCoef)
  return _internal_timecostcoef();
}
inline void Configuration::set_timecostcoef(float value) {
  _internal_set_timecostcoef(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.timeCostCoef)
}
inline float Configuration::_internal_timecostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timecostcoef_;
}
inline void Configuration::_internal_set_timecostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.timecostcoef_ = value;
}

// required .ISR.Configuration.eMeasurementUnit distanceUnit = 4 [default = KILOMETRES];
inline bool Configuration::has_distanceunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Configuration::clear_distanceunit() {
  _impl_.distanceunit_ = 4;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::ISR::Configuration_eMeasurementUnit Configuration::distanceunit() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.distanceUnit)
  return _internal_distanceunit();
}
inline void Configuration::set_distanceunit(::ISR::Configuration_eMeasurementUnit value) {
  _internal_set_distanceunit(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.distanceUnit)
}
inline ::ISR::Configuration_eMeasurementUnit Configuration::_internal_distanceunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ISR::Configuration_eMeasurementUnit>(_impl_.distanceunit_);
}
inline void Configuration::_internal_set_distanceunit(::ISR::Configuration_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ISR::Configuration_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.distanceunit_ = value;
}

// required float distanceCostCoef = 5 [default = 1];
inline bool Configuration::has_distancecostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Configuration::clear_distancecostcoef() {
  _impl_.distancecostcoef_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Configuration::distancecostcoef() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.distanceCostCoef)
  return _internal_distancecostcoef();
}
inline void Configuration::set_distancecostcoef(float value) {
  _internal_set_distancecostcoef(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.distanceCostCoef)
}
inline float Configuration::_internal_distancecostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distancecostcoef_;
}
inline void Configuration::_internal_set_distancecostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.distancecostcoef_ = value;
}

// required .ISR.Configuration.eDrivingSide drivingSide = 6;
inline bool Configuration::has_drivingside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Configuration::clear_drivingside() {
  _impl_.drivingside_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::ISR::Configuration_eDrivingSide Configuration::drivingside() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.drivingSide)
  return _internal_drivingside();
}
inline void Configuration::set_drivingside(::ISR::Configuration_eDrivingSide value) {
  _internal_set_drivingside(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.drivingSide)
}
inline ::ISR::Configuration_eDrivingSide Configuration::_internal_drivingside() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ISR::Configuration_eDrivingSide>(_impl_.drivingside_);
}
inline void Configuration::_internal_set_drivingside(::ISR::Configuration_eDrivingSide value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ISR::Configuration_eDrivingSide_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.drivingside_ = value;
}

// required .ISR.Configuration.eCollectionSide collectionSide = 7;
inline bool Configuration::has_collectionside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Configuration::clear_collectionside() {
  _impl_.collectionside_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ISR::Configuration_eCollectionSide Configuration::collectionside() const {
  // @@protoc_insertion_point(field_get:ISR.Configuration.collectionSide)
  return _internal_collectionside();
}
inline void Configuration::set_collectionside(::ISR::Configuration_eCollectionSide value) {
  _internal_set_collectionside(value);
  // @@protoc_insertion_point(field_set:ISR.Configuration.collectionSide)
}
inline ::ISR::Configuration_eCollectionSide Configuration::_internal_collectionside() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ISR::Configuration_eCollectionSide>(_impl_.collectionside_);
}
inline void Configuration::_internal_set_collectionside(::ISR::Configuration_eCollectionSide value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ISR::Configuration_eCollectionSide_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.collectionside_ = value;
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:ISR.Geocode.longitude)
  return _internal_longitude();
}
inline void Geocode::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:ISR.Geocode.longitude)
}
inline float Geocode::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Geocode::_internal_set_longitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_ = value;
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:ISR.Geocode.latitude)
  return _internal_latitude();
}
inline void Geocode::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:ISR.Geocode.latitude)
}
inline float Geocode::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Geocode::_internal_set_latitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// OffloadSite

// required string id = 1;
inline bool OffloadSite::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OffloadSite::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OffloadSite::id() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OffloadSite::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.OffloadSite.id)
}
inline std::string* OffloadSite::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISR.OffloadSite.id)
  return _s;
}
inline const std::string& OffloadSite::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void OffloadSite::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* OffloadSite::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* OffloadSite::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.OffloadSite.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OffloadSite::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.OffloadSite.id)
}

// required .ISR.Geocode location = 2;
inline bool OffloadSite::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void OffloadSite::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ISR::Geocode& OffloadSite::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Geocode* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Geocode&>(::ISR::_Geocode_default_instance_);
}
inline const ::ISR::Geocode& OffloadSite::location() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.location)
  return _internal_location();
}
inline void OffloadSite::unsafe_arena_set_allocated_location(::ISR::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.OffloadSite.location)
}
inline ::ISR::Geocode* OffloadSite::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Geocode* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Geocode* OffloadSite::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.OffloadSite.location)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Geocode* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::ISR::Geocode* OffloadSite::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaForAllocation());
    _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(p);
  }
  return _impl_.location_;
}
inline ::ISR::Geocode* OffloadSite::mutable_location() {
  ::ISR::Geocode* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ISR.OffloadSite.location)
  return _msg;
}
inline void OffloadSite::set_allocated_location(::ISR::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Geocode*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.OffloadSite.location)
}

// required float fixedOffloadTime = 3 [default = 0];
inline bool OffloadSite::has_fixedoffloadtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void OffloadSite::clear_fixedoffloadtime() {
  _impl_.fixedoffloadtime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float OffloadSite::fixedoffloadtime() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.fixedOffloadTime)
  return _internal_fixedoffloadtime();
}
inline void OffloadSite::set_fixedoffloadtime(float value) {
  _internal_set_fixedoffloadtime(value);
  // @@protoc_insertion_point(field_set:ISR.OffloadSite.fixedOffloadTime)
}
inline float OffloadSite::_internal_fixedoffloadtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedoffloadtime_;
}
inline void OffloadSite::_internal_set_fixedoffloadtime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fixedoffloadtime_ = value;
}

// required float offloadTimePerQuantity = 4 [default = 0];
inline bool OffloadSite::has_offloadtimeperquantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void OffloadSite::clear_offloadtimeperquantity() {
  _impl_.offloadtimeperquantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float OffloadSite::offloadtimeperquantity() const {
  // @@protoc_insertion_point(field_get:ISR.OffloadSite.offloadTimePerQuantity)
  return _internal_offloadtimeperquantity();
}
inline void OffloadSite::set_offloadtimeperquantity(float value) {
  _internal_set_offloadtimeperquantity(value);
  // @@protoc_insertion_point(field_set:ISR.OffloadSite.offloadTimePerQuantity)
}
inline float OffloadSite::_internal_offloadtimeperquantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offloadtimeperquantity_;
}
inline void OffloadSite::_internal_set_offloadtimeperquantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.offloadtimeperquantity_ = value;
}

// -------------------------------------------------------------------

// Collection

// required string id = 1;
inline bool Collection::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Collection::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Collection::id() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Collection::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.Collection.id)
}
inline std::string* Collection::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISR.Collection.id)
  return _s;
}
inline const std::string& Collection::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Collection::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Collection::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Collection::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Collection.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Collection::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.Collection.id)
}

// required .ISR.Geocode location = 2;
inline bool Collection::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Collection::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ISR::Geocode& Collection::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Geocode* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Geocode&>(::ISR::_Geocode_default_instance_);
}
inline const ::ISR::Geocode& Collection::location() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.location)
  return _internal_location();
}
inline void Collection::unsafe_arena_set_allocated_location(::ISR::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.Collection.location)
}
inline ::ISR::Geocode* Collection::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ISR::Geocode* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Geocode* Collection::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Collection.location)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ISR::Geocode* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::ISR::Geocode* Collection::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaForAllocation());
    _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(p);
  }
  return _impl_.location_;
}
inline ::ISR::Geocode* Collection::mutable_location() {
  ::ISR::Geocode* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ISR.Collection.location)
  return _msg;
}
inline void Collection::set_allocated_location(::ISR::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Geocode*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.Collection.location)
}

// required float stopTime = 3 [default = 0];
inline bool Collection::has_stoptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Collection::clear_stoptime() {
  _impl_.stoptime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Collection::stoptime() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.stopTime)
  return _internal_stoptime();
}
inline void Collection::set_stoptime(float value) {
  _internal_set_stoptime(value);
  // @@protoc_insertion_point(field_set:ISR.Collection.stopTime)
}
inline float Collection::_internal_stoptime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stoptime_;
}
inline void Collection::_internal_set_stoptime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stoptime_ = value;
}

// required float quantity = 4 [default = 0];
inline bool Collection::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Collection::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Collection::quantity() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.quantity)
  return _internal_quantity();
}
inline void Collection::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:ISR.Collection.quantity)
}
inline float Collection::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Collection::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.quantity_ = value;
}

// required string offloadSiteId = 5;
inline bool Collection::has_offloadsiteid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Collection::clear_offloadsiteid() {
  _impl_.offloadsiteid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Collection::offloadsiteid() const {
  // @@protoc_insertion_point(field_get:ISR.Collection.offloadSiteId)
  return _internal_offloadsiteid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Collection::set_offloadsiteid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offloadsiteid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.Collection.offloadSiteId)
}
inline std::string* Collection::mutable_offloadsiteid() {
  std::string* _s = _internal_mutable_offloadsiteid();
  // @@protoc_insertion_point(field_mutable:ISR.Collection.offloadSiteId)
  return _s;
}
inline const std::string& Collection::_internal_offloadsiteid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offloadsiteid_.Get();
}
inline void Collection::_internal_set_offloadsiteid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offloadsiteid_.Set(value, GetArenaForAllocation());
}
inline std::string* Collection::_internal_mutable_offloadsiteid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.offloadsiteid_.Mutable( GetArenaForAllocation());
}
inline std::string* Collection::release_offloadsiteid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Collection.offloadSiteId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.offloadsiteid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offloadsiteid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Collection::set_allocated_offloadsiteid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.offloadsiteid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.offloadsiteid_.IsDefault()) {
          _impl_.offloadsiteid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.Collection.offloadSiteId)
}

// -------------------------------------------------------------------

// Vehicle

// required string id = 1;
inline bool Vehicle::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle::id() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.Vehicle.id)
}
inline std::string* Vehicle::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISR.Vehicle.id)
  return _s;
}
inline const std::string& Vehicle::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Vehicle::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Vehicle.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.Vehicle.id)
}

// required .ISR.Geocode startLocation = 2;
inline bool Vehicle::has_startlocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.startlocation_ != nullptr);
  return value;
}
inline void Vehicle::clear_startlocation() {
  if (_impl_.startlocation_ != nullptr) _impl_.startlocation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ISR::Geocode& Vehicle::_internal_startlocation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Geocode* p = _impl_.startlocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Geocode&>(::ISR::_Geocode_default_instance_);
}
inline const ::ISR::Geocode& Vehicle::startlocation() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.startLocation)
  return _internal_startlocation();
}
inline void Vehicle::unsafe_arena_set_allocated_startlocation(::ISR::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.startlocation_);
  }
  _impl_.startlocation_ = reinterpret_cast<::ISR::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.Vehicle.startLocation)
}
inline ::ISR::Geocode* Vehicle::release_startlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Geocode* released = _impl_.startlocation_;
  _impl_.startlocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Geocode* Vehicle::unsafe_arena_release_startlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Vehicle.startLocation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Geocode* temp = _impl_.startlocation_;
  _impl_.startlocation_ = nullptr;
  return temp;
}
inline ::ISR::Geocode* Vehicle::_internal_mutable_startlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.startlocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaForAllocation());
    _impl_.startlocation_ = reinterpret_cast<::ISR::Geocode*>(p);
  }
  return _impl_.startlocation_;
}
inline ::ISR::Geocode* Vehicle::mutable_startlocation() {
  ::ISR::Geocode* _msg = _internal_mutable_startlocation();
  // @@protoc_insertion_point(field_mutable:ISR.Vehicle.startLocation)
  return _msg;
}
inline void Vehicle::set_allocated_startlocation(::ISR::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Geocode*>(_impl_.startlocation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.startlocation_ = reinterpret_cast<::ISR::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.Vehicle.startLocation)
}

// required .ISR.Geocode endLocation = 3;
inline bool Vehicle::has_endlocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endlocation_ != nullptr);
  return value;
}
inline void Vehicle::clear_endlocation() {
  if (_impl_.endlocation_ != nullptr) _impl_.endlocation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ISR::Geocode& Vehicle::_internal_endlocation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Geocode* p = _impl_.endlocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Geocode&>(::ISR::_Geocode_default_instance_);
}
inline const ::ISR::Geocode& Vehicle::endlocation() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.endLocation)
  return _internal_endlocation();
}
inline void Vehicle::unsafe_arena_set_allocated_endlocation(::ISR::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endlocation_);
  }
  _impl_.endlocation_ = reinterpret_cast<::ISR::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.Vehicle.endLocation)
}
inline ::ISR::Geocode* Vehicle::release_endlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ISR::Geocode* released = _impl_.endlocation_;
  _impl_.endlocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Geocode* Vehicle::unsafe_arena_release_endlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Vehicle.endLocation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ISR::Geocode* temp = _impl_.endlocation_;
  _impl_.endlocation_ = nullptr;
  return temp;
}
inline ::ISR::Geocode* Vehicle::_internal_mutable_endlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.endlocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaForAllocation());
    _impl_.endlocation_ = reinterpret_cast<::ISR::Geocode*>(p);
  }
  return _impl_.endlocation_;
}
inline ::ISR::Geocode* Vehicle::mutable_endlocation() {
  ::ISR::Geocode* _msg = _internal_mutable_endlocation();
  // @@protoc_insertion_point(field_mutable:ISR.Vehicle.endLocation)
  return _msg;
}
inline void Vehicle::set_allocated_endlocation(::ISR::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Geocode*>(_impl_.endlocation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.endlocation_ = reinterpret_cast<::ISR::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.Vehicle.endLocation)
}

// required float startTime = 4;
inline bool Vehicle::has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Vehicle::clear_starttime() {
  _impl_.starttime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Vehicle::starttime() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.startTime)
  return _internal_starttime();
}
inline void Vehicle::set_starttime(float value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:ISR.Vehicle.startTime)
}
inline float Vehicle::_internal_starttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.starttime_;
}
inline void Vehicle::_internal_set_starttime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.starttime_ = value;
}

// required float endTime = 5;
inline bool Vehicle::has_endtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Vehicle::clear_endtime() {
  _impl_.endtime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Vehicle::endtime() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.endTime)
  return _internal_endtime();
}
inline void Vehicle::set_endtime(float value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:ISR.Vehicle.endTime)
}
inline float Vehicle::_internal_endtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endtime_;
}
inline void Vehicle::_internal_set_endtime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.endtime_ = value;
}

// required float capacity = 6;
inline bool Vehicle::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Vehicle::clear_capacity() {
  _impl_.capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Vehicle::capacity() const {
  // @@protoc_insertion_point(field_get:ISR.Vehicle.capacity)
  return _internal_capacity();
}
inline void Vehicle::set_capacity(float value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:ISR.Vehicle.capacity)
}
inline float Vehicle::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void Vehicle::_internal_set_capacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.capacity_ = value;
}

// -------------------------------------------------------------------

// CollectionSequence

// required string vehicleId = 1;
inline bool CollectionSequence::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollectionSequence::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollectionSequence::vehicleid() const {
  // @@protoc_insertion_point(field_get:ISR.CollectionSequence.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollectionSequence::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.CollectionSequence.vehicleId)
}
inline std::string* CollectionSequence::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:ISR.CollectionSequence.vehicleId)
  return _s;
}
inline const std::string& CollectionSequence::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void CollectionSequence::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectionSequence::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* CollectionSequence::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.CollectionSequence.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollectionSequence::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.CollectionSequence.vehicleId)
}

// repeated string collectionId = 2;
inline int CollectionSequence::_internal_collectionid_size() const {
  return _internal_collectionid().size();
}
inline int CollectionSequence::collectionid_size() const {
  return _internal_collectionid_size();
}
inline void CollectionSequence::clear_collectionid() {
  _internal_mutable_collectionid()->Clear();
}
inline std::string* CollectionSequence::add_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_collectionid()->Add();
  // @@protoc_insertion_point(field_add_mutable:ISR.CollectionSequence.collectionId)
  return _s;
}
inline const std::string& CollectionSequence::collectionid(int index) const {
  // @@protoc_insertion_point(field_get:ISR.CollectionSequence.collectionId)
  return _internal_collectionid().Get(index);
}
inline std::string* CollectionSequence::mutable_collectionid(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.CollectionSequence.collectionId)
  return _internal_mutable_collectionid()->Mutable(index);
}
inline void CollectionSequence::set_collectionid(int index, const std::string& value) {
  _internal_mutable_collectionid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::set_collectionid(int index, std::string&& value) {
  _internal_mutable_collectionid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::set_collectionid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_collectionid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::set_collectionid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_collectionid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::set_collectionid(int index, absl::string_view value) {
  _internal_mutable_collectionid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::add_collectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collectionid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::add_collectionid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collectionid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::add_collectionid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collectionid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::add_collectionid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collectionid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ISR.CollectionSequence.collectionId)
}
inline void CollectionSequence::add_collectionid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_collectionid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ISR.CollectionSequence.collectionId)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollectionSequence::collectionid() const {
  // @@protoc_insertion_point(field_list:ISR.CollectionSequence.collectionId)
  return _internal_collectionid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* CollectionSequence::mutable_collectionid() {
  // @@protoc_insertion_point(field_mutable_list:ISR.CollectionSequence.collectionId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_collectionid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollectionSequence::_internal_collectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collectionid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollectionSequence::_internal_mutable_collectionid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.collectionid_;
}

// -------------------------------------------------------------------

// Model

// required .ISR.Configuration configuration = 1;
inline bool Model::has_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.configuration_ != nullptr);
  return value;
}
inline void Model::clear_configuration() {
  if (_impl_.configuration_ != nullptr) _impl_.configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ISR::Configuration& Model::_internal_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Configuration* p = _impl_.configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Configuration&>(::ISR::_Configuration_default_instance_);
}
inline const ::ISR::Configuration& Model::configuration() const {
  // @@protoc_insertion_point(field_get:ISR.Model.configuration)
  return _internal_configuration();
}
inline void Model::unsafe_arena_set_allocated_configuration(::ISR::Configuration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.configuration_);
  }
  _impl_.configuration_ = reinterpret_cast<::ISR::Configuration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.Model.configuration)
}
inline ::ISR::Configuration* Model::release_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ISR::Configuration* released = _impl_.configuration_;
  _impl_.configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Configuration* Model::unsafe_arena_release_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.Model.configuration)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ISR::Configuration* temp = _impl_.configuration_;
  _impl_.configuration_ = nullptr;
  return temp;
}
inline ::ISR::Configuration* Model::_internal_mutable_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Configuration>(GetArenaForAllocation());
    _impl_.configuration_ = reinterpret_cast<::ISR::Configuration*>(p);
  }
  return _impl_.configuration_;
}
inline ::ISR::Configuration* Model::mutable_configuration() {
  ::ISR::Configuration* _msg = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:ISR.Model.configuration)
  return _msg;
}
inline void Model::set_allocated_configuration(::ISR::Configuration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Configuration*>(_impl_.configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Configuration*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.configuration_ = reinterpret_cast<::ISR::Configuration*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.Model.configuration)
}

// repeated .ISR.Collection collections = 2;
inline int Model::_internal_collections_size() const {
  return _internal_collections().size();
}
inline int Model::collections_size() const {
  return _internal_collections_size();
}
inline void Model::clear_collections() {
  _internal_mutable_collections()->Clear();
}
inline ::ISR::Collection* Model::mutable_collections(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.collections)
  return _internal_mutable_collections()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Collection >*
Model::mutable_collections() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.collections)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_collections();
}
inline const ::ISR::Collection& Model::collections(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.collections)
    return _internal_collections().Get(index);
}
inline ::ISR::Collection* Model::add_collections() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::Collection* _add = _internal_mutable_collections()->Add();
  // @@protoc_insertion_point(field_add:ISR.Model.collections)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Collection >&
Model::collections() const {
  // @@protoc_insertion_point(field_list:ISR.Model.collections)
  return _internal_collections();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::Collection>&
Model::_internal_collections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collections_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::Collection>*
Model::_internal_mutable_collections() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.collections_;
}

// repeated .ISR.OffloadSite offloadSites = 3;
inline int Model::_internal_offloadsites_size() const {
  return _internal_offloadsites().size();
}
inline int Model::offloadsites_size() const {
  return _internal_offloadsites_size();
}
inline void Model::clear_offloadsites() {
  _internal_mutable_offloadsites()->Clear();
}
inline ::ISR::OffloadSite* Model::mutable_offloadsites(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.offloadSites)
  return _internal_mutable_offloadsites()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >*
Model::mutable_offloadsites() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.offloadSites)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_offloadsites();
}
inline const ::ISR::OffloadSite& Model::offloadsites(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.offloadSites)
    return _internal_offloadsites().Get(index);
}
inline ::ISR::OffloadSite* Model::add_offloadsites() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::OffloadSite* _add = _internal_mutable_offloadsites()->Add();
  // @@protoc_insertion_point(field_add:ISR.Model.offloadSites)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::OffloadSite >&
Model::offloadsites() const {
  // @@protoc_insertion_point(field_list:ISR.Model.offloadSites)
  return _internal_offloadsites();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::OffloadSite>&
Model::_internal_offloadsites() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offloadsites_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::OffloadSite>*
Model::_internal_mutable_offloadsites() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.offloadsites_;
}

// repeated .ISR.Vehicle vehicles = 4;
inline int Model::_internal_vehicles_size() const {
  return _internal_vehicles().size();
}
inline int Model::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void Model::clear_vehicles() {
  _internal_mutable_vehicles()->Clear();
}
inline ::ISR::Vehicle* Model::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.vehicles)
  return _internal_mutable_vehicles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >*
Model::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.vehicles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicles();
}
inline const ::ISR::Vehicle& Model::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.vehicles)
    return _internal_vehicles().Get(index);
}
inline ::ISR::Vehicle* Model::add_vehicles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::Vehicle* _add = _internal_mutable_vehicles()->Add();
  // @@protoc_insertion_point(field_add:ISR.Model.vehicles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Vehicle >&
Model::vehicles() const {
  // @@protoc_insertion_point(field_list:ISR.Model.vehicles)
  return _internal_vehicles();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::Vehicle>&
Model::_internal_vehicles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicles_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::Vehicle>*
Model::_internal_mutable_vehicles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicles_;
}

// repeated .ISR.CollectionSequence collectionSequence = 5;
inline int Model::_internal_collectionsequence_size() const {
  return _internal_collectionsequence().size();
}
inline int Model::collectionsequence_size() const {
  return _internal_collectionsequence_size();
}
inline void Model::clear_collectionsequence() {
  _internal_mutable_collectionsequence()->Clear();
}
inline ::ISR::CollectionSequence* Model::mutable_collectionsequence(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.Model.collectionSequence)
  return _internal_mutable_collectionsequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
Model::mutable_collectionsequence() {
  // @@protoc_insertion_point(field_mutable_list:ISR.Model.collectionSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_collectionsequence();
}
inline const ::ISR::CollectionSequence& Model::collectionsequence(int index) const {
  // @@protoc_insertion_point(field_get:ISR.Model.collectionSequence)
    return _internal_collectionsequence().Get(index);
}
inline ::ISR::CollectionSequence* Model::add_collectionsequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::CollectionSequence* _add = _internal_mutable_collectionsequence()->Add();
  // @@protoc_insertion_point(field_add:ISR.Model.collectionSequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
Model::collectionsequence() const {
  // @@protoc_insertion_point(field_list:ISR.Model.collectionSequence)
  return _internal_collectionsequence();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>&
Model::_internal_collectionsequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collectionsequence_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>*
Model::_internal_mutable_collectionsequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.collectionsequence_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .ISR.Model model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ISR::Model& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Model&>(::ISR::_Model_default_instance_);
}
inline const ::ISR::Model& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::ISR::Model* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::ISR::Model*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.SolveRequest.model)
}
inline ::ISR::Model* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Model* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Model* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::ISR::Model* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Model>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::ISR::Model*>(p);
  }
  return _impl_.model_;
}
inline ::ISR::Model* SolveRequest::mutable_model() {
  ::ISR::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:ISR.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::ISR::Model* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Model*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Model*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::ISR::Model*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:ISR.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolveRequest.modelID)
}

// repeated .ISR.CollectionSequence routes = 3;
inline int SolveRequest::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolveRequest::routes_size() const {
  return _internal_routes_size();
}
inline void SolveRequest::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::ISR::CollectionSequence* SolveRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolveRequest.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >*
SolveRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolveRequest.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::ISR::CollectionSequence& SolveRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.routes)
    return _internal_routes().Get(index);
}
inline ::ISR::CollectionSequence* SolveRequest::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::CollectionSequence* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolveRequest.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::CollectionSequence >&
SolveRequest::routes() const {
  // @@protoc_insertion_point(field_list:ISR.SolveRequest.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>&
SolveRequest::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::CollectionSequence>*
SolveRequest::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// optional .ISR.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::ISR::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:ISR.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::ISR::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:ISR.SolveRequest.solveType)
}
inline ::ISR::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ISR::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::ISR::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ISR::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_StopAttribute

// required string dimId = 1;
inline bool SolutionResponse_StopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_StopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_StopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.dimId)
}
inline std::string* SolutionResponse_StopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.StopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_StopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_StopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.StopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_StopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.StopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_StopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_StopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_StopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.startValue)
}
inline float SolutionResponse_StopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_StopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_StopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_StopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.endValue)
}
inline float SolutionResponse_StopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_StopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_StopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.StopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_StopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.StopAttribute.cost)
}
inline float SolutionResponse_StopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStopAttribute

// required string dimId = 1;
inline bool SolutionResponse_InterStopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_InterStopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_InterStopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.dimId)
}
inline std::string* SolutionResponse_InterStopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.InterStopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_InterStopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_InterStopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.InterStopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_InterStopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.InterStopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_InterStopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_InterStopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_InterStopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.startValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_InterStopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_InterStopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_InterStopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.endValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_InterStopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_InterStopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_InterStopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStopAttribute.cost)
}
inline float SolutionResponse_InterStopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Stop

// required int32 id = 1;
inline bool SolutionResponse_Stop::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SolutionResponse_Stop::id() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.id)
  return _internal_id();
}
inline void SolutionResponse_Stop::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.id)
}
inline ::int32_t SolutionResponse_Stop::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SolutionResponse_Stop::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}

// required int32 sequence = 2;
inline bool SolutionResponse_Stop::has_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_sequence() {
  _impl_.sequence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SolutionResponse_Stop::sequence() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.sequence)
  return _internal_sequence();
}
inline void SolutionResponse_Stop::set_sequence(::int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.sequence)
}
inline ::int32_t SolutionResponse_Stop::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline void SolutionResponse_Stop::_internal_set_sequence(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sequence_ = value;
}

// optional string collectionId = 3;
inline bool SolutionResponse_Stop::has_collectionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_collectionid() {
  _impl_.collectionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Stop::collectionid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.collectionId)
  return _internal_collectionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_collectionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collectionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.collectionId)
}
inline std::string* SolutionResponse_Stop::mutable_collectionid() {
  std::string* _s = _internal_mutable_collectionid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.collectionId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_collectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collectionid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_collectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.collectionid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Stop.collectionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.collectionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.collectionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_collectionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.collectionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.collectionid_.IsDefault()) {
          _impl_.collectionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Stop.collectionId)
}

// optional string offloadSiteId = 4;
inline bool SolutionResponse_Stop::has_offloadsiteid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_offloadsiteid() {
  _impl_.offloadsiteid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Stop::offloadsiteid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.offloadSiteId)
  return _internal_offloadsiteid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_offloadsiteid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offloadsiteid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.offloadSiteId)
}
inline std::string* SolutionResponse_Stop::mutable_offloadsiteid() {
  std::string* _s = _internal_mutable_offloadsiteid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.offloadSiteId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_offloadsiteid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offloadsiteid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_offloadsiteid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offloadsiteid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_offloadsiteid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.offloadsiteid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_offloadsiteid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Stop.offloadSiteId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.offloadsiteid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offloadsiteid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_offloadsiteid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.offloadsiteid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.offloadsiteid_.IsDefault()) {
          _impl_.offloadsiteid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Stop.offloadSiteId)
}

// repeated .ISR.SolutionResponse.StopAttribute attributes = 5;
inline int SolutionResponse_Stop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_Stop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_Stop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::ISR::SolutionResponse_StopAttribute* SolutionResponse_Stop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >*
SolutionResponse_Stop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Stop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::ISR::SolutionResponse_StopAttribute& SolutionResponse_Stop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.attributes)
    return _internal_attributes().Get(index);
}
inline ::ISR::SolutionResponse_StopAttribute* SolutionResponse_Stop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_StopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Stop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_StopAttribute >&
SolutionResponse_Stop::attributes() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Stop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_StopAttribute>&
SolutionResponse_Stop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_StopAttribute>*
SolutionResponse_Stop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// optional int32 segmentId = 6;
inline bool SolutionResponse_Stop::has_segmentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_segmentid() {
  _impl_.segmentid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t SolutionResponse_Stop::segmentid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.segmentId)
  return _internal_segmentid();
}
inline void SolutionResponse_Stop::set_segmentid(::int32_t value) {
  _internal_set_segmentid(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Stop.segmentId)
}
inline ::int32_t SolutionResponse_Stop::_internal_segmentid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segmentid_;
}
inline void SolutionResponse_Stop::_internal_set_segmentid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.segmentid_ = value;
}

// required .ISR.Geocode location = 7;
inline bool SolutionResponse_Stop::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void SolutionResponse_Stop::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ISR::Geocode& SolutionResponse_Stop::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Geocode* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Geocode&>(::ISR::_Geocode_default_instance_);
}
inline const ::ISR::Geocode& SolutionResponse_Stop::location() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Stop.location)
  return _internal_location();
}
inline void SolutionResponse_Stop::unsafe_arena_set_allocated_location(::ISR::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.SolutionResponse.Stop.location)
}
inline ::ISR::Geocode* SolutionResponse_Stop::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ISR::Geocode* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Geocode* SolutionResponse_Stop::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Stop.location)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ISR::Geocode* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::ISR::Geocode* SolutionResponse_Stop::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaForAllocation());
    _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(p);
  }
  return _impl_.location_;
}
inline ::ISR::Geocode* SolutionResponse_Stop::mutable_location() {
  ::ISR::Geocode* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Stop.location)
  return _msg;
}
inline void SolutionResponse_Stop::set_allocated_location(::ISR::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Geocode*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.location_ = reinterpret_cast<::ISR::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Stop.location)
}

// -------------------------------------------------------------------

// SolutionResponse_InterStop

// required int32 fromStopId = 1;
inline bool SolutionResponse_InterStop::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SolutionResponse_InterStop::fromstopid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_InterStop::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStop.fromStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_InterStop::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 2;
inline bool SolutionResponse_InterStop::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_InterStop::tostopid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_InterStop::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.InterStop.toStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_InterStop::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tostopid_ = value;
}

// repeated .ISR.SolutionResponse.InterStopAttribute attributes = 3;
inline int SolutionResponse_InterStop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_InterStop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_InterStop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::ISR::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.InterStop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >*
SolutionResponse_InterStop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.InterStop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::ISR::SolutionResponse_InterStopAttribute& SolutionResponse_InterStop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.attributes)
    return _internal_attributes().Get(index);
}
inline ::ISR::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_InterStopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.InterStop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStopAttribute >&
SolutionResponse_InterStop::attributes() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.InterStop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStopAttribute>&
SolutionResponse_InterStop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStopAttribute>*
SolutionResponse_InterStop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .ISR.Geocode geometry = 4;
inline int SolutionResponse_InterStop::_internal_geometry_size() const {
  return _internal_geometry().size();
}
inline int SolutionResponse_InterStop::geometry_size() const {
  return _internal_geometry_size();
}
inline void SolutionResponse_InterStop::clear_geometry() {
  _internal_mutable_geometry()->Clear();
}
inline ::ISR::Geocode* SolutionResponse_InterStop::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.InterStop.geometry)
  return _internal_mutable_geometry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
SolutionResponse_InterStop::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.InterStop.geometry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometry();
}
inline const ::ISR::Geocode& SolutionResponse_InterStop::geometry(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.InterStop.geometry)
    return _internal_geometry().Get(index);
}
inline ::ISR::Geocode* SolutionResponse_InterStop::add_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::Geocode* _add = _internal_mutable_geometry()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.InterStop.geometry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
SolutionResponse_InterStop::geometry() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.InterStop.geometry)
  return _internal_geometry();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::Geocode>&
SolutionResponse_InterStop::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometry_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::Geocode>*
SolutionResponse_InterStop::_internal_mutable_geometry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string vehicleId = 1;
inline bool SolutionResponse_Route::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Route::vehicleid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Route.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Route::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Route.vehicleId)
}
inline std::string* SolutionResponse_Route::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Route.vehicleId)
  return _s;
}
inline const std::string& SolutionResponse_Route::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void SolutionResponse_Route::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Route.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Route::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Route.vehicleId)
}

// repeated .ISR.SolutionResponse.Stop stops = 2;
inline int SolutionResponse_Route::_internal_stops_size() const {
  return _internal_stops().size();
}
inline int SolutionResponse_Route::stops_size() const {
  return _internal_stops_size();
}
inline void SolutionResponse_Route::clear_stops() {
  _internal_mutable_stops()->Clear();
}
inline ::ISR::SolutionResponse_Stop* SolutionResponse_Route::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Route.stops)
  return _internal_mutable_stops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >*
SolutionResponse_Route::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Route.stops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stops();
}
inline const ::ISR::SolutionResponse_Stop& SolutionResponse_Route::stops(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Route.stops)
    return _internal_stops().Get(index);
}
inline ::ISR::SolutionResponse_Stop* SolutionResponse_Route::add_stops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_Stop* _add = _internal_mutable_stops()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Route.stops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Stop >&
SolutionResponse_Route::stops() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Route.stops)
  return _internal_stops();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Stop>&
SolutionResponse_Route::_internal_stops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stops_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Stop>*
SolutionResponse_Route::_internal_mutable_stops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stops_;
}

// repeated .ISR.SolutionResponse.InterStop interStops = 3;
inline int SolutionResponse_Route::_internal_interstops_size() const {
  return _internal_interstops().size();
}
inline int SolutionResponse_Route::interstops_size() const {
  return _internal_interstops_size();
}
inline void SolutionResponse_Route::clear_interstops() {
  _internal_mutable_interstops()->Clear();
}
inline ::ISR::SolutionResponse_InterStop* SolutionResponse_Route::mutable_interstops(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Route.interStops)
  return _internal_mutable_interstops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >*
SolutionResponse_Route::mutable_interstops() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Route.interStops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_interstops();
}
inline const ::ISR::SolutionResponse_InterStop& SolutionResponse_Route::interstops(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Route.interStops)
    return _internal_interstops().Get(index);
}
inline ::ISR::SolutionResponse_InterStop* SolutionResponse_Route::add_interstops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_InterStop* _add = _internal_mutable_interstops()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Route.interStops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_InterStop >&
SolutionResponse_Route::interstops() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Route.interStops)
  return _internal_interstops();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStop>&
SolutionResponse_Route::_internal_interstops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interstops_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_InterStop>*
SolutionResponse_Route::_internal_mutable_interstops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.interstops_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility_Info

// required string message = 1;
inline bool SolutionResponse_Infeasibility_Info::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::message() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.message)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.Info.message)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Infeasibility.Info.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Infeasibility.Info.message)
}

// optional string dimId = 2;
inline bool SolutionResponse_Infeasibility_Info::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::dimid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.dimId)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.Info.dimId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Infeasibility.Info.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Infeasibility.Info.dimId)
}

// optional float limit = 3;
inline bool SolutionResponse_Infeasibility_Info::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_limit() {
  _impl_.limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_Infeasibility_Info::limit() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.limit)
  return _internal_limit();
}
inline void SolutionResponse_Infeasibility_Info::set_limit(float value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.limit)
}
inline float SolutionResponse_Infeasibility_Info::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.limit_ = value;
}

// optional float value = 4;
inline bool SolutionResponse_Infeasibility_Info::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_Infeasibility_Info::value() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.value)
  return _internal_value();
}
inline void SolutionResponse_Infeasibility_Info::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.value)
}
inline float SolutionResponse_Infeasibility_Info::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.value_ = value;
}

// optional int64 count = 5;
inline bool SolutionResponse_Infeasibility_Info::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_count() {
  _impl_.count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SolutionResponse_Infeasibility_Info::count() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.count)
  return _internal_count();
}
inline void SolutionResponse_Infeasibility_Info::set_count(::int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.count)
}
inline ::int64_t SolutionResponse_Infeasibility_Info::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_count(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_ = value;
}

// repeated string constrainingCollectionIds = 6;
inline int SolutionResponse_Infeasibility_Info::_internal_constrainingcollectionids_size() const {
  return _internal_constrainingcollectionids().size();
}
inline int SolutionResponse_Infeasibility_Info::constrainingcollectionids_size() const {
  return _internal_constrainingcollectionids_size();
}
inline void SolutionResponse_Infeasibility_Info::clear_constrainingcollectionids() {
  _internal_mutable_constrainingcollectionids()->Clear();
}
inline std::string* SolutionResponse_Infeasibility_Info::add_constrainingcollectionids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_constrainingcollectionids()->Add();
  // @@protoc_insertion_point(field_add_mutable:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::constrainingcollectionids(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return _internal_constrainingcollectionids().Get(index);
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_constrainingcollectionids(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return _internal_mutable_constrainingcollectionids()->Mutable(index);
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, const std::string& value) {
  _internal_mutable_constrainingcollectionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, std::string&& value) {
  _internal_mutable_constrainingcollectionids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_constrainingcollectionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_constrainingcollectionids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingcollectionids(int index, absl::string_view value) {
  _internal_mutable_constrainingcollectionids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingcollectionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingcollectionids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingcollectionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingcollectionids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingcollectionids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingcollectionids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::constrainingcollectionids() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  return _internal_constrainingcollectionids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_Infeasibility_Info::mutable_constrainingcollectionids() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Infeasibility.Info.constrainingCollectionIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_constrainingcollectionids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::_internal_constrainingcollectionids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.constrainingcollectionids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_Infeasibility_Info::_internal_mutable_constrainingcollectionids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.constrainingcollectionids_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility

// required string collectionId = 1;
inline bool SolutionResponse_Infeasibility::has_collectionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility::clear_collectionid() {
  _impl_.collectionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility::collectionid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.collectionId)
  return _internal_collectionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility::set_collectionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collectionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Infeasibility.collectionId)
}
inline std::string* SolutionResponse_Infeasibility::mutable_collectionid() {
  std::string* _s = _internal_mutable_collectionid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.collectionId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility::_internal_collectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collectionid_.Get();
}
inline void SolutionResponse_Infeasibility::_internal_set_collectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::_internal_mutable_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.collectionid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::release_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Infeasibility.collectionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.collectionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.collectionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility::set_allocated_collectionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.collectionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.collectionid_.IsDefault()) {
          _impl_.collectionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Infeasibility.collectionId)
}

// repeated .ISR.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
inline int SolutionResponse_Infeasibility::_internal_infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo().size();
}
inline int SolutionResponse_Infeasibility::infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo_size();
}
inline void SolutionResponse_Infeasibility::clear_infeasibilityinfo() {
  _internal_mutable_infeasibilityinfo()->Clear();
}
inline ::ISR::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::mutable_infeasibilityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_mutable_infeasibilityinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >*
SolutionResponse_Infeasibility::mutable_infeasibilityinfo() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilityinfo();
}
inline const ::ISR::SolutionResponse_Infeasibility_Info& SolutionResponse_Infeasibility::infeasibilityinfo(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
    return _internal_infeasibilityinfo().Get(index);
}
inline ::ISR::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::add_infeasibilityinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_Infeasibility_Info* _add = _internal_mutable_infeasibilityinfo()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility_Info >&
SolutionResponse_Infeasibility::infeasibilityinfo() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_infeasibilityinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility_Info>&
SolutionResponse_Infeasibility::_internal_infeasibilityinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilityinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility_Info>*
SolutionResponse_Infeasibility::_internal_mutable_infeasibilityinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilityinfo_;
}

// -------------------------------------------------------------------

// SolutionResponse_Matching

// required string collectionId = 1;
inline bool SolutionResponse_Matching::has_collectionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Matching::clear_collectionid() {
  _impl_.collectionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Matching::collectionid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Matching.collectionId)
  return _internal_collectionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Matching::set_collectionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collectionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Matching.collectionId)
}
inline std::string* SolutionResponse_Matching::mutable_collectionid() {
  std::string* _s = _internal_mutable_collectionid();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Matching.collectionId)
  return _s;
}
inline const std::string& SolutionResponse_Matching::_internal_collectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collectionid_.Get();
}
inline void SolutionResponse_Matching::_internal_set_collectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Matching::_internal_mutable_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.collectionid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Matching::release_collectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Matching.collectionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.collectionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.collectionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Matching::set_allocated_collectionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.collectionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.collectionid_.IsDefault()) {
          _impl_.collectionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Matching.collectionId)
}

// required .ISR.Geocode collectionPoint = 2;
inline bool SolutionResponse_Matching::has_collectionpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.collectionpoint_ != nullptr);
  return value;
}
inline void SolutionResponse_Matching::clear_collectionpoint() {
  if (_impl_.collectionpoint_ != nullptr) _impl_.collectionpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ISR::Geocode& SolutionResponse_Matching::_internal_collectionpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ISR::Geocode* p = _impl_.collectionpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISR::Geocode&>(::ISR::_Geocode_default_instance_);
}
inline const ::ISR::Geocode& SolutionResponse_Matching::collectionpoint() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Matching.collectionPoint)
  return _internal_collectionpoint();
}
inline void SolutionResponse_Matching::unsafe_arena_set_allocated_collectionpoint(::ISR::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.collectionpoint_);
  }
  _impl_.collectionpoint_ = reinterpret_cast<::ISR::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISR.SolutionResponse.Matching.collectionPoint)
}
inline ::ISR::Geocode* SolutionResponse_Matching::release_collectionpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Geocode* released = _impl_.collectionpoint_;
  _impl_.collectionpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ISR::Geocode* SolutionResponse_Matching::unsafe_arena_release_collectionpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Matching.collectionPoint)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ISR::Geocode* temp = _impl_.collectionpoint_;
  _impl_.collectionpoint_ = nullptr;
  return temp;
}
inline ::ISR::Geocode* SolutionResponse_Matching::_internal_mutable_collectionpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.collectionpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISR::Geocode>(GetArenaForAllocation());
    _impl_.collectionpoint_ = reinterpret_cast<::ISR::Geocode*>(p);
  }
  return _impl_.collectionpoint_;
}
inline ::ISR::Geocode* SolutionResponse_Matching::mutable_collectionpoint() {
  ::ISR::Geocode* _msg = _internal_mutable_collectionpoint();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Matching.collectionPoint)
  return _msg;
}
inline void SolutionResponse_Matching::set_allocated_collectionpoint(::ISR::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ISR::Geocode*>(_impl_.collectionpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ISR::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.collectionpoint_ = reinterpret_cast<::ISR::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Matching.collectionPoint)
}

// required int32 segmentId = 3;
inline bool SolutionResponse_Matching::has_segmentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Matching::clear_segmentid() {
  _impl_.segmentid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SolutionResponse_Matching::segmentid() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Matching.segmentId)
  return _internal_segmentid();
}
inline void SolutionResponse_Matching::set_segmentid(::int32_t value) {
  _internal_set_segmentid(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Matching.segmentId)
}
inline ::int32_t SolutionResponse_Matching::_internal_segmentid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segmentid_;
}
inline void SolutionResponse_Matching::_internal_set_segmentid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.segmentid_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Segment

// required int32 id = 1;
inline bool SolutionResponse_Segment::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Segment::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_Segment::id() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.id)
  return _internal_id();
}
inline void SolutionResponse_Segment::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.id)
}
inline ::int32_t SolutionResponse_Segment::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SolutionResponse_Segment::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}

// required string name = 2;
inline bool SolutionResponse_Segment::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Segment::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Segment::name() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Segment::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.name)
}
inline std::string* SolutionResponse_Segment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Segment.name)
  return _s;
}
inline const std::string& SolutionResponse_Segment::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SolutionResponse_Segment::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Segment::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Segment::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ISR.SolutionResponse.Segment.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Segment::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISR.SolutionResponse.Segment.name)
}

// required float weight = 3;
inline bool SolutionResponse_Segment::has_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Segment::clear_weight() {
  _impl_.weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_Segment::weight() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.weight)
  return _internal_weight();
}
inline void SolutionResponse_Segment::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.weight)
}
inline float SolutionResponse_Segment::_internal_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_;
}
inline void SolutionResponse_Segment::_internal_set_weight(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.weight_ = value;
}

// required float duration = 4;
inline bool SolutionResponse_Segment::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Segment::clear_duration() {
  _impl_.duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_Segment::duration() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.duration)
  return _internal_duration();
}
inline void SolutionResponse_Segment::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.Segment.duration)
}
inline float SolutionResponse_Segment::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void SolutionResponse_Segment::_internal_set_duration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.duration_ = value;
}

// repeated .ISR.Geocode geometry = 5;
inline int SolutionResponse_Segment::_internal_geometry_size() const {
  return _internal_geometry().size();
}
inline int SolutionResponse_Segment::geometry_size() const {
  return _internal_geometry_size();
}
inline void SolutionResponse_Segment::clear_geometry() {
  _internal_mutable_geometry()->Clear();
}
inline ::ISR::Geocode* SolutionResponse_Segment::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.Segment.geometry)
  return _internal_mutable_geometry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >*
SolutionResponse_Segment::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.Segment.geometry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometry();
}
inline const ::ISR::Geocode& SolutionResponse_Segment::geometry(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.Segment.geometry)
    return _internal_geometry().Get(index);
}
inline ::ISR::Geocode* SolutionResponse_Segment::add_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::Geocode* _add = _internal_mutable_geometry()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.Segment.geometry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::Geocode >&
SolutionResponse_Segment::geometry() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.Segment.geometry)
  return _internal_geometry();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::Geocode>&
SolutionResponse_Segment::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometry_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::Geocode>*
SolutionResponse_Segment::_internal_mutable_geometry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse

// required float objective = 1;
inline bool SolutionResponse::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse::clear_objective() {
  _impl_.objective_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.objective)
  return _internal_objective();
}
inline void SolutionResponse::set_objective(float value) {
  _internal_set_objective(value);
  // @@protoc_insertion_point(field_set:ISR.SolutionResponse.objective)
}
inline float SolutionResponse::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objective_;
}
inline void SolutionResponse::_internal_set_objective(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.objective_ = value;
}

// repeated .ISR.SolutionResponse.Route routes = 2;
inline int SolutionResponse::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolutionResponse::routes_size() const {
  return _internal_routes_size();
}
inline void SolutionResponse::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::ISR::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::ISR::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.routes)
    return _internal_routes().Get(index);
}
inline ::ISR::SolutionResponse_Route* SolutionResponse::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_Route* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Route>&
SolutionResponse::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Route>*
SolutionResponse::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// repeated .ISR.SolutionResponse.Infeasibility infeasibilities = 3;
inline int SolutionResponse::_internal_infeasibilities_size() const {
  return _internal_infeasibilities().size();
}
inline int SolutionResponse::infeasibilities_size() const {
  return _internal_infeasibilities_size();
}
inline void SolutionResponse::clear_infeasibilities() {
  _internal_mutable_infeasibilities()->Clear();
}
inline ::ISR::SolutionResponse_Infeasibility* SolutionResponse::mutable_infeasibilities(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.infeasibilities)
  return _internal_mutable_infeasibilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >*
SolutionResponse::mutable_infeasibilities() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.infeasibilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilities();
}
inline const ::ISR::SolutionResponse_Infeasibility& SolutionResponse::infeasibilities(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.infeasibilities)
    return _internal_infeasibilities().Get(index);
}
inline ::ISR::SolutionResponse_Infeasibility* SolutionResponse::add_infeasibilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_Infeasibility* _add = _internal_mutable_infeasibilities()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.infeasibilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Infeasibility >&
SolutionResponse::infeasibilities() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.infeasibilities)
  return _internal_infeasibilities();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility>&
SolutionResponse::_internal_infeasibilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilities_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Infeasibility>*
SolutionResponse::_internal_mutable_infeasibilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilities_;
}

// repeated .ISR.SolutionResponse.Matching matchings = 4;
inline int SolutionResponse::_internal_matchings_size() const {
  return _internal_matchings().size();
}
inline int SolutionResponse::matchings_size() const {
  return _internal_matchings_size();
}
inline void SolutionResponse::clear_matchings() {
  _internal_mutable_matchings()->Clear();
}
inline ::ISR::SolutionResponse_Matching* SolutionResponse::mutable_matchings(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.matchings)
  return _internal_mutable_matchings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >*
SolutionResponse::mutable_matchings() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.matchings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_matchings();
}
inline const ::ISR::SolutionResponse_Matching& SolutionResponse::matchings(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.matchings)
    return _internal_matchings().Get(index);
}
inline ::ISR::SolutionResponse_Matching* SolutionResponse::add_matchings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_Matching* _add = _internal_mutable_matchings()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.matchings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Matching >&
SolutionResponse::matchings() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.matchings)
  return _internal_matchings();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Matching>&
SolutionResponse::_internal_matchings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matchings_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Matching>*
SolutionResponse::_internal_mutable_matchings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.matchings_;
}

// repeated .ISR.SolutionResponse.Segment segments = 5;
inline int SolutionResponse::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int SolutionResponse::segments_size() const {
  return _internal_segments_size();
}
inline void SolutionResponse::clear_segments() {
  _internal_mutable_segments()->Clear();
}
inline ::ISR::SolutionResponse_Segment* SolutionResponse::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:ISR.SolutionResponse.segments)
  return _internal_mutable_segments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >*
SolutionResponse::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:ISR.SolutionResponse.segments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_segments();
}
inline const ::ISR::SolutionResponse_Segment& SolutionResponse::segments(int index) const {
  // @@protoc_insertion_point(field_get:ISR.SolutionResponse.segments)
    return _internal_segments().Get(index);
}
inline ::ISR::SolutionResponse_Segment* SolutionResponse::add_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ISR::SolutionResponse_Segment* _add = _internal_mutable_segments()->Add();
  // @@protoc_insertion_point(field_add:ISR.SolutionResponse.segments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ISR::SolutionResponse_Segment >&
SolutionResponse::segments() const {
  // @@protoc_insertion_point(field_list:ISR.SolutionResponse.segments)
  return _internal_segments();
}
inline const ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Segment>&
SolutionResponse::_internal_segments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segments_;
}
inline ::google::protobuf::RepeatedPtrField<::ISR::SolutionResponse_Segment>*
SolutionResponse::_internal_mutable_segments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.segments_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ISR


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ISR::Configuration_eMeasurementUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ISR::Configuration_eMeasurementUnit>() {
  return ::ISR::Configuration_eMeasurementUnit_descriptor();
}
template <>
struct is_proto_enum<::ISR::Configuration_eDrivingSide> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ISR::Configuration_eDrivingSide>() {
  return ::ISR::Configuration_eDrivingSide_descriptor();
}
template <>
struct is_proto_enum<::ISR::Configuration_eCollectionSide> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ISR::Configuration_eCollectionSide>() {
  return ::ISR::Configuration_eCollectionSide_descriptor();
}
template <>
struct is_proto_enum<::ISR::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ISR::SolveRequest_SolveType>() {
  return ::ISR::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_isr_2dz4foi53qznrv_2eproto_2epb_2eh
