// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ndd-cmibu6krtqja.proto

#ifndef PROTOBUF_INCLUDED_ndd_2dcmibu6krtqja_2eproto
#define PROTOBUF_INCLUDED_ndd_2dcmibu6krtqja_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ndd_2dcmibu6krtqja_2eproto 

namespace protobuf_ndd_2dcmibu6krtqja_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[41];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ndd_2dcmibu6krtqja_2eproto
namespace NDD {
class CapacityDimension;
class CapacityDimensionDefaultTypeInternal;
extern CapacityDimensionDefaultTypeInternal _CapacityDimension_default_instance_;
class DimensionConfiguration;
class DimensionConfigurationDefaultTypeInternal;
extern DimensionConfigurationDefaultTypeInternal _DimensionConfiguration_default_instance_;
class Geocode;
class GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class InternalDimension;
class InternalDimensionDefaultTypeInternal;
extern InternalDimensionDefaultTypeInternal _InternalDimension_default_instance_;
class Job;
class JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class Job_Task;
class Job_TaskDefaultTypeInternal;
extern Job_TaskDefaultTypeInternal _Job_Task_default_instance_;
class Job_Task_Attribute;
class Job_Task_AttributeDefaultTypeInternal;
extern Job_Task_AttributeDefaultTypeInternal _Job_Task_Attribute_default_instance_;
class Job_VehicleRelation;
class Job_VehicleRelationDefaultTypeInternal;
extern Job_VehicleRelationDefaultTypeInternal _Job_VehicleRelation_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Location_Attribute;
class Location_AttributeDefaultTypeInternal;
extern Location_AttributeDefaultTypeInternal _Location_Attribute_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Profile;
class ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class Profile_customCycle;
class Profile_customCycleDefaultTypeInternal;
extern Profile_customCycleDefaultTypeInternal _Profile_customCycle_default_instance_;
class SolutionResponse;
class SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_CompactSolution;
class SolutionResponse_CompactSolutionDefaultTypeInternal;
extern SolutionResponse_CompactSolutionDefaultTypeInternal _SolutionResponse_CompactSolution_default_instance_;
class SolutionResponse_Infeasibility;
class SolutionResponse_InfeasibilityDefaultTypeInternal;
extern SolutionResponse_InfeasibilityDefaultTypeInternal _SolutionResponse_Infeasibility_default_instance_;
class SolutionResponse_Infeasibility_Info;
class SolutionResponse_Infeasibility_InfoDefaultTypeInternal;
extern SolutionResponse_Infeasibility_InfoDefaultTypeInternal _SolutionResponse_Infeasibility_Info_default_instance_;
class SolutionResponse_InterStop;
class SolutionResponse_InterStopDefaultTypeInternal;
extern SolutionResponse_InterStopDefaultTypeInternal _SolutionResponse_InterStop_default_instance_;
class SolutionResponse_InterStopAttribute;
class SolutionResponse_InterStopAttributeDefaultTypeInternal;
extern SolutionResponse_InterStopAttributeDefaultTypeInternal _SolutionResponse_InterStopAttribute_default_instance_;
class SolutionResponse_Route;
class SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolutionResponse_SolutionInstance;
class SolutionResponse_SolutionInstanceDefaultTypeInternal;
extern SolutionResponse_SolutionInstanceDefaultTypeInternal _SolutionResponse_SolutionInstance_default_instance_;
class SolutionResponse_Stop;
class SolutionResponse_StopDefaultTypeInternal;
extern SolutionResponse_StopDefaultTypeInternal _SolutionResponse_Stop_default_instance_;
class SolutionResponse_StopAttribute;
class SolutionResponse_StopAttributeDefaultTypeInternal;
extern SolutionResponse_StopAttributeDefaultTypeInternal _SolutionResponse_StopAttribute_default_instance_;
class SolutionResponse_TransitRuleAttribute;
class SolutionResponse_TransitRuleAttributeDefaultTypeInternal;
extern SolutionResponse_TransitRuleAttributeDefaultTypeInternal _SolutionResponse_TransitRuleAttribute_default_instance_;
class SolveRequest;
class SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class TaskSequence;
class TaskSequenceDefaultTypeInternal;
extern TaskSequenceDefaultTypeInternal _TaskSequence_default_instance_;
class TransitGenerator;
class TransitGeneratorDefaultTypeInternal;
extern TransitGeneratorDefaultTypeInternal _TransitGenerator_default_instance_;
class TransitRule;
class TransitRuleDefaultTypeInternal;
extern TransitRuleDefaultTypeInternal _TransitRule_default_instance_;
class TransitRule_Trigger;
class TransitRule_TriggerDefaultTypeInternal;
extern TransitRule_TriggerDefaultTypeInternal _TransitRule_Trigger_default_instance_;
class TransitSet;
class TransitSetDefaultTypeInternal;
extern TransitSetDefaultTypeInternal _TransitSet_default_instance_;
class TransitSet_TransitValue;
class TransitSet_TransitValueDefaultTypeInternal;
extern TransitSet_TransitValueDefaultTypeInternal _TransitSet_TransitValue_default_instance_;
class Vehicle;
class VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
class VehicleClass;
class VehicleClassDefaultTypeInternal;
extern VehicleClassDefaultTypeInternal _VehicleClass_default_instance_;
class VehicleClass_Attribute;
class VehicleClass_AttributeDefaultTypeInternal;
extern VehicleClass_AttributeDefaultTypeInternal _VehicleClass_Attribute_default_instance_;
class VehicleCostClass;
class VehicleCostClassDefaultTypeInternal;
extern VehicleCostClassDefaultTypeInternal _VehicleCostClass_default_instance_;
class VehicleCostClass_Attribute;
class VehicleCostClass_AttributeDefaultTypeInternal;
extern VehicleCostClass_AttributeDefaultTypeInternal _VehicleCostClass_Attribute_default_instance_;
class Vehicle_Capacity;
class Vehicle_CapacityDefaultTypeInternal;
extern Vehicle_CapacityDefaultTypeInternal _Vehicle_Capacity_default_instance_;
class Vehicle_Shift;
class Vehicle_ShiftDefaultTypeInternal;
extern Vehicle_ShiftDefaultTypeInternal _Vehicle_Shift_default_instance_;
class Vehicle_Task;
class Vehicle_TaskDefaultTypeInternal;
extern Vehicle_TaskDefaultTypeInternal _Vehicle_Task_default_instance_;
class Vehicle_Task_Attribute;
class Vehicle_Task_AttributeDefaultTypeInternal;
extern Vehicle_Task_AttributeDefaultTypeInternal _Vehicle_Task_Attribute_default_instance_;
class Window;
class WindowDefaultTypeInternal;
extern WindowDefaultTypeInternal _Window_default_instance_;
}  // namespace NDD
namespace google {
namespace protobuf {
template<> ::NDD::CapacityDimension* Arena::CreateMaybeMessage<::NDD::CapacityDimension>(Arena*);
template<> ::NDD::DimensionConfiguration* Arena::CreateMaybeMessage<::NDD::DimensionConfiguration>(Arena*);
template<> ::NDD::Geocode* Arena::CreateMaybeMessage<::NDD::Geocode>(Arena*);
template<> ::NDD::InternalDimension* Arena::CreateMaybeMessage<::NDD::InternalDimension>(Arena*);
template<> ::NDD::Job* Arena::CreateMaybeMessage<::NDD::Job>(Arena*);
template<> ::NDD::Job_Task* Arena::CreateMaybeMessage<::NDD::Job_Task>(Arena*);
template<> ::NDD::Job_Task_Attribute* Arena::CreateMaybeMessage<::NDD::Job_Task_Attribute>(Arena*);
template<> ::NDD::Job_VehicleRelation* Arena::CreateMaybeMessage<::NDD::Job_VehicleRelation>(Arena*);
template<> ::NDD::Location* Arena::CreateMaybeMessage<::NDD::Location>(Arena*);
template<> ::NDD::Location_Attribute* Arena::CreateMaybeMessage<::NDD::Location_Attribute>(Arena*);
template<> ::NDD::Model* Arena::CreateMaybeMessage<::NDD::Model>(Arena*);
template<> ::NDD::Profile* Arena::CreateMaybeMessage<::NDD::Profile>(Arena*);
template<> ::NDD::Profile_customCycle* Arena::CreateMaybeMessage<::NDD::Profile_customCycle>(Arena*);
template<> ::NDD::SolutionResponse* Arena::CreateMaybeMessage<::NDD::SolutionResponse>(Arena*);
template<> ::NDD::SolutionResponse_CompactSolution* Arena::CreateMaybeMessage<::NDD::SolutionResponse_CompactSolution>(Arena*);
template<> ::NDD::SolutionResponse_Infeasibility* Arena::CreateMaybeMessage<::NDD::SolutionResponse_Infeasibility>(Arena*);
template<> ::NDD::SolutionResponse_Infeasibility_Info* Arena::CreateMaybeMessage<::NDD::SolutionResponse_Infeasibility_Info>(Arena*);
template<> ::NDD::SolutionResponse_InterStop* Arena::CreateMaybeMessage<::NDD::SolutionResponse_InterStop>(Arena*);
template<> ::NDD::SolutionResponse_InterStopAttribute* Arena::CreateMaybeMessage<::NDD::SolutionResponse_InterStopAttribute>(Arena*);
template<> ::NDD::SolutionResponse_Route* Arena::CreateMaybeMessage<::NDD::SolutionResponse_Route>(Arena*);
template<> ::NDD::SolutionResponse_SolutionInstance* Arena::CreateMaybeMessage<::NDD::SolutionResponse_SolutionInstance>(Arena*);
template<> ::NDD::SolutionResponse_Stop* Arena::CreateMaybeMessage<::NDD::SolutionResponse_Stop>(Arena*);
template<> ::NDD::SolutionResponse_StopAttribute* Arena::CreateMaybeMessage<::NDD::SolutionResponse_StopAttribute>(Arena*);
template<> ::NDD::SolutionResponse_TransitRuleAttribute* Arena::CreateMaybeMessage<::NDD::SolutionResponse_TransitRuleAttribute>(Arena*);
template<> ::NDD::SolveRequest* Arena::CreateMaybeMessage<::NDD::SolveRequest>(Arena*);
template<> ::NDD::TaskSequence* Arena::CreateMaybeMessage<::NDD::TaskSequence>(Arena*);
template<> ::NDD::TransitGenerator* Arena::CreateMaybeMessage<::NDD::TransitGenerator>(Arena*);
template<> ::NDD::TransitRule* Arena::CreateMaybeMessage<::NDD::TransitRule>(Arena*);
template<> ::NDD::TransitRule_Trigger* Arena::CreateMaybeMessage<::NDD::TransitRule_Trigger>(Arena*);
template<> ::NDD::TransitSet* Arena::CreateMaybeMessage<::NDD::TransitSet>(Arena*);
template<> ::NDD::TransitSet_TransitValue* Arena::CreateMaybeMessage<::NDD::TransitSet_TransitValue>(Arena*);
template<> ::NDD::Vehicle* Arena::CreateMaybeMessage<::NDD::Vehicle>(Arena*);
template<> ::NDD::VehicleClass* Arena::CreateMaybeMessage<::NDD::VehicleClass>(Arena*);
template<> ::NDD::VehicleClass_Attribute* Arena::CreateMaybeMessage<::NDD::VehicleClass_Attribute>(Arena*);
template<> ::NDD::VehicleCostClass* Arena::CreateMaybeMessage<::NDD::VehicleCostClass>(Arena*);
template<> ::NDD::VehicleCostClass_Attribute* Arena::CreateMaybeMessage<::NDD::VehicleCostClass_Attribute>(Arena*);
template<> ::NDD::Vehicle_Capacity* Arena::CreateMaybeMessage<::NDD::Vehicle_Capacity>(Arena*);
template<> ::NDD::Vehicle_Shift* Arena::CreateMaybeMessage<::NDD::Vehicle_Shift>(Arena*);
template<> ::NDD::Vehicle_Task* Arena::CreateMaybeMessage<::NDD::Vehicle_Task>(Arena*);
template<> ::NDD::Vehicle_Task_Attribute* Arena::CreateMaybeMessage<::NDD::Vehicle_Task_Attribute>(Arena*);
template<> ::NDD::Window* Arena::CreateMaybeMessage<::NDD::Window>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NDD {

enum InternalDimension_eMeasurementUnit {
  InternalDimension_eMeasurementUnit_SECONDS = 0,
  InternalDimension_eMeasurementUnit_MINUTES = 1,
  InternalDimension_eMeasurementUnit_HOURS = 2,
  InternalDimension_eMeasurementUnit_DAYS = 3,
  InternalDimension_eMeasurementUnit_KILOMETRES = 4,
  InternalDimension_eMeasurementUnit_MILES = 5
};
bool InternalDimension_eMeasurementUnit_IsValid(int value);
const InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN = InternalDimension_eMeasurementUnit_SECONDS;
const InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX = InternalDimension_eMeasurementUnit_MILES;
const int InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* InternalDimension_eMeasurementUnit_descriptor();
inline const ::std::string& InternalDimension_eMeasurementUnit_Name(InternalDimension_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    InternalDimension_eMeasurementUnit_descriptor(), value);
}
inline bool InternalDimension_eMeasurementUnit_Parse(
    const ::std::string& name, InternalDimension_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalDimension_eMeasurementUnit>(
    InternalDimension_eMeasurementUnit_descriptor(), name, value);
}
enum Profile_eFrequency {
  Profile_eFrequency_CUSTOM = 0,
  Profile_eFrequency_SEVEN_TIMES_A_WEEK = 1,
  Profile_eFrequency_SIX_TIMES_A_WEEK = 2,
  Profile_eFrequency_FIVE_TIMES_A_WEEK = 3,
  Profile_eFrequency_FOUR_TIMES_A_WEEK = 4,
  Profile_eFrequency_THREE_TIMES_A_WEEK = 5,
  Profile_eFrequency_TWICE_A_WEEK = 6,
  Profile_eFrequency_ONCE_A_WEEK = 7,
  Profile_eFrequency_EVERY_SECOND_WEEK = 8,
  Profile_eFrequency_ONCE_A_MONTH = 9
};
bool Profile_eFrequency_IsValid(int value);
const Profile_eFrequency Profile_eFrequency_eFrequency_MIN = Profile_eFrequency_CUSTOM;
const Profile_eFrequency Profile_eFrequency_eFrequency_MAX = Profile_eFrequency_ONCE_A_MONTH;
const int Profile_eFrequency_eFrequency_ARRAYSIZE = Profile_eFrequency_eFrequency_MAX + 1;

const ::google::protobuf::EnumDescriptor* Profile_eFrequency_descriptor();
inline const ::std::string& Profile_eFrequency_Name(Profile_eFrequency value) {
  return ::google::protobuf::internal::NameOfEnum(
    Profile_eFrequency_descriptor(), value);
}
inline bool Profile_eFrequency_Parse(
    const ::std::string& name, Profile_eFrequency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Profile_eFrequency>(
    Profile_eFrequency_descriptor(), name, value);
}
enum Job_VehicleRelation_Type {
  Job_VehicleRelation_Type_INCLUSIVE = 0,
  Job_VehicleRelation_Type_EXCLUSIVE = 1
};
bool Job_VehicleRelation_Type_IsValid(int value);
const Job_VehicleRelation_Type Job_VehicleRelation_Type_Type_MIN = Job_VehicleRelation_Type_INCLUSIVE;
const Job_VehicleRelation_Type Job_VehicleRelation_Type_Type_MAX = Job_VehicleRelation_Type_EXCLUSIVE;
const int Job_VehicleRelation_Type_Type_ARRAYSIZE = Job_VehicleRelation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Job_VehicleRelation_Type_descriptor();
inline const ::std::string& Job_VehicleRelation_Type_Name(Job_VehicleRelation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Job_VehicleRelation_Type_descriptor(), value);
}
inline bool Job_VehicleRelation_Type_Parse(
    const ::std::string& name, Job_VehicleRelation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_VehicleRelation_Type>(
    Job_VehicleRelation_Type_descriptor(), name, value);
}
enum Job_Task_TripConstraint {
  Job_Task_TripConstraint_FIRST = 0,
  Job_Task_TripConstraint_LAST = 1
};
bool Job_Task_TripConstraint_IsValid(int value);
const Job_Task_TripConstraint Job_Task_TripConstraint_TripConstraint_MIN = Job_Task_TripConstraint_FIRST;
const Job_Task_TripConstraint Job_Task_TripConstraint_TripConstraint_MAX = Job_Task_TripConstraint_LAST;
const int Job_Task_TripConstraint_TripConstraint_ARRAYSIZE = Job_Task_TripConstraint_TripConstraint_MAX + 1;

const ::google::protobuf::EnumDescriptor* Job_Task_TripConstraint_descriptor();
inline const ::std::string& Job_Task_TripConstraint_Name(Job_Task_TripConstraint value) {
  return ::google::protobuf::internal::NameOfEnum(
    Job_Task_TripConstraint_descriptor(), value);
}
inline bool Job_Task_TripConstraint_Parse(
    const ::std::string& name, Job_Task_TripConstraint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_Task_TripConstraint>(
    Job_Task_TripConstraint_descriptor(), name, value);
}
enum SolveRequest_SolveType {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2
};
bool SolveRequest_SolveType_IsValid(int value);
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = SolveRequest_SolveType_Optimise;
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = SolveRequest_SolveType_ReOptimise;
const int SolveRequest_SolveType_SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor();
inline const ::std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_SolveType_descriptor(), value);
}
inline bool SolveRequest_SolveType_Parse(
    const ::std::string& name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
    SolveRequest_SolveType_descriptor(), name, value);
}
// ===================================================================

class InternalDimension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.InternalDimension) */ {
 public:
  InternalDimension();
  virtual ~InternalDimension();

  InternalDimension(const InternalDimension& from);

  inline InternalDimension& operator=(const InternalDimension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InternalDimension(InternalDimension&& from) noexcept
    : InternalDimension() {
    *this = ::std::move(from);
  }

  inline InternalDimension& operator=(InternalDimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalDimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InternalDimension* internal_default_instance() {
    return reinterpret_cast<const InternalDimension*>(
               &_InternalDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InternalDimension* other);
  friend void swap(InternalDimension& a, InternalDimension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InternalDimension* New() const final {
    return CreateMaybeMessage<InternalDimension>(NULL);
  }

  InternalDimension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InternalDimension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InternalDimension& from);
  void MergeFrom(const InternalDimension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InternalDimension_eMeasurementUnit eMeasurementUnit;
  static const eMeasurementUnit SECONDS =
    InternalDimension_eMeasurementUnit_SECONDS;
  static const eMeasurementUnit MINUTES =
    InternalDimension_eMeasurementUnit_MINUTES;
  static const eMeasurementUnit HOURS =
    InternalDimension_eMeasurementUnit_HOURS;
  static const eMeasurementUnit DAYS =
    InternalDimension_eMeasurementUnit_DAYS;
  static const eMeasurementUnit KILOMETRES =
    InternalDimension_eMeasurementUnit_KILOMETRES;
  static const eMeasurementUnit MILES =
    InternalDimension_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return InternalDimension_eMeasurementUnit_IsValid(value);
  }
  static const eMeasurementUnit eMeasurementUnit_MIN =
    InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN;
  static const eMeasurementUnit eMeasurementUnit_MAX =
    InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX;
  static const int eMeasurementUnit_ARRAYSIZE =
    InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eMeasurementUnit_descriptor() {
    return InternalDimension_eMeasurementUnit_descriptor();
  }
  static inline const ::std::string& eMeasurementUnit_Name(eMeasurementUnit value) {
    return InternalDimension_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(const ::std::string& name,
      eMeasurementUnit* value) {
    return InternalDimension_eMeasurementUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .NDD.InternalDimension.eMeasurementUnit measurementUnit = 2;
  bool has_measurementunit() const;
  void clear_measurementunit();
  static const int kMeasurementUnitFieldNumber = 2;
  ::NDD::InternalDimension_eMeasurementUnit measurementunit() const;
  void set_measurementunit(::NDD::InternalDimension_eMeasurementUnit value);

  // optional float slackMax = 3 [default = 0];
  bool has_slackmax() const;
  void clear_slackmax();
  static const int kSlackMaxFieldNumber = 3;
  float slackmax() const;
  void set_slackmax(float value);

  // optional float tardyMax = 4 [default = 0];
  bool has_tardymax() const;
  void clear_tardymax();
  static const int kTardyMaxFieldNumber = 4;
  float tardymax() const;
  void set_tardymax(float value);

  // @@protoc_insertion_point(class_scope:NDD.InternalDimension)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_measurementunit();
  void clear_has_measurementunit();
  void set_has_slackmax();
  void clear_has_slackmax();
  void set_has_tardymax();
  void clear_has_tardymax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int measurementunit_;
  float slackmax_;
  float tardymax_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CapacityDimension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.CapacityDimension) */ {
 public:
  CapacityDimension();
  virtual ~CapacityDimension();

  CapacityDimension(const CapacityDimension& from);

  inline CapacityDimension& operator=(const CapacityDimension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapacityDimension(CapacityDimension&& from) noexcept
    : CapacityDimension() {
    *this = ::std::move(from);
  }

  inline CapacityDimension& operator=(CapacityDimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CapacityDimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapacityDimension* internal_default_instance() {
    return reinterpret_cast<const CapacityDimension*>(
               &_CapacityDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CapacityDimension* other);
  friend void swap(CapacityDimension& a, CapacityDimension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapacityDimension* New() const final {
    return CreateMaybeMessage<CapacityDimension>(NULL);
  }

  CapacityDimension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CapacityDimension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CapacityDimension& from);
  void MergeFrom(const CapacityDimension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacityDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string units = 2;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  const ::std::string& units() const;
  void set_units(const ::std::string& value);
  #if LANG_CXX11
  void set_units(::std::string&& value);
  #endif
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  ::std::string* mutable_units();
  ::std::string* release_units();
  void set_allocated_units(::std::string* units);

  // optional float slackMax = 3 [default = 0];
  bool has_slackmax() const;
  void clear_slackmax();
  static const int kSlackMaxFieldNumber = 3;
  float slackmax() const;
  void set_slackmax(float value);

  // optional float tardyMax = 4 [default = 0];
  bool has_tardymax() const;
  void clear_tardymax();
  static const int kTardyMaxFieldNumber = 4;
  float tardymax() const;
  void set_tardymax(float value);

  // @@protoc_insertion_point(class_scope:NDD.CapacityDimension)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_units();
  void clear_has_units();
  void set_has_slackmax();
  void clear_has_slackmax();
  void set_has_tardymax();
  void clear_has_tardymax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr units_;
  float slackmax_;
  float tardymax_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DimensionConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.DimensionConfiguration) */ {
 public:
  DimensionConfiguration();
  virtual ~DimensionConfiguration();

  DimensionConfiguration(const DimensionConfiguration& from);

  inline DimensionConfiguration& operator=(const DimensionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DimensionConfiguration(DimensionConfiguration&& from) noexcept
    : DimensionConfiguration() {
    *this = ::std::move(from);
  }

  inline DimensionConfiguration& operator=(DimensionConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DimensionConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DimensionConfiguration* internal_default_instance() {
    return reinterpret_cast<const DimensionConfiguration*>(
               &_DimensionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DimensionConfiguration* other);
  friend void swap(DimensionConfiguration& a, DimensionConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DimensionConfiguration* New() const final {
    return CreateMaybeMessage<DimensionConfiguration>(NULL);
  }

  DimensionConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DimensionConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DimensionConfiguration& from);
  void MergeFrom(const DimensionConfiguration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.CapacityDimension capacityDimensions = 3;
  int capacitydimensions_size() const;
  void clear_capacitydimensions();
  static const int kCapacityDimensionsFieldNumber = 3;
  ::NDD::CapacityDimension* mutable_capacitydimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >*
      mutable_capacitydimensions();
  const ::NDD::CapacityDimension& capacitydimensions(int index) const;
  ::NDD::CapacityDimension* add_capacitydimensions();
  const ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >&
      capacitydimensions() const;

  // optional .NDD.InternalDimension timeConfig = 1;
  bool has_timeconfig() const;
  void clear_timeconfig();
  static const int kTimeConfigFieldNumber = 1;
  private:
  const ::NDD::InternalDimension& _internal_timeconfig() const;
  public:
  const ::NDD::InternalDimension& timeconfig() const;
  ::NDD::InternalDimension* release_timeconfig();
  ::NDD::InternalDimension* mutable_timeconfig();
  void set_allocated_timeconfig(::NDD::InternalDimension* timeconfig);

  // optional .NDD.InternalDimension distanceConfig = 2;
  bool has_distanceconfig() const;
  void clear_distanceconfig();
  static const int kDistanceConfigFieldNumber = 2;
  private:
  const ::NDD::InternalDimension& _internal_distanceconfig() const;
  public:
  const ::NDD::InternalDimension& distanceconfig() const;
  ::NDD::InternalDimension* release_distanceconfig();
  ::NDD::InternalDimension* mutable_distanceconfig();
  void set_allocated_distanceconfig(::NDD::InternalDimension* distanceconfig);

  // required int32 weekLength = 4;
  bool has_weeklength() const;
  void clear_weeklength();
  static const int kWeekLengthFieldNumber = 4;
  ::google::protobuf::int32 weeklength() const;
  void set_weeklength(::google::protobuf::int32 value);

  // required int32 periodLength = 5;
  bool has_periodlength() const;
  void clear_periodlength();
  static const int kPeriodLengthFieldNumber = 5;
  ::google::protobuf::int32 periodlength() const;
  void set_periodlength(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NDD.DimensionConfiguration)
 private:
  void set_has_timeconfig();
  void clear_has_timeconfig();
  void set_has_distanceconfig();
  void clear_has_distanceconfig();
  void set_has_weeklength();
  void clear_has_weeklength();
  void set_has_periodlength();
  void clear_has_periodlength();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension > capacitydimensions_;
  ::NDD::InternalDimension* timeconfig_;
  ::NDD::InternalDimension* distanceconfig_;
  ::google::protobuf::int32 weeklength_;
  ::google::protobuf::int32 periodlength_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geocode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Geocode) */ {
 public:
  Geocode();
  virtual ~Geocode();

  Geocode(const Geocode& from);

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(Geocode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geocode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Geocode* other);
  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geocode* New() const final {
    return CreateMaybeMessage<Geocode>(NULL);
  }

  Geocode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geocode& from);
  void MergeFrom(const Geocode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  float longitude() const;
  void set_longitude(float value);

  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  float latitude() const;
  void set_latitude(float value);

  // @@protoc_insertion_point(class_scope:NDD.Geocode)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float longitude_;
  float latitude_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Window : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Window) */ {
 public:
  Window();
  virtual ~Window();

  Window(const Window& from);

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Window(Window&& from) noexcept
    : Window() {
    *this = ::std::move(from);
  }

  inline Window& operator=(Window&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Window& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Window* internal_default_instance() {
    return reinterpret_cast<const Window*>(
               &_Window_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Window* other);
  friend void swap(Window& a, Window& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Window* New() const final {
    return CreateMaybeMessage<Window>(NULL);
  }

  Window* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Window>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Window& from);
  void MergeFrom(const Window& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Window* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  float start() const;
  void set_start(float value);

  // required float end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  float end() const;
  void set_end(float value);

  // optional float slackCostCoef = 3 [default = 0];
  bool has_slackcostcoef() const;
  void clear_slackcostcoef();
  static const int kSlackCostCoefFieldNumber = 3;
  float slackcostcoef() const;
  void set_slackcostcoef(float value);

  // optional float tardyCostCoef = 4 [default = 0];
  bool has_tardycostcoef() const;
  void clear_tardycostcoef();
  static const int kTardyCostCoefFieldNumber = 4;
  float tardycostcoef() const;
  void set_tardycostcoef(float value);

  // optional float slackMax = 5 [default = -1];
  bool has_slackmax() const;
  void clear_slackmax();
  static const int kSlackMaxFieldNumber = 5;
  float slackmax() const;
  void set_slackmax(float value);

  // optional float tardyMax = 6 [default = -1];
  bool has_tardymax() const;
  void clear_tardymax();
  static const int kTardyMaxFieldNumber = 6;
  float tardymax() const;
  void set_tardymax(float value);

  // @@protoc_insertion_point(class_scope:NDD.Window)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();
  void set_has_slackcostcoef();
  void clear_has_slackcostcoef();
  void set_has_tardycostcoef();
  void clear_has_tardycostcoef();
  void set_has_slackmax();
  void clear_has_slackmax();
  void set_has_tardymax();
  void clear_has_tardymax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float start_;
  float end_;
  float slackcostcoef_;
  float tardycostcoef_;
  float slackmax_;
  float tardymax_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Location_Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Location.Attribute) */ {
 public:
  Location_Attribute();
  virtual ~Location_Attribute();

  Location_Attribute(const Location_Attribute& from);

  inline Location_Attribute& operator=(const Location_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location_Attribute(Location_Attribute&& from) noexcept
    : Location_Attribute() {
    *this = ::std::move(from);
  }

  inline Location_Attribute& operator=(Location_Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location_Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location_Attribute* internal_default_instance() {
    return reinterpret_cast<const Location_Attribute*>(
               &_Location_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Location_Attribute* other);
  friend void swap(Location_Attribute& a, Location_Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location_Attribute* New() const final {
    return CreateMaybeMessage<Location_Attribute>(NULL);
  }

  Location_Attribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location_Attribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location_Attribute& from);
  void MergeFrom(const Location_Attribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location_Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.Window arrivalWindows = 4;
  int arrivalwindows_size() const;
  void clear_arrivalwindows();
  static const int kArrivalWindowsFieldNumber = 4;
  ::NDD::Window* mutable_arrivalwindows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_arrivalwindows();
  const ::NDD::Window& arrivalwindows(int index) const;
  ::NDD::Window* add_arrivalwindows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      arrivalwindows() const;

  // repeated .NDD.Window departureWindows = 5;
  int departurewindows_size() const;
  void clear_departurewindows();
  static const int kDepartureWindowsFieldNumber = 5;
  ::NDD::Window* mutable_departurewindows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_departurewindows();
  const ::NDD::Window& departurewindows(int index) const;
  ::NDD::Window* add_departurewindows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      departurewindows() const;

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // optional string vehicleId = 2;
  bool has_vehicleid() const;
  void clear_vehicleid();
  static const int kVehicleIdFieldNumber = 2;
  const ::std::string& vehicleid() const;
  void set_vehicleid(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleid(::std::string&& value);
  #endif
  void set_vehicleid(const char* value);
  void set_vehicleid(const char* value, size_t size);
  ::std::string* mutable_vehicleid();
  ::std::string* release_vehicleid();
  void set_allocated_vehicleid(::std::string* vehicleid);

  // optional float quantity = 3;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:NDD.Location.Attribute)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_vehicleid();
  void clear_has_vehicleid();
  void set_has_quantity();
  void clear_has_quantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Window > arrivalwindows_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Window > departurewindows_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  ::google::protobuf::internal::ArenaStringPtr vehicleid_;
  float quantity_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(NULL);
  }

  Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Location_Attribute Attribute;

  // accessors -------------------------------------------------------

  // repeated .NDD.Location.Attribute attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::NDD::Location_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >*
      mutable_attributes();
  const ::NDD::Location_Attribute& attributes(int index) const;
  ::NDD::Location_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >&
      attributes() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .NDD.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode();
  static const int kGeocodeFieldNumber = 2;
  private:
  const ::NDD::Geocode& _internal_geocode() const;
  public:
  const ::NDD::Geocode& geocode() const;
  ::NDD::Geocode* release_geocode();
  ::NDD::Geocode* mutable_geocode();
  void set_allocated_geocode(::NDD::Geocode* geocode);

  // @@protoc_insertion_point(class_scope:NDD.Location)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_geocode();
  void clear_has_geocode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::NDD::Geocode* geocode_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Profile_customCycle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Profile.customCycle) */ {
 public:
  Profile_customCycle();
  virtual ~Profile_customCycle();

  Profile_customCycle(const Profile_customCycle& from);

  inline Profile_customCycle& operator=(const Profile_customCycle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Profile_customCycle(Profile_customCycle&& from) noexcept
    : Profile_customCycle() {
    *this = ::std::move(from);
  }

  inline Profile_customCycle& operator=(Profile_customCycle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Profile_customCycle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Profile_customCycle* internal_default_instance() {
    return reinterpret_cast<const Profile_customCycle*>(
               &_Profile_customCycle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Profile_customCycle* other);
  friend void swap(Profile_customCycle& a, Profile_customCycle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Profile_customCycle* New() const final {
    return CreateMaybeMessage<Profile_customCycle>(NULL);
  }

  Profile_customCycle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Profile_customCycle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Profile_customCycle& from);
  void MergeFrom(const Profile_customCycle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile_customCycle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool visitProfile = 2;
  int visitprofile_size() const;
  void clear_visitprofile();
  static const int kVisitProfileFieldNumber = 2;
  bool visitprofile(int index) const;
  void set_visitprofile(int index, bool value);
  void add_visitprofile(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      visitprofile() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_visitprofile();

  // @@protoc_insertion_point(class_scope:NDD.Profile.customCycle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< bool > visitprofile_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Profile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Profile) */ {
 public:
  Profile();
  virtual ~Profile();

  Profile(const Profile& from);

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(Profile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Profile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Profile* other);
  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Profile* New() const final {
    return CreateMaybeMessage<Profile>(NULL);
  }

  Profile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Profile& from);
  void MergeFrom(const Profile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Profile_customCycle customCycle;

  typedef Profile_eFrequency eFrequency;
  static const eFrequency CUSTOM =
    Profile_eFrequency_CUSTOM;
  static const eFrequency SEVEN_TIMES_A_WEEK =
    Profile_eFrequency_SEVEN_TIMES_A_WEEK;
  static const eFrequency SIX_TIMES_A_WEEK =
    Profile_eFrequency_SIX_TIMES_A_WEEK;
  static const eFrequency FIVE_TIMES_A_WEEK =
    Profile_eFrequency_FIVE_TIMES_A_WEEK;
  static const eFrequency FOUR_TIMES_A_WEEK =
    Profile_eFrequency_FOUR_TIMES_A_WEEK;
  static const eFrequency THREE_TIMES_A_WEEK =
    Profile_eFrequency_THREE_TIMES_A_WEEK;
  static const eFrequency TWICE_A_WEEK =
    Profile_eFrequency_TWICE_A_WEEK;
  static const eFrequency ONCE_A_WEEK =
    Profile_eFrequency_ONCE_A_WEEK;
  static const eFrequency EVERY_SECOND_WEEK =
    Profile_eFrequency_EVERY_SECOND_WEEK;
  static const eFrequency ONCE_A_MONTH =
    Profile_eFrequency_ONCE_A_MONTH;
  static inline bool eFrequency_IsValid(int value) {
    return Profile_eFrequency_IsValid(value);
  }
  static const eFrequency eFrequency_MIN =
    Profile_eFrequency_eFrequency_MIN;
  static const eFrequency eFrequency_MAX =
    Profile_eFrequency_eFrequency_MAX;
  static const int eFrequency_ARRAYSIZE =
    Profile_eFrequency_eFrequency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFrequency_descriptor() {
    return Profile_eFrequency_descriptor();
  }
  static inline const ::std::string& eFrequency_Name(eFrequency value) {
    return Profile_eFrequency_Name(value);
  }
  static inline bool eFrequency_Parse(const ::std::string& name,
      eFrequency* value) {
    return Profile_eFrequency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NDD.Profile.customCycle allowableCycles = 2;
  int allowablecycles_size() const;
  void clear_allowablecycles();
  static const int kAllowableCyclesFieldNumber = 2;
  ::NDD::Profile_customCycle* mutable_allowablecycles(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >*
      mutable_allowablecycles();
  const ::NDD::Profile_customCycle& allowablecycles(int index) const;
  ::NDD::Profile_customCycle* add_allowablecycles();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >&
      allowablecycles() const;

  // required .NDD.Profile.eFrequency frequencyType = 1;
  bool has_frequencytype() const;
  void clear_frequencytype();
  static const int kFrequencyTypeFieldNumber = 1;
  ::NDD::Profile_eFrequency frequencytype() const;
  void set_frequencytype(::NDD::Profile_eFrequency value);

  // optional int32 numVisits = 3;
  bool has_numvisits() const;
  void clear_numvisits();
  static const int kNumVisitsFieldNumber = 3;
  ::google::protobuf::int32 numvisits() const;
  void set_numvisits(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NDD.Profile)
 private:
  void set_has_frequencytype();
  void clear_has_frequencytype();
  void set_has_numvisits();
  void clear_has_numvisits();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle > allowablecycles_;
  int frequencytype_;
  ::google::protobuf::int32 numvisits_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Job_VehicleRelation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job.VehicleRelation) */ {
 public:
  Job_VehicleRelation();
  virtual ~Job_VehicleRelation();

  Job_VehicleRelation(const Job_VehicleRelation& from);

  inline Job_VehicleRelation& operator=(const Job_VehicleRelation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Job_VehicleRelation(Job_VehicleRelation&& from) noexcept
    : Job_VehicleRelation() {
    *this = ::std::move(from);
  }

  inline Job_VehicleRelation& operator=(Job_VehicleRelation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Job_VehicleRelation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Job_VehicleRelation* internal_default_instance() {
    return reinterpret_cast<const Job_VehicleRelation*>(
               &_Job_VehicleRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Job_VehicleRelation* other);
  friend void swap(Job_VehicleRelation& a, Job_VehicleRelation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Job_VehicleRelation* New() const final {
    return CreateMaybeMessage<Job_VehicleRelation>(NULL);
  }

  Job_VehicleRelation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Job_VehicleRelation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Job_VehicleRelation& from);
  void MergeFrom(const Job_VehicleRelation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_VehicleRelation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_VehicleRelation_Type Type;
  static const Type INCLUSIVE =
    Job_VehicleRelation_Type_INCLUSIVE;
  static const Type EXCLUSIVE =
    Job_VehicleRelation_Type_EXCLUSIVE;
  static inline bool Type_IsValid(int value) {
    return Job_VehicleRelation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Job_VehicleRelation_Type_Type_MIN;
  static const Type Type_MAX =
    Job_VehicleRelation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Job_VehicleRelation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Job_VehicleRelation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Job_VehicleRelation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Job_VehicleRelation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string vehicleIds = 2;
  int vehicleids_size() const;
  void clear_vehicleids();
  static const int kVehicleIdsFieldNumber = 2;
  const ::std::string& vehicleids(int index) const;
  ::std::string* mutable_vehicleids(int index);
  void set_vehicleids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleids(int index, ::std::string&& value);
  #endif
  void set_vehicleids(int index, const char* value);
  void set_vehicleids(int index, const char* value, size_t size);
  ::std::string* add_vehicleids();
  void add_vehicleids(const ::std::string& value);
  #if LANG_CXX11
  void add_vehicleids(::std::string&& value);
  #endif
  void add_vehicleids(const char* value);
  void add_vehicleids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& vehicleids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_vehicleids();

  // required .NDD.Job.VehicleRelation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::NDD::Job_VehicleRelation_Type type() const;
  void set_type(::NDD::Job_VehicleRelation_Type value);

  // @@protoc_insertion_point(class_scope:NDD.Job.VehicleRelation)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> vehicleids_;
  int type_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Job_Task_Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job.Task.Attribute) */ {
 public:
  Job_Task_Attribute();
  virtual ~Job_Task_Attribute();

  Job_Task_Attribute(const Job_Task_Attribute& from);

  inline Job_Task_Attribute& operator=(const Job_Task_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Job_Task_Attribute(Job_Task_Attribute&& from) noexcept
    : Job_Task_Attribute() {
    *this = ::std::move(from);
  }

  inline Job_Task_Attribute& operator=(Job_Task_Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Job_Task_Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Job_Task_Attribute* internal_default_instance() {
    return reinterpret_cast<const Job_Task_Attribute*>(
               &_Job_Task_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Job_Task_Attribute* other);
  friend void swap(Job_Task_Attribute& a, Job_Task_Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Job_Task_Attribute* New() const final {
    return CreateMaybeMessage<Job_Task_Attribute>(NULL);
  }

  Job_Task_Attribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Job_Task_Attribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Job_Task_Attribute& from);
  void MergeFrom(const Job_Task_Attribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task_Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.Window windows = 3;
  int windows_size() const;
  void clear_windows();
  static const int kWindowsFieldNumber = 3;
  ::NDD::Window* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_windows();
  const ::NDD::Window& windows(int index) const;
  ::NDD::Window* add_windows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      windows() const;

  // repeated string vehicleIds = 4;
  int vehicleids_size() const;
  void clear_vehicleids();
  static const int kVehicleIdsFieldNumber = 4;
  const ::std::string& vehicleids(int index) const;
  ::std::string* mutable_vehicleids(int index);
  void set_vehicleids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleids(int index, ::std::string&& value);
  #endif
  void set_vehicleids(int index, const char* value);
  void set_vehicleids(int index, const char* value, size_t size);
  ::std::string* add_vehicleids();
  void add_vehicleids(const ::std::string& value);
  #if LANG_CXX11
  void add_vehicleids(::std::string&& value);
  #endif
  void add_vehicleids(const char* value);
  void add_vehicleids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& vehicleids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_vehicleids();

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // optional float quantity = 2;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:NDD.Job.Task.Attribute)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_quantity();
  void clear_has_quantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Window > windows_;
  ::google::protobuf::RepeatedPtrField< ::std::string> vehicleids_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  float quantity_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Job_Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job.Task) */ {
 public:
  Job_Task();
  virtual ~Job_Task();

  Job_Task(const Job_Task& from);

  inline Job_Task& operator=(const Job_Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Job_Task(Job_Task&& from) noexcept
    : Job_Task() {
    *this = ::std::move(from);
  }

  inline Job_Task& operator=(Job_Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Job_Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Job_Task* internal_default_instance() {
    return reinterpret_cast<const Job_Task*>(
               &_Job_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Job_Task* other);
  friend void swap(Job_Task& a, Job_Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Job_Task* New() const final {
    return CreateMaybeMessage<Job_Task>(NULL);
  }

  Job_Task* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Job_Task>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Job_Task& from);
  void MergeFrom(const Job_Task& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_Task_Attribute Attribute;

  typedef Job_Task_TripConstraint TripConstraint;
  static const TripConstraint FIRST =
    Job_Task_TripConstraint_FIRST;
  static const TripConstraint LAST =
    Job_Task_TripConstraint_LAST;
  static inline bool TripConstraint_IsValid(int value) {
    return Job_Task_TripConstraint_IsValid(value);
  }
  static const TripConstraint TripConstraint_MIN =
    Job_Task_TripConstraint_TripConstraint_MIN;
  static const TripConstraint TripConstraint_MAX =
    Job_Task_TripConstraint_TripConstraint_MAX;
  static const int TripConstraint_ARRAYSIZE =
    Job_Task_TripConstraint_TripConstraint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TripConstraint_descriptor() {
    return Job_Task_TripConstraint_descriptor();
  }
  static inline const ::std::string& TripConstraint_Name(TripConstraint value) {
    return Job_Task_TripConstraint_Name(value);
  }
  static inline bool TripConstraint_Parse(const ::std::string& name,
      TripConstraint* value) {
    return Job_Task_TripConstraint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NDD.Job.Task.Attribute attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::NDD::Job_Task_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >*
      mutable_attributes();
  const ::NDD::Job_Task_Attribute& attributes(int index) const;
  ::NDD::Job_Task_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >&
      attributes() const;

  // repeated .NDD.Job.Task.TripConstraint tripConstraints = 4;
  int tripconstraints_size() const;
  void clear_tripconstraints();
  static const int kTripConstraintsFieldNumber = 4;
  ::NDD::Job_Task_TripConstraint tripconstraints(int index) const;
  void set_tripconstraints(int index, ::NDD::Job_Task_TripConstraint value);
  void add_tripconstraints(::NDD::Job_Task_TripConstraint value);
  const ::google::protobuf::RepeatedField<int>& tripconstraints() const;
  ::google::protobuf::RepeatedField<int>* mutable_tripconstraints();

  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid();
  static const int kTaskIdFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const char* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // required string locationId = 2;
  bool has_locationid() const;
  void clear_locationid();
  static const int kLocationIdFieldNumber = 2;
  const ::std::string& locationid() const;
  void set_locationid(const ::std::string& value);
  #if LANG_CXX11
  void set_locationid(::std::string&& value);
  #endif
  void set_locationid(const char* value);
  void set_locationid(const char* value, size_t size);
  ::std::string* mutable_locationid();
  ::std::string* release_locationid();
  void set_allocated_locationid(::std::string* locationid);

  // @@protoc_insertion_point(class_scope:NDD.Job.Task)
 private:
  void set_has_taskid();
  void clear_has_taskid();
  void set_has_locationid();
  void clear_has_locationid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute > attributes_;
  ::google::protobuf::RepeatedField<int> tripconstraints_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr locationid_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Job : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job) */ {
 public:
  Job();
  virtual ~Job();

  Job(const Job& from);

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(Job&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Job& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Job* other);
  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Job* New() const final {
    return CreateMaybeMessage<Job>(NULL);
  }

  Job* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Job& from);
  void MergeFrom(const Job& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_VehicleRelation VehicleRelation;
  typedef Job_Task Task;

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .NDD.Job.Task pickupTask = 2;
  bool has_pickuptask() const;
  void clear_pickuptask();
  static const int kPickupTaskFieldNumber = 2;
  private:
  const ::NDD::Job_Task& _internal_pickuptask() const;
  public:
  const ::NDD::Job_Task& pickuptask() const;
  ::NDD::Job_Task* release_pickuptask();
  ::NDD::Job_Task* mutable_pickuptask();
  void set_allocated_pickuptask(::NDD::Job_Task* pickuptask);

  // optional .NDD.Job.Task dropoffTask = 3;
  bool has_dropofftask() const;
  void clear_dropofftask();
  static const int kDropoffTaskFieldNumber = 3;
  private:
  const ::NDD::Job_Task& _internal_dropofftask() const;
  public:
  const ::NDD::Job_Task& dropofftask() const;
  ::NDD::Job_Task* release_dropofftask();
  ::NDD::Job_Task* mutable_dropofftask();
  void set_allocated_dropofftask(::NDD::Job_Task* dropofftask);

  // optional .NDD.Job.VehicleRelation vehicleRelations = 5;
  bool has_vehiclerelations() const;
  void clear_vehiclerelations();
  static const int kVehicleRelationsFieldNumber = 5;
  private:
  const ::NDD::Job_VehicleRelation& _internal_vehiclerelations() const;
  public:
  const ::NDD::Job_VehicleRelation& vehiclerelations() const;
  ::NDD::Job_VehicleRelation* release_vehiclerelations();
  ::NDD::Job_VehicleRelation* mutable_vehiclerelations();
  void set_allocated_vehiclerelations(::NDD::Job_VehicleRelation* vehiclerelations);

  // required .NDD.Profile profile = 6;
  bool has_profile() const;
  void clear_profile();
  static const int kProfileFieldNumber = 6;
  private:
  const ::NDD::Profile& _internal_profile() const;
  public:
  const ::NDD::Profile& profile() const;
  ::NDD::Profile* release_profile();
  ::NDD::Profile* mutable_profile();
  void set_allocated_profile(::NDD::Profile* profile);

  // required float penalty = 4;
  bool has_penalty() const;
  void clear_penalty();
  static const int kPenaltyFieldNumber = 4;
  float penalty() const;
  void set_penalty(float value);

  // @@protoc_insertion_point(class_scope:NDD.Job)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_pickuptask();
  void clear_has_pickuptask();
  void set_has_dropofftask();
  void clear_has_dropofftask();
  void set_has_penalty();
  void clear_has_penalty();
  void set_has_vehiclerelations();
  void clear_has_vehiclerelations();
  void set_has_profile();
  void clear_has_profile();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::NDD::Job_Task* pickuptask_;
  ::NDD::Job_Task* dropofftask_;
  ::NDD::Job_VehicleRelation* vehiclerelations_;
  ::NDD::Profile* profile_;
  float penalty_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransitSet_TransitValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitSet.TransitValue) */ {
 public:
  TransitSet_TransitValue();
  virtual ~TransitSet_TransitValue();

  TransitSet_TransitValue(const TransitSet_TransitValue& from);

  inline TransitSet_TransitValue& operator=(const TransitSet_TransitValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransitSet_TransitValue(TransitSet_TransitValue&& from) noexcept
    : TransitSet_TransitValue() {
    *this = ::std::move(from);
  }

  inline TransitSet_TransitValue& operator=(TransitSet_TransitValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitSet_TransitValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitSet_TransitValue* internal_default_instance() {
    return reinterpret_cast<const TransitSet_TransitValue*>(
               &_TransitSet_TransitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TransitSet_TransitValue* other);
  friend void swap(TransitSet_TransitValue& a, TransitSet_TransitValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransitSet_TransitValue* New() const final {
    return CreateMaybeMessage<TransitSet_TransitValue>(NULL);
  }

  TransitSet_TransitValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransitSet_TransitValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransitSet_TransitValue& from);
  void MergeFrom(const TransitSet_TransitValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitSet_TransitValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fromId = 1;
  bool has_fromid() const;
  void clear_fromid();
  static const int kFromIdFieldNumber = 1;
  const ::std::string& fromid() const;
  void set_fromid(const ::std::string& value);
  #if LANG_CXX11
  void set_fromid(::std::string&& value);
  #endif
  void set_fromid(const char* value);
  void set_fromid(const char* value, size_t size);
  ::std::string* mutable_fromid();
  ::std::string* release_fromid();
  void set_allocated_fromid(::std::string* fromid);

  // required string toId = 2;
  bool has_toid() const;
  void clear_toid();
  static const int kToIdFieldNumber = 2;
  const ::std::string& toid() const;
  void set_toid(const ::std::string& value);
  #if LANG_CXX11
  void set_toid(::std::string&& value);
  #endif
  void set_toid(const char* value);
  void set_toid(const char* value, size_t size);
  ::std::string* mutable_toid();
  ::std::string* release_toid();
  void set_allocated_toid(::std::string* toid);

  // required float value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:NDD.TransitSet.TransitValue)
 private:
  void set_has_fromid();
  void clear_has_fromid();
  void set_has_toid();
  void clear_has_toid();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fromid_;
  ::google::protobuf::internal::ArenaStringPtr toid_;
  float value_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransitSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitSet) */ {
 public:
  TransitSet();
  virtual ~TransitSet();

  TransitSet(const TransitSet& from);

  inline TransitSet& operator=(const TransitSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransitSet(TransitSet&& from) noexcept
    : TransitSet() {
    *this = ::std::move(from);
  }

  inline TransitSet& operator=(TransitSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitSet* internal_default_instance() {
    return reinterpret_cast<const TransitSet*>(
               &_TransitSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TransitSet* other);
  friend void swap(TransitSet& a, TransitSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransitSet* New() const final {
    return CreateMaybeMessage<TransitSet>(NULL);
  }

  TransitSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransitSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransitSet& from);
  void MergeFrom(const TransitSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransitSet_TransitValue TransitValue;

  // accessors -------------------------------------------------------

  // repeated .NDD.TransitSet.TransitValue transits = 1;
  int transits_size() const;
  void clear_transits();
  static const int kTransitsFieldNumber = 1;
  ::NDD::TransitSet_TransitValue* mutable_transits(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >*
      mutable_transits();
  const ::NDD::TransitSet_TransitValue& transits(int index) const;
  ::NDD::TransitSet_TransitValue* add_transits();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >&
      transits() const;

  // @@protoc_insertion_point(class_scope:NDD.TransitSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue > transits_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransitGenerator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitGenerator) */ {
 public:
  TransitGenerator();
  virtual ~TransitGenerator();

  TransitGenerator(const TransitGenerator& from);

  inline TransitGenerator& operator=(const TransitGenerator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransitGenerator(TransitGenerator&& from) noexcept
    : TransitGenerator() {
    *this = ::std::move(from);
  }

  inline TransitGenerator& operator=(TransitGenerator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitGenerator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitGenerator* internal_default_instance() {
    return reinterpret_cast<const TransitGenerator*>(
               &_TransitGenerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TransitGenerator* other);
  friend void swap(TransitGenerator& a, TransitGenerator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransitGenerator* New() const final {
    return CreateMaybeMessage<TransitGenerator>(NULL);
  }

  TransitGenerator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransitGenerator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransitGenerator& from);
  void MergeFrom(const TransitGenerator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitGenerator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string requestId = 2;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 2;
  const ::std::string& requestid() const;
  void set_requestid(const ::std::string& value);
  #if LANG_CXX11
  void set_requestid(::std::string&& value);
  #endif
  void set_requestid(const char* value);
  void set_requestid(const char* value, size_t size);
  ::std::string* mutable_requestid();
  ::std::string* release_requestid();
  void set_allocated_requestid(::std::string* requestid);

  // optional .NDD.TransitSet transitSet = 3;
  bool has_transitset() const;
  void clear_transitset();
  static const int kTransitSetFieldNumber = 3;
  private:
  const ::NDD::TransitSet& _internal_transitset() const;
  public:
  const ::NDD::TransitSet& transitset() const;
  ::NDD::TransitSet* release_transitset();
  ::NDD::TransitSet* mutable_transitset();
  void set_allocated_transitset(::NDD::TransitSet* transitset);

  // @@protoc_insertion_point(class_scope:NDD.TransitGenerator)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_requestid();
  void clear_has_requestid();
  void set_has_transitset();
  void clear_has_transitset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr requestid_;
  ::NDD::TransitSet* transitset_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleClass_Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleClass.Attribute) */ {
 public:
  VehicleClass_Attribute();
  virtual ~VehicleClass_Attribute();

  VehicleClass_Attribute(const VehicleClass_Attribute& from);

  inline VehicleClass_Attribute& operator=(const VehicleClass_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleClass_Attribute(VehicleClass_Attribute&& from) noexcept
    : VehicleClass_Attribute() {
    *this = ::std::move(from);
  }

  inline VehicleClass_Attribute& operator=(VehicleClass_Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleClass_Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleClass_Attribute* internal_default_instance() {
    return reinterpret_cast<const VehicleClass_Attribute*>(
               &_VehicleClass_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(VehicleClass_Attribute* other);
  friend void swap(VehicleClass_Attribute& a, VehicleClass_Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleClass_Attribute* New() const final {
    return CreateMaybeMessage<VehicleClass_Attribute>(NULL);
  }

  VehicleClass_Attribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleClass_Attribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleClass_Attribute& from);
  void MergeFrom(const VehicleClass_Attribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleClass_Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // optional string transitGeneratorId = 2;
  bool has_transitgeneratorid() const;
  void clear_transitgeneratorid();
  static const int kTransitGeneratorIdFieldNumber = 2;
  const ::std::string& transitgeneratorid() const;
  void set_transitgeneratorid(const ::std::string& value);
  #if LANG_CXX11
  void set_transitgeneratorid(::std::string&& value);
  #endif
  void set_transitgeneratorid(const char* value);
  void set_transitgeneratorid(const char* value, size_t size);
  ::std::string* mutable_transitgeneratorid();
  ::std::string* release_transitgeneratorid();
  void set_allocated_transitgeneratorid(::std::string* transitgeneratorid);

  // optional float transitCoef = 3;
  bool has_transitcoef() const;
  void clear_transitcoef();
  static const int kTransitCoefFieldNumber = 3;
  float transitcoef() const;
  void set_transitcoef(float value);

  // optional float taskCoef = 4;
  bool has_taskcoef() const;
  void clear_taskcoef();
  static const int kTaskCoefFieldNumber = 4;
  float taskcoef() const;
  void set_taskcoef(float value);

  // optional float locationCoef = 5;
  bool has_locationcoef() const;
  void clear_locationcoef();
  static const int kLocationCoefFieldNumber = 5;
  float locationcoef() const;
  void set_locationcoef(float value);

  // @@protoc_insertion_point(class_scope:NDD.VehicleClass.Attribute)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_transitgeneratorid();
  void clear_has_transitgeneratorid();
  void set_has_transitcoef();
  void clear_has_transitcoef();
  void set_has_taskcoef();
  void clear_has_taskcoef();
  void set_has_locationcoef();
  void clear_has_locationcoef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  ::google::protobuf::internal::ArenaStringPtr transitgeneratorid_;
  float transitcoef_;
  float taskcoef_;
  float locationcoef_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleClass) */ {
 public:
  VehicleClass();
  virtual ~VehicleClass();

  VehicleClass(const VehicleClass& from);

  inline VehicleClass& operator=(const VehicleClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleClass(VehicleClass&& from) noexcept
    : VehicleClass() {
    *this = ::std::move(from);
  }

  inline VehicleClass& operator=(VehicleClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleClass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleClass* internal_default_instance() {
    return reinterpret_cast<const VehicleClass*>(
               &_VehicleClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(VehicleClass* other);
  friend void swap(VehicleClass& a, VehicleClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleClass* New() const final {
    return CreateMaybeMessage<VehicleClass>(NULL);
  }

  VehicleClass* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleClass>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleClass& from);
  void MergeFrom(const VehicleClass& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleClass_Attribute Attribute;

  // accessors -------------------------------------------------------

  // repeated .NDD.VehicleClass.Attribute attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  ::NDD::VehicleClass_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >*
      mutable_attributes();
  const ::NDD::VehicleClass_Attribute& attributes(int index) const;
  ::NDD::VehicleClass_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >&
      attributes() const;

  // repeated string transitRuleIds = 3;
  int transitruleids_size() const;
  void clear_transitruleids();
  static const int kTransitRuleIdsFieldNumber = 3;
  const ::std::string& transitruleids(int index) const;
  ::std::string* mutable_transitruleids(int index);
  void set_transitruleids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_transitruleids(int index, ::std::string&& value);
  #endif
  void set_transitruleids(int index, const char* value);
  void set_transitruleids(int index, const char* value, size_t size);
  ::std::string* add_transitruleids();
  void add_transitruleids(const ::std::string& value);
  #if LANG_CXX11
  void add_transitruleids(::std::string&& value);
  #endif
  void add_transitruleids(const char* value);
  void add_transitruleids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& transitruleids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_transitruleids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:NDD.VehicleClass)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> transitruleids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleCostClass_Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleCostClass.Attribute) */ {
 public:
  VehicleCostClass_Attribute();
  virtual ~VehicleCostClass_Attribute();

  VehicleCostClass_Attribute(const VehicleCostClass_Attribute& from);

  inline VehicleCostClass_Attribute& operator=(const VehicleCostClass_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleCostClass_Attribute(VehicleCostClass_Attribute&& from) noexcept
    : VehicleCostClass_Attribute() {
    *this = ::std::move(from);
  }

  inline VehicleCostClass_Attribute& operator=(VehicleCostClass_Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleCostClass_Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleCostClass_Attribute* internal_default_instance() {
    return reinterpret_cast<const VehicleCostClass_Attribute*>(
               &_VehicleCostClass_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(VehicleCostClass_Attribute* other);
  friend void swap(VehicleCostClass_Attribute& a, VehicleCostClass_Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleCostClass_Attribute* New() const final {
    return CreateMaybeMessage<VehicleCostClass_Attribute>(NULL);
  }

  VehicleCostClass_Attribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleCostClass_Attribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleCostClass_Attribute& from);
  void MergeFrom(const VehicleCostClass_Attribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCostClass_Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // optional float transitCostCoef = 2;
  bool has_transitcostcoef() const;
  void clear_transitcostcoef();
  static const int kTransitCostCoefFieldNumber = 2;
  float transitcostcoef() const;
  void set_transitcostcoef(float value);

  // optional float taskCostCoef = 3;
  bool has_taskcostcoef() const;
  void clear_taskcostcoef();
  static const int kTaskCostCoefFieldNumber = 3;
  float taskcostcoef() const;
  void set_taskcostcoef(float value);

  // optional float locationCostCoef = 4;
  bool has_locationcostcoef() const;
  void clear_locationcostcoef();
  static const int kLocationCostCoefFieldNumber = 4;
  float locationcostcoef() const;
  void set_locationcostcoef(float value);

  // optional float slackCostCoef = 5;
  bool has_slackcostcoef() const;
  void clear_slackcostcoef();
  static const int kSlackCostCoefFieldNumber = 5;
  float slackcostcoef() const;
  void set_slackcostcoef(float value);

  // optional float tardyCostCoef = 6;
  bool has_tardycostcoef() const;
  void clear_tardycostcoef();
  static const int kTardyCostCoefFieldNumber = 6;
  float tardycostcoef() const;
  void set_tardycostcoef(float value);

  // @@protoc_insertion_point(class_scope:NDD.VehicleCostClass.Attribute)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_transitcostcoef();
  void clear_has_transitcostcoef();
  void set_has_taskcostcoef();
  void clear_has_taskcostcoef();
  void set_has_locationcostcoef();
  void clear_has_locationcostcoef();
  void set_has_slackcostcoef();
  void clear_has_slackcostcoef();
  void set_has_tardycostcoef();
  void clear_has_tardycostcoef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  float transitcostcoef_;
  float taskcostcoef_;
  float locationcostcoef_;
  float slackcostcoef_;
  float tardycostcoef_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleCostClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleCostClass) */ {
 public:
  VehicleCostClass();
  virtual ~VehicleCostClass();

  VehicleCostClass(const VehicleCostClass& from);

  inline VehicleCostClass& operator=(const VehicleCostClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleCostClass(VehicleCostClass&& from) noexcept
    : VehicleCostClass() {
    *this = ::std::move(from);
  }

  inline VehicleCostClass& operator=(VehicleCostClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleCostClass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleCostClass* internal_default_instance() {
    return reinterpret_cast<const VehicleCostClass*>(
               &_VehicleCostClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(VehicleCostClass* other);
  friend void swap(VehicleCostClass& a, VehicleCostClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleCostClass* New() const final {
    return CreateMaybeMessage<VehicleCostClass>(NULL);
  }

  VehicleCostClass* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleCostClass>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleCostClass& from);
  void MergeFrom(const VehicleCostClass& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCostClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleCostClass_Attribute Attribute;

  // accessors -------------------------------------------------------

  // repeated .NDD.VehicleCostClass.Attribute attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::NDD::VehicleCostClass_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >*
      mutable_attributes();
  const ::NDD::VehicleCostClass_Attribute& attributes(int index) const;
  ::NDD::VehicleCostClass_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >&
      attributes() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required float fixedCost = 2;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 2;
  float fixedcost() const;
  void set_fixedcost(float value);

  // @@protoc_insertion_point(class_scope:NDD.VehicleCostClass)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_fixedcost();
  void clear_has_fixedcost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  float fixedcost_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_Task_Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Task.Attribute) */ {
 public:
  Vehicle_Task_Attribute();
  virtual ~Vehicle_Task_Attribute();

  Vehicle_Task_Attribute(const Vehicle_Task_Attribute& from);

  inline Vehicle_Task_Attribute& operator=(const Vehicle_Task_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_Task_Attribute(Vehicle_Task_Attribute&& from) noexcept
    : Vehicle_Task_Attribute() {
    *this = ::std::move(from);
  }

  inline Vehicle_Task_Attribute& operator=(Vehicle_Task_Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_Task_Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_Task_Attribute* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Task_Attribute*>(
               &_Vehicle_Task_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Vehicle_Task_Attribute* other);
  friend void swap(Vehicle_Task_Attribute& a, Vehicle_Task_Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_Task_Attribute* New() const final {
    return CreateMaybeMessage<Vehicle_Task_Attribute>(NULL);
  }

  Vehicle_Task_Attribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_Task_Attribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle_Task_Attribute& from);
  void MergeFrom(const Vehicle_Task_Attribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Task_Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.Window windows = 3;
  int windows_size() const;
  void clear_windows();
  static const int kWindowsFieldNumber = 3;
  ::NDD::Window* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_windows();
  const ::NDD::Window& windows(int index) const;
  ::NDD::Window* add_windows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      windows() const;

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // optional float quantity = 2;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Task.Attribute)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_quantity();
  void clear_has_quantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Window > windows_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  float quantity_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Task) */ {
 public:
  Vehicle_Task();
  virtual ~Vehicle_Task();

  Vehicle_Task(const Vehicle_Task& from);

  inline Vehicle_Task& operator=(const Vehicle_Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_Task(Vehicle_Task&& from) noexcept
    : Vehicle_Task() {
    *this = ::std::move(from);
  }

  inline Vehicle_Task& operator=(Vehicle_Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_Task* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Task*>(
               &_Vehicle_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Vehicle_Task* other);
  friend void swap(Vehicle_Task& a, Vehicle_Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_Task* New() const final {
    return CreateMaybeMessage<Vehicle_Task>(NULL);
  }

  Vehicle_Task* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_Task>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle_Task& from);
  void MergeFrom(const Vehicle_Task& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_Task_Attribute Attribute;

  // accessors -------------------------------------------------------

  // repeated .NDD.Vehicle.Task.Attribute attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  ::NDD::Vehicle_Task_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >*
      mutable_attributes();
  const ::NDD::Vehicle_Task_Attribute& attributes(int index) const;
  ::NDD::Vehicle_Task_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >&
      attributes() const;

  // required string locationId = 1;
  bool has_locationid() const;
  void clear_locationid();
  static const int kLocationIdFieldNumber = 1;
  const ::std::string& locationid() const;
  void set_locationid(const ::std::string& value);
  #if LANG_CXX11
  void set_locationid(::std::string&& value);
  #endif
  void set_locationid(const char* value);
  void set_locationid(const char* value, size_t size);
  ::std::string* mutable_locationid();
  ::std::string* release_locationid();
  void set_allocated_locationid(::std::string* locationid);

  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Task)
 private:
  void set_has_locationid();
  void clear_has_locationid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr locationid_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_Shift : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Shift) */ {
 public:
  Vehicle_Shift();
  virtual ~Vehicle_Shift();

  Vehicle_Shift(const Vehicle_Shift& from);

  inline Vehicle_Shift& operator=(const Vehicle_Shift& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_Shift(Vehicle_Shift&& from) noexcept
    : Vehicle_Shift() {
    *this = ::std::move(from);
  }

  inline Vehicle_Shift& operator=(Vehicle_Shift&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_Shift& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_Shift* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Shift*>(
               &_Vehicle_Shift_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Vehicle_Shift* other);
  friend void swap(Vehicle_Shift& a, Vehicle_Shift& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_Shift* New() const final {
    return CreateMaybeMessage<Vehicle_Shift>(NULL);
  }

  Vehicle_Shift* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_Shift>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle_Shift& from);
  void MergeFrom(const Vehicle_Shift& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Shift* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NDD.Vehicle.Task shiftStart = 1;
  bool has_shiftstart() const;
  void clear_shiftstart();
  static const int kShiftStartFieldNumber = 1;
  private:
  const ::NDD::Vehicle_Task& _internal_shiftstart() const;
  public:
  const ::NDD::Vehicle_Task& shiftstart() const;
  ::NDD::Vehicle_Task* release_shiftstart();
  ::NDD::Vehicle_Task* mutable_shiftstart();
  void set_allocated_shiftstart(::NDD::Vehicle_Task* shiftstart);

  // optional .NDD.Vehicle.Task shiftEnd = 2;
  bool has_shiftend() const;
  void clear_shiftend();
  static const int kShiftEndFieldNumber = 2;
  private:
  const ::NDD::Vehicle_Task& _internal_shiftend() const;
  public:
  const ::NDD::Vehicle_Task& shiftend() const;
  ::NDD::Vehicle_Task* release_shiftend();
  ::NDD::Vehicle_Task* mutable_shiftend();
  void set_allocated_shiftend(::NDD::Vehicle_Task* shiftend);

  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Shift)
 private:
  void set_has_shiftstart();
  void clear_has_shiftstart();
  void set_has_shiftend();
  void clear_has_shiftend();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::NDD::Vehicle_Task* shiftstart_;
  ::NDD::Vehicle_Task* shiftend_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_Capacity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Capacity) */ {
 public:
  Vehicle_Capacity();
  virtual ~Vehicle_Capacity();

  Vehicle_Capacity(const Vehicle_Capacity& from);

  inline Vehicle_Capacity& operator=(const Vehicle_Capacity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_Capacity(Vehicle_Capacity&& from) noexcept
    : Vehicle_Capacity() {
    *this = ::std::move(from);
  }

  inline Vehicle_Capacity& operator=(Vehicle_Capacity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_Capacity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_Capacity* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Capacity*>(
               &_Vehicle_Capacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(Vehicle_Capacity* other);
  friend void swap(Vehicle_Capacity& a, Vehicle_Capacity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_Capacity* New() const final {
    return CreateMaybeMessage<Vehicle_Capacity>(NULL);
  }

  Vehicle_Capacity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_Capacity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle_Capacity& from);
  void MergeFrom(const Vehicle_Capacity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Capacity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // required float capacity = 2;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  float capacity() const;
  void set_capacity(float value);

  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Capacity)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_capacity();
  void clear_has_capacity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  float capacity_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle) */ {
 public:
  Vehicle();
  virtual ~Vehicle();

  Vehicle(const Vehicle& from);

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Vehicle* other);
  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle* New() const final {
    return CreateMaybeMessage<Vehicle>(NULL);
  }

  Vehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle& from);
  void MergeFrom(const Vehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_Task Task;
  typedef Vehicle_Shift Shift;
  typedef Vehicle_Capacity Capacity;

  // accessors -------------------------------------------------------

  // repeated .NDD.Vehicle.Shift shift = 4;
  int shift_size() const;
  void clear_shift();
  static const int kShiftFieldNumber = 4;
  ::NDD::Vehicle_Shift* mutable_shift(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >*
      mutable_shift();
  const ::NDD::Vehicle_Shift& shift(int index) const;
  ::NDD::Vehicle_Shift* add_shift();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >&
      shift() const;

  // repeated .NDD.Vehicle.Capacity capacities = 5;
  int capacities_size() const;
  void clear_capacities();
  static const int kCapacitiesFieldNumber = 5;
  ::NDD::Vehicle_Capacity* mutable_capacities(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >*
      mutable_capacities();
  const ::NDD::Vehicle_Capacity& capacities(int index) const;
  ::NDD::Vehicle_Capacity* add_capacities();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >&
      capacities() const;

  // repeated string transitRuleIds = 6;
  int transitruleids_size() const;
  void clear_transitruleids();
  static const int kTransitRuleIdsFieldNumber = 6;
  const ::std::string& transitruleids(int index) const;
  ::std::string* mutable_transitruleids(int index);
  void set_transitruleids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_transitruleids(int index, ::std::string&& value);
  #endif
  void set_transitruleids(int index, const char* value);
  void set_transitruleids(int index, const char* value, size_t size);
  ::std::string* add_transitruleids();
  void add_transitruleids(const ::std::string& value);
  #if LANG_CXX11
  void add_transitruleids(::std::string&& value);
  #endif
  void add_transitruleids(const char* value);
  void add_transitruleids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& transitruleids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_transitruleids();

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string classId = 2;
  bool has_classid() const;
  void clear_classid();
  static const int kClassIdFieldNumber = 2;
  const ::std::string& classid() const;
  void set_classid(const ::std::string& value);
  #if LANG_CXX11
  void set_classid(::std::string&& value);
  #endif
  void set_classid(const char* value);
  void set_classid(const char* value, size_t size);
  ::std::string* mutable_classid();
  ::std::string* release_classid();
  void set_allocated_classid(::std::string* classid);

  // required string costClassId = 3;
  bool has_costclassid() const;
  void clear_costclassid();
  static const int kCostClassIdFieldNumber = 3;
  const ::std::string& costclassid() const;
  void set_costclassid(const ::std::string& value);
  #if LANG_CXX11
  void set_costclassid(::std::string&& value);
  #endif
  void set_costclassid(const char* value);
  void set_costclassid(const char* value, size_t size);
  ::std::string* mutable_costclassid();
  ::std::string* release_costclassid();
  void set_allocated_costclassid(::std::string* costclassid);

  // @@protoc_insertion_point(class_scope:NDD.Vehicle)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_classid();
  void clear_has_classid();
  void set_has_costclassid();
  void clear_has_costclassid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift > shift_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity > capacities_;
  ::google::protobuf::RepeatedPtrField< ::std::string> transitruleids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr classid_;
  ::google::protobuf::internal::ArenaStringPtr costclassid_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskSequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TaskSequence) */ {
 public:
  TaskSequence();
  virtual ~TaskSequence();

  TaskSequence(const TaskSequence& from);

  inline TaskSequence& operator=(const TaskSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskSequence(TaskSequence&& from) noexcept
    : TaskSequence() {
    *this = ::std::move(from);
  }

  inline TaskSequence& operator=(TaskSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskSequence* internal_default_instance() {
    return reinterpret_cast<const TaskSequence*>(
               &_TaskSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(TaskSequence* other);
  friend void swap(TaskSequence& a, TaskSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskSequence* New() const final {
    return CreateMaybeMessage<TaskSequence>(NULL);
  }

  TaskSequence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskSequence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskSequence& from);
  void MergeFrom(const TaskSequence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string taskId = 3;
  int taskid_size() const;
  void clear_taskid();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& taskid(int index) const;
  ::std::string* mutable_taskid(int index);
  void set_taskid(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(int index, ::std::string&& value);
  #endif
  void set_taskid(int index, const char* value);
  void set_taskid(int index, const char* value, size_t size);
  ::std::string* add_taskid();
  void add_taskid(const ::std::string& value);
  #if LANG_CXX11
  void add_taskid(::std::string&& value);
  #endif
  void add_taskid(const char* value);
  void add_taskid(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& taskid() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_taskid();

  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid();
  static const int kVehicleIdFieldNumber = 1;
  const ::std::string& vehicleid() const;
  void set_vehicleid(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleid(::std::string&& value);
  #endif
  void set_vehicleid(const char* value);
  void set_vehicleid(const char* value, size_t size);
  ::std::string* mutable_vehicleid();
  ::std::string* release_vehicleid();
  void set_allocated_vehicleid(::std::string* vehicleid);

  // required int32 dayIndex = 2;
  bool has_dayindex() const;
  void clear_dayindex();
  static const int kDayIndexFieldNumber = 2;
  ::google::protobuf::int32 dayindex() const;
  void set_dayindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NDD.TaskSequence)
 private:
  void set_has_vehicleid();
  void clear_has_vehicleid();
  void set_has_dayindex();
  void clear_has_dayindex();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> taskid_;
  ::google::protobuf::internal::ArenaStringPtr vehicleid_;
  ::google::protobuf::int32 dayindex_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransitRule_Trigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitRule.Trigger) */ {
 public:
  TransitRule_Trigger();
  virtual ~TransitRule_Trigger();

  TransitRule_Trigger(const TransitRule_Trigger& from);

  inline TransitRule_Trigger& operator=(const TransitRule_Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransitRule_Trigger(TransitRule_Trigger&& from) noexcept
    : TransitRule_Trigger() {
    *this = ::std::move(from);
  }

  inline TransitRule_Trigger& operator=(TransitRule_Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitRule_Trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitRule_Trigger* internal_default_instance() {
    return reinterpret_cast<const TransitRule_Trigger*>(
               &_TransitRule_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(TransitRule_Trigger* other);
  friend void swap(TransitRule_Trigger& a, TransitRule_Trigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransitRule_Trigger* New() const final {
    return CreateMaybeMessage<TransitRule_Trigger>(NULL);
  }

  TransitRule_Trigger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransitRule_Trigger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransitRule_Trigger& from);
  void MergeFrom(const TransitRule_Trigger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitRule_Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // required float quantity = 2;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:NDD.TransitRule.Trigger)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_quantity();
  void clear_has_quantity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float value_;
  float quantity_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransitRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitRule) */ {
 public:
  TransitRule();
  virtual ~TransitRule();

  TransitRule(const TransitRule& from);

  inline TransitRule& operator=(const TransitRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransitRule(TransitRule&& from) noexcept
    : TransitRule() {
    *this = ::std::move(from);
  }

  inline TransitRule& operator=(TransitRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitRule* internal_default_instance() {
    return reinterpret_cast<const TransitRule*>(
               &_TransitRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(TransitRule* other);
  friend void swap(TransitRule& a, TransitRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransitRule* New() const final {
    return CreateMaybeMessage<TransitRule>(NULL);
  }

  TransitRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransitRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransitRule& from);
  void MergeFrom(const TransitRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransitRule_Trigger Trigger;

  // accessors -------------------------------------------------------

  // repeated .NDD.TransitRule.Trigger triggers = 6;
  int triggers_size() const;
  void clear_triggers();
  static const int kTriggersFieldNumber = 6;
  ::NDD::TransitRule_Trigger* mutable_triggers(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >*
      mutable_triggers();
  const ::NDD::TransitRule_Trigger& triggers(int index) const;
  ::NDD::TransitRule_Trigger* add_triggers();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >&
      triggers() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string dimensionId = 2;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 2;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // required string ruleIdPrefix = 5;
  bool has_ruleidprefix() const;
  void clear_ruleidprefix();
  static const int kRuleIdPrefixFieldNumber = 5;
  const ::std::string& ruleidprefix() const;
  void set_ruleidprefix(const ::std::string& value);
  #if LANG_CXX11
  void set_ruleidprefix(::std::string&& value);
  #endif
  void set_ruleidprefix(const char* value);
  void set_ruleidprefix(const char* value, size_t size);
  ::std::string* mutable_ruleidprefix();
  ::std::string* release_ruleidprefix();
  void set_allocated_ruleidprefix(::std::string* ruleidprefix);

  // optional bool useTransitState = 4 [default = false];
  bool has_usetransitstate() const;
  void clear_usetransitstate();
  static const int kUseTransitStateFieldNumber = 4;
  bool usetransitstate() const;
  void set_usetransitstate(bool value);

  // optional bool useStandingState = 3 [default = true];
  bool has_usestandingstate() const;
  void clear_usestandingstate();
  static const int kUseStandingStateFieldNumber = 3;
  bool usestandingstate() const;
  void set_usestandingstate(bool value);

  // @@protoc_insertion_point(class_scope:NDD.TransitRule)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_usestandingstate();
  void clear_has_usestandingstate();
  void set_has_usetransitstate();
  void clear_has_usetransitstate();
  void set_has_ruleidprefix();
  void clear_has_ruleidprefix();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger > triggers_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  ::google::protobuf::internal::ArenaStringPtr ruleidprefix_;
  bool usetransitstate_;
  bool usestandingstate_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(NULL);
  }

  Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.Location locations = 2;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 2;
  ::NDD::Location* mutable_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Location >*
      mutable_locations();
  const ::NDD::Location& locations(int index) const;
  ::NDD::Location* add_locations();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Location >&
      locations() const;

  // repeated .NDD.Job jobs = 3;
  int jobs_size() const;
  void clear_jobs();
  static const int kJobsFieldNumber = 3;
  ::NDD::Job* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Job >*
      mutable_jobs();
  const ::NDD::Job& jobs(int index) const;
  ::NDD::Job* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Job >&
      jobs() const;

  // repeated .NDD.Vehicle vehicles = 4;
  int vehicles_size() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 4;
  ::NDD::Vehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >*
      mutable_vehicles();
  const ::NDD::Vehicle& vehicles(int index) const;
  ::NDD::Vehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >&
      vehicles() const;

  // repeated .NDD.VehicleClass vehicleClasses = 5;
  int vehicleclasses_size() const;
  void clear_vehicleclasses();
  static const int kVehicleClassesFieldNumber = 5;
  ::NDD::VehicleClass* mutable_vehicleclasses(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >*
      mutable_vehicleclasses();
  const ::NDD::VehicleClass& vehicleclasses(int index) const;
  ::NDD::VehicleClass* add_vehicleclasses();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >&
      vehicleclasses() const;

  // repeated .NDD.VehicleCostClass vehicleCostClasses = 6;
  int vehiclecostclasses_size() const;
  void clear_vehiclecostclasses();
  static const int kVehicleCostClassesFieldNumber = 6;
  ::NDD::VehicleCostClass* mutable_vehiclecostclasses(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >*
      mutable_vehiclecostclasses();
  const ::NDD::VehicleCostClass& vehiclecostclasses(int index) const;
  ::NDD::VehicleCostClass* add_vehiclecostclasses();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >&
      vehiclecostclasses() const;

  // repeated .NDD.TransitRule transitRules = 7;
  int transitrules_size() const;
  void clear_transitrules();
  static const int kTransitRulesFieldNumber = 7;
  ::NDD::TransitRule* mutable_transitrules(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >*
      mutable_transitrules();
  const ::NDD::TransitRule& transitrules(int index) const;
  ::NDD::TransitRule* add_transitrules();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >&
      transitrules() const;

  // repeated .NDD.TransitGenerator transitGenerators = 8;
  int transitgenerators_size() const;
  void clear_transitgenerators();
  static const int kTransitGeneratorsFieldNumber = 8;
  ::NDD::TransitGenerator* mutable_transitgenerators(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >*
      mutable_transitgenerators();
  const ::NDD::TransitGenerator& transitgenerators(int index) const;
  ::NDD::TransitGenerator* add_transitgenerators();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >&
      transitgenerators() const;

  // repeated .NDD.TaskSequence taskSequence = 9;
  int tasksequence_size() const;
  void clear_tasksequence();
  static const int kTaskSequenceFieldNumber = 9;
  ::NDD::TaskSequence* mutable_tasksequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
      mutable_tasksequence();
  const ::NDD::TaskSequence& tasksequence(int index) const;
  ::NDD::TaskSequence* add_tasksequence();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
      tasksequence() const;

  // required .NDD.DimensionConfiguration dimensions = 1;
  bool has_dimensions() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 1;
  private:
  const ::NDD::DimensionConfiguration& _internal_dimensions() const;
  public:
  const ::NDD::DimensionConfiguration& dimensions() const;
  ::NDD::DimensionConfiguration* release_dimensions();
  ::NDD::DimensionConfiguration* mutable_dimensions();
  void set_allocated_dimensions(::NDD::DimensionConfiguration* dimensions);

  // @@protoc_insertion_point(class_scope:NDD.Model)
 private:
  void set_has_dimensions();
  void clear_has_dimensions();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Location > locations_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Job > jobs_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass > vehicleclasses_;
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass > vehiclecostclasses_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule > transitrules_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator > transitgenerators_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence > tasksequence_;
  ::NDD::DimensionConfiguration* dimensions_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolveRequest) */ {
 public:
  SolveRequest();
  virtual ~SolveRequest();

  SolveRequest(const SolveRequest& from);

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(SolveRequest* other);
  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolveRequest* New() const final {
    return CreateMaybeMessage<SolveRequest>(NULL);
  }

  SolveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolveRequest& from);
  void MergeFrom(const SolveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolveRequest_SolveType SolveType;
  static const SolveType Optimise =
    SolveRequest_SolveType_Optimise;
  static const SolveType Evaluate =
    SolveRequest_SolveType_Evaluate;
  static const SolveType ReOptimise =
    SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static const SolveType SolveType_MIN =
    SolveRequest_SolveType_SolveType_MIN;
  static const SolveType SolveType_MAX =
    SolveRequest_SolveType_SolveType_MAX;
  static const int SolveType_ARRAYSIZE =
    SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  static inline const ::std::string& SolveType_Name(SolveType value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(const ::std::string& name,
      SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NDD.TaskSequence routes = 3;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 3;
  ::NDD::TaskSequence* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
      mutable_routes();
  const ::NDD::TaskSequence& routes(int index) const;
  ::NDD::TaskSequence* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
      routes() const;

  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIDFieldNumber = 2;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // optional .NDD.Model model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  private:
  const ::NDD::Model& _internal_model() const;
  public:
  const ::NDD::Model& model() const;
  ::NDD::Model* release_model();
  ::NDD::Model* mutable_model();
  void set_allocated_model(::NDD::Model* model);

  // optional .NDD.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype();
  static const int kSolveTypeFieldNumber = 4;
  ::NDD::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::NDD::SolveRequest_SolveType value);

  // @@protoc_insertion_point(class_scope:NDD.SolveRequest)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_modelid();
  void clear_has_modelid();
  void set_has_solvetype();
  void clear_has_solvetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence > routes_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  ::NDD::Model* model_;
  int solvetype_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_StopAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.StopAttribute) */ {
 public:
  SolutionResponse_StopAttribute();
  virtual ~SolutionResponse_StopAttribute();

  SolutionResponse_StopAttribute(const SolutionResponse_StopAttribute& from);

  inline SolutionResponse_StopAttribute& operator=(const SolutionResponse_StopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_StopAttribute(SolutionResponse_StopAttribute&& from) noexcept
    : SolutionResponse_StopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_StopAttribute& operator=(SolutionResponse_StopAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_StopAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_StopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_StopAttribute*>(
               &_SolutionResponse_StopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(SolutionResponse_StopAttribute* other);
  friend void swap(SolutionResponse_StopAttribute& a, SolutionResponse_StopAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_StopAttribute* New() const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(NULL);
  }

  SolutionResponse_StopAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_StopAttribute& from);
  void MergeFrom(const SolutionResponse_StopAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_StopAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 1;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue();
  static const int kStartValueFieldNumber = 2;
  float startvalue() const;
  void set_startvalue(float value);

  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue();
  static const int kEndValueFieldNumber = 3;
  float endvalue() const;
  void set_endvalue(float value);

  // required float cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  float cost() const;
  void set_cost(float value);

  // required float slackValue = 5;
  bool has_slackvalue() const;
  void clear_slackvalue();
  static const int kSlackValueFieldNumber = 5;
  float slackvalue() const;
  void set_slackvalue(float value);

  // required float slackCost = 6;
  bool has_slackcost() const;
  void clear_slackcost();
  static const int kSlackCostFieldNumber = 6;
  float slackcost() const;
  void set_slackcost(float value);

  // required float tardyValue = 7;
  bool has_tardyvalue() const;
  void clear_tardyvalue();
  static const int kTardyValueFieldNumber = 7;
  float tardyvalue() const;
  void set_tardyvalue(float value);

  // required float tardyCost = 8;
  bool has_tardycost() const;
  void clear_tardycost();
  static const int kTardyCostFieldNumber = 8;
  float tardycost() const;
  void set_tardycost(float value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.StopAttribute)
 private:
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_startvalue();
  void clear_has_startvalue();
  void set_has_endvalue();
  void clear_has_endvalue();
  void set_has_cost();
  void clear_has_cost();
  void set_has_slackvalue();
  void clear_has_slackvalue();
  void set_has_slackcost();
  void clear_has_slackcost();
  void set_has_tardyvalue();
  void clear_has_tardyvalue();
  void set_has_tardycost();
  void clear_has_tardycost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  float startvalue_;
  float endvalue_;
  float cost_;
  float slackvalue_;
  float slackcost_;
  float tardyvalue_;
  float tardycost_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_InterStopAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.InterStopAttribute) */ {
 public:
  SolutionResponse_InterStopAttribute();
  virtual ~SolutionResponse_InterStopAttribute();

  SolutionResponse_InterStopAttribute(const SolutionResponse_InterStopAttribute& from);

  inline SolutionResponse_InterStopAttribute& operator=(const SolutionResponse_InterStopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_InterStopAttribute(SolutionResponse_InterStopAttribute&& from) noexcept
    : SolutionResponse_InterStopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStopAttribute& operator=(SolutionResponse_InterStopAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_InterStopAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_InterStopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStopAttribute*>(
               &_SolutionResponse_InterStopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(SolutionResponse_InterStopAttribute* other);
  friend void swap(SolutionResponse_InterStopAttribute& a, SolutionResponse_InterStopAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_InterStopAttribute* New() const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(NULL);
  }

  SolutionResponse_InterStopAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_InterStopAttribute& from);
  void MergeFrom(const SolutionResponse_InterStopAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStopAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 1;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue();
  static const int kStartValueFieldNumber = 2;
  float startvalue() const;
  void set_startvalue(float value);

  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue();
  static const int kEndValueFieldNumber = 3;
  float endvalue() const;
  void set_endvalue(float value);

  // required float cost = 4;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  float cost() const;
  void set_cost(float value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.InterStopAttribute)
 private:
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_startvalue();
  void clear_has_startvalue();
  void set_has_endvalue();
  void clear_has_endvalue();
  void set_has_cost();
  void clear_has_cost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  float startvalue_;
  float endvalue_;
  float cost_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Stop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Stop) */ {
 public:
  SolutionResponse_Stop();
  virtual ~SolutionResponse_Stop();

  SolutionResponse_Stop(const SolutionResponse_Stop& from);

  inline SolutionResponse_Stop& operator=(const SolutionResponse_Stop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Stop(SolutionResponse_Stop&& from) noexcept
    : SolutionResponse_Stop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Stop& operator=(SolutionResponse_Stop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Stop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Stop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Stop*>(
               &_SolutionResponse_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(SolutionResponse_Stop* other);
  friend void swap(SolutionResponse_Stop& a, SolutionResponse_Stop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Stop* New() const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(NULL);
  }

  SolutionResponse_Stop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Stop& from);
  void MergeFrom(const SolutionResponse_Stop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Stop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.SolutionResponse.StopAttribute attributes = 6;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  ::NDD::SolutionResponse_StopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >*
      mutable_attributes();
  const ::NDD::SolutionResponse_StopAttribute& attributes(int index) const;
  ::NDD::SolutionResponse_StopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >&
      attributes() const;

  // required string locationId = 3;
  bool has_locationid() const;
  void clear_locationid();
  static const int kLocationIdFieldNumber = 3;
  const ::std::string& locationid() const;
  void set_locationid(const ::std::string& value);
  #if LANG_CXX11
  void set_locationid(::std::string&& value);
  #endif
  void set_locationid(const char* value);
  void set_locationid(const char* value, size_t size);
  ::std::string* mutable_locationid();
  ::std::string* release_locationid();
  void set_allocated_locationid(::std::string* locationid);

  // required string taskId = 4;
  bool has_taskid() const;
  void clear_taskid();
  static const int kTaskIdFieldNumber = 4;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const char* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // required string jobId = 5;
  bool has_jobid() const;
  void clear_jobid();
  static const int kJobIdFieldNumber = 5;
  const ::std::string& jobid() const;
  void set_jobid(const ::std::string& value);
  #if LANG_CXX11
  void set_jobid(::std::string&& value);
  #endif
  void set_jobid(const char* value);
  void set_jobid(const char* value, size_t size);
  ::std::string* mutable_jobid();
  ::std::string* release_jobid();
  void set_allocated_jobid(::std::string* jobid);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int32 sequence() const;
  void set_sequence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Stop)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_locationid();
  void clear_has_locationid();
  void set_has_taskid();
  void clear_has_taskid();
  void set_has_jobid();
  void clear_has_jobid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr locationid_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr jobid_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sequence_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_InterStop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.InterStop) */ {
 public:
  SolutionResponse_InterStop();
  virtual ~SolutionResponse_InterStop();

  SolutionResponse_InterStop(const SolutionResponse_InterStop& from);

  inline SolutionResponse_InterStop& operator=(const SolutionResponse_InterStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_InterStop(SolutionResponse_InterStop&& from) noexcept
    : SolutionResponse_InterStop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStop& operator=(SolutionResponse_InterStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_InterStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_InterStop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStop*>(
               &_SolutionResponse_InterStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(SolutionResponse_InterStop* other);
  friend void swap(SolutionResponse_InterStop& a, SolutionResponse_InterStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_InterStop* New() const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(NULL);
  }

  SolutionResponse_InterStop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_InterStop& from);
  void MergeFrom(const SolutionResponse_InterStop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.SolutionResponse.InterStopAttribute attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::NDD::SolutionResponse_InterStopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >*
      mutable_attributes();
  const ::NDD::SolutionResponse_InterStopAttribute& attributes(int index) const;
  ::NDD::SolutionResponse_InterStopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >&
      attributes() const;

  // repeated .NDD.Geocode routeSegments = 4;
  int routesegments_size() const;
  void clear_routesegments();
  static const int kRouteSegmentsFieldNumber = 4;
  ::NDD::Geocode* mutable_routesegments(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >*
      mutable_routesegments();
  const ::NDD::Geocode& routesegments(int index) const;
  ::NDD::Geocode* add_routesegments();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >&
      routesegments() const;

  // required int32 fromStopId = 1;
  bool has_fromstopid() const;
  void clear_fromstopid();
  static const int kFromStopIdFieldNumber = 1;
  ::google::protobuf::int32 fromstopid() const;
  void set_fromstopid(::google::protobuf::int32 value);

  // required int32 toStopId = 2;
  bool has_tostopid() const;
  void clear_tostopid();
  static const int kToStopIdFieldNumber = 2;
  ::google::protobuf::int32 tostopid() const;
  void set_tostopid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.InterStop)
 private:
  void set_has_fromstopid();
  void clear_has_fromstopid();
  void set_has_tostopid();
  void clear_has_tostopid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::NDD::Geocode > routesegments_;
  ::google::protobuf::int32 fromstopid_;
  ::google::protobuf::int32 tostopid_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_TransitRuleAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.TransitRuleAttribute) */ {
 public:
  SolutionResponse_TransitRuleAttribute();
  virtual ~SolutionResponse_TransitRuleAttribute();

  SolutionResponse_TransitRuleAttribute(const SolutionResponse_TransitRuleAttribute& from);

  inline SolutionResponse_TransitRuleAttribute& operator=(const SolutionResponse_TransitRuleAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_TransitRuleAttribute(SolutionResponse_TransitRuleAttribute&& from) noexcept
    : SolutionResponse_TransitRuleAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_TransitRuleAttribute& operator=(SolutionResponse_TransitRuleAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_TransitRuleAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_TransitRuleAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_TransitRuleAttribute*>(
               &_SolutionResponse_TransitRuleAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(SolutionResponse_TransitRuleAttribute* other);
  friend void swap(SolutionResponse_TransitRuleAttribute& a, SolutionResponse_TransitRuleAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_TransitRuleAttribute* New() const final {
    return CreateMaybeMessage<SolutionResponse_TransitRuleAttribute>(NULL);
  }

  SolutionResponse_TransitRuleAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_TransitRuleAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_TransitRuleAttribute& from);
  void MergeFrom(const SolutionResponse_TransitRuleAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_TransitRuleAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ruleId = 1;
  bool has_ruleid() const;
  void clear_ruleid();
  static const int kRuleIdFieldNumber = 1;
  const ::std::string& ruleid() const;
  void set_ruleid(const ::std::string& value);
  #if LANG_CXX11
  void set_ruleid(::std::string&& value);
  #endif
  void set_ruleid(const char* value);
  void set_ruleid(const char* value, size_t size);
  ::std::string* mutable_ruleid();
  ::std::string* release_ruleid();
  void set_allocated_ruleid(::std::string* ruleid);

  // required string dimId = 2;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 2;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // required int32 fromStopId = 3;
  bool has_fromstopid() const;
  void clear_fromstopid();
  static const int kFromStopIdFieldNumber = 3;
  ::google::protobuf::int32 fromstopid() const;
  void set_fromstopid(::google::protobuf::int32 value);

  // required int32 toStopId = 4;
  bool has_tostopid() const;
  void clear_tostopid();
  static const int kToStopIdFieldNumber = 4;
  ::google::protobuf::int32 tostopid() const;
  void set_tostopid(::google::protobuf::int32 value);

  // required float startValue = 5;
  bool has_startvalue() const;
  void clear_startvalue();
  static const int kStartValueFieldNumber = 5;
  float startvalue() const;
  void set_startvalue(float value);

  // required float endValue = 6;
  bool has_endvalue() const;
  void clear_endvalue();
  static const int kEndValueFieldNumber = 6;
  float endvalue() const;
  void set_endvalue(float value);

  // required float cost = 7;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 7;
  float cost() const;
  void set_cost(float value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.TransitRuleAttribute)
 private:
  void set_has_ruleid();
  void clear_has_ruleid();
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_fromstopid();
  void clear_has_fromstopid();
  void set_has_tostopid();
  void clear_has_tostopid();
  void set_has_startvalue();
  void clear_has_startvalue();
  void set_has_endvalue();
  void clear_has_endvalue();
  void set_has_cost();
  void clear_has_cost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ruleid_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  ::google::protobuf::int32 fromstopid_;
  ::google::protobuf::int32 tostopid_;
  float startvalue_;
  float endvalue_;
  float cost_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Route) */ {
 public:
  SolutionResponse_Route();
  virtual ~SolutionResponse_Route();

  SolutionResponse_Route(const SolutionResponse_Route& from);

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Route& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(SolutionResponse_Route* other);
  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Route* New() const final {
    return CreateMaybeMessage<SolutionResponse_Route>(NULL);
  }

  SolutionResponse_Route* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Route& from);
  void MergeFrom(const SolutionResponse_Route& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.SolutionResponse.Stop stops = 2;
  int stops_size() const;
  void clear_stops();
  static const int kStopsFieldNumber = 2;
  ::NDD::SolutionResponse_Stop* mutable_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >*
      mutable_stops();
  const ::NDD::SolutionResponse_Stop& stops(int index) const;
  ::NDD::SolutionResponse_Stop* add_stops();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >&
      stops() const;

  // repeated .NDD.SolutionResponse.InterStop interStops = 3;
  int interstops_size() const;
  void clear_interstops();
  static const int kInterStopsFieldNumber = 3;
  ::NDD::SolutionResponse_InterStop* mutable_interstops(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >*
      mutable_interstops();
  const ::NDD::SolutionResponse_InterStop& interstops(int index) const;
  ::NDD::SolutionResponse_InterStop* add_interstops();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >&
      interstops() const;

  // repeated float fixedCost = 4;
  int fixedcost_size() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 4;
  float fixedcost(int index) const;
  void set_fixedcost(int index, float value);
  void add_fixedcost(float value);
  const ::google::protobuf::RepeatedField< float >&
      fixedcost() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_fixedcost();

  // repeated .NDD.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
  int transitruleattributes_size() const;
  void clear_transitruleattributes();
  static const int kTransitRuleAttributesFieldNumber = 5;
  ::NDD::SolutionResponse_TransitRuleAttribute* mutable_transitruleattributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >*
      mutable_transitruleattributes();
  const ::NDD::SolutionResponse_TransitRuleAttribute& transitruleattributes(int index) const;
  ::NDD::SolutionResponse_TransitRuleAttribute* add_transitruleattributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >&
      transitruleattributes() const;

  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid();
  static const int kVehicleIdFieldNumber = 1;
  const ::std::string& vehicleid() const;
  void set_vehicleid(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleid(::std::string&& value);
  #endif
  void set_vehicleid(const char* value);
  void set_vehicleid(const char* value, size_t size);
  ::std::string* mutable_vehicleid();
  ::std::string* release_vehicleid();
  void set_allocated_vehicleid(::std::string* vehicleid);

  // required int32 day = 6;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 6;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Route)
 private:
  void set_has_vehicleid();
  void clear_has_vehicleid();
  void set_has_day();
  void clear_has_day();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop > stops_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop > interstops_;
  ::google::protobuf::RepeatedField< float > fixedcost_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute > transitruleattributes_;
  ::google::protobuf::internal::ArenaStringPtr vehicleid_;
  ::google::protobuf::int32 day_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Infeasibility_Info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Infeasibility.Info) */ {
 public:
  SolutionResponse_Infeasibility_Info();
  virtual ~SolutionResponse_Infeasibility_Info();

  SolutionResponse_Infeasibility_Info(const SolutionResponse_Infeasibility_Info& from);

  inline SolutionResponse_Infeasibility_Info& operator=(const SolutionResponse_Infeasibility_Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Infeasibility_Info(SolutionResponse_Infeasibility_Info&& from) noexcept
    : SolutionResponse_Infeasibility_Info() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility_Info& operator=(SolutionResponse_Infeasibility_Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Infeasibility_Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Infeasibility_Info* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility_Info*>(
               &_SolutionResponse_Infeasibility_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(SolutionResponse_Infeasibility_Info* other);
  friend void swap(SolutionResponse_Infeasibility_Info& a, SolutionResponse_Infeasibility_Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Infeasibility_Info* New() const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(NULL);
  }

  SolutionResponse_Infeasibility_Info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Infeasibility_Info& from);
  void MergeFrom(const SolutionResponse_Infeasibility_Info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility_Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string constrainingTaskIds = 6;
  int constrainingtaskids_size() const;
  void clear_constrainingtaskids();
  static const int kConstrainingTaskIdsFieldNumber = 6;
  const ::std::string& constrainingtaskids(int index) const;
  ::std::string* mutable_constrainingtaskids(int index);
  void set_constrainingtaskids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_constrainingtaskids(int index, ::std::string&& value);
  #endif
  void set_constrainingtaskids(int index, const char* value);
  void set_constrainingtaskids(int index, const char* value, size_t size);
  ::std::string* add_constrainingtaskids();
  void add_constrainingtaskids(const ::std::string& value);
  #if LANG_CXX11
  void add_constrainingtaskids(::std::string&& value);
  #endif
  void add_constrainingtaskids(const char* value);
  void add_constrainingtaskids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_constrainingtaskids();

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string dimId = 2;
  bool has_dimid() const;
  void clear_dimid();
  static const int kDimIdFieldNumber = 2;
  const ::std::string& dimid() const;
  void set_dimid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimid(::std::string&& value);
  #endif
  void set_dimid(const char* value);
  void set_dimid(const char* value, size_t size);
  ::std::string* mutable_dimid();
  ::std::string* release_dimid();
  void set_allocated_dimid(::std::string* dimid);

  // optional float limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  float limit() const;
  void set_limit(float value);

  // optional float value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  float value() const;
  void set_value(float value);

  // optional int64 count = 5;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 5;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Infeasibility.Info)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_dimid();
  void clear_has_dimid();
  void set_has_limit();
  void clear_has_limit();
  void set_has_value();
  void clear_has_value();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> constrainingtaskids_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr dimid_;
  float limit_;
  float value_;
  ::google::protobuf::int64 count_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Infeasibility : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Infeasibility) */ {
 public:
  SolutionResponse_Infeasibility();
  virtual ~SolutionResponse_Infeasibility();

  SolutionResponse_Infeasibility(const SolutionResponse_Infeasibility& from);

  inline SolutionResponse_Infeasibility& operator=(const SolutionResponse_Infeasibility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Infeasibility(SolutionResponse_Infeasibility&& from) noexcept
    : SolutionResponse_Infeasibility() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility& operator=(SolutionResponse_Infeasibility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Infeasibility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Infeasibility* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility*>(
               &_SolutionResponse_Infeasibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(SolutionResponse_Infeasibility* other);
  friend void swap(SolutionResponse_Infeasibility& a, SolutionResponse_Infeasibility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Infeasibility* New() const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(NULL);
  }

  SolutionResponse_Infeasibility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Infeasibility& from);
  void MergeFrom(const SolutionResponse_Infeasibility& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Infeasibility_Info Info;

  // accessors -------------------------------------------------------

  // repeated .NDD.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
  int infeasibilityinfo_size() const;
  void clear_infeasibilityinfo();
  static const int kInfeasibilityInfoFieldNumber = 2;
  ::NDD::SolutionResponse_Infeasibility_Info* mutable_infeasibilityinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >*
      mutable_infeasibilityinfo();
  const ::NDD::SolutionResponse_Infeasibility_Info& infeasibilityinfo(int index) const;
  ::NDD::SolutionResponse_Infeasibility_Info* add_infeasibilityinfo();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >&
      infeasibilityinfo() const;

  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid();
  static const int kTaskIdFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const char* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Infeasibility)
 private:
  void set_has_taskid();
  void clear_has_taskid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info > infeasibilityinfo_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_CompactSolution : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.CompactSolution) */ {
 public:
  SolutionResponse_CompactSolution();
  virtual ~SolutionResponse_CompactSolution();

  SolutionResponse_CompactSolution(const SolutionResponse_CompactSolution& from);

  inline SolutionResponse_CompactSolution& operator=(const SolutionResponse_CompactSolution& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_CompactSolution(SolutionResponse_CompactSolution&& from) noexcept
    : SolutionResponse_CompactSolution() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_CompactSolution& operator=(SolutionResponse_CompactSolution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_CompactSolution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_CompactSolution* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_CompactSolution*>(
               &_SolutionResponse_CompactSolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(SolutionResponse_CompactSolution* other);
  friend void swap(SolutionResponse_CompactSolution& a, SolutionResponse_CompactSolution& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_CompactSolution* New() const final {
    return CreateMaybeMessage<SolutionResponse_CompactSolution>(NULL);
  }

  SolutionResponse_CompactSolution* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_CompactSolution>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_CompactSolution& from);
  void MergeFrom(const SolutionResponse_CompactSolution& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_CompactSolution* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.TaskSequence taskSequence = 1;
  int tasksequence_size() const;
  void clear_tasksequence();
  static const int kTaskSequenceFieldNumber = 1;
  ::NDD::TaskSequence* mutable_tasksequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
      mutable_tasksequence();
  const ::NDD::TaskSequence& tasksequence(int index) const;
  ::NDD::TaskSequence* add_tasksequence();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
      tasksequence() const;

  // repeated float objectives = 2;
  int objectives_size() const;
  void clear_objectives();
  static const int kObjectivesFieldNumber = 2;
  float objectives(int index) const;
  void set_objectives(int index, float value);
  void add_objectives(float value);
  const ::google::protobuf::RepeatedField< float >&
      objectives() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_objectives();

  // repeated string objectiveNames = 3;
  int objectivenames_size() const;
  void clear_objectivenames();
  static const int kObjectiveNamesFieldNumber = 3;
  const ::std::string& objectivenames(int index) const;
  ::std::string* mutable_objectivenames(int index);
  void set_objectivenames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_objectivenames(int index, ::std::string&& value);
  #endif
  void set_objectivenames(int index, const char* value);
  void set_objectivenames(int index, const char* value, size_t size);
  ::std::string* add_objectivenames();
  void add_objectivenames(const ::std::string& value);
  #if LANG_CXX11
  void add_objectivenames(::std::string&& value);
  #endif
  void add_objectivenames(const char* value);
  void add_objectivenames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& objectivenames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_objectivenames();

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.CompactSolution)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence > tasksequence_;
  ::google::protobuf::RepeatedField< float > objectives_;
  ::google::protobuf::RepeatedPtrField< ::std::string> objectivenames_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_SolutionInstance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.SolutionInstance) */ {
 public:
  SolutionResponse_SolutionInstance();
  virtual ~SolutionResponse_SolutionInstance();

  SolutionResponse_SolutionInstance(const SolutionResponse_SolutionInstance& from);

  inline SolutionResponse_SolutionInstance& operator=(const SolutionResponse_SolutionInstance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_SolutionInstance(SolutionResponse_SolutionInstance&& from) noexcept
    : SolutionResponse_SolutionInstance() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_SolutionInstance& operator=(SolutionResponse_SolutionInstance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_SolutionInstance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_SolutionInstance* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_SolutionInstance*>(
               &_SolutionResponse_SolutionInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(SolutionResponse_SolutionInstance* other);
  friend void swap(SolutionResponse_SolutionInstance& a, SolutionResponse_SolutionInstance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_SolutionInstance* New() const final {
    return CreateMaybeMessage<SolutionResponse_SolutionInstance>(NULL);
  }

  SolutionResponse_SolutionInstance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_SolutionInstance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_SolutionInstance& from);
  void MergeFrom(const SolutionResponse_SolutionInstance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_SolutionInstance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NDD.SolutionResponse.Route routes = 1;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 1;
  ::NDD::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >*
      mutable_routes();
  const ::NDD::SolutionResponse_Route& routes(int index) const;
  ::NDD::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >&
      routes() const;

  // repeated .NDD.SolutionResponse.Infeasibility infeasibilities = 2;
  int infeasibilities_size() const;
  void clear_infeasibilities();
  static const int kInfeasibilitiesFieldNumber = 2;
  ::NDD::SolutionResponse_Infeasibility* mutable_infeasibilities(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >*
      mutable_infeasibilities();
  const ::NDD::SolutionResponse_Infeasibility& infeasibilities(int index) const;
  ::NDD::SolutionResponse_Infeasibility* add_infeasibilities();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >&
      infeasibilities() const;

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.SolutionInstance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route > routes_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility > infeasibilities_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse) */ {
 public:
  SolutionResponse();
  virtual ~SolutionResponse();

  SolutionResponse(const SolutionResponse& from);

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(SolutionResponse* other);
  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse* New() const final {
    return CreateMaybeMessage<SolutionResponse>(NULL);
  }

  SolutionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse& from);
  void MergeFrom(const SolutionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_StopAttribute StopAttribute;
  typedef SolutionResponse_InterStopAttribute InterStopAttribute;
  typedef SolutionResponse_Stop Stop;
  typedef SolutionResponse_InterStop InterStop;
  typedef SolutionResponse_TransitRuleAttribute TransitRuleAttribute;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_Infeasibility Infeasibility;
  typedef SolutionResponse_CompactSolution CompactSolution;
  typedef SolutionResponse_SolutionInstance SolutionInstance;

  // accessors -------------------------------------------------------

  // repeated .NDD.SolutionResponse.CompactSolution frontier = 1;
  int frontier_size() const;
  void clear_frontier();
  static const int kFrontierFieldNumber = 1;
  ::NDD::SolutionResponse_CompactSolution* mutable_frontier(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >*
      mutable_frontier();
  const ::NDD::SolutionResponse_CompactSolution& frontier(int index) const;
  ::NDD::SolutionResponse_CompactSolution* add_frontier();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >&
      frontier() const;

  // optional .NDD.SolutionResponse.SolutionInstance instance = 2;
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 2;
  private:
  const ::NDD::SolutionResponse_SolutionInstance& _internal_instance() const;
  public:
  const ::NDD::SolutionResponse_SolutionInstance& instance() const;
  ::NDD::SolutionResponse_SolutionInstance* release_instance();
  ::NDD::SolutionResponse_SolutionInstance* mutable_instance();
  void set_allocated_instance(::NDD::SolutionResponse_SolutionInstance* instance);

  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse)
 private:
  void set_has_instance();
  void clear_has_instance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution > frontier_;
  ::NDD::SolutionResponse_SolutionInstance* instance_;
  friend struct ::protobuf_ndd_2dcmibu6krtqja_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InternalDimension

// required string id = 1;
inline bool InternalDimension::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalDimension::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalDimension::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalDimension::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& InternalDimension::id() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.id)
  return id_.GetNoArena();
}
inline void InternalDimension::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.id)
}
#if LANG_CXX11
inline void InternalDimension::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.InternalDimension.id)
}
#endif
inline void InternalDimension::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.InternalDimension.id)
}
inline void InternalDimension::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.InternalDimension.id)
}
inline ::std::string* InternalDimension::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.InternalDimension.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalDimension::release_id() {
  // @@protoc_insertion_point(field_release:NDD.InternalDimension.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalDimension::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.InternalDimension.id)
}

// required .NDD.InternalDimension.eMeasurementUnit measurementUnit = 2;
inline bool InternalDimension::has_measurementunit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalDimension::set_has_measurementunit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalDimension::clear_has_measurementunit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalDimension::clear_measurementunit() {
  measurementunit_ = 0;
  clear_has_measurementunit();
}
inline ::NDD::InternalDimension_eMeasurementUnit InternalDimension::measurementunit() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.measurementUnit)
  return static_cast< ::NDD::InternalDimension_eMeasurementUnit >(measurementunit_);
}
inline void InternalDimension::set_measurementunit(::NDD::InternalDimension_eMeasurementUnit value) {
  assert(::NDD::InternalDimension_eMeasurementUnit_IsValid(value));
  set_has_measurementunit();
  measurementunit_ = value;
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.measurementUnit)
}

// optional float slackMax = 3 [default = 0];
inline bool InternalDimension::has_slackmax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalDimension::set_has_slackmax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalDimension::clear_has_slackmax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalDimension::clear_slackmax() {
  slackmax_ = 0;
  clear_has_slackmax();
}
inline float InternalDimension::slackmax() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.slackMax)
  return slackmax_;
}
inline void InternalDimension::set_slackmax(float value) {
  set_has_slackmax();
  slackmax_ = value;
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.slackMax)
}

// optional float tardyMax = 4 [default = 0];
inline bool InternalDimension::has_tardymax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalDimension::set_has_tardymax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalDimension::clear_has_tardymax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalDimension::clear_tardymax() {
  tardymax_ = 0;
  clear_has_tardymax();
}
inline float InternalDimension::tardymax() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.tardyMax)
  return tardymax_;
}
inline void InternalDimension::set_tardymax(float value) {
  set_has_tardymax();
  tardymax_ = value;
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.tardyMax)
}

// -------------------------------------------------------------------

// CapacityDimension

// required string id = 1;
inline bool CapacityDimension::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CapacityDimension::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CapacityDimension::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CapacityDimension::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& CapacityDimension::id() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.id)
  return id_.GetNoArena();
}
inline void CapacityDimension::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.id)
}
#if LANG_CXX11
inline void CapacityDimension::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.CapacityDimension.id)
}
#endif
inline void CapacityDimension::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.CapacityDimension.id)
}
inline void CapacityDimension::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.CapacityDimension.id)
}
inline ::std::string* CapacityDimension::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.CapacityDimension.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CapacityDimension::release_id() {
  // @@protoc_insertion_point(field_release:NDD.CapacityDimension.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CapacityDimension::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.CapacityDimension.id)
}

// required string units = 2;
inline bool CapacityDimension::has_units() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CapacityDimension::set_has_units() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CapacityDimension::clear_has_units() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CapacityDimension::clear_units() {
  units_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_units();
}
inline const ::std::string& CapacityDimension::units() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.units)
  return units_.GetNoArena();
}
inline void CapacityDimension::set_units(const ::std::string& value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.units)
}
#if LANG_CXX11
inline void CapacityDimension::set_units(::std::string&& value) {
  set_has_units();
  units_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.CapacityDimension.units)
}
#endif
inline void CapacityDimension::set_units(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.CapacityDimension.units)
}
inline void CapacityDimension::set_units(const char* value, size_t size) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.CapacityDimension.units)
}
inline ::std::string* CapacityDimension::mutable_units() {
  set_has_units();
  // @@protoc_insertion_point(field_mutable:NDD.CapacityDimension.units)
  return units_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CapacityDimension::release_units() {
  // @@protoc_insertion_point(field_release:NDD.CapacityDimension.units)
  if (!has_units()) {
    return NULL;
  }
  clear_has_units();
  return units_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CapacityDimension::set_allocated_units(::std::string* units) {
  if (units != NULL) {
    set_has_units();
  } else {
    clear_has_units();
  }
  units_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:NDD.CapacityDimension.units)
}

// optional float slackMax = 3 [default = 0];
inline bool CapacityDimension::has_slackmax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CapacityDimension::set_has_slackmax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CapacityDimension::clear_has_slackmax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CapacityDimension::clear_slackmax() {
  slackmax_ = 0;
  clear_has_slackmax();
}
inline float CapacityDimension::slackmax() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.slackMax)
  return slackmax_;
}
inline void CapacityDimension::set_slackmax(float value) {
  set_has_slackmax();
  slackmax_ = value;
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.slackMax)
}

// optional float tardyMax = 4 [default = 0];
inline bool CapacityDimension::has_tardymax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CapacityDimension::set_has_tardymax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CapacityDimension::clear_has_tardymax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CapacityDimension::clear_tardymax() {
  tardymax_ = 0;
  clear_has_tardymax();
}
inline float CapacityDimension::tardymax() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.tardyMax)
  return tardymax_;
}
inline void CapacityDimension::set_tardymax(float value) {
  set_has_tardymax();
  tardymax_ = value;
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.tardyMax)
}

// -------------------------------------------------------------------

// DimensionConfiguration

// optional .NDD.InternalDimension timeConfig = 1;
inline bool DimensionConfiguration::has_timeconfig() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DimensionConfiguration::set_has_timeconfig() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DimensionConfiguration::clear_has_timeconfig() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DimensionConfiguration::clear_timeconfig() {
  if (timeconfig_ != NULL) timeconfig_->Clear();
  clear_has_timeconfig();
}
inline const ::NDD::InternalDimension& DimensionConfiguration::_internal_timeconfig() const {
  return *timeconfig_;
}
inline const ::NDD::InternalDimension& DimensionConfiguration::timeconfig() const {
  const ::NDD::InternalDimension* p = timeconfig_;
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.timeConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::InternalDimension*>(
      &::NDD::_InternalDimension_default_instance_);
}
inline ::NDD::InternalDimension* DimensionConfiguration::release_timeconfig() {
  // @@protoc_insertion_point(field_release:NDD.DimensionConfiguration.timeConfig)
  clear_has_timeconfig();
  ::NDD::InternalDimension* temp = timeconfig_;
  timeconfig_ = NULL;
  return temp;
}
inline ::NDD::InternalDimension* DimensionConfiguration::mutable_timeconfig() {
  set_has_timeconfig();
  if (timeconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::InternalDimension>(GetArenaNoVirtual());
    timeconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.DimensionConfiguration.timeConfig)
  return timeconfig_;
}
inline void DimensionConfiguration::set_allocated_timeconfig(::NDD::InternalDimension* timeconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timeconfig_;
  }
  if (timeconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timeconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeconfig, submessage_arena);
    }
    set_has_timeconfig();
  } else {
    clear_has_timeconfig();
  }
  timeconfig_ = timeconfig;
  // @@protoc_insertion_point(field_set_allocated:NDD.DimensionConfiguration.timeConfig)
}

// optional .NDD.InternalDimension distanceConfig = 2;
inline bool DimensionConfiguration::has_distanceconfig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DimensionConfiguration::set_has_distanceconfig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DimensionConfiguration::clear_has_distanceconfig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DimensionConfiguration::clear_distanceconfig() {
  if (distanceconfig_ != NULL) distanceconfig_->Clear();
  clear_has_distanceconfig();
}
inline const ::NDD::InternalDimension& DimensionConfiguration::_internal_distanceconfig() const {
  return *distanceconfig_;
}
inline const ::NDD::InternalDimension& DimensionConfiguration::distanceconfig() const {
  const ::NDD::InternalDimension* p = distanceconfig_;
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.distanceConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::InternalDimension*>(
      &::NDD::_InternalDimension_default_instance_);
}
inline ::NDD::InternalDimension* DimensionConfiguration::release_distanceconfig() {
  // @@protoc_insertion_point(field_release:NDD.DimensionConfiguration.distanceConfig)
  clear_has_distanceconfig();
  ::NDD::InternalDimension* temp = distanceconfig_;
  distanceconfig_ = NULL;
  return temp;
}
inline ::NDD::InternalDimension* DimensionConfiguration::mutable_distanceconfig() {
  set_has_distanceconfig();
  if (distanceconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::InternalDimension>(GetArenaNoVirtual());
    distanceconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.DimensionConfiguration.distanceConfig)
  return distanceconfig_;
}
inline void DimensionConfiguration::set_allocated_distanceconfig(::NDD::InternalDimension* distanceconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete distanceconfig_;
  }
  if (distanceconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      distanceconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distanceconfig, submessage_arena);
    }
    set_has_distanceconfig();
  } else {
    clear_has_distanceconfig();
  }
  distanceconfig_ = distanceconfig;
  // @@protoc_insertion_point(field_set_allocated:NDD.DimensionConfiguration.distanceConfig)
}

// repeated .NDD.CapacityDimension capacityDimensions = 3;
inline int DimensionConfiguration::capacitydimensions_size() const {
  return capacitydimensions_.size();
}
inline void DimensionConfiguration::clear_capacitydimensions() {
  capacitydimensions_.Clear();
}
inline ::NDD::CapacityDimension* DimensionConfiguration::mutable_capacitydimensions(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.DimensionConfiguration.capacityDimensions)
  return capacitydimensions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >*
DimensionConfiguration::mutable_capacitydimensions() {
  // @@protoc_insertion_point(field_mutable_list:NDD.DimensionConfiguration.capacityDimensions)
  return &capacitydimensions_;
}
inline const ::NDD::CapacityDimension& DimensionConfiguration::capacitydimensions(int index) const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.capacityDimensions)
  return capacitydimensions_.Get(index);
}
inline ::NDD::CapacityDimension* DimensionConfiguration::add_capacitydimensions() {
  // @@protoc_insertion_point(field_add:NDD.DimensionConfiguration.capacityDimensions)
  return capacitydimensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >&
DimensionConfiguration::capacitydimensions() const {
  // @@protoc_insertion_point(field_list:NDD.DimensionConfiguration.capacityDimensions)
  return capacitydimensions_;
}

// required int32 weekLength = 4;
inline bool DimensionConfiguration::has_weeklength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DimensionConfiguration::set_has_weeklength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DimensionConfiguration::clear_has_weeklength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DimensionConfiguration::clear_weeklength() {
  weeklength_ = 0;
  clear_has_weeklength();
}
inline ::google::protobuf::int32 DimensionConfiguration::weeklength() const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.weekLength)
  return weeklength_;
}
inline void DimensionConfiguration::set_weeklength(::google::protobuf::int32 value) {
  set_has_weeklength();
  weeklength_ = value;
  // @@protoc_insertion_point(field_set:NDD.DimensionConfiguration.weekLength)
}

// required int32 periodLength = 5;
inline bool DimensionConfiguration::has_periodlength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DimensionConfiguration::set_has_periodlength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DimensionConfiguration::clear_has_periodlength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DimensionConfiguration::clear_periodlength() {
  periodlength_ = 0;
  clear_has_periodlength();
}
inline ::google::protobuf::int32 DimensionConfiguration::periodlength() const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.periodLength)
  return periodlength_;
}
inline void DimensionConfiguration::set_periodlength(::google::protobuf::int32 value) {
  set_has_periodlength();
  periodlength_ = value;
  // @@protoc_insertion_point(field_set:NDD.DimensionConfiguration.periodLength)
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geocode::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geocode::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geocode::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:NDD.Geocode.longitude)
  return longitude_;
}
inline void Geocode::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:NDD.Geocode.longitude)
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geocode::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geocode::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geocode::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:NDD.Geocode.latitude)
  return latitude_;
}
inline void Geocode::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:NDD.Geocode.latitude)
}

// -------------------------------------------------------------------

// Window

// required float start = 1;
inline bool Window::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Window::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Window::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Window::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline float Window::start() const {
  // @@protoc_insertion_point(field_get:NDD.Window.start)
  return start_;
}
inline void Window::set_start(float value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:NDD.Window.start)
}

// required float end = 2;
inline bool Window::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Window::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Window::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Window::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline float Window::end() const {
  // @@protoc_insertion_point(field_get:NDD.Window.end)
  return end_;
}
inline void Window::set_end(float value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:NDD.Window.end)
}

// optional float slackCostCoef = 3 [default = 0];
inline bool Window::has_slackcostcoef() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Window::set_has_slackcostcoef() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Window::clear_has_slackcostcoef() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Window::clear_slackcostcoef() {
  slackcostcoef_ = 0;
  clear_has_slackcostcoef();
}
inline float Window::slackcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.Window.slackCostCoef)
  return slackcostcoef_;
}
inline void Window::set_slackcostcoef(float value) {
  set_has_slackcostcoef();
  slackcostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.Window.slackCostCoef)
}

// optional float tardyCostCoef = 4 [default = 0];
inline bool Window::has_tardycostcoef() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Window::set_has_tardycostcoef() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Window::clear_has_tardycostcoef() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Window::clear_tardycostcoef() {
  tardycostcoef_ = 0;
  clear_has_tardycostcoef();
}
inline float Window::tardycostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.Window.tardyCostCoef)
  return tardycostcoef_;
}
inline void Window::set_tardycostcoef(float value) {
  set_has_tardycostcoef();
  tardycostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.Window.tardyCostCoef)
}

// optional float slackMax = 5 [default = -1];
inline bool Window::has_slackmax() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Window::set_has_slackmax() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Window::clear_has_slackmax() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Window::clear_slackmax() {
  slackmax_ = -1;
  clear_has_slackmax();
}
inline float Window::slackmax() const {
  // @@protoc_insertion_point(field_get:NDD.Window.slackMax)
  return slackmax_;
}
inline void Window::set_slackmax(float value) {
  set_has_slackmax();
  slackmax_ = value;
  // @@protoc_insertion_point(field_set:NDD.Window.slackMax)
}

// optional float tardyMax = 6 [default = -1];
inline bool Window::has_tardymax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Window::set_has_tardymax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Window::clear_has_tardymax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Window::clear_tardymax() {
  tardymax_ = -1;
  clear_has_tardymax();
}
inline float Window::tardymax() const {
  // @@protoc_insertion_point(field_get:NDD.Window.tardyMax)
  return tardymax_;
}
inline void Window::set_tardymax(float value) {
  set_has_tardymax();
  tardymax_ = value;
  // @@protoc_insertion_point(field_set:NDD.Window.tardyMax)
}

// -------------------------------------------------------------------

// Location_Attribute

// required string dimensionId = 1;
inline bool Location_Attribute::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location_Attribute::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location_Attribute::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location_Attribute::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& Location_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void Location_Attribute::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Location.Attribute.dimensionId)
}
#if LANG_CXX11
inline void Location_Attribute::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Location.Attribute.dimensionId)
}
#endif
inline void Location_Attribute::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Location.Attribute.dimensionId)
}
inline void Location_Attribute::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Location.Attribute.dimensionId)
}
inline ::std::string* Location_Attribute::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location_Attribute::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.Location.Attribute.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location_Attribute::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.Attribute.dimensionId)
}

// optional string vehicleId = 2;
inline bool Location_Attribute::has_vehicleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location_Attribute::set_has_vehicleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location_Attribute::clear_has_vehicleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location_Attribute::clear_vehicleid() {
  vehicleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicleid();
}
inline const ::std::string& Location_Attribute::vehicleid() const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.vehicleId)
  return vehicleid_.GetNoArena();
}
inline void Location_Attribute::set_vehicleid(const ::std::string& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Location.Attribute.vehicleId)
}
#if LANG_CXX11
inline void Location_Attribute::set_vehicleid(::std::string&& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Location.Attribute.vehicleId)
}
#endif
inline void Location_Attribute::set_vehicleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Location.Attribute.vehicleId)
}
inline void Location_Attribute::set_vehicleid(const char* value, size_t size) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Location.Attribute.vehicleId)
}
inline ::std::string* Location_Attribute::mutable_vehicleid() {
  set_has_vehicleid();
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.vehicleId)
  return vehicleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location_Attribute::release_vehicleid() {
  // @@protoc_insertion_point(field_release:NDD.Location.Attribute.vehicleId)
  if (!has_vehicleid()) {
    return NULL;
  }
  clear_has_vehicleid();
  return vehicleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location_Attribute::set_allocated_vehicleid(::std::string* vehicleid) {
  if (vehicleid != NULL) {
    set_has_vehicleid();
  } else {
    clear_has_vehicleid();
  }
  vehicleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicleid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.Attribute.vehicleId)
}

// optional float quantity = 3;
inline bool Location_Attribute::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location_Attribute::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location_Attribute::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location_Attribute::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float Location_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.quantity)
  return quantity_;
}
inline void Location_Attribute::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:NDD.Location.Attribute.quantity)
}

// repeated .NDD.Window arrivalWindows = 4;
inline int Location_Attribute::arrivalwindows_size() const {
  return arrivalwindows_.size();
}
inline void Location_Attribute::clear_arrivalwindows() {
  arrivalwindows_.Clear();
}
inline ::NDD::Window* Location_Attribute::mutable_arrivalwindows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.arrivalWindows)
  return arrivalwindows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Location_Attribute::mutable_arrivalwindows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Location.Attribute.arrivalWindows)
  return &arrivalwindows_;
}
inline const ::NDD::Window& Location_Attribute::arrivalwindows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.arrivalWindows)
  return arrivalwindows_.Get(index);
}
inline ::NDD::Window* Location_Attribute::add_arrivalwindows() {
  // @@protoc_insertion_point(field_add:NDD.Location.Attribute.arrivalWindows)
  return arrivalwindows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Location_Attribute::arrivalwindows() const {
  // @@protoc_insertion_point(field_list:NDD.Location.Attribute.arrivalWindows)
  return arrivalwindows_;
}

// repeated .NDD.Window departureWindows = 5;
inline int Location_Attribute::departurewindows_size() const {
  return departurewindows_.size();
}
inline void Location_Attribute::clear_departurewindows() {
  departurewindows_.Clear();
}
inline ::NDD::Window* Location_Attribute::mutable_departurewindows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.departureWindows)
  return departurewindows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Location_Attribute::mutable_departurewindows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Location.Attribute.departureWindows)
  return &departurewindows_;
}
inline const ::NDD::Window& Location_Attribute::departurewindows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.departureWindows)
  return departurewindows_.Get(index);
}
inline ::NDD::Window* Location_Attribute::add_departurewindows() {
  // @@protoc_insertion_point(field_add:NDD.Location.Attribute.departureWindows)
  return departurewindows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Location_Attribute::departurewindows() const {
  // @@protoc_insertion_point(field_list:NDD.Location.Attribute.departureWindows)
  return departurewindows_;
}

// -------------------------------------------------------------------

// Location

// required string id = 1;
inline bool Location::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:NDD.Location.id)
  return id_.GetNoArena();
}
inline void Location::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Location.id)
}
#if LANG_CXX11
inline void Location::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Location.id)
}
#endif
inline void Location::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Location.id)
}
inline void Location::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Location.id)
}
inline ::std::string* Location::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.Location.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_id() {
  // @@protoc_insertion_point(field_release:NDD.Location.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.id)
}

// optional .NDD.Geocode geocode = 2;
inline bool Location::has_geocode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_geocode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_geocode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_geocode() {
  if (geocode_ != NULL) geocode_->Clear();
  clear_has_geocode();
}
inline const ::NDD::Geocode& Location::_internal_geocode() const {
  return *geocode_;
}
inline const ::NDD::Geocode& Location::geocode() const {
  const ::NDD::Geocode* p = geocode_;
  // @@protoc_insertion_point(field_get:NDD.Location.geocode)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Geocode*>(
      &::NDD::_Geocode_default_instance_);
}
inline ::NDD::Geocode* Location::release_geocode() {
  // @@protoc_insertion_point(field_release:NDD.Location.geocode)
  clear_has_geocode();
  ::NDD::Geocode* temp = geocode_;
  geocode_ = NULL;
  return temp;
}
inline ::NDD::Geocode* Location::mutable_geocode() {
  set_has_geocode();
  if (geocode_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Geocode>(GetArenaNoVirtual());
    geocode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Location.geocode)
  return geocode_;
}
inline void Location::set_allocated_geocode(::NDD::Geocode* geocode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geocode_;
  }
  if (geocode) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geocode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geocode, submessage_arena);
    }
    set_has_geocode();
  } else {
    clear_has_geocode();
  }
  geocode_ = geocode;
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.geocode)
}

// repeated .NDD.Location.Attribute attributes = 3;
inline int Location::attributes_size() const {
  return attributes_.size();
}
inline void Location::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::Location_Attribute* Location::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Location.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >*
Location::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Location.attributes)
  return &attributes_;
}
inline const ::NDD::Location_Attribute& Location::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Location.attributes)
  return attributes_.Get(index);
}
inline ::NDD::Location_Attribute* Location::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.Location.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >&
Location::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.Location.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// Profile_customCycle

// repeated bool visitProfile = 2;
inline int Profile_customCycle::visitprofile_size() const {
  return visitprofile_.size();
}
inline void Profile_customCycle::clear_visitprofile() {
  visitprofile_.Clear();
}
inline bool Profile_customCycle::visitprofile(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Profile.customCycle.visitProfile)
  return visitprofile_.Get(index);
}
inline void Profile_customCycle::set_visitprofile(int index, bool value) {
  visitprofile_.Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.Profile.customCycle.visitProfile)
}
inline void Profile_customCycle::add_visitprofile(bool value) {
  visitprofile_.Add(value);
  // @@protoc_insertion_point(field_add:NDD.Profile.customCycle.visitProfile)
}
inline const ::google::protobuf::RepeatedField< bool >&
Profile_customCycle::visitprofile() const {
  // @@protoc_insertion_point(field_list:NDD.Profile.customCycle.visitProfile)
  return visitprofile_;
}
inline ::google::protobuf::RepeatedField< bool >*
Profile_customCycle::mutable_visitprofile() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Profile.customCycle.visitProfile)
  return &visitprofile_;
}

// -------------------------------------------------------------------

// Profile

// required .NDD.Profile.eFrequency frequencyType = 1;
inline bool Profile::has_frequencytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Profile::set_has_frequencytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Profile::clear_has_frequencytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Profile::clear_frequencytype() {
  frequencytype_ = 0;
  clear_has_frequencytype();
}
inline ::NDD::Profile_eFrequency Profile::frequencytype() const {
  // @@protoc_insertion_point(field_get:NDD.Profile.frequencyType)
  return static_cast< ::NDD::Profile_eFrequency >(frequencytype_);
}
inline void Profile::set_frequencytype(::NDD::Profile_eFrequency value) {
  assert(::NDD::Profile_eFrequency_IsValid(value));
  set_has_frequencytype();
  frequencytype_ = value;
  // @@protoc_insertion_point(field_set:NDD.Profile.frequencyType)
}

// repeated .NDD.Profile.customCycle allowableCycles = 2;
inline int Profile::allowablecycles_size() const {
  return allowablecycles_.size();
}
inline void Profile::clear_allowablecycles() {
  allowablecycles_.Clear();
}
inline ::NDD::Profile_customCycle* Profile::mutable_allowablecycles(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Profile.allowableCycles)
  return allowablecycles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >*
Profile::mutable_allowablecycles() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Profile.allowableCycles)
  return &allowablecycles_;
}
inline const ::NDD::Profile_customCycle& Profile::allowablecycles(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Profile.allowableCycles)
  return allowablecycles_.Get(index);
}
inline ::NDD::Profile_customCycle* Profile::add_allowablecycles() {
  // @@protoc_insertion_point(field_add:NDD.Profile.allowableCycles)
  return allowablecycles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >&
Profile::allowablecycles() const {
  // @@protoc_insertion_point(field_list:NDD.Profile.allowableCycles)
  return allowablecycles_;
}

// optional int32 numVisits = 3;
inline bool Profile::has_numvisits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Profile::set_has_numvisits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Profile::clear_has_numvisits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Profile::clear_numvisits() {
  numvisits_ = 0;
  clear_has_numvisits();
}
inline ::google::protobuf::int32 Profile::numvisits() const {
  // @@protoc_insertion_point(field_get:NDD.Profile.numVisits)
  return numvisits_;
}
inline void Profile::set_numvisits(::google::protobuf::int32 value) {
  set_has_numvisits();
  numvisits_ = value;
  // @@protoc_insertion_point(field_set:NDD.Profile.numVisits)
}

// -------------------------------------------------------------------

// Job_VehicleRelation

// required .NDD.Job.VehicleRelation.Type type = 1;
inline bool Job_VehicleRelation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Job_VehicleRelation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Job_VehicleRelation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Job_VehicleRelation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::NDD::Job_VehicleRelation_Type Job_VehicleRelation::type() const {
  // @@protoc_insertion_point(field_get:NDD.Job.VehicleRelation.type)
  return static_cast< ::NDD::Job_VehicleRelation_Type >(type_);
}
inline void Job_VehicleRelation::set_type(::NDD::Job_VehicleRelation_Type value) {
  assert(::NDD::Job_VehicleRelation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:NDD.Job.VehicleRelation.type)
}

// repeated string vehicleIds = 2;
inline int Job_VehicleRelation::vehicleids_size() const {
  return vehicleids_.size();
}
inline void Job_VehicleRelation::clear_vehicleids() {
  vehicleids_.Clear();
}
inline const ::std::string& Job_VehicleRelation::vehicleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.VehicleRelation.vehicleIds)
  return vehicleids_.Get(index);
}
inline ::std::string* Job_VehicleRelation::mutable_vehicleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.VehicleRelation.vehicleIds)
  return vehicleids_.Mutable(index);
}
inline void Job_VehicleRelation::set_vehicleids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.Job.VehicleRelation.vehicleIds)
  vehicleids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Job_VehicleRelation::set_vehicleids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.Job.VehicleRelation.vehicleIds)
  vehicleids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Job_VehicleRelation::set_vehicleids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vehicleids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, const char* value, size_t size) {
  vehicleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.VehicleRelation.vehicleIds)
}
inline ::std::string* Job_VehicleRelation::add_vehicleids() {
  // @@protoc_insertion_point(field_add_mutable:NDD.Job.VehicleRelation.vehicleIds)
  return vehicleids_.Add();
}
inline void Job_VehicleRelation::add_vehicleids(const ::std::string& value) {
  vehicleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.Job.VehicleRelation.vehicleIds)
}
#if LANG_CXX11
inline void Job_VehicleRelation::add_vehicleids(::std::string&& value) {
  vehicleids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.Job.VehicleRelation.vehicleIds)
}
#endif
inline void Job_VehicleRelation::add_vehicleids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vehicleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const char* value, size_t size) {
  vehicleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.Job.VehicleRelation.vehicleIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Job_VehicleRelation::vehicleids() const {
  // @@protoc_insertion_point(field_list:NDD.Job.VehicleRelation.vehicleIds)
  return vehicleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Job_VehicleRelation::mutable_vehicleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.VehicleRelation.vehicleIds)
  return &vehicleids_;
}

// -------------------------------------------------------------------

// Job_Task_Attribute

// required string dimensionId = 1;
inline bool Job_Task_Attribute::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Job_Task_Attribute::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Job_Task_Attribute::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Job_Task_Attribute::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& Job_Task_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void Job_Task_Attribute::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.dimensionId)
}
#if LANG_CXX11
inline void Job_Task_Attribute::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Job.Task.Attribute.dimensionId)
}
#endif
inline void Job_Task_Attribute::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Job.Task.Attribute.dimensionId)
}
inline void Job_Task_Attribute::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.Task.Attribute.dimensionId)
}
inline ::std::string* Job_Task_Attribute::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.Attribute.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Job_Task_Attribute::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.Job.Task.Attribute.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Job_Task_Attribute::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.Task.Attribute.dimensionId)
}

// optional float quantity = 2;
inline bool Job_Task_Attribute::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Job_Task_Attribute::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Job_Task_Attribute::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Job_Task_Attribute::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float Job_Task_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.quantity)
  return quantity_;
}
inline void Job_Task_Attribute::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.quantity)
}

// repeated .NDD.Window windows = 3;
inline int Job_Task_Attribute::windows_size() const {
  return windows_.size();
}
inline void Job_Task_Attribute::clear_windows() {
  windows_.Clear();
}
inline ::NDD::Window* Job_Task_Attribute::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.Attribute.windows)
  return windows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Job_Task_Attribute::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.Attribute.windows)
  return &windows_;
}
inline const ::NDD::Window& Job_Task_Attribute::windows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.windows)
  return windows_.Get(index);
}
inline ::NDD::Window* Job_Task_Attribute::add_windows() {
  // @@protoc_insertion_point(field_add:NDD.Job.Task.Attribute.windows)
  return windows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Job_Task_Attribute::windows() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.Attribute.windows)
  return windows_;
}

// repeated string vehicleIds = 4;
inline int Job_Task_Attribute::vehicleids_size() const {
  return vehicleids_.size();
}
inline void Job_Task_Attribute::clear_vehicleids() {
  vehicleids_.Clear();
}
inline const ::std::string& Job_Task_Attribute::vehicleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.vehicleIds)
  return vehicleids_.Get(index);
}
inline ::std::string* Job_Task_Attribute::mutable_vehicleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.Attribute.vehicleIds)
  return vehicleids_.Mutable(index);
}
inline void Job_Task_Attribute::set_vehicleids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.vehicleIds)
  vehicleids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Job_Task_Attribute::set_vehicleids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.vehicleIds)
  vehicleids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Job_Task_Attribute::set_vehicleids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vehicleids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, const char* value, size_t size) {
  vehicleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.Task.Attribute.vehicleIds)
}
inline ::std::string* Job_Task_Attribute::add_vehicleids() {
  // @@protoc_insertion_point(field_add_mutable:NDD.Job.Task.Attribute.vehicleIds)
  return vehicleids_.Add();
}
inline void Job_Task_Attribute::add_vehicleids(const ::std::string& value) {
  vehicleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.Job.Task.Attribute.vehicleIds)
}
#if LANG_CXX11
inline void Job_Task_Attribute::add_vehicleids(::std::string&& value) {
  vehicleids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.Job.Task.Attribute.vehicleIds)
}
#endif
inline void Job_Task_Attribute::add_vehicleids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vehicleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const char* value, size_t size) {
  vehicleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.Job.Task.Attribute.vehicleIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Job_Task_Attribute::vehicleids() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.Attribute.vehicleIds)
  return vehicleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Job_Task_Attribute::mutable_vehicleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.Attribute.vehicleIds)
  return &vehicleids_;
}

// -------------------------------------------------------------------

// Job_Task

// required string taskId = 1;
inline bool Job_Task::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Job_Task::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Job_Task::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Job_Task::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_taskid();
}
inline const ::std::string& Job_Task::taskid() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.taskId)
  return taskid_.GetNoArena();
}
inline void Job_Task::set_taskid(const ::std::string& value) {
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.taskId)
}
#if LANG_CXX11
inline void Job_Task::set_taskid(::std::string&& value) {
  set_has_taskid();
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Job.Task.taskId)
}
#endif
inline void Job_Task::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Job.Task.taskId)
}
inline void Job_Task::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.Task.taskId)
}
inline ::std::string* Job_Task::mutable_taskid() {
  set_has_taskid();
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.taskId)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Job_Task::release_taskid() {
  // @@protoc_insertion_point(field_release:NDD.Job.Task.taskId)
  if (!has_taskid()) {
    return NULL;
  }
  clear_has_taskid();
  return taskid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Job_Task::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    set_has_taskid();
  } else {
    clear_has_taskid();
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.Task.taskId)
}

// required string locationId = 2;
inline bool Job_Task::has_locationid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Job_Task::set_has_locationid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Job_Task::clear_has_locationid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Job_Task::clear_locationid() {
  locationid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_locationid();
}
inline const ::std::string& Job_Task::locationid() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.locationId)
  return locationid_.GetNoArena();
}
inline void Job_Task::set_locationid(const ::std::string& value) {
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.locationId)
}
#if LANG_CXX11
inline void Job_Task::set_locationid(::std::string&& value) {
  set_has_locationid();
  locationid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Job.Task.locationId)
}
#endif
inline void Job_Task::set_locationid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Job.Task.locationId)
}
inline void Job_Task::set_locationid(const char* value, size_t size) {
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.Task.locationId)
}
inline ::std::string* Job_Task::mutable_locationid() {
  set_has_locationid();
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.locationId)
  return locationid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Job_Task::release_locationid() {
  // @@protoc_insertion_point(field_release:NDD.Job.Task.locationId)
  if (!has_locationid()) {
    return NULL;
  }
  clear_has_locationid();
  return locationid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Job_Task::set_allocated_locationid(::std::string* locationid) {
  if (locationid != NULL) {
    set_has_locationid();
  } else {
    clear_has_locationid();
  }
  locationid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), locationid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.Task.locationId)
}

// repeated .NDD.Job.Task.Attribute attributes = 3;
inline int Job_Task::attributes_size() const {
  return attributes_.size();
}
inline void Job_Task::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::Job_Task_Attribute* Job_Task::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >*
Job_Task::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.attributes)
  return &attributes_;
}
inline const ::NDD::Job_Task_Attribute& Job_Task::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.attributes)
  return attributes_.Get(index);
}
inline ::NDD::Job_Task_Attribute* Job_Task::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.Job.Task.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >&
Job_Task::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.attributes)
  return attributes_;
}

// repeated .NDD.Job.Task.TripConstraint tripConstraints = 4;
inline int Job_Task::tripconstraints_size() const {
  return tripconstraints_.size();
}
inline void Job_Task::clear_tripconstraints() {
  tripconstraints_.Clear();
}
inline ::NDD::Job_Task_TripConstraint Job_Task::tripconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.tripConstraints)
  return static_cast< ::NDD::Job_Task_TripConstraint >(tripconstraints_.Get(index));
}
inline void Job_Task::set_tripconstraints(int index, ::NDD::Job_Task_TripConstraint value) {
  assert(::NDD::Job_Task_TripConstraint_IsValid(value));
  tripconstraints_.Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.tripConstraints)
}
inline void Job_Task::add_tripconstraints(::NDD::Job_Task_TripConstraint value) {
  assert(::NDD::Job_Task_TripConstraint_IsValid(value));
  tripconstraints_.Add(value);
  // @@protoc_insertion_point(field_add:NDD.Job.Task.tripConstraints)
}
inline const ::google::protobuf::RepeatedField<int>&
Job_Task::tripconstraints() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.tripConstraints)
  return tripconstraints_;
}
inline ::google::protobuf::RepeatedField<int>*
Job_Task::mutable_tripconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.tripConstraints)
  return &tripconstraints_;
}

// -------------------------------------------------------------------

// Job

// required string id = 1;
inline bool Job::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Job::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Job::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Job::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Job::id() const {
  // @@protoc_insertion_point(field_get:NDD.Job.id)
  return id_.GetNoArena();
}
inline void Job::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Job.id)
}
#if LANG_CXX11
inline void Job::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Job.id)
}
#endif
inline void Job::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Job.id)
}
inline void Job::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.id)
}
inline ::std::string* Job::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.Job.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Job::release_id() {
  // @@protoc_insertion_point(field_release:NDD.Job.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Job::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.id)
}

// optional .NDD.Job.Task pickupTask = 2;
inline bool Job::has_pickuptask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Job::set_has_pickuptask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Job::clear_has_pickuptask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Job::clear_pickuptask() {
  if (pickuptask_ != NULL) pickuptask_->Clear();
  clear_has_pickuptask();
}
inline const ::NDD::Job_Task& Job::_internal_pickuptask() const {
  return *pickuptask_;
}
inline const ::NDD::Job_Task& Job::pickuptask() const {
  const ::NDD::Job_Task* p = pickuptask_;
  // @@protoc_insertion_point(field_get:NDD.Job.pickupTask)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Job_Task*>(
      &::NDD::_Job_Task_default_instance_);
}
inline ::NDD::Job_Task* Job::release_pickuptask() {
  // @@protoc_insertion_point(field_release:NDD.Job.pickupTask)
  clear_has_pickuptask();
  ::NDD::Job_Task* temp = pickuptask_;
  pickuptask_ = NULL;
  return temp;
}
inline ::NDD::Job_Task* Job::mutable_pickuptask() {
  set_has_pickuptask();
  if (pickuptask_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Job_Task>(GetArenaNoVirtual());
    pickuptask_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Job.pickupTask)
  return pickuptask_;
}
inline void Job::set_allocated_pickuptask(::NDD::Job_Task* pickuptask) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pickuptask_;
  }
  if (pickuptask) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pickuptask = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pickuptask, submessage_arena);
    }
    set_has_pickuptask();
  } else {
    clear_has_pickuptask();
  }
  pickuptask_ = pickuptask;
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.pickupTask)
}

// optional .NDD.Job.Task dropoffTask = 3;
inline bool Job::has_dropofftask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Job::set_has_dropofftask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Job::clear_has_dropofftask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Job::clear_dropofftask() {
  if (dropofftask_ != NULL) dropofftask_->Clear();
  clear_has_dropofftask();
}
inline const ::NDD::Job_Task& Job::_internal_dropofftask() const {
  return *dropofftask_;
}
inline const ::NDD::Job_Task& Job::dropofftask() const {
  const ::NDD::Job_Task* p = dropofftask_;
  // @@protoc_insertion_point(field_get:NDD.Job.dropoffTask)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Job_Task*>(
      &::NDD::_Job_Task_default_instance_);
}
inline ::NDD::Job_Task* Job::release_dropofftask() {
  // @@protoc_insertion_point(field_release:NDD.Job.dropoffTask)
  clear_has_dropofftask();
  ::NDD::Job_Task* temp = dropofftask_;
  dropofftask_ = NULL;
  return temp;
}
inline ::NDD::Job_Task* Job::mutable_dropofftask() {
  set_has_dropofftask();
  if (dropofftask_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Job_Task>(GetArenaNoVirtual());
    dropofftask_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Job.dropoffTask)
  return dropofftask_;
}
inline void Job::set_allocated_dropofftask(::NDD::Job_Task* dropofftask) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dropofftask_;
  }
  if (dropofftask) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dropofftask = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dropofftask, submessage_arena);
    }
    set_has_dropofftask();
  } else {
    clear_has_dropofftask();
  }
  dropofftask_ = dropofftask;
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.dropoffTask)
}

// required float penalty = 4;
inline bool Job::has_penalty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Job::set_has_penalty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Job::clear_has_penalty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Job::clear_penalty() {
  penalty_ = 0;
  clear_has_penalty();
}
inline float Job::penalty() const {
  // @@protoc_insertion_point(field_get:NDD.Job.penalty)
  return penalty_;
}
inline void Job::set_penalty(float value) {
  set_has_penalty();
  penalty_ = value;
  // @@protoc_insertion_point(field_set:NDD.Job.penalty)
}

// optional .NDD.Job.VehicleRelation vehicleRelations = 5;
inline bool Job::has_vehiclerelations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Job::set_has_vehiclerelations() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Job::clear_has_vehiclerelations() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Job::clear_vehiclerelations() {
  if (vehiclerelations_ != NULL) vehiclerelations_->Clear();
  clear_has_vehiclerelations();
}
inline const ::NDD::Job_VehicleRelation& Job::_internal_vehiclerelations() const {
  return *vehiclerelations_;
}
inline const ::NDD::Job_VehicleRelation& Job::vehiclerelations() const {
  const ::NDD::Job_VehicleRelation* p = vehiclerelations_;
  // @@protoc_insertion_point(field_get:NDD.Job.vehicleRelations)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Job_VehicleRelation*>(
      &::NDD::_Job_VehicleRelation_default_instance_);
}
inline ::NDD::Job_VehicleRelation* Job::release_vehiclerelations() {
  // @@protoc_insertion_point(field_release:NDD.Job.vehicleRelations)
  clear_has_vehiclerelations();
  ::NDD::Job_VehicleRelation* temp = vehiclerelations_;
  vehiclerelations_ = NULL;
  return temp;
}
inline ::NDD::Job_VehicleRelation* Job::mutable_vehiclerelations() {
  set_has_vehiclerelations();
  if (vehiclerelations_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Job_VehicleRelation>(GetArenaNoVirtual());
    vehiclerelations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Job.vehicleRelations)
  return vehiclerelations_;
}
inline void Job::set_allocated_vehiclerelations(::NDD::Job_VehicleRelation* vehiclerelations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehiclerelations_;
  }
  if (vehiclerelations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehiclerelations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehiclerelations, submessage_arena);
    }
    set_has_vehiclerelations();
  } else {
    clear_has_vehiclerelations();
  }
  vehiclerelations_ = vehiclerelations;
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.vehicleRelations)
}

// required .NDD.Profile profile = 6;
inline bool Job::has_profile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Job::set_has_profile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Job::clear_has_profile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Job::clear_profile() {
  if (profile_ != NULL) profile_->Clear();
  clear_has_profile();
}
inline const ::NDD::Profile& Job::_internal_profile() const {
  return *profile_;
}
inline const ::NDD::Profile& Job::profile() const {
  const ::NDD::Profile* p = profile_;
  // @@protoc_insertion_point(field_get:NDD.Job.profile)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Profile*>(
      &::NDD::_Profile_default_instance_);
}
inline ::NDD::Profile* Job::release_profile() {
  // @@protoc_insertion_point(field_release:NDD.Job.profile)
  clear_has_profile();
  ::NDD::Profile* temp = profile_;
  profile_ = NULL;
  return temp;
}
inline ::NDD::Profile* Job::mutable_profile() {
  set_has_profile();
  if (profile_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Profile>(GetArenaNoVirtual());
    profile_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Job.profile)
  return profile_;
}
inline void Job::set_allocated_profile(::NDD::Profile* profile) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete profile_;
  }
  if (profile) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      profile = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    set_has_profile();
  } else {
    clear_has_profile();
  }
  profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.profile)
}

// -------------------------------------------------------------------

// TransitSet_TransitValue

// required string fromId = 1;
inline bool TransitSet_TransitValue::has_fromid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitSet_TransitValue::set_has_fromid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitSet_TransitValue::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitSet_TransitValue::clear_fromid() {
  fromid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromid();
}
inline const ::std::string& TransitSet_TransitValue::fromid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.TransitValue.fromId)
  return fromid_.GetNoArena();
}
inline void TransitSet_TransitValue::set_fromid(const ::std::string& value) {
  set_has_fromid();
  fromid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitSet.TransitValue.fromId)
}
#if LANG_CXX11
inline void TransitSet_TransitValue::set_fromid(::std::string&& value) {
  set_has_fromid();
  fromid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitSet.TransitValue.fromId)
}
#endif
inline void TransitSet_TransitValue::set_fromid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromid();
  fromid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitSet.TransitValue.fromId)
}
inline void TransitSet_TransitValue::set_fromid(const char* value, size_t size) {
  set_has_fromid();
  fromid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitSet.TransitValue.fromId)
}
inline ::std::string* TransitSet_TransitValue::mutable_fromid() {
  set_has_fromid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitSet.TransitValue.fromId)
  return fromid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitSet_TransitValue::release_fromid() {
  // @@protoc_insertion_point(field_release:NDD.TransitSet.TransitValue.fromId)
  if (!has_fromid()) {
    return NULL;
  }
  clear_has_fromid();
  return fromid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitSet_TransitValue::set_allocated_fromid(::std::string* fromid) {
  if (fromid != NULL) {
    set_has_fromid();
  } else {
    clear_has_fromid();
  }
  fromid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromid);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitSet.TransitValue.fromId)
}

// required string toId = 2;
inline bool TransitSet_TransitValue::has_toid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitSet_TransitValue::set_has_toid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitSet_TransitValue::clear_has_toid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitSet_TransitValue::clear_toid() {
  toid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_toid();
}
inline const ::std::string& TransitSet_TransitValue::toid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.TransitValue.toId)
  return toid_.GetNoArena();
}
inline void TransitSet_TransitValue::set_toid(const ::std::string& value) {
  set_has_toid();
  toid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitSet.TransitValue.toId)
}
#if LANG_CXX11
inline void TransitSet_TransitValue::set_toid(::std::string&& value) {
  set_has_toid();
  toid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitSet.TransitValue.toId)
}
#endif
inline void TransitSet_TransitValue::set_toid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_toid();
  toid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitSet.TransitValue.toId)
}
inline void TransitSet_TransitValue::set_toid(const char* value, size_t size) {
  set_has_toid();
  toid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitSet.TransitValue.toId)
}
inline ::std::string* TransitSet_TransitValue::mutable_toid() {
  set_has_toid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitSet.TransitValue.toId)
  return toid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitSet_TransitValue::release_toid() {
  // @@protoc_insertion_point(field_release:NDD.TransitSet.TransitValue.toId)
  if (!has_toid()) {
    return NULL;
  }
  clear_has_toid();
  return toid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitSet_TransitValue::set_allocated_toid(::std::string* toid) {
  if (toid != NULL) {
    set_has_toid();
  } else {
    clear_has_toid();
  }
  toid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), toid);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitSet.TransitValue.toId)
}

// required float value = 3;
inline bool TransitSet_TransitValue::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitSet_TransitValue::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitSet_TransitValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitSet_TransitValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float TransitSet_TransitValue::value() const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.TransitValue.value)
  return value_;
}
inline void TransitSet_TransitValue::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:NDD.TransitSet.TransitValue.value)
}

// -------------------------------------------------------------------

// TransitSet

// repeated .NDD.TransitSet.TransitValue transits = 1;
inline int TransitSet::transits_size() const {
  return transits_.size();
}
inline void TransitSet::clear_transits() {
  transits_.Clear();
}
inline ::NDD::TransitSet_TransitValue* TransitSet::mutable_transits(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.TransitSet.transits)
  return transits_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >*
TransitSet::mutable_transits() {
  // @@protoc_insertion_point(field_mutable_list:NDD.TransitSet.transits)
  return &transits_;
}
inline const ::NDD::TransitSet_TransitValue& TransitSet::transits(int index) const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.transits)
  return transits_.Get(index);
}
inline ::NDD::TransitSet_TransitValue* TransitSet::add_transits() {
  // @@protoc_insertion_point(field_add:NDD.TransitSet.transits)
  return transits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >&
TransitSet::transits() const {
  // @@protoc_insertion_point(field_list:NDD.TransitSet.transits)
  return transits_;
}

// -------------------------------------------------------------------

// TransitGenerator

// required string id = 1;
inline bool TransitGenerator::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitGenerator::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitGenerator::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitGenerator::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TransitGenerator::id() const {
  // @@protoc_insertion_point(field_get:NDD.TransitGenerator.id)
  return id_.GetNoArena();
}
inline void TransitGenerator::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitGenerator.id)
}
#if LANG_CXX11
inline void TransitGenerator::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitGenerator.id)
}
#endif
inline void TransitGenerator::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitGenerator.id)
}
inline void TransitGenerator::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitGenerator.id)
}
inline ::std::string* TransitGenerator::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.TransitGenerator.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitGenerator::release_id() {
  // @@protoc_insertion_point(field_release:NDD.TransitGenerator.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitGenerator::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitGenerator.id)
}

// optional string requestId = 2;
inline bool TransitGenerator::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitGenerator::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitGenerator::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitGenerator::clear_requestid() {
  requestid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requestid();
}
inline const ::std::string& TransitGenerator::requestid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitGenerator.requestId)
  return requestid_.GetNoArena();
}
inline void TransitGenerator::set_requestid(const ::std::string& value) {
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitGenerator.requestId)
}
#if LANG_CXX11
inline void TransitGenerator::set_requestid(::std::string&& value) {
  set_has_requestid();
  requestid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitGenerator.requestId)
}
#endif
inline void TransitGenerator::set_requestid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitGenerator.requestId)
}
inline void TransitGenerator::set_requestid(const char* value, size_t size) {
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitGenerator.requestId)
}
inline ::std::string* TransitGenerator::mutable_requestid() {
  set_has_requestid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitGenerator.requestId)
  return requestid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitGenerator::release_requestid() {
  // @@protoc_insertion_point(field_release:NDD.TransitGenerator.requestId)
  if (!has_requestid()) {
    return NULL;
  }
  clear_has_requestid();
  return requestid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitGenerator::set_allocated_requestid(::std::string* requestid) {
  if (requestid != NULL) {
    set_has_requestid();
  } else {
    clear_has_requestid();
  }
  requestid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestid);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitGenerator.requestId)
}

// optional .NDD.TransitSet transitSet = 3;
inline bool TransitGenerator::has_transitset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitGenerator::set_has_transitset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitGenerator::clear_has_transitset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitGenerator::clear_transitset() {
  if (transitset_ != NULL) transitset_->Clear();
  clear_has_transitset();
}
inline const ::NDD::TransitSet& TransitGenerator::_internal_transitset() const {
  return *transitset_;
}
inline const ::NDD::TransitSet& TransitGenerator::transitset() const {
  const ::NDD::TransitSet* p = transitset_;
  // @@protoc_insertion_point(field_get:NDD.TransitGenerator.transitSet)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::TransitSet*>(
      &::NDD::_TransitSet_default_instance_);
}
inline ::NDD::TransitSet* TransitGenerator::release_transitset() {
  // @@protoc_insertion_point(field_release:NDD.TransitGenerator.transitSet)
  clear_has_transitset();
  ::NDD::TransitSet* temp = transitset_;
  transitset_ = NULL;
  return temp;
}
inline ::NDD::TransitSet* TransitGenerator::mutable_transitset() {
  set_has_transitset();
  if (transitset_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::TransitSet>(GetArenaNoVirtual());
    transitset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.TransitGenerator.transitSet)
  return transitset_;
}
inline void TransitGenerator::set_allocated_transitset(::NDD::TransitSet* transitset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transitset_;
  }
  if (transitset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transitset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transitset, submessage_arena);
    }
    set_has_transitset();
  } else {
    clear_has_transitset();
  }
  transitset_ = transitset;
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitGenerator.transitSet)
}

// -------------------------------------------------------------------

// VehicleClass_Attribute

// required string dimensionId = 1;
inline bool VehicleClass_Attribute::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleClass_Attribute::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleClass_Attribute::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleClass_Attribute::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& VehicleClass_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void VehicleClass_Attribute::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.dimensionId)
}
#if LANG_CXX11
inline void VehicleClass_Attribute::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.VehicleClass.Attribute.dimensionId)
}
#endif
inline void VehicleClass_Attribute::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.VehicleClass.Attribute.dimensionId)
}
inline void VehicleClass_Attribute::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleClass.Attribute.dimensionId)
}
inline ::std::string* VehicleClass_Attribute::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.Attribute.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleClass_Attribute::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.VehicleClass.Attribute.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleClass_Attribute::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleClass.Attribute.dimensionId)
}

// optional string transitGeneratorId = 2;
inline bool VehicleClass_Attribute::has_transitgeneratorid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleClass_Attribute::set_has_transitgeneratorid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleClass_Attribute::clear_has_transitgeneratorid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleClass_Attribute::clear_transitgeneratorid() {
  transitgeneratorid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transitgeneratorid();
}
inline const ::std::string& VehicleClass_Attribute::transitgeneratorid() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.transitGeneratorId)
  return transitgeneratorid_.GetNoArena();
}
inline void VehicleClass_Attribute::set_transitgeneratorid(const ::std::string& value) {
  set_has_transitgeneratorid();
  transitgeneratorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.transitGeneratorId)
}
#if LANG_CXX11
inline void VehicleClass_Attribute::set_transitgeneratorid(::std::string&& value) {
  set_has_transitgeneratorid();
  transitgeneratorid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.VehicleClass.Attribute.transitGeneratorId)
}
#endif
inline void VehicleClass_Attribute::set_transitgeneratorid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transitgeneratorid();
  transitgeneratorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.VehicleClass.Attribute.transitGeneratorId)
}
inline void VehicleClass_Attribute::set_transitgeneratorid(const char* value, size_t size) {
  set_has_transitgeneratorid();
  transitgeneratorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleClass.Attribute.transitGeneratorId)
}
inline ::std::string* VehicleClass_Attribute::mutable_transitgeneratorid() {
  set_has_transitgeneratorid();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.Attribute.transitGeneratorId)
  return transitgeneratorid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleClass_Attribute::release_transitgeneratorid() {
  // @@protoc_insertion_point(field_release:NDD.VehicleClass.Attribute.transitGeneratorId)
  if (!has_transitgeneratorid()) {
    return NULL;
  }
  clear_has_transitgeneratorid();
  return transitgeneratorid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleClass_Attribute::set_allocated_transitgeneratorid(::std::string* transitgeneratorid) {
  if (transitgeneratorid != NULL) {
    set_has_transitgeneratorid();
  } else {
    clear_has_transitgeneratorid();
  }
  transitgeneratorid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transitgeneratorid);
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleClass.Attribute.transitGeneratorId)
}

// optional float transitCoef = 3;
inline bool VehicleClass_Attribute::has_transitcoef() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleClass_Attribute::set_has_transitcoef() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleClass_Attribute::clear_has_transitcoef() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleClass_Attribute::clear_transitcoef() {
  transitcoef_ = 0;
  clear_has_transitcoef();
}
inline float VehicleClass_Attribute::transitcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.transitCoef)
  return transitcoef_;
}
inline void VehicleClass_Attribute::set_transitcoef(float value) {
  set_has_transitcoef();
  transitcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.transitCoef)
}

// optional float taskCoef = 4;
inline bool VehicleClass_Attribute::has_taskcoef() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleClass_Attribute::set_has_taskcoef() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleClass_Attribute::clear_has_taskcoef() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleClass_Attribute::clear_taskcoef() {
  taskcoef_ = 0;
  clear_has_taskcoef();
}
inline float VehicleClass_Attribute::taskcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.taskCoef)
  return taskcoef_;
}
inline void VehicleClass_Attribute::set_taskcoef(float value) {
  set_has_taskcoef();
  taskcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.taskCoef)
}

// optional float locationCoef = 5;
inline bool VehicleClass_Attribute::has_locationcoef() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleClass_Attribute::set_has_locationcoef() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleClass_Attribute::clear_has_locationcoef() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleClass_Attribute::clear_locationcoef() {
  locationcoef_ = 0;
  clear_has_locationcoef();
}
inline float VehicleClass_Attribute::locationcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.locationCoef)
  return locationcoef_;
}
inline void VehicleClass_Attribute::set_locationcoef(float value) {
  set_has_locationcoef();
  locationcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.locationCoef)
}

// -------------------------------------------------------------------

// VehicleClass

// required string id = 1;
inline bool VehicleClass::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleClass::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleClass::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleClass::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& VehicleClass::id() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.id)
  return id_.GetNoArena();
}
inline void VehicleClass::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.id)
}
#if LANG_CXX11
inline void VehicleClass::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.VehicleClass.id)
}
#endif
inline void VehicleClass::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.VehicleClass.id)
}
inline void VehicleClass::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleClass.id)
}
inline ::std::string* VehicleClass::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleClass::release_id() {
  // @@protoc_insertion_point(field_release:NDD.VehicleClass.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleClass::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleClass.id)
}

// repeated .NDD.VehicleClass.Attribute attributes = 2;
inline int VehicleClass::attributes_size() const {
  return attributes_.size();
}
inline void VehicleClass::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::VehicleClass_Attribute* VehicleClass::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >*
VehicleClass::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.VehicleClass.attributes)
  return &attributes_;
}
inline const ::NDD::VehicleClass_Attribute& VehicleClass::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.attributes)
  return attributes_.Get(index);
}
inline ::NDD::VehicleClass_Attribute* VehicleClass::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.VehicleClass.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >&
VehicleClass::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.VehicleClass.attributes)
  return attributes_;
}

// repeated string transitRuleIds = 3;
inline int VehicleClass::transitruleids_size() const {
  return transitruleids_.size();
}
inline void VehicleClass::clear_transitruleids() {
  transitruleids_.Clear();
}
inline const ::std::string& VehicleClass::transitruleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.transitRuleIds)
  return transitruleids_.Get(index);
}
inline ::std::string* VehicleClass::mutable_transitruleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.transitRuleIds)
  return transitruleids_.Mutable(index);
}
inline void VehicleClass::set_transitruleids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.transitRuleIds)
  transitruleids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void VehicleClass::set_transitruleids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.transitRuleIds)
  transitruleids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void VehicleClass::set_transitruleids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transitruleids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, const char* value, size_t size) {
  transitruleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleClass.transitRuleIds)
}
inline ::std::string* VehicleClass::add_transitruleids() {
  // @@protoc_insertion_point(field_add_mutable:NDD.VehicleClass.transitRuleIds)
  return transitruleids_.Add();
}
inline void VehicleClass::add_transitruleids(const ::std::string& value) {
  transitruleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.VehicleClass.transitRuleIds)
}
#if LANG_CXX11
inline void VehicleClass::add_transitruleids(::std::string&& value) {
  transitruleids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.VehicleClass.transitRuleIds)
}
#endif
inline void VehicleClass::add_transitruleids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transitruleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const char* value, size_t size) {
  transitruleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.VehicleClass.transitRuleIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VehicleClass::transitruleids() const {
  // @@protoc_insertion_point(field_list:NDD.VehicleClass.transitRuleIds)
  return transitruleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VehicleClass::mutable_transitruleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.VehicleClass.transitRuleIds)
  return &transitruleids_;
}

// -------------------------------------------------------------------

// VehicleCostClass_Attribute

// required string dimensionId = 1;
inline bool VehicleCostClass_Attribute::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleCostClass_Attribute::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleCostClass_Attribute::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleCostClass_Attribute::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& VehicleCostClass_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void VehicleCostClass_Attribute::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.dimensionId)
}
#if LANG_CXX11
inline void VehicleCostClass_Attribute::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.VehicleCostClass.Attribute.dimensionId)
}
#endif
inline void VehicleCostClass_Attribute::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.VehicleCostClass.Attribute.dimensionId)
}
inline void VehicleCostClass_Attribute::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleCostClass.Attribute.dimensionId)
}
inline ::std::string* VehicleCostClass_Attribute::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleCostClass.Attribute.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleCostClass_Attribute::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.VehicleCostClass.Attribute.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleCostClass_Attribute::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleCostClass.Attribute.dimensionId)
}

// optional float transitCostCoef = 2;
inline bool VehicleCostClass_Attribute::has_transitcostcoef() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleCostClass_Attribute::set_has_transitcostcoef() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleCostClass_Attribute::clear_has_transitcostcoef() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleCostClass_Attribute::clear_transitcostcoef() {
  transitcostcoef_ = 0;
  clear_has_transitcostcoef();
}
inline float VehicleCostClass_Attribute::transitcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.transitCostCoef)
  return transitcostcoef_;
}
inline void VehicleCostClass_Attribute::set_transitcostcoef(float value) {
  set_has_transitcostcoef();
  transitcostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.transitCostCoef)
}

// optional float taskCostCoef = 3;
inline bool VehicleCostClass_Attribute::has_taskcostcoef() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleCostClass_Attribute::set_has_taskcostcoef() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleCostClass_Attribute::clear_has_taskcostcoef() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleCostClass_Attribute::clear_taskcostcoef() {
  taskcostcoef_ = 0;
  clear_has_taskcostcoef();
}
inline float VehicleCostClass_Attribute::taskcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.taskCostCoef)
  return taskcostcoef_;
}
inline void VehicleCostClass_Attribute::set_taskcostcoef(float value) {
  set_has_taskcostcoef();
  taskcostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.taskCostCoef)
}

// optional float locationCostCoef = 4;
inline bool VehicleCostClass_Attribute::has_locationcostcoef() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleCostClass_Attribute::set_has_locationcostcoef() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleCostClass_Attribute::clear_has_locationcostcoef() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleCostClass_Attribute::clear_locationcostcoef() {
  locationcostcoef_ = 0;
  clear_has_locationcostcoef();
}
inline float VehicleCostClass_Attribute::locationcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.locationCostCoef)
  return locationcostcoef_;
}
inline void VehicleCostClass_Attribute::set_locationcostcoef(float value) {
  set_has_locationcostcoef();
  locationcostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.locationCostCoef)
}

// optional float slackCostCoef = 5;
inline bool VehicleCostClass_Attribute::has_slackcostcoef() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleCostClass_Attribute::set_has_slackcostcoef() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleCostClass_Attribute::clear_has_slackcostcoef() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleCostClass_Attribute::clear_slackcostcoef() {
  slackcostcoef_ = 0;
  clear_has_slackcostcoef();
}
inline float VehicleCostClass_Attribute::slackcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.slackCostCoef)
  return slackcostcoef_;
}
inline void VehicleCostClass_Attribute::set_slackcostcoef(float value) {
  set_has_slackcostcoef();
  slackcostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.slackCostCoef)
}

// optional float tardyCostCoef = 6;
inline bool VehicleCostClass_Attribute::has_tardycostcoef() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleCostClass_Attribute::set_has_tardycostcoef() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleCostClass_Attribute::clear_has_tardycostcoef() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleCostClass_Attribute::clear_tardycostcoef() {
  tardycostcoef_ = 0;
  clear_has_tardycostcoef();
}
inline float VehicleCostClass_Attribute::tardycostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.tardyCostCoef)
  return tardycostcoef_;
}
inline void VehicleCostClass_Attribute::set_tardycostcoef(float value) {
  set_has_tardycostcoef();
  tardycostcoef_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.tardyCostCoef)
}

// -------------------------------------------------------------------

// VehicleCostClass

// required string id = 1;
inline bool VehicleCostClass::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleCostClass::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleCostClass::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleCostClass::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& VehicleCostClass::id() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.id)
  return id_.GetNoArena();
}
inline void VehicleCostClass::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.id)
}
#if LANG_CXX11
inline void VehicleCostClass::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.VehicleCostClass.id)
}
#endif
inline void VehicleCostClass::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.VehicleCostClass.id)
}
inline void VehicleCostClass::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleCostClass.id)
}
inline ::std::string* VehicleCostClass::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleCostClass.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleCostClass::release_id() {
  // @@protoc_insertion_point(field_release:NDD.VehicleCostClass.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleCostClass::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleCostClass.id)
}

// required float fixedCost = 2;
inline bool VehicleCostClass::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleCostClass::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleCostClass::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleCostClass::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float VehicleCostClass::fixedcost() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.fixedCost)
  return fixedcost_;
}
inline void VehicleCostClass::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.fixedCost)
}

// repeated .NDD.VehicleCostClass.Attribute attributes = 3;
inline int VehicleCostClass::attributes_size() const {
  return attributes_.size();
}
inline void VehicleCostClass::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::VehicleCostClass_Attribute* VehicleCostClass::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.VehicleCostClass.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >*
VehicleCostClass::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.VehicleCostClass.attributes)
  return &attributes_;
}
inline const ::NDD::VehicleCostClass_Attribute& VehicleCostClass::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.attributes)
  return attributes_.Get(index);
}
inline ::NDD::VehicleCostClass_Attribute* VehicleCostClass::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.VehicleCostClass.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >&
VehicleCostClass::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.VehicleCostClass.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// Vehicle_Task_Attribute

// required string dimensionId = 1;
inline bool Vehicle_Task_Attribute::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_Task_Attribute::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_Task_Attribute::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_Task_Attribute::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& Vehicle_Task_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.Attribute.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void Vehicle_Task_Attribute::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Task.Attribute.dimensionId)
}
#if LANG_CXX11
inline void Vehicle_Task_Attribute::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Vehicle.Task.Attribute.dimensionId)
}
#endif
inline void Vehicle_Task_Attribute::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.Task.Attribute.dimensionId)
}
inline void Vehicle_Task_Attribute::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.Task.Attribute.dimensionId)
}
inline ::std::string* Vehicle_Task_Attribute::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.Attribute.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle_Task_Attribute::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Task.Attribute.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle_Task_Attribute::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Task.Attribute.dimensionId)
}

// optional float quantity = 2;
inline bool Vehicle_Task_Attribute::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_Task_Attribute::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_Task_Attribute::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_Task_Attribute::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float Vehicle_Task_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.Attribute.quantity)
  return quantity_;
}
inline void Vehicle_Task_Attribute::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Task.Attribute.quantity)
}

// repeated .NDD.Window windows = 3;
inline int Vehicle_Task_Attribute::windows_size() const {
  return windows_.size();
}
inline void Vehicle_Task_Attribute::clear_windows() {
  windows_.Clear();
}
inline ::NDD::Window* Vehicle_Task_Attribute::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.Attribute.windows)
  return windows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Vehicle_Task_Attribute::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.Task.Attribute.windows)
  return &windows_;
}
inline const ::NDD::Window& Vehicle_Task_Attribute::windows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.Attribute.windows)
  return windows_.Get(index);
}
inline ::NDD::Window* Vehicle_Task_Attribute::add_windows() {
  // @@protoc_insertion_point(field_add:NDD.Vehicle.Task.Attribute.windows)
  return windows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Vehicle_Task_Attribute::windows() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.Task.Attribute.windows)
  return windows_;
}

// -------------------------------------------------------------------

// Vehicle_Task

// required string locationId = 1;
inline bool Vehicle_Task::has_locationid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_Task::set_has_locationid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_Task::clear_has_locationid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_Task::clear_locationid() {
  locationid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_locationid();
}
inline const ::std::string& Vehicle_Task::locationid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.locationId)
  return locationid_.GetNoArena();
}
inline void Vehicle_Task::set_locationid(const ::std::string& value) {
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Task.locationId)
}
#if LANG_CXX11
inline void Vehicle_Task::set_locationid(::std::string&& value) {
  set_has_locationid();
  locationid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Vehicle.Task.locationId)
}
#endif
inline void Vehicle_Task::set_locationid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.Task.locationId)
}
inline void Vehicle_Task::set_locationid(const char* value, size_t size) {
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.Task.locationId)
}
inline ::std::string* Vehicle_Task::mutable_locationid() {
  set_has_locationid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.locationId)
  return locationid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle_Task::release_locationid() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Task.locationId)
  if (!has_locationid()) {
    return NULL;
  }
  clear_has_locationid();
  return locationid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle_Task::set_allocated_locationid(::std::string* locationid) {
  if (locationid != NULL) {
    set_has_locationid();
  } else {
    clear_has_locationid();
  }
  locationid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), locationid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Task.locationId)
}

// repeated .NDD.Vehicle.Task.Attribute attributes = 2;
inline int Vehicle_Task::attributes_size() const {
  return attributes_.size();
}
inline void Vehicle_Task::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::Vehicle_Task_Attribute* Vehicle_Task::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >*
Vehicle_Task::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.Task.attributes)
  return &attributes_;
}
inline const ::NDD::Vehicle_Task_Attribute& Vehicle_Task::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.attributes)
  return attributes_.Get(index);
}
inline ::NDD::Vehicle_Task_Attribute* Vehicle_Task::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.Vehicle.Task.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >&
Vehicle_Task::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.Task.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// Vehicle_Shift

// required .NDD.Vehicle.Task shiftStart = 1;
inline bool Vehicle_Shift::has_shiftstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_Shift::set_has_shiftstart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_Shift::clear_has_shiftstart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_Shift::clear_shiftstart() {
  if (shiftstart_ != NULL) shiftstart_->Clear();
  clear_has_shiftstart();
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::_internal_shiftstart() const {
  return *shiftstart_;
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::shiftstart() const {
  const ::NDD::Vehicle_Task* p = shiftstart_;
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Shift.shiftStart)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Vehicle_Task*>(
      &::NDD::_Vehicle_Task_default_instance_);
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::release_shiftstart() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Shift.shiftStart)
  clear_has_shiftstart();
  ::NDD::Vehicle_Task* temp = shiftstart_;
  shiftstart_ = NULL;
  return temp;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::mutable_shiftstart() {
  set_has_shiftstart();
  if (shiftstart_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Vehicle_Task>(GetArenaNoVirtual());
    shiftstart_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Shift.shiftStart)
  return shiftstart_;
}
inline void Vehicle_Shift::set_allocated_shiftstart(::NDD::Vehicle_Task* shiftstart) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shiftstart_;
  }
  if (shiftstart) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shiftstart = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shiftstart, submessage_arena);
    }
    set_has_shiftstart();
  } else {
    clear_has_shiftstart();
  }
  shiftstart_ = shiftstart;
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Shift.shiftStart)
}

// optional .NDD.Vehicle.Task shiftEnd = 2;
inline bool Vehicle_Shift::has_shiftend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_Shift::set_has_shiftend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_Shift::clear_has_shiftend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_Shift::clear_shiftend() {
  if (shiftend_ != NULL) shiftend_->Clear();
  clear_has_shiftend();
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::_internal_shiftend() const {
  return *shiftend_;
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::shiftend() const {
  const ::NDD::Vehicle_Task* p = shiftend_;
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Shift.shiftEnd)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Vehicle_Task*>(
      &::NDD::_Vehicle_Task_default_instance_);
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::release_shiftend() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Shift.shiftEnd)
  clear_has_shiftend();
  ::NDD::Vehicle_Task* temp = shiftend_;
  shiftend_ = NULL;
  return temp;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::mutable_shiftend() {
  set_has_shiftend();
  if (shiftend_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Vehicle_Task>(GetArenaNoVirtual());
    shiftend_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Shift.shiftEnd)
  return shiftend_;
}
inline void Vehicle_Shift::set_allocated_shiftend(::NDD::Vehicle_Task* shiftend) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shiftend_;
  }
  if (shiftend) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shiftend = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shiftend, submessage_arena);
    }
    set_has_shiftend();
  } else {
    clear_has_shiftend();
  }
  shiftend_ = shiftend;
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Shift.shiftEnd)
}

// -------------------------------------------------------------------

// Vehicle_Capacity

// required string dimensionId = 1;
inline bool Vehicle_Capacity::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_Capacity::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_Capacity::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_Capacity::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& Vehicle_Capacity::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Capacity.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void Vehicle_Capacity::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Capacity.dimensionId)
}
#if LANG_CXX11
inline void Vehicle_Capacity::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Vehicle.Capacity.dimensionId)
}
#endif
inline void Vehicle_Capacity::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.Capacity.dimensionId)
}
inline void Vehicle_Capacity::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.Capacity.dimensionId)
}
inline ::std::string* Vehicle_Capacity::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Capacity.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle_Capacity::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Capacity.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle_Capacity::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Capacity.dimensionId)
}

// required float capacity = 2;
inline bool Vehicle_Capacity::has_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_Capacity::set_has_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_Capacity::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_Capacity::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline float Vehicle_Capacity::capacity() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Capacity.capacity)
  return capacity_;
}
inline void Vehicle_Capacity::set_capacity(float value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Capacity.capacity)
}

// -------------------------------------------------------------------

// Vehicle

// required string id = 1;
inline bool Vehicle::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Vehicle::id() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.id)
  return id_.GetNoArena();
}
inline void Vehicle::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.id)
}
#if LANG_CXX11
inline void Vehicle::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Vehicle.id)
}
#endif
inline void Vehicle::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.id)
}
inline void Vehicle::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.id)
}
inline ::std::string* Vehicle::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle::release_id() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.id)
}

// required string classId = 2;
inline bool Vehicle::has_classid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle::set_has_classid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle::clear_has_classid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle::clear_classid() {
  classid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_classid();
}
inline const ::std::string& Vehicle::classid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.classId)
  return classid_.GetNoArena();
}
inline void Vehicle::set_classid(const ::std::string& value) {
  set_has_classid();
  classid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.classId)
}
#if LANG_CXX11
inline void Vehicle::set_classid(::std::string&& value) {
  set_has_classid();
  classid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Vehicle.classId)
}
#endif
inline void Vehicle::set_classid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_classid();
  classid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.classId)
}
inline void Vehicle::set_classid(const char* value, size_t size) {
  set_has_classid();
  classid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.classId)
}
inline ::std::string* Vehicle::mutable_classid() {
  set_has_classid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.classId)
  return classid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle::release_classid() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.classId)
  if (!has_classid()) {
    return NULL;
  }
  clear_has_classid();
  return classid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_classid(::std::string* classid) {
  if (classid != NULL) {
    set_has_classid();
  } else {
    clear_has_classid();
  }
  classid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), classid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.classId)
}

// required string costClassId = 3;
inline bool Vehicle::has_costclassid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vehicle::set_has_costclassid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vehicle::clear_has_costclassid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vehicle::clear_costclassid() {
  costclassid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_costclassid();
}
inline const ::std::string& Vehicle::costclassid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.costClassId)
  return costclassid_.GetNoArena();
}
inline void Vehicle::set_costclassid(const ::std::string& value) {
  set_has_costclassid();
  costclassid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.costClassId)
}
#if LANG_CXX11
inline void Vehicle::set_costclassid(::std::string&& value) {
  set_has_costclassid();
  costclassid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.Vehicle.costClassId)
}
#endif
inline void Vehicle::set_costclassid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_costclassid();
  costclassid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.costClassId)
}
inline void Vehicle::set_costclassid(const char* value, size_t size) {
  set_has_costclassid();
  costclassid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.costClassId)
}
inline ::std::string* Vehicle::mutable_costclassid() {
  set_has_costclassid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.costClassId)
  return costclassid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vehicle::release_costclassid() {
  // @@protoc_insertion_point(field_release:NDD.Vehicle.costClassId)
  if (!has_costclassid()) {
    return NULL;
  }
  clear_has_costclassid();
  return costclassid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_costclassid(::std::string* costclassid) {
  if (costclassid != NULL) {
    set_has_costclassid();
  } else {
    clear_has_costclassid();
  }
  costclassid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), costclassid);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.costClassId)
}

// repeated .NDD.Vehicle.Shift shift = 4;
inline int Vehicle::shift_size() const {
  return shift_.size();
}
inline void Vehicle::clear_shift() {
  shift_.Clear();
}
inline ::NDD::Vehicle_Shift* Vehicle::mutable_shift(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.shift)
  return shift_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >*
Vehicle::mutable_shift() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.shift)
  return &shift_;
}
inline const ::NDD::Vehicle_Shift& Vehicle::shift(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.shift)
  return shift_.Get(index);
}
inline ::NDD::Vehicle_Shift* Vehicle::add_shift() {
  // @@protoc_insertion_point(field_add:NDD.Vehicle.shift)
  return shift_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >&
Vehicle::shift() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.shift)
  return shift_;
}

// repeated .NDD.Vehicle.Capacity capacities = 5;
inline int Vehicle::capacities_size() const {
  return capacities_.size();
}
inline void Vehicle::clear_capacities() {
  capacities_.Clear();
}
inline ::NDD::Vehicle_Capacity* Vehicle::mutable_capacities(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.capacities)
  return capacities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >*
Vehicle::mutable_capacities() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.capacities)
  return &capacities_;
}
inline const ::NDD::Vehicle_Capacity& Vehicle::capacities(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.capacities)
  return capacities_.Get(index);
}
inline ::NDD::Vehicle_Capacity* Vehicle::add_capacities() {
  // @@protoc_insertion_point(field_add:NDD.Vehicle.capacities)
  return capacities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >&
Vehicle::capacities() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.capacities)
  return capacities_;
}

// repeated string transitRuleIds = 6;
inline int Vehicle::transitruleids_size() const {
  return transitruleids_.size();
}
inline void Vehicle::clear_transitruleids() {
  transitruleids_.Clear();
}
inline const ::std::string& Vehicle::transitruleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.transitRuleIds)
  return transitruleids_.Get(index);
}
inline ::std::string* Vehicle::mutable_transitruleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.transitRuleIds)
  return transitruleids_.Mutable(index);
}
inline void Vehicle::set_transitruleids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.Vehicle.transitRuleIds)
  transitruleids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Vehicle::set_transitruleids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.Vehicle.transitRuleIds)
  transitruleids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Vehicle::set_transitruleids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transitruleids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, const char* value, size_t size) {
  transitruleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.transitRuleIds)
}
inline ::std::string* Vehicle::add_transitruleids() {
  // @@protoc_insertion_point(field_add_mutable:NDD.Vehicle.transitRuleIds)
  return transitruleids_.Add();
}
inline void Vehicle::add_transitruleids(const ::std::string& value) {
  transitruleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.Vehicle.transitRuleIds)
}
#if LANG_CXX11
inline void Vehicle::add_transitruleids(::std::string&& value) {
  transitruleids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.Vehicle.transitRuleIds)
}
#endif
inline void Vehicle::add_transitruleids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transitruleids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const char* value, size_t size) {
  transitruleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.Vehicle.transitRuleIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Vehicle::transitruleids() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.transitRuleIds)
  return transitruleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Vehicle::mutable_transitruleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.transitRuleIds)
  return &transitruleids_;
}

// -------------------------------------------------------------------

// TaskSequence

// required string vehicleId = 1;
inline bool TaskSequence::has_vehicleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskSequence::set_has_vehicleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskSequence::clear_has_vehicleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskSequence::clear_vehicleid() {
  vehicleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicleid();
}
inline const ::std::string& TaskSequence::vehicleid() const {
  // @@protoc_insertion_point(field_get:NDD.TaskSequence.vehicleId)
  return vehicleid_.GetNoArena();
}
inline void TaskSequence::set_vehicleid(const ::std::string& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.vehicleId)
}
#if LANG_CXX11
inline void TaskSequence::set_vehicleid(::std::string&& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TaskSequence.vehicleId)
}
#endif
inline void TaskSequence::set_vehicleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TaskSequence.vehicleId)
}
inline void TaskSequence::set_vehicleid(const char* value, size_t size) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TaskSequence.vehicleId)
}
inline ::std::string* TaskSequence::mutable_vehicleid() {
  set_has_vehicleid();
  // @@protoc_insertion_point(field_mutable:NDD.TaskSequence.vehicleId)
  return vehicleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskSequence::release_vehicleid() {
  // @@protoc_insertion_point(field_release:NDD.TaskSequence.vehicleId)
  if (!has_vehicleid()) {
    return NULL;
  }
  clear_has_vehicleid();
  return vehicleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskSequence::set_allocated_vehicleid(::std::string* vehicleid) {
  if (vehicleid != NULL) {
    set_has_vehicleid();
  } else {
    clear_has_vehicleid();
  }
  vehicleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicleid);
  // @@protoc_insertion_point(field_set_allocated:NDD.TaskSequence.vehicleId)
}

// required int32 dayIndex = 2;
inline bool TaskSequence::has_dayindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskSequence::set_has_dayindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskSequence::clear_has_dayindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskSequence::clear_dayindex() {
  dayindex_ = 0;
  clear_has_dayindex();
}
inline ::google::protobuf::int32 TaskSequence::dayindex() const {
  // @@protoc_insertion_point(field_get:NDD.TaskSequence.dayIndex)
  return dayindex_;
}
inline void TaskSequence::set_dayindex(::google::protobuf::int32 value) {
  set_has_dayindex();
  dayindex_ = value;
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.dayIndex)
}

// repeated string taskId = 3;
inline int TaskSequence::taskid_size() const {
  return taskid_.size();
}
inline void TaskSequence::clear_taskid() {
  taskid_.Clear();
}
inline const ::std::string& TaskSequence::taskid(int index) const {
  // @@protoc_insertion_point(field_get:NDD.TaskSequence.taskId)
  return taskid_.Get(index);
}
inline ::std::string* TaskSequence::mutable_taskid(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.TaskSequence.taskId)
  return taskid_.Mutable(index);
}
inline void TaskSequence::set_taskid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.taskId)
  taskid_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TaskSequence::set_taskid(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.taskId)
  taskid_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TaskSequence::set_taskid(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  taskid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, const char* value, size_t size) {
  taskid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.TaskSequence.taskId)
}
inline ::std::string* TaskSequence::add_taskid() {
  // @@protoc_insertion_point(field_add_mutable:NDD.TaskSequence.taskId)
  return taskid_.Add();
}
inline void TaskSequence::add_taskid(const ::std::string& value) {
  taskid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.TaskSequence.taskId)
}
#if LANG_CXX11
inline void TaskSequence::add_taskid(::std::string&& value) {
  taskid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.TaskSequence.taskId)
}
#endif
inline void TaskSequence::add_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  taskid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const char* value, size_t size) {
  taskid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.TaskSequence.taskId)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskSequence::taskid() const {
  // @@protoc_insertion_point(field_list:NDD.TaskSequence.taskId)
  return taskid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskSequence::mutable_taskid() {
  // @@protoc_insertion_point(field_mutable_list:NDD.TaskSequence.taskId)
  return &taskid_;
}

// -------------------------------------------------------------------

// TransitRule_Trigger

// required float value = 1;
inline bool TransitRule_Trigger::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitRule_Trigger::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitRule_Trigger::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitRule_Trigger::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float TransitRule_Trigger::value() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.Trigger.value)
  return value_;
}
inline void TransitRule_Trigger::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:NDD.TransitRule.Trigger.value)
}

// required float quantity = 2;
inline bool TransitRule_Trigger::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitRule_Trigger::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitRule_Trigger::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitRule_Trigger::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float TransitRule_Trigger::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.Trigger.quantity)
  return quantity_;
}
inline void TransitRule_Trigger::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:NDD.TransitRule.Trigger.quantity)
}

// -------------------------------------------------------------------

// TransitRule

// required string id = 1;
inline bool TransitRule::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitRule::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitRule::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitRule::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TransitRule::id() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.id)
  return id_.GetNoArena();
}
inline void TransitRule::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.id)
}
#if LANG_CXX11
inline void TransitRule::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitRule.id)
}
#endif
inline void TransitRule::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitRule.id)
}
inline void TransitRule::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitRule.id)
}
inline ::std::string* TransitRule::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitRule::release_id() {
  // @@protoc_insertion_point(field_release:NDD.TransitRule.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitRule::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitRule.id)
}

// required string dimensionId = 2;
inline bool TransitRule::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitRule::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitRule::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitRule::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& TransitRule::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void TransitRule::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.dimensionId)
}
#if LANG_CXX11
inline void TransitRule::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitRule.dimensionId)
}
#endif
inline void TransitRule::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitRule.dimensionId)
}
inline void TransitRule::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitRule.dimensionId)
}
inline ::std::string* TransitRule::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitRule::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NDD.TransitRule.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitRule::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitRule.dimensionId)
}

// optional bool useStandingState = 3 [default = true];
inline bool TransitRule::has_usestandingstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransitRule::set_has_usestandingstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransitRule::clear_has_usestandingstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransitRule::clear_usestandingstate() {
  usestandingstate_ = true;
  clear_has_usestandingstate();
}
inline bool TransitRule::usestandingstate() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.useStandingState)
  return usestandingstate_;
}
inline void TransitRule::set_usestandingstate(bool value) {
  set_has_usestandingstate();
  usestandingstate_ = value;
  // @@protoc_insertion_point(field_set:NDD.TransitRule.useStandingState)
}

// optional bool useTransitState = 4 [default = false];
inline bool TransitRule::has_usetransitstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransitRule::set_has_usetransitstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransitRule::clear_has_usetransitstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransitRule::clear_usetransitstate() {
  usetransitstate_ = false;
  clear_has_usetransitstate();
}
inline bool TransitRule::usetransitstate() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.useTransitState)
  return usetransitstate_;
}
inline void TransitRule::set_usetransitstate(bool value) {
  set_has_usetransitstate();
  usetransitstate_ = value;
  // @@protoc_insertion_point(field_set:NDD.TransitRule.useTransitState)
}

// required string ruleIdPrefix = 5;
inline bool TransitRule::has_ruleidprefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitRule::set_has_ruleidprefix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitRule::clear_has_ruleidprefix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitRule::clear_ruleidprefix() {
  ruleidprefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ruleidprefix();
}
inline const ::std::string& TransitRule::ruleidprefix() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.ruleIdPrefix)
  return ruleidprefix_.GetNoArena();
}
inline void TransitRule::set_ruleidprefix(const ::std::string& value) {
  set_has_ruleidprefix();
  ruleidprefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.ruleIdPrefix)
}
#if LANG_CXX11
inline void TransitRule::set_ruleidprefix(::std::string&& value) {
  set_has_ruleidprefix();
  ruleidprefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.TransitRule.ruleIdPrefix)
}
#endif
inline void TransitRule::set_ruleidprefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ruleidprefix();
  ruleidprefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.TransitRule.ruleIdPrefix)
}
inline void TransitRule::set_ruleidprefix(const char* value, size_t size) {
  set_has_ruleidprefix();
  ruleidprefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.TransitRule.ruleIdPrefix)
}
inline ::std::string* TransitRule::mutable_ruleidprefix() {
  set_has_ruleidprefix();
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.ruleIdPrefix)
  return ruleidprefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransitRule::release_ruleidprefix() {
  // @@protoc_insertion_point(field_release:NDD.TransitRule.ruleIdPrefix)
  if (!has_ruleidprefix()) {
    return NULL;
  }
  clear_has_ruleidprefix();
  return ruleidprefix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransitRule::set_allocated_ruleidprefix(::std::string* ruleidprefix) {
  if (ruleidprefix != NULL) {
    set_has_ruleidprefix();
  } else {
    clear_has_ruleidprefix();
  }
  ruleidprefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ruleidprefix);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitRule.ruleIdPrefix)
}

// repeated .NDD.TransitRule.Trigger triggers = 6;
inline int TransitRule::triggers_size() const {
  return triggers_.size();
}
inline void TransitRule::clear_triggers() {
  triggers_.Clear();
}
inline ::NDD::TransitRule_Trigger* TransitRule::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.triggers)
  return triggers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >*
TransitRule::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:NDD.TransitRule.triggers)
  return &triggers_;
}
inline const ::NDD::TransitRule_Trigger& TransitRule::triggers(int index) const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.triggers)
  return triggers_.Get(index);
}
inline ::NDD::TransitRule_Trigger* TransitRule::add_triggers() {
  // @@protoc_insertion_point(field_add:NDD.TransitRule.triggers)
  return triggers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >&
TransitRule::triggers() const {
  // @@protoc_insertion_point(field_list:NDD.TransitRule.triggers)
  return triggers_;
}

// -------------------------------------------------------------------

// Model

// required .NDD.DimensionConfiguration dimensions = 1;
inline bool Model::has_dimensions() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_dimensions() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_dimensions() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_dimensions() {
  if (dimensions_ != NULL) dimensions_->Clear();
  clear_has_dimensions();
}
inline const ::NDD::DimensionConfiguration& Model::_internal_dimensions() const {
  return *dimensions_;
}
inline const ::NDD::DimensionConfiguration& Model::dimensions() const {
  const ::NDD::DimensionConfiguration* p = dimensions_;
  // @@protoc_insertion_point(field_get:NDD.Model.dimensions)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::DimensionConfiguration*>(
      &::NDD::_DimensionConfiguration_default_instance_);
}
inline ::NDD::DimensionConfiguration* Model::release_dimensions() {
  // @@protoc_insertion_point(field_release:NDD.Model.dimensions)
  clear_has_dimensions();
  ::NDD::DimensionConfiguration* temp = dimensions_;
  dimensions_ = NULL;
  return temp;
}
inline ::NDD::DimensionConfiguration* Model::mutable_dimensions() {
  set_has_dimensions();
  if (dimensions_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::DimensionConfiguration>(GetArenaNoVirtual());
    dimensions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.Model.dimensions)
  return dimensions_;
}
inline void Model::set_allocated_dimensions(::NDD::DimensionConfiguration* dimensions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dimensions_;
  }
  if (dimensions) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dimensions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dimensions, submessage_arena);
    }
    set_has_dimensions();
  } else {
    clear_has_dimensions();
  }
  dimensions_ = dimensions;
  // @@protoc_insertion_point(field_set_allocated:NDD.Model.dimensions)
}

// repeated .NDD.Location locations = 2;
inline int Model::locations_size() const {
  return locations_.size();
}
inline void Model::clear_locations() {
  locations_.Clear();
}
inline ::NDD::Location* Model::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.locations)
  return locations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Location >*
Model::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.locations)
  return &locations_;
}
inline const ::NDD::Location& Model::locations(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.locations)
  return locations_.Get(index);
}
inline ::NDD::Location* Model::add_locations() {
  // @@protoc_insertion_point(field_add:NDD.Model.locations)
  return locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Location >&
Model::locations() const {
  // @@protoc_insertion_point(field_list:NDD.Model.locations)
  return locations_;
}

// repeated .NDD.Job jobs = 3;
inline int Model::jobs_size() const {
  return jobs_.size();
}
inline void Model::clear_jobs() {
  jobs_.Clear();
}
inline ::NDD::Job* Model::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.jobs)
  return jobs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Job >*
Model::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.jobs)
  return &jobs_;
}
inline const ::NDD::Job& Model::jobs(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.jobs)
  return jobs_.Get(index);
}
inline ::NDD::Job* Model::add_jobs() {
  // @@protoc_insertion_point(field_add:NDD.Model.jobs)
  return jobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Job >&
Model::jobs() const {
  // @@protoc_insertion_point(field_list:NDD.Model.jobs)
  return jobs_;
}

// repeated .NDD.Vehicle vehicles = 4;
inline int Model::vehicles_size() const {
  return vehicles_.size();
}
inline void Model::clear_vehicles() {
  vehicles_.Clear();
}
inline ::NDD::Vehicle* Model::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.vehicles)
  return vehicles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >*
Model::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.vehicles)
  return &vehicles_;
}
inline const ::NDD::Vehicle& Model::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.vehicles)
  return vehicles_.Get(index);
}
inline ::NDD::Vehicle* Model::add_vehicles() {
  // @@protoc_insertion_point(field_add:NDD.Model.vehicles)
  return vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >&
Model::vehicles() const {
  // @@protoc_insertion_point(field_list:NDD.Model.vehicles)
  return vehicles_;
}

// repeated .NDD.VehicleClass vehicleClasses = 5;
inline int Model::vehicleclasses_size() const {
  return vehicleclasses_.size();
}
inline void Model::clear_vehicleclasses() {
  vehicleclasses_.Clear();
}
inline ::NDD::VehicleClass* Model::mutable_vehicleclasses(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.vehicleClasses)
  return vehicleclasses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >*
Model::mutable_vehicleclasses() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.vehicleClasses)
  return &vehicleclasses_;
}
inline const ::NDD::VehicleClass& Model::vehicleclasses(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.vehicleClasses)
  return vehicleclasses_.Get(index);
}
inline ::NDD::VehicleClass* Model::add_vehicleclasses() {
  // @@protoc_insertion_point(field_add:NDD.Model.vehicleClasses)
  return vehicleclasses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >&
Model::vehicleclasses() const {
  // @@protoc_insertion_point(field_list:NDD.Model.vehicleClasses)
  return vehicleclasses_;
}

// repeated .NDD.VehicleCostClass vehicleCostClasses = 6;
inline int Model::vehiclecostclasses_size() const {
  return vehiclecostclasses_.size();
}
inline void Model::clear_vehiclecostclasses() {
  vehiclecostclasses_.Clear();
}
inline ::NDD::VehicleCostClass* Model::mutable_vehiclecostclasses(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.vehicleCostClasses)
  return vehiclecostclasses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >*
Model::mutable_vehiclecostclasses() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.vehicleCostClasses)
  return &vehiclecostclasses_;
}
inline const ::NDD::VehicleCostClass& Model::vehiclecostclasses(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.vehicleCostClasses)
  return vehiclecostclasses_.Get(index);
}
inline ::NDD::VehicleCostClass* Model::add_vehiclecostclasses() {
  // @@protoc_insertion_point(field_add:NDD.Model.vehicleCostClasses)
  return vehiclecostclasses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >&
Model::vehiclecostclasses() const {
  // @@protoc_insertion_point(field_list:NDD.Model.vehicleCostClasses)
  return vehiclecostclasses_;
}

// repeated .NDD.TransitRule transitRules = 7;
inline int Model::transitrules_size() const {
  return transitrules_.size();
}
inline void Model::clear_transitrules() {
  transitrules_.Clear();
}
inline ::NDD::TransitRule* Model::mutable_transitrules(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.transitRules)
  return transitrules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >*
Model::mutable_transitrules() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.transitRules)
  return &transitrules_;
}
inline const ::NDD::TransitRule& Model::transitrules(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.transitRules)
  return transitrules_.Get(index);
}
inline ::NDD::TransitRule* Model::add_transitrules() {
  // @@protoc_insertion_point(field_add:NDD.Model.transitRules)
  return transitrules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >&
Model::transitrules() const {
  // @@protoc_insertion_point(field_list:NDD.Model.transitRules)
  return transitrules_;
}

// repeated .NDD.TransitGenerator transitGenerators = 8;
inline int Model::transitgenerators_size() const {
  return transitgenerators_.size();
}
inline void Model::clear_transitgenerators() {
  transitgenerators_.Clear();
}
inline ::NDD::TransitGenerator* Model::mutable_transitgenerators(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.transitGenerators)
  return transitgenerators_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >*
Model::mutable_transitgenerators() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.transitGenerators)
  return &transitgenerators_;
}
inline const ::NDD::TransitGenerator& Model::transitgenerators(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.transitGenerators)
  return transitgenerators_.Get(index);
}
inline ::NDD::TransitGenerator* Model::add_transitgenerators() {
  // @@protoc_insertion_point(field_add:NDD.Model.transitGenerators)
  return transitgenerators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >&
Model::transitgenerators() const {
  // @@protoc_insertion_point(field_list:NDD.Model.transitGenerators)
  return transitgenerators_;
}

// repeated .NDD.TaskSequence taskSequence = 9;
inline int Model::tasksequence_size() const {
  return tasksequence_.size();
}
inline void Model::clear_tasksequence() {
  tasksequence_.Clear();
}
inline ::NDD::TaskSequence* Model::mutable_tasksequence(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.taskSequence)
  return tasksequence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
Model::mutable_tasksequence() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.taskSequence)
  return &tasksequence_;
}
inline const ::NDD::TaskSequence& Model::tasksequence(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.taskSequence)
  return tasksequence_.Get(index);
}
inline ::NDD::TaskSequence* Model::add_tasksequence() {
  // @@protoc_insertion_point(field_add:NDD.Model.taskSequence)
  return tasksequence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
Model::tasksequence() const {
  // @@protoc_insertion_point(field_list:NDD.Model.taskSequence)
  return tasksequence_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .NDD.Model model = 1;
inline bool SolveRequest::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolveRequest::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolveRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolveRequest::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::NDD::Model& SolveRequest::_internal_model() const {
  return *model_;
}
inline const ::NDD::Model& SolveRequest::model() const {
  const ::NDD::Model* p = model_;
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.model)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::Model*>(
      &::NDD::_Model_default_instance_);
}
inline ::NDD::Model* SolveRequest::release_model() {
  // @@protoc_insertion_point(field_release:NDD.SolveRequest.model)
  clear_has_model();
  ::NDD::Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::NDD::Model* SolveRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.SolveRequest.model)
  return model_;
}
inline void SolveRequest::set_allocated_model(::NDD::Model* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:NDD.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolveRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolveRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolveRequest::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.modelID)
  return modelid_.GetNoArena();
}
inline void SolveRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolveRequest.modelID)
}
#if LANG_CXX11
inline void SolveRequest::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolveRequest.modelID)
}
#endif
inline void SolveRequest::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolveRequest.modelID)
}
inline void SolveRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolveRequest.modelID)
}
inline ::std::string* SolveRequest::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:NDD.SolveRequest.modelID)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolveRequest::release_modelid() {
  // @@protoc_insertion_point(field_release:NDD.SolveRequest.modelID)
  if (!has_modelid()) {
    return NULL;
  }
  clear_has_modelid();
  return modelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolveRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolveRequest.modelID)
}

// repeated .NDD.TaskSequence routes = 3;
inline int SolveRequest::routes_size() const {
  return routes_.size();
}
inline void SolveRequest::clear_routes() {
  routes_.Clear();
}
inline ::NDD::TaskSequence* SolveRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolveRequest.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
SolveRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolveRequest.routes)
  return &routes_;
}
inline const ::NDD::TaskSequence& SolveRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.routes)
  return routes_.Get(index);
}
inline ::NDD::TaskSequence* SolveRequest::add_routes() {
  // @@protoc_insertion_point(field_add:NDD.SolveRequest.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
SolveRequest::routes() const {
  // @@protoc_insertion_point(field_list:NDD.SolveRequest.routes)
  return routes_;
}

// optional .NDD.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolveRequest::set_has_solvetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolveRequest::clear_has_solvetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolveRequest::clear_solvetype() {
  solvetype_ = 0;
  clear_has_solvetype();
}
inline ::NDD::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.solveType)
  return static_cast< ::NDD::SolveRequest_SolveType >(solvetype_);
}
inline void SolveRequest::set_solvetype(::NDD::SolveRequest_SolveType value) {
  assert(::NDD::SolveRequest_SolveType_IsValid(value));
  set_has_solvetype();
  solvetype_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolveRequest.solveType)
}

// -------------------------------------------------------------------

// SolutionResponse_StopAttribute

// required string dimId = 1;
inline bool SolutionResponse_StopAttribute::has_dimid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_dimid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_StopAttribute::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_StopAttribute::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_StopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_StopAttribute::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_StopAttribute::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.StopAttribute.dimId)
}
#endif
inline void SolutionResponse_StopAttribute::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.StopAttribute.dimId)
}
inline void SolutionResponse_StopAttribute::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.StopAttribute.dimId)
}
inline ::std::string* SolutionResponse_StopAttribute::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.StopAttribute.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_StopAttribute::release_dimid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.StopAttribute.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_StopAttribute::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.StopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_StopAttribute::has_startvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_startvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_StopAttribute::clear_has_startvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_StopAttribute::clear_startvalue() {
  startvalue_ = 0;
  clear_has_startvalue();
}
inline float SolutionResponse_StopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.startValue)
  return startvalue_;
}
inline void SolutionResponse_StopAttribute::set_startvalue(float value) {
  set_has_startvalue();
  startvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.startValue)
}

// required float endValue = 3;
inline bool SolutionResponse_StopAttribute::has_endvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_endvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_StopAttribute::clear_has_endvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_StopAttribute::clear_endvalue() {
  endvalue_ = 0;
  clear_has_endvalue();
}
inline float SolutionResponse_StopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.endValue)
  return endvalue_;
}
inline void SolutionResponse_StopAttribute::set_endvalue(float value) {
  set_has_endvalue();
  endvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.endValue)
}

// required float cost = 4;
inline bool SolutionResponse_StopAttribute::has_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_StopAttribute::clear_has_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_StopAttribute::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_StopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.cost)
  return cost_;
}
inline void SolutionResponse_StopAttribute::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.cost)
}

// required float slackValue = 5;
inline bool SolutionResponse_StopAttribute::has_slackvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_slackvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_StopAttribute::clear_has_slackvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_StopAttribute::clear_slackvalue() {
  slackvalue_ = 0;
  clear_has_slackvalue();
}
inline float SolutionResponse_StopAttribute::slackvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.slackValue)
  return slackvalue_;
}
inline void SolutionResponse_StopAttribute::set_slackvalue(float value) {
  set_has_slackvalue();
  slackvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.slackValue)
}

// required float slackCost = 6;
inline bool SolutionResponse_StopAttribute::has_slackcost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_slackcost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_StopAttribute::clear_has_slackcost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_StopAttribute::clear_slackcost() {
  slackcost_ = 0;
  clear_has_slackcost();
}
inline float SolutionResponse_StopAttribute::slackcost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.slackCost)
  return slackcost_;
}
inline void SolutionResponse_StopAttribute::set_slackcost(float value) {
  set_has_slackcost();
  slackcost_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.slackCost)
}

// required float tardyValue = 7;
inline bool SolutionResponse_StopAttribute::has_tardyvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_tardyvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_StopAttribute::clear_has_tardyvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_StopAttribute::clear_tardyvalue() {
  tardyvalue_ = 0;
  clear_has_tardyvalue();
}
inline float SolutionResponse_StopAttribute::tardyvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.tardyValue)
  return tardyvalue_;
}
inline void SolutionResponse_StopAttribute::set_tardyvalue(float value) {
  set_has_tardyvalue();
  tardyvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.tardyValue)
}

// required float tardyCost = 8;
inline bool SolutionResponse_StopAttribute::has_tardycost() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_StopAttribute::set_has_tardycost() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_StopAttribute::clear_has_tardycost() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_StopAttribute::clear_tardycost() {
  tardycost_ = 0;
  clear_has_tardycost();
}
inline float SolutionResponse_StopAttribute::tardycost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.tardyCost)
  return tardycost_;
}
inline void SolutionResponse_StopAttribute::set_tardycost(float value) {
  set_has_tardycost();
  tardycost_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.tardyCost)
}

// -------------------------------------------------------------------

// SolutionResponse_InterStopAttribute

// required string dimId = 1;
inline bool SolutionResponse_InterStopAttribute::has_dimid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_dimid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_InterStopAttribute::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_InterStopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_InterStopAttribute::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_InterStopAttribute::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.InterStopAttribute.dimId)
}
#endif
inline void SolutionResponse_InterStopAttribute::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.InterStopAttribute.dimId)
}
inline void SolutionResponse_InterStopAttribute::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.InterStopAttribute.dimId)
}
inline ::std::string* SolutionResponse_InterStopAttribute::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.InterStopAttribute.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_InterStopAttribute::release_dimid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.InterStopAttribute.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_InterStopAttribute::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.InterStopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_InterStopAttribute::has_startvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_startvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_startvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_InterStopAttribute::clear_startvalue() {
  startvalue_ = 0;
  clear_has_startvalue();
}
inline float SolutionResponse_InterStopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.startValue)
  return startvalue_;
}
inline void SolutionResponse_InterStopAttribute::set_startvalue(float value) {
  set_has_startvalue();
  startvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.startValue)
}

// required float endValue = 3;
inline bool SolutionResponse_InterStopAttribute::has_endvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_endvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_endvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_InterStopAttribute::clear_endvalue() {
  endvalue_ = 0;
  clear_has_endvalue();
}
inline float SolutionResponse_InterStopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.endValue)
  return endvalue_;
}
inline void SolutionResponse_InterStopAttribute::set_endvalue(float value) {
  set_has_endvalue();
  endvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.endValue)
}

// required float cost = 4;
inline bool SolutionResponse_InterStopAttribute::has_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_InterStopAttribute::set_has_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_InterStopAttribute::clear_has_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_InterStopAttribute::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_InterStopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.cost)
  return cost_;
}
inline void SolutionResponse_InterStopAttribute::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.cost)
}

// -------------------------------------------------------------------

// SolutionResponse_Stop

// required int32 id = 1;
inline bool SolutionResponse_Stop::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Stop::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Stop::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Stop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SolutionResponse_Stop::id() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.id)
  return id_;
}
inline void SolutionResponse_Stop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.id)
}

// required int32 sequence = 2;
inline bool SolutionResponse_Stop::has_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_Stop::set_has_sequence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_Stop::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_Stop::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 SolutionResponse_Stop::sequence() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.sequence)
  return sequence_;
}
inline void SolutionResponse_Stop::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.sequence)
}

// required string locationId = 3;
inline bool SolutionResponse_Stop::has_locationid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Stop::set_has_locationid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Stop::clear_has_locationid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Stop::clear_locationid() {
  locationid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_locationid();
}
inline const ::std::string& SolutionResponse_Stop::locationid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.locationId)
  return locationid_.GetNoArena();
}
inline void SolutionResponse_Stop::set_locationid(const ::std::string& value) {
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.locationId)
}
#if LANG_CXX11
inline void SolutionResponse_Stop::set_locationid(::std::string&& value) {
  set_has_locationid();
  locationid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Stop.locationId)
}
#endif
inline void SolutionResponse_Stop::set_locationid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Stop.locationId)
}
inline void SolutionResponse_Stop::set_locationid(const char* value, size_t size) {
  set_has_locationid();
  locationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Stop.locationId)
}
inline ::std::string* SolutionResponse_Stop::mutable_locationid() {
  set_has_locationid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.locationId)
  return locationid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Stop::release_locationid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Stop.locationId)
  if (!has_locationid()) {
    return NULL;
  }
  clear_has_locationid();
  return locationid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Stop::set_allocated_locationid(::std::string* locationid) {
  if (locationid != NULL) {
    set_has_locationid();
  } else {
    clear_has_locationid();
  }
  locationid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), locationid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Stop.locationId)
}

// required string taskId = 4;
inline bool SolutionResponse_Stop::has_taskid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Stop::set_has_taskid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Stop::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Stop::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_taskid();
}
inline const ::std::string& SolutionResponse_Stop::taskid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.taskId)
  return taskid_.GetNoArena();
}
inline void SolutionResponse_Stop::set_taskid(const ::std::string& value) {
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.taskId)
}
#if LANG_CXX11
inline void SolutionResponse_Stop::set_taskid(::std::string&& value) {
  set_has_taskid();
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Stop.taskId)
}
#endif
inline void SolutionResponse_Stop::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Stop.taskId)
}
inline void SolutionResponse_Stop::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Stop.taskId)
}
inline ::std::string* SolutionResponse_Stop::mutable_taskid() {
  set_has_taskid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.taskId)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Stop::release_taskid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Stop.taskId)
  if (!has_taskid()) {
    return NULL;
  }
  clear_has_taskid();
  return taskid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Stop::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    set_has_taskid();
  } else {
    clear_has_taskid();
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Stop.taskId)
}

// required string jobId = 5;
inline bool SolutionResponse_Stop::has_jobid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Stop::set_has_jobid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Stop::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Stop::clear_jobid() {
  jobid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jobid();
}
inline const ::std::string& SolutionResponse_Stop::jobid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.jobId)
  return jobid_.GetNoArena();
}
inline void SolutionResponse_Stop::set_jobid(const ::std::string& value) {
  set_has_jobid();
  jobid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.jobId)
}
#if LANG_CXX11
inline void SolutionResponse_Stop::set_jobid(::std::string&& value) {
  set_has_jobid();
  jobid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Stop.jobId)
}
#endif
inline void SolutionResponse_Stop::set_jobid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jobid();
  jobid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Stop.jobId)
}
inline void SolutionResponse_Stop::set_jobid(const char* value, size_t size) {
  set_has_jobid();
  jobid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Stop.jobId)
}
inline ::std::string* SolutionResponse_Stop::mutable_jobid() {
  set_has_jobid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.jobId)
  return jobid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Stop::release_jobid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Stop.jobId)
  if (!has_jobid()) {
    return NULL;
  }
  clear_has_jobid();
  return jobid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Stop::set_allocated_jobid(::std::string* jobid) {
  if (jobid != NULL) {
    set_has_jobid();
  } else {
    clear_has_jobid();
  }
  jobid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jobid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Stop.jobId)
}

// repeated .NDD.SolutionResponse.StopAttribute attributes = 6;
inline int SolutionResponse_Stop::attributes_size() const {
  return attributes_.size();
}
inline void SolutionResponse_Stop::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::SolutionResponse_StopAttribute* SolutionResponse_Stop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >*
SolutionResponse_Stop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Stop.attributes)
  return &attributes_;
}
inline const ::NDD::SolutionResponse_StopAttribute& SolutionResponse_Stop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.attributes)
  return attributes_.Get(index);
}
inline ::NDD::SolutionResponse_StopAttribute* SolutionResponse_Stop::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Stop.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >&
SolutionResponse_Stop::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Stop.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStop

// required int32 fromStopId = 1;
inline bool SolutionResponse_InterStop::has_fromstopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_InterStop::set_has_fromstopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_InterStop::clear_has_fromstopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_InterStop::clear_fromstopid() {
  fromstopid_ = 0;
  clear_has_fromstopid();
}
inline ::google::protobuf::int32 SolutionResponse_InterStop::fromstopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.fromStopId)
  return fromstopid_;
}
inline void SolutionResponse_InterStop::set_fromstopid(::google::protobuf::int32 value) {
  set_has_fromstopid();
  fromstopid_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStop.fromStopId)
}

// required int32 toStopId = 2;
inline bool SolutionResponse_InterStop::has_tostopid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_InterStop::set_has_tostopid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_InterStop::clear_has_tostopid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_InterStop::clear_tostopid() {
  tostopid_ = 0;
  clear_has_tostopid();
}
inline ::google::protobuf::int32 SolutionResponse_InterStop::tostopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.toStopId)
  return tostopid_;
}
inline void SolutionResponse_InterStop::set_tostopid(::google::protobuf::int32 value) {
  set_has_tostopid();
  tostopid_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStop.toStopId)
}

// repeated .NDD.SolutionResponse.InterStopAttribute attributes = 3;
inline int SolutionResponse_InterStop::attributes_size() const {
  return attributes_.size();
}
inline void SolutionResponse_InterStop::clear_attributes() {
  attributes_.Clear();
}
inline ::NDD::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.InterStop.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >*
SolutionResponse_InterStop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.InterStop.attributes)
  return &attributes_;
}
inline const ::NDD::SolutionResponse_InterStopAttribute& SolutionResponse_InterStop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.attributes)
  return attributes_.Get(index);
}
inline ::NDD::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::add_attributes() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.InterStop.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >&
SolutionResponse_InterStop::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.InterStop.attributes)
  return attributes_;
}

// repeated .NDD.Geocode routeSegments = 4;
inline int SolutionResponse_InterStop::routesegments_size() const {
  return routesegments_.size();
}
inline void SolutionResponse_InterStop::clear_routesegments() {
  routesegments_.Clear();
}
inline ::NDD::Geocode* SolutionResponse_InterStop::mutable_routesegments(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.InterStop.routeSegments)
  return routesegments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >*
SolutionResponse_InterStop::mutable_routesegments() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.InterStop.routeSegments)
  return &routesegments_;
}
inline const ::NDD::Geocode& SolutionResponse_InterStop::routesegments(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.routeSegments)
  return routesegments_.Get(index);
}
inline ::NDD::Geocode* SolutionResponse_InterStop::add_routesegments() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.InterStop.routeSegments)
  return routesegments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >&
SolutionResponse_InterStop::routesegments() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.InterStop.routeSegments)
  return routesegments_;
}

// -------------------------------------------------------------------

// SolutionResponse_TransitRuleAttribute

// required string ruleId = 1;
inline bool SolutionResponse_TransitRuleAttribute::has_ruleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_ruleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_ruleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_ruleid() {
  ruleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ruleid();
}
inline const ::std::string& SolutionResponse_TransitRuleAttribute::ruleid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
  return ruleid_.GetNoArena();
}
inline void SolutionResponse_TransitRuleAttribute::set_ruleid(const ::std::string& value) {
  set_has_ruleid();
  ruleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}
#if LANG_CXX11
inline void SolutionResponse_TransitRuleAttribute::set_ruleid(::std::string&& value) {
  set_has_ruleid();
  ruleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}
#endif
inline void SolutionResponse_TransitRuleAttribute::set_ruleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ruleid();
  ruleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}
inline void SolutionResponse_TransitRuleAttribute::set_ruleid(const char* value, size_t size) {
  set_has_ruleid();
  ruleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}
inline ::std::string* SolutionResponse_TransitRuleAttribute::mutable_ruleid() {
  set_has_ruleid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
  return ruleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_TransitRuleAttribute::release_ruleid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
  if (!has_ruleid()) {
    return NULL;
  }
  clear_has_ruleid();
  return ruleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_ruleid(::std::string* ruleid) {
  if (ruleid != NULL) {
    set_has_ruleid();
  } else {
    clear_has_ruleid();
  }
  ruleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ruleid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}

// required string dimId = 2;
inline bool SolutionResponse_TransitRuleAttribute::has_dimid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_dimid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_TransitRuleAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_TransitRuleAttribute::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_TransitRuleAttribute::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}
#endif
inline void SolutionResponse_TransitRuleAttribute::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}
inline void SolutionResponse_TransitRuleAttribute::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}
inline ::std::string* SolutionResponse_TransitRuleAttribute::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.TransitRuleAttribute.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_TransitRuleAttribute::release_dimid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.TransitRuleAttribute.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}

// required int32 fromStopId = 3;
inline bool SolutionResponse_TransitRuleAttribute::has_fromstopid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_fromstopid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_fromstopid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_fromstopid() {
  fromstopid_ = 0;
  clear_has_fromstopid();
}
inline ::google::protobuf::int32 SolutionResponse_TransitRuleAttribute::fromstopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.fromStopId)
  return fromstopid_;
}
inline void SolutionResponse_TransitRuleAttribute::set_fromstopid(::google::protobuf::int32 value) {
  set_has_fromstopid();
  fromstopid_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.fromStopId)
}

// required int32 toStopId = 4;
inline bool SolutionResponse_TransitRuleAttribute::has_tostopid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_tostopid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_tostopid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_tostopid() {
  tostopid_ = 0;
  clear_has_tostopid();
}
inline ::google::protobuf::int32 SolutionResponse_TransitRuleAttribute::tostopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.toStopId)
  return tostopid_;
}
inline void SolutionResponse_TransitRuleAttribute::set_tostopid(::google::protobuf::int32 value) {
  set_has_tostopid();
  tostopid_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.toStopId)
}

// required float startValue = 5;
inline bool SolutionResponse_TransitRuleAttribute::has_startvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_startvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_startvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_startvalue() {
  startvalue_ = 0;
  clear_has_startvalue();
}
inline float SolutionResponse_TransitRuleAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.startValue)
  return startvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::set_startvalue(float value) {
  set_has_startvalue();
  startvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.startValue)
}

// required float endValue = 6;
inline bool SolutionResponse_TransitRuleAttribute::has_endvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_endvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_endvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_endvalue() {
  endvalue_ = 0;
  clear_has_endvalue();
}
inline float SolutionResponse_TransitRuleAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.endValue)
  return endvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::set_endvalue(float value) {
  set_has_endvalue();
  endvalue_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.endValue)
}

// required float cost = 7;
inline bool SolutionResponse_TransitRuleAttribute::has_cost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_TransitRuleAttribute::set_has_cost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_has_cost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_TransitRuleAttribute::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_TransitRuleAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.cost)
  return cost_;
}
inline void SolutionResponse_TransitRuleAttribute::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.cost)
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string vehicleId = 1;
inline bool SolutionResponse_Route::has_vehicleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Route::set_has_vehicleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Route::clear_has_vehicleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Route::clear_vehicleid() {
  vehicleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicleid();
}
inline const ::std::string& SolutionResponse_Route::vehicleid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.vehicleId)
  return vehicleid_.GetNoArena();
}
inline void SolutionResponse_Route::set_vehicleid(const ::std::string& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Route.vehicleId)
}
#if LANG_CXX11
inline void SolutionResponse_Route::set_vehicleid(::std::string&& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Route.vehicleId)
}
#endif
inline void SolutionResponse_Route::set_vehicleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Route.vehicleId)
}
inline void SolutionResponse_Route::set_vehicleid(const char* value, size_t size) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Route.vehicleId)
}
inline ::std::string* SolutionResponse_Route::mutable_vehicleid() {
  set_has_vehicleid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.vehicleId)
  return vehicleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Route::release_vehicleid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Route.vehicleId)
  if (!has_vehicleid()) {
    return NULL;
  }
  clear_has_vehicleid();
  return vehicleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Route::set_allocated_vehicleid(::std::string* vehicleid) {
  if (vehicleid != NULL) {
    set_has_vehicleid();
  } else {
    clear_has_vehicleid();
  }
  vehicleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicleid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Route.vehicleId)
}

// repeated .NDD.SolutionResponse.Stop stops = 2;
inline int SolutionResponse_Route::stops_size() const {
  return stops_.size();
}
inline void SolutionResponse_Route::clear_stops() {
  stops_.Clear();
}
inline ::NDD::SolutionResponse_Stop* SolutionResponse_Route::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.stops)
  return stops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >*
SolutionResponse_Route::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.stops)
  return &stops_;
}
inline const ::NDD::SolutionResponse_Stop& SolutionResponse_Route::stops(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.stops)
  return stops_.Get(index);
}
inline ::NDD::SolutionResponse_Stop* SolutionResponse_Route::add_stops() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.stops)
  return stops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >&
SolutionResponse_Route::stops() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.stops)
  return stops_;
}

// repeated .NDD.SolutionResponse.InterStop interStops = 3;
inline int SolutionResponse_Route::interstops_size() const {
  return interstops_.size();
}
inline void SolutionResponse_Route::clear_interstops() {
  interstops_.Clear();
}
inline ::NDD::SolutionResponse_InterStop* SolutionResponse_Route::mutable_interstops(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.interStops)
  return interstops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >*
SolutionResponse_Route::mutable_interstops() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.interStops)
  return &interstops_;
}
inline const ::NDD::SolutionResponse_InterStop& SolutionResponse_Route::interstops(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.interStops)
  return interstops_.Get(index);
}
inline ::NDD::SolutionResponse_InterStop* SolutionResponse_Route::add_interstops() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.interStops)
  return interstops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >&
SolutionResponse_Route::interstops() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.interStops)
  return interstops_;
}

// repeated float fixedCost = 4;
inline int SolutionResponse_Route::fixedcost_size() const {
  return fixedcost_.size();
}
inline void SolutionResponse_Route::clear_fixedcost() {
  fixedcost_.Clear();
}
inline float SolutionResponse_Route::fixedcost(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.fixedCost)
  return fixedcost_.Get(index);
}
inline void SolutionResponse_Route::set_fixedcost(int index, float value) {
  fixedcost_.Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Route.fixedCost)
}
inline void SolutionResponse_Route::add_fixedcost(float value) {
  fixedcost_.Add(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.fixedCost)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_Route::fixedcost() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.fixedCost)
  return fixedcost_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_Route::mutable_fixedcost() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.fixedCost)
  return &fixedcost_;
}

// repeated .NDD.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
inline int SolutionResponse_Route::transitruleattributes_size() const {
  return transitruleattributes_.size();
}
inline void SolutionResponse_Route::clear_transitruleattributes() {
  transitruleattributes_.Clear();
}
inline ::NDD::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::mutable_transitruleattributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.transitRuleAttributes)
  return transitruleattributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >*
SolutionResponse_Route::mutable_transitruleattributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.transitRuleAttributes)
  return &transitruleattributes_;
}
inline const ::NDD::SolutionResponse_TransitRuleAttribute& SolutionResponse_Route::transitruleattributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.transitRuleAttributes)
  return transitruleattributes_.Get(index);
}
inline ::NDD::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::add_transitruleattributes() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.transitRuleAttributes)
  return transitruleattributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >&
SolutionResponse_Route::transitruleattributes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.transitRuleAttributes)
  return transitruleattributes_;
}

// required int32 day = 6;
inline bool SolutionResponse_Route::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Route::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Route::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Route::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 SolutionResponse_Route::day() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.day)
  return day_;
}
inline void SolutionResponse_Route::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Route.day)
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility_Info

// required string message = 1;
inline bool SolutionResponse_Infeasibility_Info::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Infeasibility_Info::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& SolutionResponse_Infeasibility_Info::message() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.message)
  return message_.GetNoArena();
}
inline void SolutionResponse_Infeasibility_Info::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.message)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Infeasibility.Info.message)
}
#endif
inline void SolutionResponse_Infeasibility_Info::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Infeasibility.Info.message)
}
inline void SolutionResponse_Infeasibility_Info::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Infeasibility.Info.message)
}
inline ::std::string* SolutionResponse_Infeasibility_Info::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.Info.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Infeasibility_Info::release_message() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Infeasibility.Info.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Infeasibility.Info.message)
}

// optional string dimId = 2;
inline bool SolutionResponse_Infeasibility_Info::has_dimid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_dimid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_dimid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Infeasibility_Info::clear_dimid() {
  dimid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimid();
}
inline const ::std::string& SolutionResponse_Infeasibility_Info::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.dimId)
  return dimid_.GetNoArena();
}
inline void SolutionResponse_Infeasibility_Info::set_dimid(const ::std::string& value) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.dimId)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::set_dimid(::std::string&& value) {
  set_has_dimid();
  dimid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Infeasibility.Info.dimId)
}
#endif
inline void SolutionResponse_Infeasibility_Info::set_dimid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Infeasibility.Info.dimId)
}
inline void SolutionResponse_Infeasibility_Info::set_dimid(const char* value, size_t size) {
  set_has_dimid();
  dimid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Infeasibility.Info.dimId)
}
inline ::std::string* SolutionResponse_Infeasibility_Info::mutable_dimid() {
  set_has_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.Info.dimId)
  return dimid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Infeasibility_Info::release_dimid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Infeasibility.Info.dimId)
  if (!has_dimid()) {
    return NULL;
  }
  clear_has_dimid();
  return dimid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_dimid(::std::string* dimid) {
  if (dimid != NULL) {
    set_has_dimid();
  } else {
    clear_has_dimid();
  }
  dimid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Infeasibility.Info.dimId)
}

// optional float limit = 3;
inline bool SolutionResponse_Infeasibility_Info::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Infeasibility_Info::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline float SolutionResponse_Infeasibility_Info::limit() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.limit)
  return limit_;
}
inline void SolutionResponse_Infeasibility_Info::set_limit(float value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.limit)
}

// optional float value = 4;
inline bool SolutionResponse_Infeasibility_Info::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Infeasibility_Info::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float SolutionResponse_Infeasibility_Info::value() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.value)
  return value_;
}
inline void SolutionResponse_Infeasibility_Info::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.value)
}

// optional int64 count = 5;
inline bool SolutionResponse_Infeasibility_Info::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_Infeasibility_Info::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_Infeasibility_Info::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_Infeasibility_Info::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::int64 SolutionResponse_Infeasibility_Info::count() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.count)
  return count_;
}
inline void SolutionResponse_Infeasibility_Info::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.count)
}

// repeated string constrainingTaskIds = 6;
inline int SolutionResponse_Infeasibility_Info::constrainingtaskids_size() const {
  return constrainingtaskids_.size();
}
inline void SolutionResponse_Infeasibility_Info::clear_constrainingtaskids() {
  constrainingtaskids_.Clear();
}
inline const ::std::string& SolutionResponse_Infeasibility_Info::constrainingtaskids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return constrainingtaskids_.Get(index);
}
inline ::std::string* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return constrainingtaskids_.Mutable(index);
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  constrainingtaskids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  constrainingtaskids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  constrainingtaskids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value, size_t size) {
  constrainingtaskids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline ::std::string* SolutionResponse_Infeasibility_Info::add_constrainingtaskids() {
  // @@protoc_insertion_point(field_add_mutable:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return constrainingtaskids_.Add();
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const ::std::string& value) {
  constrainingtaskids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(::std::string&& value) {
  constrainingtaskids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
#endif
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  constrainingtaskids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value, size_t size) {
  constrainingtaskids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolutionResponse_Infeasibility_Info::constrainingtaskids() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return constrainingtaskids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return &constrainingtaskids_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility

// required string taskId = 1;
inline bool SolutionResponse_Infeasibility::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Infeasibility::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Infeasibility::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Infeasibility::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_taskid();
}
inline const ::std::string& SolutionResponse_Infeasibility::taskid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.taskId)
  return taskid_.GetNoArena();
}
inline void SolutionResponse_Infeasibility::set_taskid(const ::std::string& value) {
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.taskId)
}
#if LANG_CXX11
inline void SolutionResponse_Infeasibility::set_taskid(::std::string&& value) {
  set_has_taskid();
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NDD.SolutionResponse.Infeasibility.taskId)
}
#endif
inline void SolutionResponse_Infeasibility::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Infeasibility.taskId)
}
inline void SolutionResponse_Infeasibility::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Infeasibility.taskId)
}
inline ::std::string* SolutionResponse_Infeasibility::mutable_taskid() {
  set_has_taskid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.taskId)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Infeasibility::release_taskid() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Infeasibility.taskId)
  if (!has_taskid()) {
    return NULL;
  }
  clear_has_taskid();
  return taskid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Infeasibility::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    set_has_taskid();
  } else {
    clear_has_taskid();
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Infeasibility.taskId)
}

// repeated .NDD.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
inline int SolutionResponse_Infeasibility::infeasibilityinfo_size() const {
  return infeasibilityinfo_.size();
}
inline void SolutionResponse_Infeasibility::clear_infeasibilityinfo() {
  infeasibilityinfo_.Clear();
}
inline ::NDD::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::mutable_infeasibilityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >*
SolutionResponse_Infeasibility::mutable_infeasibilityinfo() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return &infeasibilityinfo_;
}
inline const ::NDD::SolutionResponse_Infeasibility_Info& SolutionResponse_Infeasibility::infeasibilityinfo(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_.Get(index);
}
inline ::NDD::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::add_infeasibilityinfo() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >&
SolutionResponse_Infeasibility::infeasibilityinfo() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return infeasibilityinfo_;
}

// -------------------------------------------------------------------

// SolutionResponse_CompactSolution

// repeated .NDD.TaskSequence taskSequence = 1;
inline int SolutionResponse_CompactSolution::tasksequence_size() const {
  return tasksequence_.size();
}
inline void SolutionResponse_CompactSolution::clear_tasksequence() {
  tasksequence_.Clear();
}
inline ::NDD::TaskSequence* SolutionResponse_CompactSolution::mutable_tasksequence(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.CompactSolution.taskSequence)
  return tasksequence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
SolutionResponse_CompactSolution::mutable_tasksequence() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.CompactSolution.taskSequence)
  return &tasksequence_;
}
inline const ::NDD::TaskSequence& SolutionResponse_CompactSolution::tasksequence(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.CompactSolution.taskSequence)
  return tasksequence_.Get(index);
}
inline ::NDD::TaskSequence* SolutionResponse_CompactSolution::add_tasksequence() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.taskSequence)
  return tasksequence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
SolutionResponse_CompactSolution::tasksequence() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.CompactSolution.taskSequence)
  return tasksequence_;
}

// repeated float objectives = 2;
inline int SolutionResponse_CompactSolution::objectives_size() const {
  return objectives_.size();
}
inline void SolutionResponse_CompactSolution::clear_objectives() {
  objectives_.Clear();
}
inline float SolutionResponse_CompactSolution::objectives(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.CompactSolution.objectives)
  return objectives_.Get(index);
}
inline void SolutionResponse_CompactSolution::set_objectives(int index, float value) {
  objectives_.Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.CompactSolution.objectives)
}
inline void SolutionResponse_CompactSolution::add_objectives(float value) {
  objectives_.Add(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.objectives)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_CompactSolution::objectives() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.CompactSolution.objectives)
  return objectives_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_CompactSolution::mutable_objectives() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.CompactSolution.objectives)
  return &objectives_;
}

// repeated string objectiveNames = 3;
inline int SolutionResponse_CompactSolution::objectivenames_size() const {
  return objectivenames_.size();
}
inline void SolutionResponse_CompactSolution::clear_objectivenames() {
  objectivenames_.Clear();
}
inline const ::std::string& SolutionResponse_CompactSolution::objectivenames(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return objectivenames_.Get(index);
}
inline ::std::string* SolutionResponse_CompactSolution::mutable_objectivenames(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return objectivenames_.Mutable(index);
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.CompactSolution.objectiveNames)
  objectivenames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.CompactSolution.objectiveNames)
  objectivenames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  objectivenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const char* value, size_t size) {
  objectivenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline ::std::string* SolutionResponse_CompactSolution::add_objectivenames() {
  // @@protoc_insertion_point(field_add_mutable:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return objectivenames_.Add();
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const ::std::string& value) {
  objectivenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
#if LANG_CXX11
inline void SolutionResponse_CompactSolution::add_objectivenames(::std::string&& value) {
  objectivenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
#endif
inline void SolutionResponse_CompactSolution::add_objectivenames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  objectivenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const char* value, size_t size) {
  objectivenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolutionResponse_CompactSolution::objectivenames() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return objectivenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolutionResponse_CompactSolution::mutable_objectivenames() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return &objectivenames_;
}

// -------------------------------------------------------------------

// SolutionResponse_SolutionInstance

// repeated .NDD.SolutionResponse.Route routes = 1;
inline int SolutionResponse_SolutionInstance::routes_size() const {
  return routes_.size();
}
inline void SolutionResponse_SolutionInstance::clear_routes() {
  routes_.Clear();
}
inline ::NDD::SolutionResponse_Route* SolutionResponse_SolutionInstance::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.SolutionInstance.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >*
SolutionResponse_SolutionInstance::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.SolutionInstance.routes)
  return &routes_;
}
inline const ::NDD::SolutionResponse_Route& SolutionResponse_SolutionInstance::routes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.SolutionInstance.routes)
  return routes_.Get(index);
}
inline ::NDD::SolutionResponse_Route* SolutionResponse_SolutionInstance::add_routes() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.SolutionInstance.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >&
SolutionResponse_SolutionInstance::routes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.SolutionInstance.routes)
  return routes_;
}

// repeated .NDD.SolutionResponse.Infeasibility infeasibilities = 2;
inline int SolutionResponse_SolutionInstance::infeasibilities_size() const {
  return infeasibilities_.size();
}
inline void SolutionResponse_SolutionInstance::clear_infeasibilities() {
  infeasibilities_.Clear();
}
inline ::NDD::SolutionResponse_Infeasibility* SolutionResponse_SolutionInstance::mutable_infeasibilities(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return infeasibilities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >*
SolutionResponse_SolutionInstance::mutable_infeasibilities() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return &infeasibilities_;
}
inline const ::NDD::SolutionResponse_Infeasibility& SolutionResponse_SolutionInstance::infeasibilities(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return infeasibilities_.Get(index);
}
inline ::NDD::SolutionResponse_Infeasibility* SolutionResponse_SolutionInstance::add_infeasibilities() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return infeasibilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >&
SolutionResponse_SolutionInstance::infeasibilities() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return infeasibilities_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated .NDD.SolutionResponse.CompactSolution frontier = 1;
inline int SolutionResponse::frontier_size() const {
  return frontier_.size();
}
inline void SolutionResponse::clear_frontier() {
  frontier_.Clear();
}
inline ::NDD::SolutionResponse_CompactSolution* SolutionResponse::mutable_frontier(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.frontier)
  return frontier_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >*
SolutionResponse::mutable_frontier() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.frontier)
  return &frontier_;
}
inline const ::NDD::SolutionResponse_CompactSolution& SolutionResponse::frontier(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.frontier)
  return frontier_.Get(index);
}
inline ::NDD::SolutionResponse_CompactSolution* SolutionResponse::add_frontier() {
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.frontier)
  return frontier_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >&
SolutionResponse::frontier() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.frontier)
  return frontier_;
}

// optional .NDD.SolutionResponse.SolutionInstance instance = 2;
inline bool SolutionResponse::has_instance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse::set_has_instance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse::clear_has_instance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse::clear_instance() {
  if (instance_ != NULL) instance_->Clear();
  clear_has_instance();
}
inline const ::NDD::SolutionResponse_SolutionInstance& SolutionResponse::_internal_instance() const {
  return *instance_;
}
inline const ::NDD::SolutionResponse_SolutionInstance& SolutionResponse::instance() const {
  const ::NDD::SolutionResponse_SolutionInstance* p = instance_;
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.instance)
  return p != NULL ? *p : *reinterpret_cast<const ::NDD::SolutionResponse_SolutionInstance*>(
      &::NDD::_SolutionResponse_SolutionInstance_default_instance_);
}
inline ::NDD::SolutionResponse_SolutionInstance* SolutionResponse::release_instance() {
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.instance)
  clear_has_instance();
  ::NDD::SolutionResponse_SolutionInstance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline ::NDD::SolutionResponse_SolutionInstance* SolutionResponse::mutable_instance() {
  set_has_instance();
  if (instance_ == NULL) {
    auto* p = CreateMaybeMessage<::NDD::SolutionResponse_SolutionInstance>(GetArenaNoVirtual());
    instance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.instance)
  return instance_;
}
inline void SolutionResponse::set_allocated_instance(::NDD::SolutionResponse_SolutionInstance* instance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete instance_;
  }
  if (instance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    set_has_instance();
  } else {
    clear_has_instance();
  }
  instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.instance)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NDD

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NDD::InternalDimension_eMeasurementUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NDD::InternalDimension_eMeasurementUnit>() {
  return ::NDD::InternalDimension_eMeasurementUnit_descriptor();
}
template <> struct is_proto_enum< ::NDD::Profile_eFrequency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NDD::Profile_eFrequency>() {
  return ::NDD::Profile_eFrequency_descriptor();
}
template <> struct is_proto_enum< ::NDD::Job_VehicleRelation_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NDD::Job_VehicleRelation_Type>() {
  return ::NDD::Job_VehicleRelation_Type_descriptor();
}
template <> struct is_proto_enum< ::NDD::Job_Task_TripConstraint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NDD::Job_Task_TripConstraint>() {
  return ::NDD::Job_Task_TripConstraint_descriptor();
}
template <> struct is_proto_enum< ::NDD::SolveRequest_SolveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NDD::SolveRequest_SolveType>() {
  return ::NDD::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ndd_2dcmibu6krtqja_2eproto
