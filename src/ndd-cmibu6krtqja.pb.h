// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ndd-cmibu6krtqja.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ndd_2dcmibu6krtqja_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ndd_2dcmibu6krtqja_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ndd_2dcmibu6krtqja_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ndd_2dcmibu6krtqja_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ndd_2dcmibu6krtqja_2eproto;
namespace NDD {
class CapacityDimension;
struct CapacityDimensionDefaultTypeInternal;
extern CapacityDimensionDefaultTypeInternal _CapacityDimension_default_instance_;
class DimensionConfiguration;
struct DimensionConfigurationDefaultTypeInternal;
extern DimensionConfigurationDefaultTypeInternal _DimensionConfiguration_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class InternalDimension;
struct InternalDimensionDefaultTypeInternal;
extern InternalDimensionDefaultTypeInternal _InternalDimension_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class Job_Task;
struct Job_TaskDefaultTypeInternal;
extern Job_TaskDefaultTypeInternal _Job_Task_default_instance_;
class Job_Task_Attribute;
struct Job_Task_AttributeDefaultTypeInternal;
extern Job_Task_AttributeDefaultTypeInternal _Job_Task_Attribute_default_instance_;
class Job_VehicleRelation;
struct Job_VehicleRelationDefaultTypeInternal;
extern Job_VehicleRelationDefaultTypeInternal _Job_VehicleRelation_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Location_Attribute;
struct Location_AttributeDefaultTypeInternal;
extern Location_AttributeDefaultTypeInternal _Location_Attribute_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Profile;
struct ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class Profile_customCycle;
struct Profile_customCycleDefaultTypeInternal;
extern Profile_customCycleDefaultTypeInternal _Profile_customCycle_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_CompactSolution;
struct SolutionResponse_CompactSolutionDefaultTypeInternal;
extern SolutionResponse_CompactSolutionDefaultTypeInternal _SolutionResponse_CompactSolution_default_instance_;
class SolutionResponse_Infeasibility;
struct SolutionResponse_InfeasibilityDefaultTypeInternal;
extern SolutionResponse_InfeasibilityDefaultTypeInternal _SolutionResponse_Infeasibility_default_instance_;
class SolutionResponse_Infeasibility_Info;
struct SolutionResponse_Infeasibility_InfoDefaultTypeInternal;
extern SolutionResponse_Infeasibility_InfoDefaultTypeInternal _SolutionResponse_Infeasibility_Info_default_instance_;
class SolutionResponse_InterStop;
struct SolutionResponse_InterStopDefaultTypeInternal;
extern SolutionResponse_InterStopDefaultTypeInternal _SolutionResponse_InterStop_default_instance_;
class SolutionResponse_InterStopAttribute;
struct SolutionResponse_InterStopAttributeDefaultTypeInternal;
extern SolutionResponse_InterStopAttributeDefaultTypeInternal _SolutionResponse_InterStopAttribute_default_instance_;
class SolutionResponse_Route;
struct SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolutionResponse_SolutionInstance;
struct SolutionResponse_SolutionInstanceDefaultTypeInternal;
extern SolutionResponse_SolutionInstanceDefaultTypeInternal _SolutionResponse_SolutionInstance_default_instance_;
class SolutionResponse_Stop;
struct SolutionResponse_StopDefaultTypeInternal;
extern SolutionResponse_StopDefaultTypeInternal _SolutionResponse_Stop_default_instance_;
class SolutionResponse_StopAttribute;
struct SolutionResponse_StopAttributeDefaultTypeInternal;
extern SolutionResponse_StopAttributeDefaultTypeInternal _SolutionResponse_StopAttribute_default_instance_;
class SolutionResponse_TransitRuleAttribute;
struct SolutionResponse_TransitRuleAttributeDefaultTypeInternal;
extern SolutionResponse_TransitRuleAttributeDefaultTypeInternal _SolutionResponse_TransitRuleAttribute_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class TaskSequence;
struct TaskSequenceDefaultTypeInternal;
extern TaskSequenceDefaultTypeInternal _TaskSequence_default_instance_;
class TransitGenerator;
struct TransitGeneratorDefaultTypeInternal;
extern TransitGeneratorDefaultTypeInternal _TransitGenerator_default_instance_;
class TransitRule;
struct TransitRuleDefaultTypeInternal;
extern TransitRuleDefaultTypeInternal _TransitRule_default_instance_;
class TransitRule_Trigger;
struct TransitRule_TriggerDefaultTypeInternal;
extern TransitRule_TriggerDefaultTypeInternal _TransitRule_Trigger_default_instance_;
class TransitSet;
struct TransitSetDefaultTypeInternal;
extern TransitSetDefaultTypeInternal _TransitSet_default_instance_;
class TransitSet_TransitValue;
struct TransitSet_TransitValueDefaultTypeInternal;
extern TransitSet_TransitValueDefaultTypeInternal _TransitSet_TransitValue_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
class VehicleClass;
struct VehicleClassDefaultTypeInternal;
extern VehicleClassDefaultTypeInternal _VehicleClass_default_instance_;
class VehicleClass_Attribute;
struct VehicleClass_AttributeDefaultTypeInternal;
extern VehicleClass_AttributeDefaultTypeInternal _VehicleClass_Attribute_default_instance_;
class VehicleCostClass;
struct VehicleCostClassDefaultTypeInternal;
extern VehicleCostClassDefaultTypeInternal _VehicleCostClass_default_instance_;
class VehicleCostClass_Attribute;
struct VehicleCostClass_AttributeDefaultTypeInternal;
extern VehicleCostClass_AttributeDefaultTypeInternal _VehicleCostClass_Attribute_default_instance_;
class Vehicle_Capacity;
struct Vehicle_CapacityDefaultTypeInternal;
extern Vehicle_CapacityDefaultTypeInternal _Vehicle_Capacity_default_instance_;
class Vehicle_Shift;
struct Vehicle_ShiftDefaultTypeInternal;
extern Vehicle_ShiftDefaultTypeInternal _Vehicle_Shift_default_instance_;
class Vehicle_Task;
struct Vehicle_TaskDefaultTypeInternal;
extern Vehicle_TaskDefaultTypeInternal _Vehicle_Task_default_instance_;
class Vehicle_Task_Attribute;
struct Vehicle_Task_AttributeDefaultTypeInternal;
extern Vehicle_Task_AttributeDefaultTypeInternal _Vehicle_Task_Attribute_default_instance_;
class Window;
struct WindowDefaultTypeInternal;
extern WindowDefaultTypeInternal _Window_default_instance_;
}  // namespace NDD
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace NDD {
enum InternalDimension_eMeasurementUnit : int {
  InternalDimension_eMeasurementUnit_SECONDS = 0,
  InternalDimension_eMeasurementUnit_MINUTES = 1,
  InternalDimension_eMeasurementUnit_HOURS = 2,
  InternalDimension_eMeasurementUnit_DAYS = 3,
  InternalDimension_eMeasurementUnit_KILOMETRES = 4,
  InternalDimension_eMeasurementUnit_MILES = 5,
};

bool InternalDimension_eMeasurementUnit_IsValid(int value);
constexpr InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN = static_cast<InternalDimension_eMeasurementUnit>(0);
constexpr InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX = static_cast<InternalDimension_eMeasurementUnit>(5);
constexpr int InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
InternalDimension_eMeasurementUnit_descriptor();
template <typename T>
const std::string& InternalDimension_eMeasurementUnit_Name(T value) {
  static_assert(std::is_same<T, InternalDimension_eMeasurementUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eMeasurementUnit_Name().");
  return InternalDimension_eMeasurementUnit_Name(static_cast<InternalDimension_eMeasurementUnit>(value));
}
template <>
inline const std::string& InternalDimension_eMeasurementUnit_Name(InternalDimension_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InternalDimension_eMeasurementUnit_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool InternalDimension_eMeasurementUnit_Parse(absl::string_view name, InternalDimension_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalDimension_eMeasurementUnit>(
      InternalDimension_eMeasurementUnit_descriptor(), name, value);
}
enum Profile_eFrequency : int {
  Profile_eFrequency_CUSTOM = 0,
  Profile_eFrequency_SEVEN_TIMES_A_WEEK = 1,
  Profile_eFrequency_SIX_TIMES_A_WEEK = 2,
  Profile_eFrequency_FIVE_TIMES_A_WEEK = 3,
  Profile_eFrequency_FOUR_TIMES_A_WEEK = 4,
  Profile_eFrequency_THREE_TIMES_A_WEEK = 5,
  Profile_eFrequency_TWICE_A_WEEK = 6,
  Profile_eFrequency_ONCE_A_WEEK = 7,
  Profile_eFrequency_EVERY_SECOND_WEEK = 8,
  Profile_eFrequency_ONCE_A_MONTH = 9,
};

bool Profile_eFrequency_IsValid(int value);
constexpr Profile_eFrequency Profile_eFrequency_eFrequency_MIN = static_cast<Profile_eFrequency>(0);
constexpr Profile_eFrequency Profile_eFrequency_eFrequency_MAX = static_cast<Profile_eFrequency>(9);
constexpr int Profile_eFrequency_eFrequency_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
Profile_eFrequency_descriptor();
template <typename T>
const std::string& Profile_eFrequency_Name(T value) {
  static_assert(std::is_same<T, Profile_eFrequency>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eFrequency_Name().");
  return Profile_eFrequency_Name(static_cast<Profile_eFrequency>(value));
}
template <>
inline const std::string& Profile_eFrequency_Name(Profile_eFrequency value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Profile_eFrequency_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool Profile_eFrequency_Parse(absl::string_view name, Profile_eFrequency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Profile_eFrequency>(
      Profile_eFrequency_descriptor(), name, value);
}
enum Job_VehicleRelation_Type : int {
  Job_VehicleRelation_Type_INCLUSIVE = 0,
  Job_VehicleRelation_Type_EXCLUSIVE = 1,
};

bool Job_VehicleRelation_Type_IsValid(int value);
constexpr Job_VehicleRelation_Type Job_VehicleRelation_Type_Type_MIN = static_cast<Job_VehicleRelation_Type>(0);
constexpr Job_VehicleRelation_Type Job_VehicleRelation_Type_Type_MAX = static_cast<Job_VehicleRelation_Type>(1);
constexpr int Job_VehicleRelation_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Job_VehicleRelation_Type_descriptor();
template <typename T>
const std::string& Job_VehicleRelation_Type_Name(T value) {
  static_assert(std::is_same<T, Job_VehicleRelation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Job_VehicleRelation_Type_Name(static_cast<Job_VehicleRelation_Type>(value));
}
template <>
inline const std::string& Job_VehicleRelation_Type_Name(Job_VehicleRelation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Job_VehicleRelation_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Job_VehicleRelation_Type_Parse(absl::string_view name, Job_VehicleRelation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_VehicleRelation_Type>(
      Job_VehicleRelation_Type_descriptor(), name, value);
}
enum Job_Task_TripConstraint : int {
  Job_Task_TripConstraint_FIRST = 0,
  Job_Task_TripConstraint_LAST = 1,
};

bool Job_Task_TripConstraint_IsValid(int value);
constexpr Job_Task_TripConstraint Job_Task_TripConstraint_TripConstraint_MIN = static_cast<Job_Task_TripConstraint>(0);
constexpr Job_Task_TripConstraint Job_Task_TripConstraint_TripConstraint_MAX = static_cast<Job_Task_TripConstraint>(1);
constexpr int Job_Task_TripConstraint_TripConstraint_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Job_Task_TripConstraint_descriptor();
template <typename T>
const std::string& Job_Task_TripConstraint_Name(T value) {
  static_assert(std::is_same<T, Job_Task_TripConstraint>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TripConstraint_Name().");
  return Job_Task_TripConstraint_Name(static_cast<Job_Task_TripConstraint>(value));
}
template <>
inline const std::string& Job_Task_TripConstraint_Name(Job_Task_TripConstraint value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Job_Task_TripConstraint_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Job_Task_TripConstraint_Parse(absl::string_view name, Job_Task_TripConstraint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Job_Task_TripConstraint>(
      Job_Task_TripConstraint_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(2);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class InternalDimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.InternalDimension) */ {
 public:
  inline InternalDimension() : InternalDimension(nullptr) {}
  ~InternalDimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InternalDimension(::google::protobuf::internal::ConstantInitialized);

  InternalDimension(const InternalDimension& from);
  InternalDimension(InternalDimension&& from) noexcept
    : InternalDimension() {
    *this = ::std::move(from);
  }

  inline InternalDimension& operator=(const InternalDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalDimension& operator=(InternalDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalDimension* internal_default_instance() {
    return reinterpret_cast<const InternalDimension*>(
               &_InternalDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InternalDimension& a, InternalDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalDimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InternalDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InternalDimension& from) {
    InternalDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalDimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.InternalDimension";
  }
  protected:
  explicit InternalDimension(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eMeasurementUnit = InternalDimension_eMeasurementUnit;
  static constexpr eMeasurementUnit SECONDS = InternalDimension_eMeasurementUnit_SECONDS;
  static constexpr eMeasurementUnit MINUTES = InternalDimension_eMeasurementUnit_MINUTES;
  static constexpr eMeasurementUnit HOURS = InternalDimension_eMeasurementUnit_HOURS;
  static constexpr eMeasurementUnit DAYS = InternalDimension_eMeasurementUnit_DAYS;
  static constexpr eMeasurementUnit KILOMETRES = InternalDimension_eMeasurementUnit_KILOMETRES;
  static constexpr eMeasurementUnit MILES = InternalDimension_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return InternalDimension_eMeasurementUnit_IsValid(value);
  }
  static constexpr eMeasurementUnit eMeasurementUnit_MIN = InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN;
  static constexpr eMeasurementUnit eMeasurementUnit_MAX = InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX;
  static constexpr int eMeasurementUnit_ARRAYSIZE = InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eMeasurementUnit_descriptor() {
    return InternalDimension_eMeasurementUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eMeasurementUnit_Name(T value) {
    return InternalDimension_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(absl::string_view name, eMeasurementUnit* value) {
    return InternalDimension_eMeasurementUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMeasurementUnitFieldNumber = 2,
    kSlackMaxFieldNumber = 3,
    kTardyMaxFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .NDD.InternalDimension.eMeasurementUnit measurementUnit = 2;
  bool has_measurementunit() const;
  void clear_measurementunit() ;
  ::NDD::InternalDimension_eMeasurementUnit measurementunit() const;
  void set_measurementunit(::NDD::InternalDimension_eMeasurementUnit value);

  private:
  ::NDD::InternalDimension_eMeasurementUnit _internal_measurementunit() const;
  void _internal_set_measurementunit(::NDD::InternalDimension_eMeasurementUnit value);

  public:
  // optional float slackMax = 3 [default = 0];
  bool has_slackmax() const;
  void clear_slackmax() ;
  float slackmax() const;
  void set_slackmax(float value);

  private:
  float _internal_slackmax() const;
  void _internal_set_slackmax(float value);

  public:
  // optional float tardyMax = 4 [default = 0];
  bool has_tardymax() const;
  void clear_tardymax() ;
  float tardymax() const;
  void set_tardymax(float value);

  private:
  float _internal_tardymax() const;
  void _internal_set_tardymax(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.InternalDimension)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    int measurementunit_;
    float slackmax_;
    float tardymax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class CapacityDimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.CapacityDimension) */ {
 public:
  inline CapacityDimension() : CapacityDimension(nullptr) {}
  ~CapacityDimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CapacityDimension(::google::protobuf::internal::ConstantInitialized);

  CapacityDimension(const CapacityDimension& from);
  CapacityDimension(CapacityDimension&& from) noexcept
    : CapacityDimension() {
    *this = ::std::move(from);
  }

  inline CapacityDimension& operator=(const CapacityDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacityDimension& operator=(CapacityDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacityDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacityDimension* internal_default_instance() {
    return reinterpret_cast<const CapacityDimension*>(
               &_CapacityDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CapacityDimension& a, CapacityDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(CapacityDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacityDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacityDimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapacityDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacityDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CapacityDimension& from) {
    CapacityDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacityDimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.CapacityDimension";
  }
  protected:
  explicit CapacityDimension(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kSlackMaxFieldNumber = 3,
    kTardyMaxFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string units = 2;
  bool has_units() const;
  void clear_units() ;
  const std::string& units() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_units(Arg_&& arg, Args_... args);
  std::string* mutable_units();
  PROTOBUF_NODISCARD std::string* release_units();
  void set_allocated_units(std::string* ptr);

  private:
  const std::string& _internal_units() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_units(
      const std::string& value);
  std::string* _internal_mutable_units();

  public:
  // optional float slackMax = 3 [default = 0];
  bool has_slackmax() const;
  void clear_slackmax() ;
  float slackmax() const;
  void set_slackmax(float value);

  private:
  float _internal_slackmax() const;
  void _internal_set_slackmax(float value);

  public:
  // optional float tardyMax = 4 [default = 0];
  bool has_tardymax() const;
  void clear_tardymax() ;
  float tardymax() const;
  void set_tardymax(float value);

  private:
  float _internal_tardymax() const;
  void _internal_set_tardymax(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.CapacityDimension)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 37, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr units_;
    float slackmax_;
    float tardymax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class DimensionConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.DimensionConfiguration) */ {
 public:
  inline DimensionConfiguration() : DimensionConfiguration(nullptr) {}
  ~DimensionConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DimensionConfiguration(::google::protobuf::internal::ConstantInitialized);

  DimensionConfiguration(const DimensionConfiguration& from);
  DimensionConfiguration(DimensionConfiguration&& from) noexcept
    : DimensionConfiguration() {
    *this = ::std::move(from);
  }

  inline DimensionConfiguration& operator=(const DimensionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DimensionConfiguration& operator=(DimensionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DimensionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DimensionConfiguration* internal_default_instance() {
    return reinterpret_cast<const DimensionConfiguration*>(
               &_DimensionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DimensionConfiguration& a, DimensionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(DimensionConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DimensionConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DimensionConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DimensionConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DimensionConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DimensionConfiguration& from) {
    DimensionConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.DimensionConfiguration";
  }
  protected:
  explicit DimensionConfiguration(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityDimensionsFieldNumber = 3,
    kTimeConfigFieldNumber = 1,
    kDistanceConfigFieldNumber = 2,
    kWeekLengthFieldNumber = 4,
    kPeriodLengthFieldNumber = 5,
  };
  // repeated .NDD.CapacityDimension capacityDimensions = 3;
  int capacitydimensions_size() const;
  private:
  int _internal_capacitydimensions_size() const;

  public:
  void clear_capacitydimensions() ;
  ::NDD::CapacityDimension* mutable_capacitydimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >*
      mutable_capacitydimensions();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::CapacityDimension>& _internal_capacitydimensions() const;
  ::google::protobuf::RepeatedPtrField<::NDD::CapacityDimension>* _internal_mutable_capacitydimensions();
  public:
  const ::NDD::CapacityDimension& capacitydimensions(int index) const;
  ::NDD::CapacityDimension* add_capacitydimensions();
  const ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >&
      capacitydimensions() const;
  // optional .NDD.InternalDimension timeConfig = 1;
  bool has_timeconfig() const;
  void clear_timeconfig() ;
  const ::NDD::InternalDimension& timeconfig() const;
  PROTOBUF_NODISCARD ::NDD::InternalDimension* release_timeconfig();
  ::NDD::InternalDimension* mutable_timeconfig();
  void set_allocated_timeconfig(::NDD::InternalDimension* value);
  void unsafe_arena_set_allocated_timeconfig(::NDD::InternalDimension* value);
  ::NDD::InternalDimension* unsafe_arena_release_timeconfig();

  private:
  const ::NDD::InternalDimension& _internal_timeconfig() const;
  ::NDD::InternalDimension* _internal_mutable_timeconfig();

  public:
  // optional .NDD.InternalDimension distanceConfig = 2;
  bool has_distanceconfig() const;
  void clear_distanceconfig() ;
  const ::NDD::InternalDimension& distanceconfig() const;
  PROTOBUF_NODISCARD ::NDD::InternalDimension* release_distanceconfig();
  ::NDD::InternalDimension* mutable_distanceconfig();
  void set_allocated_distanceconfig(::NDD::InternalDimension* value);
  void unsafe_arena_set_allocated_distanceconfig(::NDD::InternalDimension* value);
  ::NDD::InternalDimension* unsafe_arena_release_distanceconfig();

  private:
  const ::NDD::InternalDimension& _internal_distanceconfig() const;
  ::NDD::InternalDimension* _internal_mutable_distanceconfig();

  public:
  // required int32 weekLength = 4;
  bool has_weeklength() const;
  void clear_weeklength() ;
  ::int32_t weeklength() const;
  void set_weeklength(::int32_t value);

  private:
  ::int32_t _internal_weeklength() const;
  void _internal_set_weeklength(::int32_t value);

  public:
  // required int32 periodLength = 5;
  bool has_periodlength() const;
  void clear_periodlength() ;
  ::int32_t periodlength() const;
  void set_periodlength(::int32_t value);

  private:
  ::int32_t _internal_periodlength() const;
  void _internal_set_periodlength(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.DimensionConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension > capacitydimensions_;
    ::NDD::InternalDimension* timeconfig_;
    ::NDD::InternalDimension* distanceconfig_;
    ::int32_t weeklength_;
    ::int32_t periodlength_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float longitude_;
    float latitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Window final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Window) */ {
 public:
  inline Window() : Window(nullptr) {}
  ~Window() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Window(::google::protobuf::internal::ConstantInitialized);

  Window(const Window& from);
  Window(Window&& from) noexcept
    : Window() {
    *this = ::std::move(from);
  }

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  inline Window& operator=(Window&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Window& default_instance() {
    return *internal_default_instance();
  }
  static inline const Window* internal_default_instance() {
    return reinterpret_cast<const Window*>(
               &_Window_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Window& a, Window& b) {
    a.Swap(&b);
  }
  inline void Swap(Window* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Window* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Window* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Window>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Window& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Window& from) {
    Window::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Window* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Window";
  }
  protected:
  explicit Window(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kSlackCostCoefFieldNumber = 3,
    kTardyCostCoefFieldNumber = 4,
    kSlackMaxFieldNumber = 5,
    kTardyMaxFieldNumber = 6,
  };
  // required float start = 1;
  bool has_start() const;
  void clear_start() ;
  float start() const;
  void set_start(float value);

  private:
  float _internal_start() const;
  void _internal_set_start(float value);

  public:
  // required float end = 2;
  bool has_end() const;
  void clear_end() ;
  float end() const;
  void set_end(float value);

  private:
  float _internal_end() const;
  void _internal_set_end(float value);

  public:
  // optional float slackCostCoef = 3 [default = 0];
  bool has_slackcostcoef() const;
  void clear_slackcostcoef() ;
  float slackcostcoef() const;
  void set_slackcostcoef(float value);

  private:
  float _internal_slackcostcoef() const;
  void _internal_set_slackcostcoef(float value);

  public:
  // optional float tardyCostCoef = 4 [default = 0];
  bool has_tardycostcoef() const;
  void clear_tardycostcoef() ;
  float tardycostcoef() const;
  void set_tardycostcoef(float value);

  private:
  float _internal_tardycostcoef() const;
  void _internal_set_tardycostcoef(float value);

  public:
  // optional float slackMax = 5 [default = -1];
  bool has_slackmax() const;
  void clear_slackmax() ;
  float slackmax() const;
  void set_slackmax(float value);

  private:
  float _internal_slackmax() const;
  void _internal_set_slackmax(float value);

  public:
  // optional float tardyMax = 6 [default = -1];
  bool has_tardymax() const;
  void clear_tardymax() ;
  float tardymax() const;
  void set_tardymax(float value);

  private:
  float _internal_tardymax() const;
  void _internal_set_tardymax(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Window)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float start_;
    float end_;
    float slackcostcoef_;
    float tardycostcoef_;
    float slackmax_;
    float tardymax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Location_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Location.Attribute) */ {
 public:
  inline Location_Attribute() : Location_Attribute(nullptr) {}
  ~Location_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Location_Attribute(::google::protobuf::internal::ConstantInitialized);

  Location_Attribute(const Location_Attribute& from);
  Location_Attribute(Location_Attribute&& from) noexcept
    : Location_Attribute() {
    *this = ::std::move(from);
  }

  inline Location_Attribute& operator=(const Location_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location_Attribute& operator=(Location_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location_Attribute* internal_default_instance() {
    return reinterpret_cast<const Location_Attribute*>(
               &_Location_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Location_Attribute& a, Location_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Location_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Location_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Location_Attribute& from) {
    Location_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Location.Attribute";
  }
  protected:
  explicit Location_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrivalWindowsFieldNumber = 4,
    kDepartureWindowsFieldNumber = 5,
    kDimensionIdFieldNumber = 1,
    kVehicleIdFieldNumber = 2,
    kQuantityFieldNumber = 3,
  };
  // repeated .NDD.Window arrivalWindows = 4;
  int arrivalwindows_size() const;
  private:
  int _internal_arrivalwindows_size() const;

  public:
  void clear_arrivalwindows() ;
  ::NDD::Window* mutable_arrivalwindows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_arrivalwindows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Window>& _internal_arrivalwindows() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Window>* _internal_mutable_arrivalwindows();
  public:
  const ::NDD::Window& arrivalwindows(int index) const;
  ::NDD::Window* add_arrivalwindows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      arrivalwindows() const;
  // repeated .NDD.Window departureWindows = 5;
  int departurewindows_size() const;
  private:
  int _internal_departurewindows_size() const;

  public:
  void clear_departurewindows() ;
  ::NDD::Window* mutable_departurewindows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_departurewindows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Window>& _internal_departurewindows() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Window>* _internal_mutable_departurewindows();
  public:
  const ::NDD::Window& departurewindows(int index) const;
  ::NDD::Window* add_departurewindows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      departurewindows() const;
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional string vehicleId = 2;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // optional float quantity = 3;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Location.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 2, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Window > arrivalwindows_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Window > departurewindows_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Location final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Location(::google::protobuf::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Location";
  }
  protected:
  explicit Location(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Location_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kIdFieldNumber = 1,
    kGeocodeFieldNumber = 2,
  };
  // repeated .NDD.Location.Attribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::Location_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Location_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Location_Attribute>* _internal_mutable_attributes();
  public:
  const ::NDD::Location_Attribute& attributes(int index) const;
  ::NDD::Location_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >&
      attributes() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .NDD.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode() ;
  const ::NDD::Geocode& geocode() const;
  PROTOBUF_NODISCARD ::NDD::Geocode* release_geocode();
  ::NDD::Geocode* mutable_geocode();
  void set_allocated_geocode(::NDD::Geocode* value);
  void unsafe_arena_set_allocated_geocode(::NDD::Geocode* value);
  ::NDD::Geocode* unsafe_arena_release_geocode();

  private:
  const ::NDD::Geocode& _internal_geocode() const;
  ::NDD::Geocode* _internal_mutable_geocode();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Location)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 23, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::NDD::Geocode* geocode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Profile_customCycle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Profile.customCycle) */ {
 public:
  inline Profile_customCycle() : Profile_customCycle(nullptr) {}
  ~Profile_customCycle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_customCycle(::google::protobuf::internal::ConstantInitialized);

  Profile_customCycle(const Profile_customCycle& from);
  Profile_customCycle(Profile_customCycle&& from) noexcept
    : Profile_customCycle() {
    *this = ::std::move(from);
  }

  inline Profile_customCycle& operator=(const Profile_customCycle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_customCycle& operator=(Profile_customCycle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_customCycle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_customCycle* internal_default_instance() {
    return reinterpret_cast<const Profile_customCycle*>(
               &_Profile_customCycle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Profile_customCycle& a, Profile_customCycle& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_customCycle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_customCycle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_customCycle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_customCycle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_customCycle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_customCycle& from) {
    Profile_customCycle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile_customCycle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Profile.customCycle";
  }
  protected:
  explicit Profile_customCycle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisitProfileFieldNumber = 2,
  };
  // repeated bool visitProfile = 2;
  int visitprofile_size() const;
  private:
  int _internal_visitprofile_size() const;

  public:
  void clear_visitprofile() ;
  bool visitprofile(int index) const;
  void set_visitprofile(int index, bool value);
  void add_visitprofile(bool value);
  const ::google::protobuf::RepeatedField<bool>& visitprofile() const;
  ::google::protobuf::RepeatedField<bool>* mutable_visitprofile();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_visitprofile() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_visitprofile();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Profile.customCycle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<bool> visitprofile_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Profile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Profile) */ {
 public:
  inline Profile() : Profile(nullptr) {}
  ~Profile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile(::google::protobuf::internal::ConstantInitialized);

  Profile(const Profile& from);
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile& operator=(Profile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile& from) {
    Profile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Profile";
  }
  protected:
  explicit Profile(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Profile_customCycle customCycle;

  using eFrequency = Profile_eFrequency;
  static constexpr eFrequency CUSTOM = Profile_eFrequency_CUSTOM;
  static constexpr eFrequency SEVEN_TIMES_A_WEEK = Profile_eFrequency_SEVEN_TIMES_A_WEEK;
  static constexpr eFrequency SIX_TIMES_A_WEEK = Profile_eFrequency_SIX_TIMES_A_WEEK;
  static constexpr eFrequency FIVE_TIMES_A_WEEK = Profile_eFrequency_FIVE_TIMES_A_WEEK;
  static constexpr eFrequency FOUR_TIMES_A_WEEK = Profile_eFrequency_FOUR_TIMES_A_WEEK;
  static constexpr eFrequency THREE_TIMES_A_WEEK = Profile_eFrequency_THREE_TIMES_A_WEEK;
  static constexpr eFrequency TWICE_A_WEEK = Profile_eFrequency_TWICE_A_WEEK;
  static constexpr eFrequency ONCE_A_WEEK = Profile_eFrequency_ONCE_A_WEEK;
  static constexpr eFrequency EVERY_SECOND_WEEK = Profile_eFrequency_EVERY_SECOND_WEEK;
  static constexpr eFrequency ONCE_A_MONTH = Profile_eFrequency_ONCE_A_MONTH;
  static inline bool eFrequency_IsValid(int value) {
    return Profile_eFrequency_IsValid(value);
  }
  static constexpr eFrequency eFrequency_MIN = Profile_eFrequency_eFrequency_MIN;
  static constexpr eFrequency eFrequency_MAX = Profile_eFrequency_eFrequency_MAX;
  static constexpr int eFrequency_ARRAYSIZE = Profile_eFrequency_eFrequency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eFrequency_descriptor() {
    return Profile_eFrequency_descriptor();
  }
  template <typename T>
  static inline const std::string& eFrequency_Name(T value) {
    return Profile_eFrequency_Name(value);
  }
  static inline bool eFrequency_Parse(absl::string_view name, eFrequency* value) {
    return Profile_eFrequency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowableCyclesFieldNumber = 2,
    kFrequencyTypeFieldNumber = 1,
    kNumVisitsFieldNumber = 3,
  };
  // repeated .NDD.Profile.customCycle allowableCycles = 2;
  int allowablecycles_size() const;
  private:
  int _internal_allowablecycles_size() const;

  public:
  void clear_allowablecycles() ;
  ::NDD::Profile_customCycle* mutable_allowablecycles(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >*
      mutable_allowablecycles();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Profile_customCycle>& _internal_allowablecycles() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Profile_customCycle>* _internal_mutable_allowablecycles();
  public:
  const ::NDD::Profile_customCycle& allowablecycles(int index) const;
  ::NDD::Profile_customCycle* add_allowablecycles();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >&
      allowablecycles() const;
  // required .NDD.Profile.eFrequency frequencyType = 1;
  bool has_frequencytype() const;
  void clear_frequencytype() ;
  ::NDD::Profile_eFrequency frequencytype() const;
  void set_frequencytype(::NDD::Profile_eFrequency value);

  private:
  ::NDD::Profile_eFrequency _internal_frequencytype() const;
  void _internal_set_frequencytype(::NDD::Profile_eFrequency value);

  public:
  // optional int32 numVisits = 3;
  bool has_numvisits() const;
  void clear_numvisits() ;
  ::int32_t numvisits() const;
  void set_numvisits(::int32_t value);

  private:
  ::int32_t _internal_numvisits() const;
  void _internal_set_numvisits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Profile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle > allowablecycles_;
    int frequencytype_;
    ::int32_t numvisits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Job_VehicleRelation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job.VehicleRelation) */ {
 public:
  inline Job_VehicleRelation() : Job_VehicleRelation(nullptr) {}
  ~Job_VehicleRelation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_VehicleRelation(::google::protobuf::internal::ConstantInitialized);

  Job_VehicleRelation(const Job_VehicleRelation& from);
  Job_VehicleRelation(Job_VehicleRelation&& from) noexcept
    : Job_VehicleRelation() {
    *this = ::std::move(from);
  }

  inline Job_VehicleRelation& operator=(const Job_VehicleRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_VehicleRelation& operator=(Job_VehicleRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_VehicleRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_VehicleRelation* internal_default_instance() {
    return reinterpret_cast<const Job_VehicleRelation*>(
               &_Job_VehicleRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Job_VehicleRelation& a, Job_VehicleRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_VehicleRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_VehicleRelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_VehicleRelation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_VehicleRelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_VehicleRelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_VehicleRelation& from) {
    Job_VehicleRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_VehicleRelation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Job.VehicleRelation";
  }
  protected:
  explicit Job_VehicleRelation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Job_VehicleRelation_Type;
  static constexpr Type INCLUSIVE = Job_VehicleRelation_Type_INCLUSIVE;
  static constexpr Type EXCLUSIVE = Job_VehicleRelation_Type_EXCLUSIVE;
  static inline bool Type_IsValid(int value) {
    return Job_VehicleRelation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Job_VehicleRelation_Type_Type_MIN;
  static constexpr Type Type_MAX = Job_VehicleRelation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Job_VehicleRelation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Job_VehicleRelation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Job_VehicleRelation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Job_VehicleRelation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string vehicleIds = 2;
  int vehicleids_size() const;
  private:
  int _internal_vehicleids_size() const;

  public:
  void clear_vehicleids() ;
  const std::string& vehicleids(int index) const;
  std::string* mutable_vehicleids(int index);
  void set_vehicleids(int index, const std::string& value);
  void set_vehicleids(int index, std::string&& value);
  void set_vehicleids(int index, const char* value);
  void set_vehicleids(int index, const char* value, std::size_t size);
  void set_vehicleids(int index, absl::string_view value);
  std::string* add_vehicleids();
  void add_vehicleids(const std::string& value);
  void add_vehicleids(std::string&& value);
  void add_vehicleids(const char* value);
  void add_vehicleids(const char* value, std::size_t size);
  void add_vehicleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_vehicleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_vehicleids();

  public:
  // required .NDD.Job.VehicleRelation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::NDD::Job_VehicleRelation_Type type() const;
  void set_type(::NDD::Job_VehicleRelation_Type value);

  private:
  ::NDD::Job_VehicleRelation_Type _internal_type() const;
  void _internal_set_type(::NDD::Job_VehicleRelation_Type value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Job.VehicleRelation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 42, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> vehicleids_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Job_Task_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job.Task.Attribute) */ {
 public:
  inline Job_Task_Attribute() : Job_Task_Attribute(nullptr) {}
  ~Job_Task_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_Task_Attribute(::google::protobuf::internal::ConstantInitialized);

  Job_Task_Attribute(const Job_Task_Attribute& from);
  Job_Task_Attribute(Job_Task_Attribute&& from) noexcept
    : Job_Task_Attribute() {
    *this = ::std::move(from);
  }

  inline Job_Task_Attribute& operator=(const Job_Task_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_Task_Attribute& operator=(Job_Task_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_Task_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_Task_Attribute* internal_default_instance() {
    return reinterpret_cast<const Job_Task_Attribute*>(
               &_Job_Task_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Job_Task_Attribute& a, Job_Task_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_Task_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_Task_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_Task_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_Task_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_Task_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_Task_Attribute& from) {
    Job_Task_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Job.Task.Attribute";
  }
  protected:
  explicit Job_Task_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowsFieldNumber = 3,
    kVehicleIdsFieldNumber = 4,
    kDimensionIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // repeated .NDD.Window windows = 3;
  int windows_size() const;
  private:
  int _internal_windows_size() const;

  public:
  void clear_windows() ;
  ::NDD::Window* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_windows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Window>& _internal_windows() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Window>* _internal_mutable_windows();
  public:
  const ::NDD::Window& windows(int index) const;
  ::NDD::Window* add_windows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      windows() const;
  // repeated string vehicleIds = 4;
  int vehicleids_size() const;
  private:
  int _internal_vehicleids_size() const;

  public:
  void clear_vehicleids() ;
  const std::string& vehicleids(int index) const;
  std::string* mutable_vehicleids(int index);
  void set_vehicleids(int index, const std::string& value);
  void set_vehicleids(int index, std::string&& value);
  void set_vehicleids(int index, const char* value);
  void set_vehicleids(int index, const char* value, std::size_t size);
  void set_vehicleids(int index, absl::string_view value);
  std::string* add_vehicleids();
  void add_vehicleids(const std::string& value);
  void add_vehicleids(std::string&& value);
  void add_vehicleids(const char* value);
  void add_vehicleids(const char* value, std::size_t size);
  void add_vehicleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_vehicleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_vehicleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_vehicleids();

  public:
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional float quantity = 2;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Job.Task.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Window > windows_;
    ::google::protobuf::RepeatedPtrField<std::string> vehicleids_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Job_Task final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job.Task) */ {
 public:
  inline Job_Task() : Job_Task(nullptr) {}
  ~Job_Task() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job_Task(::google::protobuf::internal::ConstantInitialized);

  Job_Task(const Job_Task& from);
  Job_Task(Job_Task&& from) noexcept
    : Job_Task() {
    *this = ::std::move(from);
  }

  inline Job_Task& operator=(const Job_Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job_Task& operator=(Job_Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job_Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job_Task* internal_default_instance() {
    return reinterpret_cast<const Job_Task*>(
               &_Job_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Job_Task& a, Job_Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Job_Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job_Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job_Task* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job_Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job_Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job_Task& from) {
    Job_Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job_Task* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Job.Task";
  }
  protected:
  explicit Job_Task(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_Task_Attribute Attribute;

  using TripConstraint = Job_Task_TripConstraint;
  static constexpr TripConstraint FIRST = Job_Task_TripConstraint_FIRST;
  static constexpr TripConstraint LAST = Job_Task_TripConstraint_LAST;
  static inline bool TripConstraint_IsValid(int value) {
    return Job_Task_TripConstraint_IsValid(value);
  }
  static constexpr TripConstraint TripConstraint_MIN = Job_Task_TripConstraint_TripConstraint_MIN;
  static constexpr TripConstraint TripConstraint_MAX = Job_Task_TripConstraint_TripConstraint_MAX;
  static constexpr int TripConstraint_ARRAYSIZE = Job_Task_TripConstraint_TripConstraint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TripConstraint_descriptor() {
    return Job_Task_TripConstraint_descriptor();
  }
  template <typename T>
  static inline const std::string& TripConstraint_Name(T value) {
    return Job_Task_TripConstraint_Name(value);
  }
  static inline bool TripConstraint_Parse(absl::string_view name, TripConstraint* value) {
    return Job_Task_TripConstraint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kTripConstraintsFieldNumber = 4,
    kTaskIdFieldNumber = 1,
    kLocationIdFieldNumber = 2,
  };
  // repeated .NDD.Job.Task.Attribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::Job_Task_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Job_Task_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Job_Task_Attribute>* _internal_mutable_attributes();
  public:
  const ::NDD::Job_Task_Attribute& attributes(int index) const;
  ::NDD::Job_Task_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >&
      attributes() const;
  // repeated .NDD.Job.Task.TripConstraint tripConstraints = 4;
  int tripconstraints_size() const;
  private:
  int _internal_tripconstraints_size() const;

  public:
  void clear_tripconstraints() ;
  public:
  ::NDD::Job_Task_TripConstraint tripconstraints(int index) const;
  void set_tripconstraints(int index, ::NDD::Job_Task_TripConstraint value);
  void add_tripconstraints(::NDD::Job_Task_TripConstraint value);
  const ::google::protobuf::RepeatedField<int>& tripconstraints() const;
  ::google::protobuf::RepeatedField<int>* mutable_tripconstraints();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_tripconstraints() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_tripconstraints();

  public:
  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // required string locationId = 2;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Job.Task)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 37, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute > attributes_;
    ::google::protobuf::RepeatedField<int> tripconstraints_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Job final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job(::google::protobuf::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Job";
  }
  protected:
  explicit Job(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Job_VehicleRelation VehicleRelation;
  typedef Job_Task Task;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPickupTaskFieldNumber = 2,
    kDropoffTaskFieldNumber = 3,
    kVehicleRelationsFieldNumber = 5,
    kProfileFieldNumber = 6,
    kPenaltyFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .NDD.Job.Task pickupTask = 2;
  bool has_pickuptask() const;
  void clear_pickuptask() ;
  const ::NDD::Job_Task& pickuptask() const;
  PROTOBUF_NODISCARD ::NDD::Job_Task* release_pickuptask();
  ::NDD::Job_Task* mutable_pickuptask();
  void set_allocated_pickuptask(::NDD::Job_Task* value);
  void unsafe_arena_set_allocated_pickuptask(::NDD::Job_Task* value);
  ::NDD::Job_Task* unsafe_arena_release_pickuptask();

  private:
  const ::NDD::Job_Task& _internal_pickuptask() const;
  ::NDD::Job_Task* _internal_mutable_pickuptask();

  public:
  // optional .NDD.Job.Task dropoffTask = 3;
  bool has_dropofftask() const;
  void clear_dropofftask() ;
  const ::NDD::Job_Task& dropofftask() const;
  PROTOBUF_NODISCARD ::NDD::Job_Task* release_dropofftask();
  ::NDD::Job_Task* mutable_dropofftask();
  void set_allocated_dropofftask(::NDD::Job_Task* value);
  void unsafe_arena_set_allocated_dropofftask(::NDD::Job_Task* value);
  ::NDD::Job_Task* unsafe_arena_release_dropofftask();

  private:
  const ::NDD::Job_Task& _internal_dropofftask() const;
  ::NDD::Job_Task* _internal_mutable_dropofftask();

  public:
  // optional .NDD.Job.VehicleRelation vehicleRelations = 5;
  bool has_vehiclerelations() const;
  void clear_vehiclerelations() ;
  const ::NDD::Job_VehicleRelation& vehiclerelations() const;
  PROTOBUF_NODISCARD ::NDD::Job_VehicleRelation* release_vehiclerelations();
  ::NDD::Job_VehicleRelation* mutable_vehiclerelations();
  void set_allocated_vehiclerelations(::NDD::Job_VehicleRelation* value);
  void unsafe_arena_set_allocated_vehiclerelations(::NDD::Job_VehicleRelation* value);
  ::NDD::Job_VehicleRelation* unsafe_arena_release_vehiclerelations();

  private:
  const ::NDD::Job_VehicleRelation& _internal_vehiclerelations() const;
  ::NDD::Job_VehicleRelation* _internal_mutable_vehiclerelations();

  public:
  // required .NDD.Profile profile = 6;
  bool has_profile() const;
  void clear_profile() ;
  const ::NDD::Profile& profile() const;
  PROTOBUF_NODISCARD ::NDD::Profile* release_profile();
  ::NDD::Profile* mutable_profile();
  void set_allocated_profile(::NDD::Profile* value);
  void unsafe_arena_set_allocated_profile(::NDD::Profile* value);
  ::NDD::Profile* unsafe_arena_release_profile();

  private:
  const ::NDD::Profile& _internal_profile() const;
  ::NDD::Profile* _internal_mutable_profile();

  public:
  // required float penalty = 4;
  bool has_penalty() const;
  void clear_penalty() ;
  float penalty() const;
  void set_penalty(float value);

  private:
  float _internal_penalty() const;
  void _internal_set_penalty(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Job)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 4, 18, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::NDD::Job_Task* pickuptask_;
    ::NDD::Job_Task* dropofftask_;
    ::NDD::Job_VehicleRelation* vehiclerelations_;
    ::NDD::Profile* profile_;
    float penalty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class TransitSet_TransitValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitSet.TransitValue) */ {
 public:
  inline TransitSet_TransitValue() : TransitSet_TransitValue(nullptr) {}
  ~TransitSet_TransitValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitSet_TransitValue(::google::protobuf::internal::ConstantInitialized);

  TransitSet_TransitValue(const TransitSet_TransitValue& from);
  TransitSet_TransitValue(TransitSet_TransitValue&& from) noexcept
    : TransitSet_TransitValue() {
    *this = ::std::move(from);
  }

  inline TransitSet_TransitValue& operator=(const TransitSet_TransitValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitSet_TransitValue& operator=(TransitSet_TransitValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitSet_TransitValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitSet_TransitValue* internal_default_instance() {
    return reinterpret_cast<const TransitSet_TransitValue*>(
               &_TransitSet_TransitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TransitSet_TransitValue& a, TransitSet_TransitValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitSet_TransitValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitSet_TransitValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitSet_TransitValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitSet_TransitValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitSet_TransitValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitSet_TransitValue& from) {
    TransitSet_TransitValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitSet_TransitValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.TransitSet.TransitValue";
  }
  protected:
  explicit TransitSet_TransitValue(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromIdFieldNumber = 1,
    kToIdFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // required string fromId = 1;
  bool has_fromid() const;
  void clear_fromid() ;
  const std::string& fromid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromid(Arg_&& arg, Args_... args);
  std::string* mutable_fromid();
  PROTOBUF_NODISCARD std::string* release_fromid();
  void set_allocated_fromid(std::string* ptr);

  private:
  const std::string& _internal_fromid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromid(
      const std::string& value);
  std::string* _internal_mutable_fromid();

  public:
  // required string toId = 2;
  bool has_toid() const;
  void clear_toid() ;
  const std::string& toid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_toid(Arg_&& arg, Args_... args);
  std::string* mutable_toid();
  PROTOBUF_NODISCARD std::string* release_toid();
  void set_allocated_toid(std::string* ptr);

  private:
  const std::string& _internal_toid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toid(
      const std::string& value);
  std::string* _internal_mutable_toid();

  public:
  // required float value = 3;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.TransitSet.TransitValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr fromid_;
    ::google::protobuf::internal::ArenaStringPtr toid_;
    float value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class TransitSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitSet) */ {
 public:
  inline TransitSet() : TransitSet(nullptr) {}
  ~TransitSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitSet(::google::protobuf::internal::ConstantInitialized);

  TransitSet(const TransitSet& from);
  TransitSet(TransitSet&& from) noexcept
    : TransitSet() {
    *this = ::std::move(from);
  }

  inline TransitSet& operator=(const TransitSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitSet& operator=(TransitSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitSet* internal_default_instance() {
    return reinterpret_cast<const TransitSet*>(
               &_TransitSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransitSet& a, TransitSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitSet& from) {
    TransitSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitSet* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.TransitSet";
  }
  protected:
  explicit TransitSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransitSet_TransitValue TransitValue;

  // accessors -------------------------------------------------------

  enum : int {
    kTransitsFieldNumber = 1,
  };
  // repeated .NDD.TransitSet.TransitValue transits = 1;
  int transits_size() const;
  private:
  int _internal_transits_size() const;

  public:
  void clear_transits() ;
  ::NDD::TransitSet_TransitValue* mutable_transits(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >*
      mutable_transits();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TransitSet_TransitValue>& _internal_transits() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TransitSet_TransitValue>* _internal_mutable_transits();
  public:
  const ::NDD::TransitSet_TransitValue& transits(int index) const;
  ::NDD::TransitSet_TransitValue* add_transits();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >&
      transits() const;
  // @@protoc_insertion_point(class_scope:NDD.TransitSet)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue > transits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class TransitGenerator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitGenerator) */ {
 public:
  inline TransitGenerator() : TransitGenerator(nullptr) {}
  ~TransitGenerator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitGenerator(::google::protobuf::internal::ConstantInitialized);

  TransitGenerator(const TransitGenerator& from);
  TransitGenerator(TransitGenerator&& from) noexcept
    : TransitGenerator() {
    *this = ::std::move(from);
  }

  inline TransitGenerator& operator=(const TransitGenerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitGenerator& operator=(TransitGenerator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitGenerator& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitGenerator* internal_default_instance() {
    return reinterpret_cast<const TransitGenerator*>(
               &_TransitGenerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransitGenerator& a, TransitGenerator& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitGenerator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitGenerator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitGenerator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitGenerator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitGenerator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitGenerator& from) {
    TransitGenerator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitGenerator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.TransitGenerator";
  }
  protected:
  explicit TransitGenerator(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kTransitSetFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string requestId = 2;
  bool has_requestid() const;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* ptr);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // optional .NDD.TransitSet transitSet = 3;
  bool has_transitset() const;
  void clear_transitset() ;
  const ::NDD::TransitSet& transitset() const;
  PROTOBUF_NODISCARD ::NDD::TransitSet* release_transitset();
  ::NDD::TransitSet* mutable_transitset();
  void set_allocated_transitset(::NDD::TransitSet* value);
  void unsafe_arena_set_allocated_transitset(::NDD::TransitSet* value);
  ::NDD::TransitSet* unsafe_arena_release_transitset();

  private:
  const ::NDD::TransitSet& _internal_transitset() const;
  ::NDD::TransitSet* _internal_mutable_transitset();

  public:
  // @@protoc_insertion_point(class_scope:NDD.TransitGenerator)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 40, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::NDD::TransitSet* transitset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class VehicleClass_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleClass.Attribute) */ {
 public:
  inline VehicleClass_Attribute() : VehicleClass_Attribute(nullptr) {}
  ~VehicleClass_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleClass_Attribute(::google::protobuf::internal::ConstantInitialized);

  VehicleClass_Attribute(const VehicleClass_Attribute& from);
  VehicleClass_Attribute(VehicleClass_Attribute&& from) noexcept
    : VehicleClass_Attribute() {
    *this = ::std::move(from);
  }

  inline VehicleClass_Attribute& operator=(const VehicleClass_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleClass_Attribute& operator=(VehicleClass_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleClass_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleClass_Attribute* internal_default_instance() {
    return reinterpret_cast<const VehicleClass_Attribute*>(
               &_VehicleClass_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VehicleClass_Attribute& a, VehicleClass_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleClass_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleClass_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleClass_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleClass_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleClass_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleClass_Attribute& from) {
    VehicleClass_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleClass_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.VehicleClass.Attribute";
  }
  protected:
  explicit VehicleClass_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kTransitGeneratorIdFieldNumber = 2,
    kTransitCoefFieldNumber = 3,
    kTaskCoefFieldNumber = 4,
    kLocationCoefFieldNumber = 5,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional string transitGeneratorId = 2;
  bool has_transitgeneratorid() const;
  void clear_transitgeneratorid() ;
  const std::string& transitgeneratorid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transitgeneratorid(Arg_&& arg, Args_... args);
  std::string* mutable_transitgeneratorid();
  PROTOBUF_NODISCARD std::string* release_transitgeneratorid();
  void set_allocated_transitgeneratorid(std::string* ptr);

  private:
  const std::string& _internal_transitgeneratorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transitgeneratorid(
      const std::string& value);
  std::string* _internal_mutable_transitgeneratorid();

  public:
  // optional float transitCoef = 3;
  bool has_transitcoef() const;
  void clear_transitcoef() ;
  float transitcoef() const;
  void set_transitcoef(float value);

  private:
  float _internal_transitcoef() const;
  void _internal_set_transitcoef(float value);

  public:
  // optional float taskCoef = 4;
  bool has_taskcoef() const;
  void clear_taskcoef() ;
  float taskcoef() const;
  void set_taskcoef(float value);

  private:
  float _internal_taskcoef() const;
  void _internal_set_taskcoef(float value);

  public:
  // optional float locationCoef = 5;
  bool has_locationcoef() const;
  void clear_locationcoef() ;
  float locationcoef() const;
  void set_locationcoef(float value);

  private:
  float _internal_locationcoef() const;
  void _internal_set_locationcoef(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.VehicleClass.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 64, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    ::google::protobuf::internal::ArenaStringPtr transitgeneratorid_;
    float transitcoef_;
    float taskcoef_;
    float locationcoef_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class VehicleClass final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleClass) */ {
 public:
  inline VehicleClass() : VehicleClass(nullptr) {}
  ~VehicleClass() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleClass(::google::protobuf::internal::ConstantInitialized);

  VehicleClass(const VehicleClass& from);
  VehicleClass(VehicleClass&& from) noexcept
    : VehicleClass() {
    *this = ::std::move(from);
  }

  inline VehicleClass& operator=(const VehicleClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleClass& operator=(VehicleClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleClass* internal_default_instance() {
    return reinterpret_cast<const VehicleClass*>(
               &_VehicleClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VehicleClass& a, VehicleClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleClass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleClass* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleClass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleClass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleClass& from) {
    VehicleClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleClass* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.VehicleClass";
  }
  protected:
  explicit VehicleClass(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleClass_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kTransitRuleIdsFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .NDD.VehicleClass.Attribute attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::VehicleClass_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass_Attribute>* _internal_mutable_attributes();
  public:
  const ::NDD::VehicleClass_Attribute& attributes(int index) const;
  ::NDD::VehicleClass_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >&
      attributes() const;
  // repeated string transitRuleIds = 3;
  int transitruleids_size() const;
  private:
  int _internal_transitruleids_size() const;

  public:
  void clear_transitruleids() ;
  const std::string& transitruleids(int index) const;
  std::string* mutable_transitruleids(int index);
  void set_transitruleids(int index, const std::string& value);
  void set_transitruleids(int index, std::string&& value);
  void set_transitruleids(int index, const char* value);
  void set_transitruleids(int index, const char* value, std::size_t size);
  void set_transitruleids(int index, absl::string_view value);
  std::string* add_transitruleids();
  void add_transitruleids(const std::string& value);
  void add_transitruleids(std::string&& value);
  void add_transitruleids(const char* value);
  void add_transitruleids(const char* value, std::size_t size);
  void add_transitruleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transitruleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transitruleids();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:NDD.VehicleClass)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 41, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute > attributes_;
    ::google::protobuf::RepeatedPtrField<std::string> transitruleids_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class VehicleCostClass_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleCostClass.Attribute) */ {
 public:
  inline VehicleCostClass_Attribute() : VehicleCostClass_Attribute(nullptr) {}
  ~VehicleCostClass_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleCostClass_Attribute(::google::protobuf::internal::ConstantInitialized);

  VehicleCostClass_Attribute(const VehicleCostClass_Attribute& from);
  VehicleCostClass_Attribute(VehicleCostClass_Attribute&& from) noexcept
    : VehicleCostClass_Attribute() {
    *this = ::std::move(from);
  }

  inline VehicleCostClass_Attribute& operator=(const VehicleCostClass_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleCostClass_Attribute& operator=(VehicleCostClass_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleCostClass_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleCostClass_Attribute* internal_default_instance() {
    return reinterpret_cast<const VehicleCostClass_Attribute*>(
               &_VehicleCostClass_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VehicleCostClass_Attribute& a, VehicleCostClass_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleCostClass_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleCostClass_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleCostClass_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleCostClass_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleCostClass_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleCostClass_Attribute& from) {
    VehicleCostClass_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCostClass_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.VehicleCostClass.Attribute";
  }
  protected:
  explicit VehicleCostClass_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kTransitCostCoefFieldNumber = 2,
    kTaskCostCoefFieldNumber = 3,
    kLocationCostCoefFieldNumber = 4,
    kSlackCostCoefFieldNumber = 5,
    kTardyCostCoefFieldNumber = 6,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional float transitCostCoef = 2;
  bool has_transitcostcoef() const;
  void clear_transitcostcoef() ;
  float transitcostcoef() const;
  void set_transitcostcoef(float value);

  private:
  float _internal_transitcostcoef() const;
  void _internal_set_transitcostcoef(float value);

  public:
  // optional float taskCostCoef = 3;
  bool has_taskcostcoef() const;
  void clear_taskcostcoef() ;
  float taskcostcoef() const;
  void set_taskcostcoef(float value);

  private:
  float _internal_taskcostcoef() const;
  void _internal_set_taskcostcoef(float value);

  public:
  // optional float locationCostCoef = 4;
  bool has_locationcostcoef() const;
  void clear_locationcostcoef() ;
  float locationcostcoef() const;
  void set_locationcostcoef(float value);

  private:
  float _internal_locationcostcoef() const;
  void _internal_set_locationcostcoef(float value);

  public:
  // optional float slackCostCoef = 5;
  bool has_slackcostcoef() const;
  void clear_slackcostcoef() ;
  float slackcostcoef() const;
  void set_slackcostcoef(float value);

  private:
  float _internal_slackcostcoef() const;
  void _internal_set_slackcostcoef(float value);

  public:
  // optional float tardyCostCoef = 6;
  bool has_tardycostcoef() const;
  void clear_tardycostcoef() ;
  float tardycostcoef() const;
  void set_tardycostcoef(float value);

  private:
  float _internal_tardycostcoef() const;
  void _internal_set_tardycostcoef(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.VehicleCostClass.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float transitcostcoef_;
    float taskcostcoef_;
    float locationcostcoef_;
    float slackcostcoef_;
    float tardycostcoef_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class VehicleCostClass final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.VehicleCostClass) */ {
 public:
  inline VehicleCostClass() : VehicleCostClass(nullptr) {}
  ~VehicleCostClass() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleCostClass(::google::protobuf::internal::ConstantInitialized);

  VehicleCostClass(const VehicleCostClass& from);
  VehicleCostClass(VehicleCostClass&& from) noexcept
    : VehicleCostClass() {
    *this = ::std::move(from);
  }

  inline VehicleCostClass& operator=(const VehicleCostClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleCostClass& operator=(VehicleCostClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleCostClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleCostClass* internal_default_instance() {
    return reinterpret_cast<const VehicleCostClass*>(
               &_VehicleCostClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VehicleCostClass& a, VehicleCostClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleCostClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleCostClass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleCostClass* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleCostClass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleCostClass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VehicleCostClass& from) {
    VehicleCostClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCostClass* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.VehicleCostClass";
  }
  protected:
  explicit VehicleCostClass(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleCostClass_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kIdFieldNumber = 1,
    kFixedCostFieldNumber = 2,
  };
  // repeated .NDD.VehicleCostClass.Attribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::VehicleCostClass_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass_Attribute>* _internal_mutable_attributes();
  public:
  const ::NDD::VehicleCostClass_Attribute& attributes(int index) const;
  ::NDD::VehicleCostClass_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >&
      attributes() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float fixedCost = 2;
  bool has_fixedcost() const;
  void clear_fixedcost() ;
  float fixedcost() const;
  void set_fixedcost(float value);

  private:
  float _internal_fixedcost() const;
  void _internal_set_fixedcost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.VehicleCostClass)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 31, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float fixedcost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Task_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Task.Attribute) */ {
 public:
  inline Vehicle_Task_Attribute() : Vehicle_Task_Attribute(nullptr) {}
  ~Vehicle_Task_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Task_Attribute(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Task_Attribute(const Vehicle_Task_Attribute& from);
  Vehicle_Task_Attribute(Vehicle_Task_Attribute&& from) noexcept
    : Vehicle_Task_Attribute() {
    *this = ::std::move(from);
  }

  inline Vehicle_Task_Attribute& operator=(const Vehicle_Task_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Task_Attribute& operator=(Vehicle_Task_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Task_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Task_Attribute* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Task_Attribute*>(
               &_Vehicle_Task_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Vehicle_Task_Attribute& a, Vehicle_Task_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Task_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Task_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Task_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Task_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Task_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Task_Attribute& from) {
    Vehicle_Task_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Task_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Vehicle.Task.Attribute";
  }
  protected:
  explicit Vehicle_Task_Attribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowsFieldNumber = 3,
    kDimensionIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // repeated .NDD.Window windows = 3;
  int windows_size() const;
  private:
  int _internal_windows_size() const;

  public:
  void clear_windows() ;
  ::NDD::Window* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
      mutable_windows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Window>& _internal_windows() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Window>* _internal_mutable_windows();
  public:
  const ::NDD::Window& windows(int index) const;
  ::NDD::Window* add_windows();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
      windows() const;
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // optional float quantity = 2;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Task.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Window > windows_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Task final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Task) */ {
 public:
  inline Vehicle_Task() : Vehicle_Task(nullptr) {}
  ~Vehicle_Task() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Task(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Task(const Vehicle_Task& from);
  Vehicle_Task(Vehicle_Task&& from) noexcept
    : Vehicle_Task() {
    *this = ::std::move(from);
  }

  inline Vehicle_Task& operator=(const Vehicle_Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Task& operator=(Vehicle_Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Task* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Task*>(
               &_Vehicle_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Vehicle_Task& a, Vehicle_Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Task* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Task& from) {
    Vehicle_Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Task* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Vehicle.Task";
  }
  protected:
  explicit Vehicle_Task(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_Task_Attribute Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kLocationIdFieldNumber = 1,
  };
  // repeated .NDD.Vehicle.Task.Attribute attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::Vehicle_Task_Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Task_Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Task_Attribute>* _internal_mutable_attributes();
  public:
  const ::NDD::Vehicle_Task_Attribute& attributes(int index) const;
  ::NDD::Vehicle_Task_Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >&
      attributes() const;
  // required string locationId = 1;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Task)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 35, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Shift final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Shift) */ {
 public:
  inline Vehicle_Shift() : Vehicle_Shift(nullptr) {}
  ~Vehicle_Shift() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Shift(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Shift(const Vehicle_Shift& from);
  Vehicle_Shift(Vehicle_Shift&& from) noexcept
    : Vehicle_Shift() {
    *this = ::std::move(from);
  }

  inline Vehicle_Shift& operator=(const Vehicle_Shift& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Shift& operator=(Vehicle_Shift&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Shift& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Shift* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Shift*>(
               &_Vehicle_Shift_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Vehicle_Shift& a, Vehicle_Shift& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Shift* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Shift* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Shift* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Shift>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Shift& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Shift& from) {
    Vehicle_Shift::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Shift* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Vehicle.Shift";
  }
  protected:
  explicit Vehicle_Shift(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShiftStartFieldNumber = 1,
    kShiftEndFieldNumber = 2,
  };
  // required .NDD.Vehicle.Task shiftStart = 1;
  bool has_shiftstart() const;
  void clear_shiftstart() ;
  const ::NDD::Vehicle_Task& shiftstart() const;
  PROTOBUF_NODISCARD ::NDD::Vehicle_Task* release_shiftstart();
  ::NDD::Vehicle_Task* mutable_shiftstart();
  void set_allocated_shiftstart(::NDD::Vehicle_Task* value);
  void unsafe_arena_set_allocated_shiftstart(::NDD::Vehicle_Task* value);
  ::NDD::Vehicle_Task* unsafe_arena_release_shiftstart();

  private:
  const ::NDD::Vehicle_Task& _internal_shiftstart() const;
  ::NDD::Vehicle_Task* _internal_mutable_shiftstart();

  public:
  // optional .NDD.Vehicle.Task shiftEnd = 2;
  bool has_shiftend() const;
  void clear_shiftend() ;
  const ::NDD::Vehicle_Task& shiftend() const;
  PROTOBUF_NODISCARD ::NDD::Vehicle_Task* release_shiftend();
  ::NDD::Vehicle_Task* mutable_shiftend();
  void set_allocated_shiftend(::NDD::Vehicle_Task* value);
  void unsafe_arena_set_allocated_shiftend(::NDD::Vehicle_Task* value);
  ::NDD::Vehicle_Task* unsafe_arena_release_shiftend();

  private:
  const ::NDD::Vehicle_Task& _internal_shiftend() const;
  ::NDD::Vehicle_Task* _internal_mutable_shiftend();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Shift)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NDD::Vehicle_Task* shiftstart_;
    ::NDD::Vehicle_Task* shiftend_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Vehicle_Capacity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle.Capacity) */ {
 public:
  inline Vehicle_Capacity() : Vehicle_Capacity(nullptr) {}
  ~Vehicle_Capacity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle_Capacity(::google::protobuf::internal::ConstantInitialized);

  Vehicle_Capacity(const Vehicle_Capacity& from);
  Vehicle_Capacity(Vehicle_Capacity&& from) noexcept
    : Vehicle_Capacity() {
    *this = ::std::move(from);
  }

  inline Vehicle_Capacity& operator=(const Vehicle_Capacity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle_Capacity& operator=(Vehicle_Capacity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle_Capacity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle_Capacity* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Capacity*>(
               &_Vehicle_Capacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Vehicle_Capacity& a, Vehicle_Capacity& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle_Capacity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle_Capacity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle_Capacity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle_Capacity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle_Capacity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle_Capacity& from) {
    Vehicle_Capacity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_Capacity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Vehicle.Capacity";
  }
  protected:
  explicit Vehicle_Capacity(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kCapacityFieldNumber = 2,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required float capacity = 2;
  bool has_capacity() const;
  void clear_capacity() ;
  float capacity() const;
  void set_capacity(float value);

  private:
  float _internal_capacity() const;
  void _internal_set_capacity(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.Vehicle.Capacity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 40, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Vehicle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle(::google::protobuf::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Vehicle";
  }
  protected:
  explicit Vehicle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_Task Task;
  typedef Vehicle_Shift Shift;
  typedef Vehicle_Capacity Capacity;

  // accessors -------------------------------------------------------

  enum : int {
    kShiftFieldNumber = 4,
    kCapacitiesFieldNumber = 5,
    kTransitRuleIdsFieldNumber = 6,
    kIdFieldNumber = 1,
    kClassIdFieldNumber = 2,
    kCostClassIdFieldNumber = 3,
  };
  // repeated .NDD.Vehicle.Shift shift = 4;
  int shift_size() const;
  private:
  int _internal_shift_size() const;

  public:
  void clear_shift() ;
  ::NDD::Vehicle_Shift* mutable_shift(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >*
      mutable_shift();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Shift>& _internal_shift() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Shift>* _internal_mutable_shift();
  public:
  const ::NDD::Vehicle_Shift& shift(int index) const;
  ::NDD::Vehicle_Shift* add_shift();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >&
      shift() const;
  // repeated .NDD.Vehicle.Capacity capacities = 5;
  int capacities_size() const;
  private:
  int _internal_capacities_size() const;

  public:
  void clear_capacities() ;
  ::NDD::Vehicle_Capacity* mutable_capacities(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >*
      mutable_capacities();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Capacity>& _internal_capacities() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Capacity>* _internal_mutable_capacities();
  public:
  const ::NDD::Vehicle_Capacity& capacities(int index) const;
  ::NDD::Vehicle_Capacity* add_capacities();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >&
      capacities() const;
  // repeated string transitRuleIds = 6;
  int transitruleids_size() const;
  private:
  int _internal_transitruleids_size() const;

  public:
  void clear_transitruleids() ;
  const std::string& transitruleids(int index) const;
  std::string* mutable_transitruleids(int index);
  void set_transitruleids(int index, const std::string& value);
  void set_transitruleids(int index, std::string&& value);
  void set_transitruleids(int index, const char* value);
  void set_transitruleids(int index, const char* value, std::size_t size);
  void set_transitruleids(int index, absl::string_view value);
  std::string* add_transitruleids();
  void add_transitruleids(const std::string& value);
  void add_transitruleids(std::string&& value);
  void add_transitruleids(const char* value);
  void add_transitruleids(const char* value, std::size_t size);
  void add_transitruleids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transitruleids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transitruleids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transitruleids();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string classId = 2;
  bool has_classid() const;
  void clear_classid() ;
  const std::string& classid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_classid(Arg_&& arg, Args_... args);
  std::string* mutable_classid();
  PROTOBUF_NODISCARD std::string* release_classid();
  void set_allocated_classid(std::string* ptr);

  private:
  const std::string& _internal_classid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classid(
      const std::string& value);
  std::string* _internal_mutable_classid();

  public:
  // required string costClassId = 3;
  bool has_costclassid() const;
  void clear_costclassid() ;
  const std::string& costclassid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_costclassid(Arg_&& arg, Args_... args);
  std::string* mutable_costclassid();
  PROTOBUF_NODISCARD std::string* release_costclassid();
  void set_allocated_costclassid(std::string* ptr);

  private:
  const std::string& _internal_costclassid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_costclassid(
      const std::string& value);
  std::string* _internal_mutable_costclassid();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Vehicle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 2, 54, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift > shift_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity > capacities_;
    ::google::protobuf::RepeatedPtrField<std::string> transitruleids_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr classid_;
    ::google::protobuf::internal::ArenaStringPtr costclassid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class TaskSequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TaskSequence) */ {
 public:
  inline TaskSequence() : TaskSequence(nullptr) {}
  ~TaskSequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskSequence(::google::protobuf::internal::ConstantInitialized);

  TaskSequence(const TaskSequence& from);
  TaskSequence(TaskSequence&& from) noexcept
    : TaskSequence() {
    *this = ::std::move(from);
  }

  inline TaskSequence& operator=(const TaskSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskSequence& operator=(TaskSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskSequence* internal_default_instance() {
    return reinterpret_cast<const TaskSequence*>(
               &_TaskSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TaskSequence& a, TaskSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskSequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskSequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskSequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskSequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TaskSequence& from) {
    TaskSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskSequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.TaskSequence";
  }
  protected:
  explicit TaskSequence(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 3,
    kVehicleIdFieldNumber = 1,
    kDayIndexFieldNumber = 2,
  };
  // repeated string taskId = 3;
  int taskid_size() const;
  private:
  int _internal_taskid_size() const;

  public:
  void clear_taskid() ;
  const std::string& taskid(int index) const;
  std::string* mutable_taskid(int index);
  void set_taskid(int index, const std::string& value);
  void set_taskid(int index, std::string&& value);
  void set_taskid(int index, const char* value);
  void set_taskid(int index, const char* value, std::size_t size);
  void set_taskid(int index, absl::string_view value);
  std::string* add_taskid();
  void add_taskid(const std::string& value);
  void add_taskid(std::string&& value);
  void add_taskid(const char* value);
  void add_taskid(const char* value, std::size_t size);
  void add_taskid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& taskid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_taskid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_taskid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_taskid();

  public:
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // required int32 dayIndex = 2;
  bool has_dayindex() const;
  void clear_dayindex() ;
  ::int32_t dayindex() const;
  void set_dayindex(::int32_t value);

  private:
  ::int32_t _internal_dayindex() const;
  void _internal_set_dayindex(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.TaskSequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 40, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> taskid_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    ::int32_t dayindex_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class TransitRule_Trigger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitRule.Trigger) */ {
 public:
  inline TransitRule_Trigger() : TransitRule_Trigger(nullptr) {}
  ~TransitRule_Trigger() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitRule_Trigger(::google::protobuf::internal::ConstantInitialized);

  TransitRule_Trigger(const TransitRule_Trigger& from);
  TransitRule_Trigger(TransitRule_Trigger&& from) noexcept
    : TransitRule_Trigger() {
    *this = ::std::move(from);
  }

  inline TransitRule_Trigger& operator=(const TransitRule_Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitRule_Trigger& operator=(TransitRule_Trigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitRule_Trigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitRule_Trigger* internal_default_instance() {
    return reinterpret_cast<const TransitRule_Trigger*>(
               &_TransitRule_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TransitRule_Trigger& a, TransitRule_Trigger& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitRule_Trigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitRule_Trigger* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitRule_Trigger* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitRule_Trigger>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitRule_Trigger& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitRule_Trigger& from) {
    TransitRule_Trigger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitRule_Trigger* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.TransitRule.Trigger";
  }
  protected:
  explicit TransitRule_Trigger(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // required float value = 1;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // required float quantity = 2;
  bool has_quantity() const;
  void clear_quantity() ;
  float quantity() const;
  void set_quantity(float value);

  private:
  float _internal_quantity() const;
  void _internal_set_quantity(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.TransitRule.Trigger)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float value_;
    float quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class TransitRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.TransitRule) */ {
 public:
  inline TransitRule() : TransitRule(nullptr) {}
  ~TransitRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitRule(::google::protobuf::internal::ConstantInitialized);

  TransitRule(const TransitRule& from);
  TransitRule(TransitRule&& from) noexcept
    : TransitRule() {
    *this = ::std::move(from);
  }

  inline TransitRule& operator=(const TransitRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitRule& operator=(TransitRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitRule* internal_default_instance() {
    return reinterpret_cast<const TransitRule*>(
               &_TransitRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TransitRule& a, TransitRule& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitRule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitRule& from) {
    TransitRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitRule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.TransitRule";
  }
  protected:
  explicit TransitRule(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransitRule_Trigger Trigger;

  // accessors -------------------------------------------------------

  enum : int {
    kTriggersFieldNumber = 6,
    kIdFieldNumber = 1,
    kDimensionIdFieldNumber = 2,
    kRuleIdPrefixFieldNumber = 5,
    kUseTransitStateFieldNumber = 4,
    kUseStandingStateFieldNumber = 3,
  };
  // repeated .NDD.TransitRule.Trigger triggers = 6;
  int triggers_size() const;
  private:
  int _internal_triggers_size() const;

  public:
  void clear_triggers() ;
  ::NDD::TransitRule_Trigger* mutable_triggers(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >*
      mutable_triggers();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TransitRule_Trigger>& _internal_triggers() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TransitRule_Trigger>* _internal_mutable_triggers();
  public:
  const ::NDD::TransitRule_Trigger& triggers(int index) const;
  ::NDD::TransitRule_Trigger* add_triggers();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >&
      triggers() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string dimensionId = 2;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required string ruleIdPrefix = 5;
  bool has_ruleidprefix() const;
  void clear_ruleidprefix() ;
  const std::string& ruleidprefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ruleidprefix(Arg_&& arg, Args_... args);
  std::string* mutable_ruleidprefix();
  PROTOBUF_NODISCARD std::string* release_ruleidprefix();
  void set_allocated_ruleidprefix(std::string* ptr);

  private:
  const std::string& _internal_ruleidprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruleidprefix(
      const std::string& value);
  std::string* _internal_mutable_ruleidprefix();

  public:
  // optional bool useTransitState = 4 [default = false];
  bool has_usetransitstate() const;
  void clear_usetransitstate() ;
  bool usetransitstate() const;
  void set_usetransitstate(bool value);

  private:
  bool _internal_usetransitstate() const;
  void _internal_set_usetransitstate(bool value);

  public:
  // optional bool useStandingState = 3 [default = true];
  bool has_usestandingstate() const;
  void clear_usestandingstate() ;
  bool usestandingstate() const;
  void set_usestandingstate(bool value);

  private:
  bool _internal_usestandingstate() const;
  void _internal_set_usestandingstate(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.TransitRule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger > triggers_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    ::google::protobuf::internal::ArenaStringPtr ruleidprefix_;
    bool usetransitstate_;
    bool usestandingstate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::google::protobuf::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.Model";
  }
  protected:
  explicit Model(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 2,
    kJobsFieldNumber = 3,
    kVehiclesFieldNumber = 4,
    kVehicleClassesFieldNumber = 5,
    kVehicleCostClassesFieldNumber = 6,
    kTransitRulesFieldNumber = 7,
    kTransitGeneratorsFieldNumber = 8,
    kTaskSequenceFieldNumber = 9,
    kDimensionsFieldNumber = 1,
  };
  // repeated .NDD.Location locations = 2;
  int locations_size() const;
  private:
  int _internal_locations_size() const;

  public:
  void clear_locations() ;
  ::NDD::Location* mutable_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Location >*
      mutable_locations();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Location>& _internal_locations() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Location>* _internal_mutable_locations();
  public:
  const ::NDD::Location& locations(int index) const;
  ::NDD::Location* add_locations();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Location >&
      locations() const;
  // repeated .NDD.Job jobs = 3;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;

  public:
  void clear_jobs() ;
  ::NDD::Job* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Job >*
      mutable_jobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Job>& _internal_jobs() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Job>* _internal_mutable_jobs();
  public:
  const ::NDD::Job& jobs(int index) const;
  ::NDD::Job* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Job >&
      jobs() const;
  // repeated .NDD.Vehicle vehicles = 4;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;

  public:
  void clear_vehicles() ;
  ::NDD::Vehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >*
      mutable_vehicles();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle>& _internal_vehicles() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Vehicle>* _internal_mutable_vehicles();
  public:
  const ::NDD::Vehicle& vehicles(int index) const;
  ::NDD::Vehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >&
      vehicles() const;
  // repeated .NDD.VehicleClass vehicleClasses = 5;
  int vehicleclasses_size() const;
  private:
  int _internal_vehicleclasses_size() const;

  public:
  void clear_vehicleclasses() ;
  ::NDD::VehicleClass* mutable_vehicleclasses(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >*
      mutable_vehicleclasses();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass>& _internal_vehicleclasses() const;
  ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass>* _internal_mutable_vehicleclasses();
  public:
  const ::NDD::VehicleClass& vehicleclasses(int index) const;
  ::NDD::VehicleClass* add_vehicleclasses();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >&
      vehicleclasses() const;
  // repeated .NDD.VehicleCostClass vehicleCostClasses = 6;
  int vehiclecostclasses_size() const;
  private:
  int _internal_vehiclecostclasses_size() const;

  public:
  void clear_vehiclecostclasses() ;
  ::NDD::VehicleCostClass* mutable_vehiclecostclasses(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >*
      mutable_vehiclecostclasses();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass>& _internal_vehiclecostclasses() const;
  ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass>* _internal_mutable_vehiclecostclasses();
  public:
  const ::NDD::VehicleCostClass& vehiclecostclasses(int index) const;
  ::NDD::VehicleCostClass* add_vehiclecostclasses();
  const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >&
      vehiclecostclasses() const;
  // repeated .NDD.TransitRule transitRules = 7;
  int transitrules_size() const;
  private:
  int _internal_transitrules_size() const;

  public:
  void clear_transitrules() ;
  ::NDD::TransitRule* mutable_transitrules(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >*
      mutable_transitrules();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TransitRule>& _internal_transitrules() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TransitRule>* _internal_mutable_transitrules();
  public:
  const ::NDD::TransitRule& transitrules(int index) const;
  ::NDD::TransitRule* add_transitrules();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >&
      transitrules() const;
  // repeated .NDD.TransitGenerator transitGenerators = 8;
  int transitgenerators_size() const;
  private:
  int _internal_transitgenerators_size() const;

  public:
  void clear_transitgenerators() ;
  ::NDD::TransitGenerator* mutable_transitgenerators(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >*
      mutable_transitgenerators();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TransitGenerator>& _internal_transitgenerators() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TransitGenerator>* _internal_mutable_transitgenerators();
  public:
  const ::NDD::TransitGenerator& transitgenerators(int index) const;
  ::NDD::TransitGenerator* add_transitgenerators();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >&
      transitgenerators() const;
  // repeated .NDD.TaskSequence taskSequence = 9;
  int tasksequence_size() const;
  private:
  int _internal_tasksequence_size() const;

  public:
  void clear_tasksequence() ;
  ::NDD::TaskSequence* mutable_tasksequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
      mutable_tasksequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>& _internal_tasksequence() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>* _internal_mutable_tasksequence();
  public:
  const ::NDD::TaskSequence& tasksequence(int index) const;
  ::NDD::TaskSequence* add_tasksequence();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
      tasksequence() const;
  // required .NDD.DimensionConfiguration dimensions = 1;
  bool has_dimensions() const;
  void clear_dimensions() ;
  const ::NDD::DimensionConfiguration& dimensions() const;
  PROTOBUF_NODISCARD ::NDD::DimensionConfiguration* release_dimensions();
  ::NDD::DimensionConfiguration* mutable_dimensions();
  void set_allocated_dimensions(::NDD::DimensionConfiguration* value);
  void unsafe_arena_set_allocated_dimensions(::NDD::DimensionConfiguration* value);
  ::NDD::DimensionConfiguration* unsafe_arena_release_dimensions();

  private:
  const ::NDD::DimensionConfiguration& _internal_dimensions() const;
  ::NDD::DimensionConfiguration* _internal_mutable_dimensions();

  public:
  // @@protoc_insertion_point(class_scope:NDD.Model)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 9, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Location > locations_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Job > jobs_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle > vehicles_;
    ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass > vehicleclasses_;
    ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass > vehiclecostclasses_;
    ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule > transitrules_;
    ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator > transitgenerators_;
    ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence > tasksequence_;
    ::NDD::DimensionConfiguration* dimensions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated .NDD.TaskSequence routes = 3;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::NDD::TaskSequence* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>* _internal_mutable_routes();
  public:
  const ::NDD::TaskSequence& routes(int index) const;
  ::NDD::TaskSequence* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
      routes() const;
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .NDD.Model model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::NDD::Model& model() const;
  PROTOBUF_NODISCARD ::NDD::Model* release_model();
  ::NDD::Model* mutable_model();
  void set_allocated_model(::NDD::Model* value);
  void unsafe_arena_set_allocated_model(::NDD::Model* value);
  ::NDD::Model* unsafe_arena_release_model();

  private:
  const ::NDD::Model& _internal_model() const;
  ::NDD::Model* _internal_mutable_model();

  public:
  // optional .NDD.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::NDD::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::NDD::SolveRequest_SolveType value);

  private:
  ::NDD::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::NDD::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 3, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence > routes_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::NDD::Model* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_StopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.StopAttribute) */ {
 public:
  inline SolutionResponse_StopAttribute() : SolutionResponse_StopAttribute(nullptr) {}
  ~SolutionResponse_StopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_StopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_StopAttribute(const SolutionResponse_StopAttribute& from);
  SolutionResponse_StopAttribute(SolutionResponse_StopAttribute&& from) noexcept
    : SolutionResponse_StopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_StopAttribute& operator=(const SolutionResponse_StopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_StopAttribute& operator=(SolutionResponse_StopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_StopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_StopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_StopAttribute*>(
               &_SolutionResponse_StopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SolutionResponse_StopAttribute& a, SolutionResponse_StopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_StopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_StopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_StopAttribute& from) {
    SolutionResponse_StopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_StopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.StopAttribute";
  }
  protected:
  explicit SolutionResponse_StopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
    kSlackValueFieldNumber = 5,
    kSlackCostFieldNumber = 6,
    kTardyValueFieldNumber = 7,
    kTardyCostFieldNumber = 8,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // required float slackValue = 5;
  bool has_slackvalue() const;
  void clear_slackvalue() ;
  float slackvalue() const;
  void set_slackvalue(float value);

  private:
  float _internal_slackvalue() const;
  void _internal_set_slackvalue(float value);

  public:
  // required float slackCost = 6;
  bool has_slackcost() const;
  void clear_slackcost() ;
  float slackcost() const;
  void set_slackcost(float value);

  private:
  float _internal_slackcost() const;
  void _internal_set_slackcost(float value);

  public:
  // required float tardyValue = 7;
  bool has_tardyvalue() const;
  void clear_tardyvalue() ;
  float tardyvalue() const;
  void set_tardyvalue(float value);

  private:
  float _internal_tardyvalue() const;
  void _internal_set_tardyvalue(float value);

  public:
  // required float tardyCost = 8;
  bool has_tardycost() const;
  void clear_tardycost() ;
  float tardycost() const;
  void set_tardycost(float value);

  private:
  float _internal_tardycost() const;
  void _internal_set_tardycost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.StopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8, 0, 56, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    float slackvalue_;
    float slackcost_;
    float tardyvalue_;
    float tardycost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.InterStopAttribute) */ {
 public:
  inline SolutionResponse_InterStopAttribute() : SolutionResponse_InterStopAttribute(nullptr) {}
  ~SolutionResponse_InterStopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStopAttribute(const SolutionResponse_InterStopAttribute& from);
  SolutionResponse_InterStopAttribute(SolutionResponse_InterStopAttribute&& from) noexcept
    : SolutionResponse_InterStopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStopAttribute& operator=(const SolutionResponse_InterStopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStopAttribute& operator=(SolutionResponse_InterStopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStopAttribute*>(
               &_SolutionResponse_InterStopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SolutionResponse_InterStopAttribute& a, SolutionResponse_InterStopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStopAttribute& from) {
    SolutionResponse_InterStopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.InterStopAttribute";
  }
  protected:
  explicit SolutionResponse_InterStopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.InterStopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Stop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Stop) */ {
 public:
  inline SolutionResponse_Stop() : SolutionResponse_Stop(nullptr) {}
  ~SolutionResponse_Stop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Stop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Stop(const SolutionResponse_Stop& from);
  SolutionResponse_Stop(SolutionResponse_Stop&& from) noexcept
    : SolutionResponse_Stop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Stop& operator=(const SolutionResponse_Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Stop& operator=(SolutionResponse_Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Stop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Stop*>(
               &_SolutionResponse_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SolutionResponse_Stop& a, SolutionResponse_Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Stop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Stop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Stop& from) {
    SolutionResponse_Stop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Stop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.Stop";
  }
  protected:
  explicit SolutionResponse_Stop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 6,
    kLocationIdFieldNumber = 3,
    kTaskIdFieldNumber = 4,
    kJobIdFieldNumber = 5,
    kIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
  };
  // repeated .NDD.SolutionResponse.StopAttribute attributes = 6;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::SolutionResponse_StopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_StopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_StopAttribute>* _internal_mutable_attributes();
  public:
  const ::NDD::SolutionResponse_StopAttribute& attributes(int index) const;
  ::NDD::SolutionResponse_StopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >&
      attributes() const;
  // required string locationId = 3;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // required string taskId = 4;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // required string jobId = 5;
  bool has_jobid() const;
  void clear_jobid() ;
  const std::string& jobid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jobid(Arg_&& arg, Args_... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* ptr);

  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(
      const std::string& value);
  std::string* _internal_mutable_jobid();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence() ;
  ::int32_t sequence() const;
  void set_sequence(::int32_t value);

  private:
  ::int32_t _internal_sequence() const;
  void _internal_set_sequence(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Stop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 55, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    ::google::protobuf::internal::ArenaStringPtr jobid_;
    ::int32_t id_;
    ::int32_t sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.InterStop) */ {
 public:
  inline SolutionResponse_InterStop() : SolutionResponse_InterStop(nullptr) {}
  ~SolutionResponse_InterStop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStop(const SolutionResponse_InterStop& from);
  SolutionResponse_InterStop(SolutionResponse_InterStop&& from) noexcept
    : SolutionResponse_InterStop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStop& operator=(const SolutionResponse_InterStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStop& operator=(SolutionResponse_InterStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStop*>(
               &_SolutionResponse_InterStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SolutionResponse_InterStop& a, SolutionResponse_InterStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStop& from) {
    SolutionResponse_InterStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.InterStop";
  }
  protected:
  explicit SolutionResponse_InterStop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kRouteSegmentsFieldNumber = 4,
    kFromStopIdFieldNumber = 1,
    kToStopIdFieldNumber = 2,
  };
  // repeated .NDD.SolutionResponse.InterStopAttribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NDD::SolutionResponse_InterStopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStopAttribute>* _internal_mutable_attributes();
  public:
  const ::NDD::SolutionResponse_InterStopAttribute& attributes(int index) const;
  ::NDD::SolutionResponse_InterStopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >&
      attributes() const;
  // repeated .NDD.Geocode routeSegments = 4;
  int routesegments_size() const;
  private:
  int _internal_routesegments_size() const;

  public:
  void clear_routesegments() ;
  ::NDD::Geocode* mutable_routesegments(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >*
      mutable_routesegments();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::Geocode>& _internal_routesegments() const;
  ::google::protobuf::RepeatedPtrField<::NDD::Geocode>* _internal_mutable_routesegments();
  public:
  const ::NDD::Geocode& routesegments(int index) const;
  ::NDD::Geocode* add_routesegments();
  const ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >&
      routesegments() const;
  // required int32 fromStopId = 1;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 2;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.InterStop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute > attributes_;
    ::google::protobuf::RepeatedPtrField< ::NDD::Geocode > routesegments_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_TransitRuleAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.TransitRuleAttribute) */ {
 public:
  inline SolutionResponse_TransitRuleAttribute() : SolutionResponse_TransitRuleAttribute(nullptr) {}
  ~SolutionResponse_TransitRuleAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_TransitRuleAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_TransitRuleAttribute(const SolutionResponse_TransitRuleAttribute& from);
  SolutionResponse_TransitRuleAttribute(SolutionResponse_TransitRuleAttribute&& from) noexcept
    : SolutionResponse_TransitRuleAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_TransitRuleAttribute& operator=(const SolutionResponse_TransitRuleAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_TransitRuleAttribute& operator=(SolutionResponse_TransitRuleAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_TransitRuleAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_TransitRuleAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_TransitRuleAttribute*>(
               &_SolutionResponse_TransitRuleAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SolutionResponse_TransitRuleAttribute& a, SolutionResponse_TransitRuleAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_TransitRuleAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_TransitRuleAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_TransitRuleAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_TransitRuleAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_TransitRuleAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_TransitRuleAttribute& from) {
    SolutionResponse_TransitRuleAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_TransitRuleAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.TransitRuleAttribute";
  }
  protected:
  explicit SolutionResponse_TransitRuleAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleIdFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kFromStopIdFieldNumber = 3,
    kToStopIdFieldNumber = 4,
    kStartValueFieldNumber = 5,
    kEndValueFieldNumber = 6,
    kCostFieldNumber = 7,
  };
  // required string ruleId = 1;
  bool has_ruleid() const;
  void clear_ruleid() ;
  const std::string& ruleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ruleid(Arg_&& arg, Args_... args);
  std::string* mutable_ruleid();
  PROTOBUF_NODISCARD std::string* release_ruleid();
  void set_allocated_ruleid(std::string* ptr);

  private:
  const std::string& _internal_ruleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruleid(
      const std::string& value);
  std::string* _internal_mutable_ruleid();

  public:
  // required string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required int32 fromStopId = 3;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 4;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // required float startValue = 5;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 6;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 7;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.TransitRuleAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 61, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ruleid_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Route final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Route) */ {
 public:
  inline SolutionResponse_Route() : SolutionResponse_Route(nullptr) {}
  ~SolutionResponse_Route() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Route(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Route(const SolutionResponse_Route& from);
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Route* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Route* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Route& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Route& from) {
    SolutionResponse_Route::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.Route";
  }
  protected:
  explicit SolutionResponse_Route(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 2,
    kInterStopsFieldNumber = 3,
    kFixedCostFieldNumber = 4,
    kTransitRuleAttributesFieldNumber = 5,
    kVehicleIdFieldNumber = 1,
    kDayFieldNumber = 6,
  };
  // repeated .NDD.SolutionResponse.Stop stops = 2;
  int stops_size() const;
  private:
  int _internal_stops_size() const;

  public:
  void clear_stops() ;
  ::NDD::SolutionResponse_Stop* mutable_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >*
      mutable_stops();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Stop>& _internal_stops() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Stop>* _internal_mutable_stops();
  public:
  const ::NDD::SolutionResponse_Stop& stops(int index) const;
  ::NDD::SolutionResponse_Stop* add_stops();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >&
      stops() const;
  // repeated .NDD.SolutionResponse.InterStop interStops = 3;
  int interstops_size() const;
  private:
  int _internal_interstops_size() const;

  public:
  void clear_interstops() ;
  ::NDD::SolutionResponse_InterStop* mutable_interstops(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >*
      mutable_interstops();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStop>& _internal_interstops() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStop>* _internal_mutable_interstops();
  public:
  const ::NDD::SolutionResponse_InterStop& interstops(int index) const;
  ::NDD::SolutionResponse_InterStop* add_interstops();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >&
      interstops() const;
  // repeated float fixedCost = 4;
  int fixedcost_size() const;
  private:
  int _internal_fixedcost_size() const;

  public:
  void clear_fixedcost() ;
  float fixedcost(int index) const;
  void set_fixedcost(int index, float value);
  void add_fixedcost(float value);
  const ::google::protobuf::RepeatedField<float>& fixedcost() const;
  ::google::protobuf::RepeatedField<float>* mutable_fixedcost();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_fixedcost() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_fixedcost();

  public:
  // repeated .NDD.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
  int transitruleattributes_size() const;
  private:
  int _internal_transitruleattributes_size() const;

  public:
  void clear_transitruleattributes() ;
  ::NDD::SolutionResponse_TransitRuleAttribute* mutable_transitruleattributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >*
      mutable_transitruleattributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_TransitRuleAttribute>& _internal_transitruleattributes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_TransitRuleAttribute>* _internal_mutable_transitruleattributes();
  public:
  const ::NDD::SolutionResponse_TransitRuleAttribute& transitruleattributes(int index) const;
  ::NDD::SolutionResponse_TransitRuleAttribute* add_transitruleattributes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >&
      transitruleattributes() const;
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // required int32 day = 6;
  bool has_day() const;
  void clear_day() ;
  ::int32_t day() const;
  void set_day(::int32_t value);

  private:
  ::int32_t _internal_day() const;
  void _internal_set_day(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Route)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 3, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop > stops_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop > interstops_;
    ::google::protobuf::RepeatedField<float> fixedcost_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute > transitruleattributes_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    ::int32_t day_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility_Info final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Infeasibility.Info) */ {
 public:
  inline SolutionResponse_Infeasibility_Info() : SolutionResponse_Infeasibility_Info(nullptr) {}
  ~SolutionResponse_Infeasibility_Info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility_Info(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility_Info(const SolutionResponse_Infeasibility_Info& from);
  SolutionResponse_Infeasibility_Info(SolutionResponse_Infeasibility_Info&& from) noexcept
    : SolutionResponse_Infeasibility_Info() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility_Info& operator=(const SolutionResponse_Infeasibility_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility_Info& operator=(SolutionResponse_Infeasibility_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility_Info* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility_Info*>(
               &_SolutionResponse_Infeasibility_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SolutionResponse_Infeasibility_Info& a, SolutionResponse_Infeasibility_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility_Info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility_Info& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility_Info& from) {
    SolutionResponse_Infeasibility_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility_Info* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.Infeasibility.Info";
  }
  protected:
  explicit SolutionResponse_Infeasibility_Info(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstrainingTaskIdsFieldNumber = 6,
    kMessageFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kLimitFieldNumber = 3,
    kValueFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // repeated string constrainingTaskIds = 6;
  int constrainingtaskids_size() const;
  private:
  int _internal_constrainingtaskids_size() const;

  public:
  void clear_constrainingtaskids() ;
  const std::string& constrainingtaskids(int index) const;
  std::string* mutable_constrainingtaskids(int index);
  void set_constrainingtaskids(int index, const std::string& value);
  void set_constrainingtaskids(int index, std::string&& value);
  void set_constrainingtaskids(int index, const char* value);
  void set_constrainingtaskids(int index, const char* value, std::size_t size);
  void set_constrainingtaskids(int index, absl::string_view value);
  std::string* add_constrainingtaskids();
  void add_constrainingtaskids(const std::string& value);
  void add_constrainingtaskids(std::string&& value);
  void add_constrainingtaskids(const char* value);
  void add_constrainingtaskids(const char* value, std::size_t size);
  void add_constrainingtaskids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_constrainingtaskids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_constrainingtaskids();

  public:
  // required string message = 1;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // optional float limit = 3;
  bool has_limit() const;
  void clear_limit() ;
  float limit() const;
  void set_limit(float value);

  private:
  float _internal_limit() const;
  void _internal_set_limit(float value);

  public:
  // optional float value = 4;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // optional int64 count = 5;
  bool has_count() const;
  void clear_count() ;
  ::int64_t count() const;
  void set_count(::int64_t value);

  private:
  ::int64_t _internal_count() const;
  void _internal_set_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Infeasibility.Info)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 79, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> constrainingtaskids_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float limit_;
    float value_;
    ::int64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.Infeasibility) */ {
 public:
  inline SolutionResponse_Infeasibility() : SolutionResponse_Infeasibility(nullptr) {}
  ~SolutionResponse_Infeasibility() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility(const SolutionResponse_Infeasibility& from);
  SolutionResponse_Infeasibility(SolutionResponse_Infeasibility&& from) noexcept
    : SolutionResponse_Infeasibility() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility& operator=(const SolutionResponse_Infeasibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility& operator=(SolutionResponse_Infeasibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility*>(
               &_SolutionResponse_Infeasibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SolutionResponse_Infeasibility& a, SolutionResponse_Infeasibility& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility& from) {
    SolutionResponse_Infeasibility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.Infeasibility";
  }
  protected:
  explicit SolutionResponse_Infeasibility(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Infeasibility_Info Info;

  // accessors -------------------------------------------------------

  enum : int {
    kInfeasibilityInfoFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // repeated .NDD.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
  int infeasibilityinfo_size() const;
  private:
  int _internal_infeasibilityinfo_size() const;

  public:
  void clear_infeasibilityinfo() ;
  ::NDD::SolutionResponse_Infeasibility_Info* mutable_infeasibilityinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >*
      mutable_infeasibilityinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility_Info>& _internal_infeasibilityinfo() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility_Info>* _internal_mutable_infeasibilityinfo();
  public:
  const ::NDD::SolutionResponse_Infeasibility_Info& infeasibilityinfo(int index) const;
  ::NDD::SolutionResponse_Infeasibility_Info* add_infeasibilityinfo();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >&
      infeasibilityinfo() const;
  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.Infeasibility)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info > infeasibilityinfo_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_CompactSolution final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.CompactSolution) */ {
 public:
  inline SolutionResponse_CompactSolution() : SolutionResponse_CompactSolution(nullptr) {}
  ~SolutionResponse_CompactSolution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_CompactSolution(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_CompactSolution(const SolutionResponse_CompactSolution& from);
  SolutionResponse_CompactSolution(SolutionResponse_CompactSolution&& from) noexcept
    : SolutionResponse_CompactSolution() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_CompactSolution& operator=(const SolutionResponse_CompactSolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_CompactSolution& operator=(SolutionResponse_CompactSolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_CompactSolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_CompactSolution* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_CompactSolution*>(
               &_SolutionResponse_CompactSolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SolutionResponse_CompactSolution& a, SolutionResponse_CompactSolution& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_CompactSolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_CompactSolution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_CompactSolution* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_CompactSolution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_CompactSolution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_CompactSolution& from) {
    SolutionResponse_CompactSolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_CompactSolution* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.CompactSolution";
  }
  protected:
  explicit SolutionResponse_CompactSolution(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskSequenceFieldNumber = 1,
    kObjectivesFieldNumber = 2,
    kObjectiveNamesFieldNumber = 3,
  };
  // repeated .NDD.TaskSequence taskSequence = 1;
  int tasksequence_size() const;
  private:
  int _internal_tasksequence_size() const;

  public:
  void clear_tasksequence() ;
  ::NDD::TaskSequence* mutable_tasksequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
      mutable_tasksequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>& _internal_tasksequence() const;
  ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>* _internal_mutable_tasksequence();
  public:
  const ::NDD::TaskSequence& tasksequence(int index) const;
  ::NDD::TaskSequence* add_tasksequence();
  const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
      tasksequence() const;
  // repeated float objectives = 2;
  int objectives_size() const;
  private:
  int _internal_objectives_size() const;

  public:
  void clear_objectives() ;
  float objectives(int index) const;
  void set_objectives(int index, float value);
  void add_objectives(float value);
  const ::google::protobuf::RepeatedField<float>& objectives() const;
  ::google::protobuf::RepeatedField<float>* mutable_objectives();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_objectives() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_objectives();

  public:
  // repeated string objectiveNames = 3;
  int objectivenames_size() const;
  private:
  int _internal_objectivenames_size() const;

  public:
  void clear_objectivenames() ;
  const std::string& objectivenames(int index) const;
  std::string* mutable_objectivenames(int index);
  void set_objectivenames(int index, const std::string& value);
  void set_objectivenames(int index, std::string&& value);
  void set_objectivenames(int index, const char* value);
  void set_objectivenames(int index, const char* value, std::size_t size);
  void set_objectivenames(int index, absl::string_view value);
  std::string* add_objectivenames();
  void add_objectivenames(const std::string& value);
  void add_objectivenames(std::string&& value);
  void add_objectivenames(const char* value);
  void add_objectivenames(const char* value, std::size_t size);
  void add_objectivenames(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& objectivenames() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_objectivenames();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_objectivenames() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_objectivenames();

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.CompactSolution)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence > tasksequence_;
    ::google::protobuf::RepeatedField<float> objectives_;
    ::google::protobuf::RepeatedPtrField<std::string> objectivenames_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_SolutionInstance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse.SolutionInstance) */ {
 public:
  inline SolutionResponse_SolutionInstance() : SolutionResponse_SolutionInstance(nullptr) {}
  ~SolutionResponse_SolutionInstance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_SolutionInstance(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_SolutionInstance(const SolutionResponse_SolutionInstance& from);
  SolutionResponse_SolutionInstance(SolutionResponse_SolutionInstance&& from) noexcept
    : SolutionResponse_SolutionInstance() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_SolutionInstance& operator=(const SolutionResponse_SolutionInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_SolutionInstance& operator=(SolutionResponse_SolutionInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_SolutionInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_SolutionInstance* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_SolutionInstance*>(
               &_SolutionResponse_SolutionInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SolutionResponse_SolutionInstance& a, SolutionResponse_SolutionInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_SolutionInstance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_SolutionInstance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_SolutionInstance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_SolutionInstance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_SolutionInstance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_SolutionInstance& from) {
    SolutionResponse_SolutionInstance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_SolutionInstance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse.SolutionInstance";
  }
  protected:
  explicit SolutionResponse_SolutionInstance(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
    kInfeasibilitiesFieldNumber = 2,
  };
  // repeated .NDD.SolutionResponse.Route routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::NDD::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Route>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Route>* _internal_mutable_routes();
  public:
  const ::NDD::SolutionResponse_Route& routes(int index) const;
  ::NDD::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >&
      routes() const;
  // repeated .NDD.SolutionResponse.Infeasibility infeasibilities = 2;
  int infeasibilities_size() const;
  private:
  int _internal_infeasibilities_size() const;

  public:
  void clear_infeasibilities() ;
  ::NDD::SolutionResponse_Infeasibility* mutable_infeasibilities(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >*
      mutable_infeasibilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility>& _internal_infeasibilities() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility>* _internal_mutable_infeasibilities();
  public:
  const ::NDD::SolutionResponse_Infeasibility& infeasibilities(int index) const;
  ::NDD::SolutionResponse_Infeasibility* add_infeasibilities();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >&
      infeasibilities() const;
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse.SolutionInstance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route > routes_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility > infeasibilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NDD.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NDD.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_StopAttribute StopAttribute;
  typedef SolutionResponse_InterStopAttribute InterStopAttribute;
  typedef SolutionResponse_Stop Stop;
  typedef SolutionResponse_InterStop InterStop;
  typedef SolutionResponse_TransitRuleAttribute TransitRuleAttribute;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_Infeasibility Infeasibility;
  typedef SolutionResponse_CompactSolution CompactSolution;
  typedef SolutionResponse_SolutionInstance SolutionInstance;

  // accessors -------------------------------------------------------

  enum : int {
    kFrontierFieldNumber = 1,
    kInstanceFieldNumber = 2,
  };
  // repeated .NDD.SolutionResponse.CompactSolution frontier = 1;
  int frontier_size() const;
  private:
  int _internal_frontier_size() const;

  public:
  void clear_frontier() ;
  ::NDD::SolutionResponse_CompactSolution* mutable_frontier(int index);
  ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >*
      mutable_frontier();
  private:
  const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_CompactSolution>& _internal_frontier() const;
  ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_CompactSolution>* _internal_mutable_frontier();
  public:
  const ::NDD::SolutionResponse_CompactSolution& frontier(int index) const;
  ::NDD::SolutionResponse_CompactSolution* add_frontier();
  const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >&
      frontier() const;
  // optional .NDD.SolutionResponse.SolutionInstance instance = 2;
  bool has_instance() const;
  void clear_instance() ;
  const ::NDD::SolutionResponse_SolutionInstance& instance() const;
  PROTOBUF_NODISCARD ::NDD::SolutionResponse_SolutionInstance* release_instance();
  ::NDD::SolutionResponse_SolutionInstance* mutable_instance();
  void set_allocated_instance(::NDD::SolutionResponse_SolutionInstance* value);
  void unsafe_arena_set_allocated_instance(::NDD::SolutionResponse_SolutionInstance* value);
  ::NDD::SolutionResponse_SolutionInstance* unsafe_arena_release_instance();

  private:
  const ::NDD::SolutionResponse_SolutionInstance& _internal_instance() const;
  ::NDD::SolutionResponse_SolutionInstance* _internal_mutable_instance();

  public:
  // @@protoc_insertion_point(class_scope:NDD.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution > frontier_;
    ::NDD::SolutionResponse_SolutionInstance* instance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ndd_2dcmibu6krtqja_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InternalDimension

// required string id = 1;
inline bool InternalDimension::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InternalDimension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InternalDimension::id() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InternalDimension::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.id)
}
inline std::string* InternalDimension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.InternalDimension.id)
  return _s;
}
inline const std::string& InternalDimension::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void InternalDimension::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalDimension::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* InternalDimension::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.InternalDimension.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InternalDimension::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.InternalDimension.id)
}

// required .NDD.InternalDimension.eMeasurementUnit measurementUnit = 2;
inline bool InternalDimension::has_measurementunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InternalDimension::clear_measurementunit() {
  _impl_.measurementunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::NDD::InternalDimension_eMeasurementUnit InternalDimension::measurementunit() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.measurementUnit)
  return _internal_measurementunit();
}
inline void InternalDimension::set_measurementunit(::NDD::InternalDimension_eMeasurementUnit value) {
  _internal_set_measurementunit(value);
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.measurementUnit)
}
inline ::NDD::InternalDimension_eMeasurementUnit InternalDimension::_internal_measurementunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NDD::InternalDimension_eMeasurementUnit>(_impl_.measurementunit_);
}
inline void InternalDimension::_internal_set_measurementunit(::NDD::InternalDimension_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NDD::InternalDimension_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.measurementunit_ = value;
}

// optional float slackMax = 3 [default = 0];
inline bool InternalDimension::has_slackmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InternalDimension::clear_slackmax() {
  _impl_.slackmax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float InternalDimension::slackmax() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.slackMax)
  return _internal_slackmax();
}
inline void InternalDimension::set_slackmax(float value) {
  _internal_set_slackmax(value);
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.slackMax)
}
inline float InternalDimension::_internal_slackmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackmax_;
}
inline void InternalDimension::_internal_set_slackmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.slackmax_ = value;
}

// optional float tardyMax = 4 [default = 0];
inline bool InternalDimension::has_tardymax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InternalDimension::clear_tardymax() {
  _impl_.tardymax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float InternalDimension::tardymax() const {
  // @@protoc_insertion_point(field_get:NDD.InternalDimension.tardyMax)
  return _internal_tardymax();
}
inline void InternalDimension::set_tardymax(float value) {
  _internal_set_tardymax(value);
  // @@protoc_insertion_point(field_set:NDD.InternalDimension.tardyMax)
}
inline float InternalDimension::_internal_tardymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardymax_;
}
inline void InternalDimension::_internal_set_tardymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tardymax_ = value;
}

// -------------------------------------------------------------------

// CapacityDimension

// required string id = 1;
inline bool CapacityDimension::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CapacityDimension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CapacityDimension::id() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacityDimension::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.id)
}
inline std::string* CapacityDimension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.CapacityDimension.id)
  return _s;
}
inline const std::string& CapacityDimension::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CapacityDimension::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CapacityDimension::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* CapacityDimension::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.CapacityDimension.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CapacityDimension::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.CapacityDimension.id)
}

// required string units = 2;
inline bool CapacityDimension::has_units() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CapacityDimension::clear_units() {
  _impl_.units_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CapacityDimension::units() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.units)
  return _internal_units();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacityDimension::set_units(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.units_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.units)
}
inline std::string* CapacityDimension::mutable_units() {
  std::string* _s = _internal_mutable_units();
  // @@protoc_insertion_point(field_mutable:NDD.CapacityDimension.units)
  return _s;
}
inline const std::string& CapacityDimension::_internal_units() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.units_.Get();
}
inline void CapacityDimension::_internal_set_units(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.units_.Set(value, GetArenaForAllocation());
}
inline std::string* CapacityDimension::_internal_mutable_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.units_.Mutable( GetArenaForAllocation());
}
inline std::string* CapacityDimension::release_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.CapacityDimension.units)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.units_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.units_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CapacityDimension::set_allocated_units(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.units_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.units_.IsDefault()) {
          _impl_.units_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.CapacityDimension.units)
}

// optional float slackMax = 3 [default = 0];
inline bool CapacityDimension::has_slackmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CapacityDimension::clear_slackmax() {
  _impl_.slackmax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CapacityDimension::slackmax() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.slackMax)
  return _internal_slackmax();
}
inline void CapacityDimension::set_slackmax(float value) {
  _internal_set_slackmax(value);
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.slackMax)
}
inline float CapacityDimension::_internal_slackmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackmax_;
}
inline void CapacityDimension::_internal_set_slackmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.slackmax_ = value;
}

// optional float tardyMax = 4 [default = 0];
inline bool CapacityDimension::has_tardymax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CapacityDimension::clear_tardymax() {
  _impl_.tardymax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CapacityDimension::tardymax() const {
  // @@protoc_insertion_point(field_get:NDD.CapacityDimension.tardyMax)
  return _internal_tardymax();
}
inline void CapacityDimension::set_tardymax(float value) {
  _internal_set_tardymax(value);
  // @@protoc_insertion_point(field_set:NDD.CapacityDimension.tardyMax)
}
inline float CapacityDimension::_internal_tardymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardymax_;
}
inline void CapacityDimension::_internal_set_tardymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tardymax_ = value;
}

// -------------------------------------------------------------------

// DimensionConfiguration

// optional .NDD.InternalDimension timeConfig = 1;
inline bool DimensionConfiguration::has_timeconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timeconfig_ != nullptr);
  return value;
}
inline void DimensionConfiguration::clear_timeconfig() {
  if (_impl_.timeconfig_ != nullptr) _impl_.timeconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NDD::InternalDimension& DimensionConfiguration::_internal_timeconfig() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::InternalDimension* p = _impl_.timeconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::InternalDimension&>(::NDD::_InternalDimension_default_instance_);
}
inline const ::NDD::InternalDimension& DimensionConfiguration::timeconfig() const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.timeConfig)
  return _internal_timeconfig();
}
inline void DimensionConfiguration::unsafe_arena_set_allocated_timeconfig(::NDD::InternalDimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeconfig_);
  }
  _impl_.timeconfig_ = reinterpret_cast<::NDD::InternalDimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.DimensionConfiguration.timeConfig)
}
inline ::NDD::InternalDimension* DimensionConfiguration::release_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::InternalDimension* released = _impl_.timeconfig_;
  _impl_.timeconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::InternalDimension* DimensionConfiguration::unsafe_arena_release_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.DimensionConfiguration.timeConfig)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::InternalDimension* temp = _impl_.timeconfig_;
  _impl_.timeconfig_ = nullptr;
  return temp;
}
inline ::NDD::InternalDimension* DimensionConfiguration::_internal_mutable_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timeconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::InternalDimension>(GetArenaForAllocation());
    _impl_.timeconfig_ = reinterpret_cast<::NDD::InternalDimension*>(p);
  }
  return _impl_.timeconfig_;
}
inline ::NDD::InternalDimension* DimensionConfiguration::mutable_timeconfig() {
  ::NDD::InternalDimension* _msg = _internal_mutable_timeconfig();
  // @@protoc_insertion_point(field_mutable:NDD.DimensionConfiguration.timeConfig)
  return _msg;
}
inline void DimensionConfiguration::set_allocated_timeconfig(::NDD::InternalDimension* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::InternalDimension*>(_impl_.timeconfig_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::InternalDimension*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timeconfig_ = reinterpret_cast<::NDD::InternalDimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.DimensionConfiguration.timeConfig)
}

// optional .NDD.InternalDimension distanceConfig = 2;
inline bool DimensionConfiguration::has_distanceconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distanceconfig_ != nullptr);
  return value;
}
inline void DimensionConfiguration::clear_distanceconfig() {
  if (_impl_.distanceconfig_ != nullptr) _impl_.distanceconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NDD::InternalDimension& DimensionConfiguration::_internal_distanceconfig() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::InternalDimension* p = _impl_.distanceconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::InternalDimension&>(::NDD::_InternalDimension_default_instance_);
}
inline const ::NDD::InternalDimension& DimensionConfiguration::distanceconfig() const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.distanceConfig)
  return _internal_distanceconfig();
}
inline void DimensionConfiguration::unsafe_arena_set_allocated_distanceconfig(::NDD::InternalDimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distanceconfig_);
  }
  _impl_.distanceconfig_ = reinterpret_cast<::NDD::InternalDimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.DimensionConfiguration.distanceConfig)
}
inline ::NDD::InternalDimension* DimensionConfiguration::release_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::InternalDimension* released = _impl_.distanceconfig_;
  _impl_.distanceconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::InternalDimension* DimensionConfiguration::unsafe_arena_release_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.DimensionConfiguration.distanceConfig)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::InternalDimension* temp = _impl_.distanceconfig_;
  _impl_.distanceconfig_ = nullptr;
  return temp;
}
inline ::NDD::InternalDimension* DimensionConfiguration::_internal_mutable_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.distanceconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::InternalDimension>(GetArenaForAllocation());
    _impl_.distanceconfig_ = reinterpret_cast<::NDD::InternalDimension*>(p);
  }
  return _impl_.distanceconfig_;
}
inline ::NDD::InternalDimension* DimensionConfiguration::mutable_distanceconfig() {
  ::NDD::InternalDimension* _msg = _internal_mutable_distanceconfig();
  // @@protoc_insertion_point(field_mutable:NDD.DimensionConfiguration.distanceConfig)
  return _msg;
}
inline void DimensionConfiguration::set_allocated_distanceconfig(::NDD::InternalDimension* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::InternalDimension*>(_impl_.distanceconfig_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::InternalDimension*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.distanceconfig_ = reinterpret_cast<::NDD::InternalDimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.DimensionConfiguration.distanceConfig)
}

// repeated .NDD.CapacityDimension capacityDimensions = 3;
inline int DimensionConfiguration::_internal_capacitydimensions_size() const {
  return _internal_capacitydimensions().size();
}
inline int DimensionConfiguration::capacitydimensions_size() const {
  return _internal_capacitydimensions_size();
}
inline void DimensionConfiguration::clear_capacitydimensions() {
  _internal_mutable_capacitydimensions()->Clear();
}
inline ::NDD::CapacityDimension* DimensionConfiguration::mutable_capacitydimensions(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.DimensionConfiguration.capacityDimensions)
  return _internal_mutable_capacitydimensions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >*
DimensionConfiguration::mutable_capacitydimensions() {
  // @@protoc_insertion_point(field_mutable_list:NDD.DimensionConfiguration.capacityDimensions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capacitydimensions();
}
inline const ::NDD::CapacityDimension& DimensionConfiguration::capacitydimensions(int index) const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.capacityDimensions)
    return _internal_capacitydimensions().Get(index);
}
inline ::NDD::CapacityDimension* DimensionConfiguration::add_capacitydimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::CapacityDimension* _add = _internal_mutable_capacitydimensions()->Add();
  // @@protoc_insertion_point(field_add:NDD.DimensionConfiguration.capacityDimensions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::CapacityDimension >&
DimensionConfiguration::capacitydimensions() const {
  // @@protoc_insertion_point(field_list:NDD.DimensionConfiguration.capacityDimensions)
  return _internal_capacitydimensions();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::CapacityDimension>&
DimensionConfiguration::_internal_capacitydimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacitydimensions_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::CapacityDimension>*
DimensionConfiguration::_internal_mutable_capacitydimensions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capacitydimensions_;
}

// required int32 weekLength = 4;
inline bool DimensionConfiguration::has_weeklength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DimensionConfiguration::clear_weeklength() {
  _impl_.weeklength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t DimensionConfiguration::weeklength() const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.weekLength)
  return _internal_weeklength();
}
inline void DimensionConfiguration::set_weeklength(::int32_t value) {
  _internal_set_weeklength(value);
  // @@protoc_insertion_point(field_set:NDD.DimensionConfiguration.weekLength)
}
inline ::int32_t DimensionConfiguration::_internal_weeklength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weeklength_;
}
inline void DimensionConfiguration::_internal_set_weeklength(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.weeklength_ = value;
}

// required int32 periodLength = 5;
inline bool DimensionConfiguration::has_periodlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DimensionConfiguration::clear_periodlength() {
  _impl_.periodlength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t DimensionConfiguration::periodlength() const {
  // @@protoc_insertion_point(field_get:NDD.DimensionConfiguration.periodLength)
  return _internal_periodlength();
}
inline void DimensionConfiguration::set_periodlength(::int32_t value) {
  _internal_set_periodlength(value);
  // @@protoc_insertion_point(field_set:NDD.DimensionConfiguration.periodLength)
}
inline ::int32_t DimensionConfiguration::_internal_periodlength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.periodlength_;
}
inline void DimensionConfiguration::_internal_set_periodlength(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.periodlength_ = value;
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:NDD.Geocode.longitude)
  return _internal_longitude();
}
inline void Geocode::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:NDD.Geocode.longitude)
}
inline float Geocode::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Geocode::_internal_set_longitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_ = value;
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:NDD.Geocode.latitude)
  return _internal_latitude();
}
inline void Geocode::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:NDD.Geocode.latitude)
}
inline float Geocode::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Geocode::_internal_set_latitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// Window

// required float start = 1;
inline bool Window::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Window::clear_start() {
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Window::start() const {
  // @@protoc_insertion_point(field_get:NDD.Window.start)
  return _internal_start();
}
inline void Window::set_start(float value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:NDD.Window.start)
}
inline float Window::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void Window::_internal_set_start(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}

// required float end = 2;
inline bool Window::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Window::clear_end() {
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Window::end() const {
  // @@protoc_insertion_point(field_get:NDD.Window.end)
  return _internal_end();
}
inline void Window::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:NDD.Window.end)
}
inline float Window::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_;
}
inline void Window::_internal_set_end(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}

// optional float slackCostCoef = 3 [default = 0];
inline bool Window::has_slackcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Window::clear_slackcostcoef() {
  _impl_.slackcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Window::slackcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.Window.slackCostCoef)
  return _internal_slackcostcoef();
}
inline void Window::set_slackcostcoef(float value) {
  _internal_set_slackcostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.Window.slackCostCoef)
}
inline float Window::_internal_slackcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcostcoef_;
}
inline void Window::_internal_set_slackcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.slackcostcoef_ = value;
}

// optional float tardyCostCoef = 4 [default = 0];
inline bool Window::has_tardycostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Window::clear_tardycostcoef() {
  _impl_.tardycostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Window::tardycostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.Window.tardyCostCoef)
  return _internal_tardycostcoef();
}
inline void Window::set_tardycostcoef(float value) {
  _internal_set_tardycostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.Window.tardyCostCoef)
}
inline float Window::_internal_tardycostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycostcoef_;
}
inline void Window::_internal_set_tardycostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tardycostcoef_ = value;
}

// optional float slackMax = 5 [default = -1];
inline bool Window::has_slackmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Window::clear_slackmax() {
  _impl_.slackmax_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Window::slackmax() const {
  // @@protoc_insertion_point(field_get:NDD.Window.slackMax)
  return _internal_slackmax();
}
inline void Window::set_slackmax(float value) {
  _internal_set_slackmax(value);
  // @@protoc_insertion_point(field_set:NDD.Window.slackMax)
}
inline float Window::_internal_slackmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackmax_;
}
inline void Window::_internal_set_slackmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackmax_ = value;
}

// optional float tardyMax = 6 [default = -1];
inline bool Window::has_tardymax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Window::clear_tardymax() {
  _impl_.tardymax_ = -1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Window::tardymax() const {
  // @@protoc_insertion_point(field_get:NDD.Window.tardyMax)
  return _internal_tardymax();
}
inline void Window::set_tardymax(float value) {
  _internal_set_tardymax(value);
  // @@protoc_insertion_point(field_set:NDD.Window.tardyMax)
}
inline float Window::_internal_tardymax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardymax_;
}
inline void Window::_internal_set_tardymax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tardymax_ = value;
}

// -------------------------------------------------------------------

// Location_Attribute

// required string dimensionId = 1;
inline bool Location_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Location_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Location.Attribute.dimensionId)
}
inline std::string* Location_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.dimensionId)
  return _s;
}
inline const std::string& Location_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Location_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Location_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Location_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Location.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.Attribute.dimensionId)
}

// optional string vehicleId = 2;
inline bool Location_Attribute::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Location_Attribute::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Location_Attribute::vehicleid() const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location_Attribute::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Location.Attribute.vehicleId)
}
inline std::string* Location_Attribute::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.vehicleId)
  return _s;
}
inline const std::string& Location_Attribute::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void Location_Attribute::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* Location_Attribute::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* Location_Attribute::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Location.Attribute.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location_Attribute::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.Attribute.vehicleId)
}

// optional float quantity = 3;
inline bool Location_Attribute::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Location_Attribute::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Location_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.quantity)
  return _internal_quantity();
}
inline void Location_Attribute::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:NDD.Location.Attribute.quantity)
}
inline float Location_Attribute::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Location_Attribute::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.quantity_ = value;
}

// repeated .NDD.Window arrivalWindows = 4;
inline int Location_Attribute::_internal_arrivalwindows_size() const {
  return _internal_arrivalwindows().size();
}
inline int Location_Attribute::arrivalwindows_size() const {
  return _internal_arrivalwindows_size();
}
inline void Location_Attribute::clear_arrivalwindows() {
  _internal_mutable_arrivalwindows()->Clear();
}
inline ::NDD::Window* Location_Attribute::mutable_arrivalwindows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.arrivalWindows)
  return _internal_mutable_arrivalwindows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Location_Attribute::mutable_arrivalwindows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Location.Attribute.arrivalWindows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arrivalwindows();
}
inline const ::NDD::Window& Location_Attribute::arrivalwindows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.arrivalWindows)
    return _internal_arrivalwindows().Get(index);
}
inline ::NDD::Window* Location_Attribute::add_arrivalwindows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Window* _add = _internal_mutable_arrivalwindows()->Add();
  // @@protoc_insertion_point(field_add:NDD.Location.Attribute.arrivalWindows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Location_Attribute::arrivalwindows() const {
  // @@protoc_insertion_point(field_list:NDD.Location.Attribute.arrivalWindows)
  return _internal_arrivalwindows();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Window>&
Location_Attribute::_internal_arrivalwindows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrivalwindows_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Window>*
Location_Attribute::_internal_mutable_arrivalwindows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arrivalwindows_;
}

// repeated .NDD.Window departureWindows = 5;
inline int Location_Attribute::_internal_departurewindows_size() const {
  return _internal_departurewindows().size();
}
inline int Location_Attribute::departurewindows_size() const {
  return _internal_departurewindows_size();
}
inline void Location_Attribute::clear_departurewindows() {
  _internal_mutable_departurewindows()->Clear();
}
inline ::NDD::Window* Location_Attribute::mutable_departurewindows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Location.Attribute.departureWindows)
  return _internal_mutable_departurewindows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Location_Attribute::mutable_departurewindows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Location.Attribute.departureWindows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_departurewindows();
}
inline const ::NDD::Window& Location_Attribute::departurewindows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Location.Attribute.departureWindows)
    return _internal_departurewindows().Get(index);
}
inline ::NDD::Window* Location_Attribute::add_departurewindows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Window* _add = _internal_mutable_departurewindows()->Add();
  // @@protoc_insertion_point(field_add:NDD.Location.Attribute.departureWindows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Location_Attribute::departurewindows() const {
  // @@protoc_insertion_point(field_list:NDD.Location.Attribute.departureWindows)
  return _internal_departurewindows();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Window>&
Location_Attribute::_internal_departurewindows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.departurewindows_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Window>*
Location_Attribute::_internal_mutable_departurewindows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.departurewindows_;
}

// -------------------------------------------------------------------

// Location

// required string id = 1;
inline bool Location::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Location::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:NDD.Location.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Location.id)
}
inline std::string* Location::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.Location.id)
  return _s;
}
inline const std::string& Location::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Location::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Location::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Location.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Location::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.id)
}

// optional .NDD.Geocode geocode = 2;
inline bool Location::has_geocode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geocode_ != nullptr);
  return value;
}
inline void Location::clear_geocode() {
  if (_impl_.geocode_ != nullptr) _impl_.geocode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NDD::Geocode& Location::_internal_geocode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Geocode* p = _impl_.geocode_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Geocode&>(::NDD::_Geocode_default_instance_);
}
inline const ::NDD::Geocode& Location::geocode() const {
  // @@protoc_insertion_point(field_get:NDD.Location.geocode)
  return _internal_geocode();
}
inline void Location::unsafe_arena_set_allocated_geocode(::NDD::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geocode_);
  }
  _impl_.geocode_ = reinterpret_cast<::NDD::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Location.geocode)
}
inline ::NDD::Geocode* Location::release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Geocode* released = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Geocode* Location::unsafe_arena_release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Location.geocode)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Geocode* temp = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
  return temp;
}
inline ::NDD::Geocode* Location::_internal_mutable_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.geocode_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Geocode>(GetArenaForAllocation());
    _impl_.geocode_ = reinterpret_cast<::NDD::Geocode*>(p);
  }
  return _impl_.geocode_;
}
inline ::NDD::Geocode* Location::mutable_geocode() {
  ::NDD::Geocode* _msg = _internal_mutable_geocode();
  // @@protoc_insertion_point(field_mutable:NDD.Location.geocode)
  return _msg;
}
inline void Location::set_allocated_geocode(::NDD::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Geocode*>(_impl_.geocode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.geocode_ = reinterpret_cast<::NDD::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Location.geocode)
}

// repeated .NDD.Location.Attribute attributes = 3;
inline int Location::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int Location::attributes_size() const {
  return _internal_attributes_size();
}
inline void Location::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::Location_Attribute* Location::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Location.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >*
Location::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Location.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::Location_Attribute& Location::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Location.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::Location_Attribute* Location::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Location_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.Location.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Location_Attribute >&
Location::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.Location.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Location_Attribute>&
Location::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Location_Attribute>*
Location::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Profile_customCycle

// repeated bool visitProfile = 2;
inline int Profile_customCycle::_internal_visitprofile_size() const {
  return _internal_visitprofile().size();
}
inline int Profile_customCycle::visitprofile_size() const {
  return _internal_visitprofile_size();
}
inline void Profile_customCycle::clear_visitprofile() {
  _internal_mutable_visitprofile()->Clear();
}
inline bool Profile_customCycle::visitprofile(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Profile.customCycle.visitProfile)
  return _internal_visitprofile().Get(index);
}
inline void Profile_customCycle::set_visitprofile(int index, bool value) {
  _internal_mutable_visitprofile()->Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.Profile.customCycle.visitProfile)
}
inline void Profile_customCycle::add_visitprofile(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitprofile()->Add(value);
  // @@protoc_insertion_point(field_add:NDD.Profile.customCycle.visitProfile)
}
inline const ::google::protobuf::RepeatedField<bool>& Profile_customCycle::visitprofile() const {
  // @@protoc_insertion_point(field_list:NDD.Profile.customCycle.visitProfile)
  return _internal_visitprofile();
}
inline ::google::protobuf::RepeatedField<bool>* Profile_customCycle::mutable_visitprofile() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Profile.customCycle.visitProfile)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitprofile();
}

inline const ::google::protobuf::RepeatedField<bool>& Profile_customCycle::_internal_visitprofile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitprofile_;
}
inline ::google::protobuf::RepeatedField<bool>* Profile_customCycle::_internal_mutable_visitprofile() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitprofile_;
}

// -------------------------------------------------------------------

// Profile

// required .NDD.Profile.eFrequency frequencyType = 1;
inline bool Profile::has_frequencytype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Profile::clear_frequencytype() {
  _impl_.frequencytype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::NDD::Profile_eFrequency Profile::frequencytype() const {
  // @@protoc_insertion_point(field_get:NDD.Profile.frequencyType)
  return _internal_frequencytype();
}
inline void Profile::set_frequencytype(::NDD::Profile_eFrequency value) {
  _internal_set_frequencytype(value);
  // @@protoc_insertion_point(field_set:NDD.Profile.frequencyType)
}
inline ::NDD::Profile_eFrequency Profile::_internal_frequencytype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NDD::Profile_eFrequency>(_impl_.frequencytype_);
}
inline void Profile::_internal_set_frequencytype(::NDD::Profile_eFrequency value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NDD::Profile_eFrequency_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.frequencytype_ = value;
}

// repeated .NDD.Profile.customCycle allowableCycles = 2;
inline int Profile::_internal_allowablecycles_size() const {
  return _internal_allowablecycles().size();
}
inline int Profile::allowablecycles_size() const {
  return _internal_allowablecycles_size();
}
inline void Profile::clear_allowablecycles() {
  _internal_mutable_allowablecycles()->Clear();
}
inline ::NDD::Profile_customCycle* Profile::mutable_allowablecycles(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Profile.allowableCycles)
  return _internal_mutable_allowablecycles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >*
Profile::mutable_allowablecycles() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Profile.allowableCycles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allowablecycles();
}
inline const ::NDD::Profile_customCycle& Profile::allowablecycles(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Profile.allowableCycles)
    return _internal_allowablecycles().Get(index);
}
inline ::NDD::Profile_customCycle* Profile::add_allowablecycles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Profile_customCycle* _add = _internal_mutable_allowablecycles()->Add();
  // @@protoc_insertion_point(field_add:NDD.Profile.allowableCycles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Profile_customCycle >&
Profile::allowablecycles() const {
  // @@protoc_insertion_point(field_list:NDD.Profile.allowableCycles)
  return _internal_allowablecycles();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Profile_customCycle>&
Profile::_internal_allowablecycles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowablecycles_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Profile_customCycle>*
Profile::_internal_mutable_allowablecycles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allowablecycles_;
}

// optional int32 numVisits = 3;
inline bool Profile::has_numvisits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Profile::clear_numvisits() {
  _impl_.numvisits_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Profile::numvisits() const {
  // @@protoc_insertion_point(field_get:NDD.Profile.numVisits)
  return _internal_numvisits();
}
inline void Profile::set_numvisits(::int32_t value) {
  _internal_set_numvisits(value);
  // @@protoc_insertion_point(field_set:NDD.Profile.numVisits)
}
inline ::int32_t Profile::_internal_numvisits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numvisits_;
}
inline void Profile::_internal_set_numvisits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.numvisits_ = value;
}

// -------------------------------------------------------------------

// Job_VehicleRelation

// required .NDD.Job.VehicleRelation.Type type = 1;
inline bool Job_VehicleRelation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_VehicleRelation::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::NDD::Job_VehicleRelation_Type Job_VehicleRelation::type() const {
  // @@protoc_insertion_point(field_get:NDD.Job.VehicleRelation.type)
  return _internal_type();
}
inline void Job_VehicleRelation::set_type(::NDD::Job_VehicleRelation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:NDD.Job.VehicleRelation.type)
}
inline ::NDD::Job_VehicleRelation_Type Job_VehicleRelation::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NDD::Job_VehicleRelation_Type>(_impl_.type_);
}
inline void Job_VehicleRelation::_internal_set_type(::NDD::Job_VehicleRelation_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NDD::Job_VehicleRelation_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// repeated string vehicleIds = 2;
inline int Job_VehicleRelation::_internal_vehicleids_size() const {
  return _internal_vehicleids().size();
}
inline int Job_VehicleRelation::vehicleids_size() const {
  return _internal_vehicleids_size();
}
inline void Job_VehicleRelation::clear_vehicleids() {
  _internal_mutable_vehicleids()->Clear();
}
inline std::string* Job_VehicleRelation::add_vehicleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_vehicleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.Job.VehicleRelation.vehicleIds)
  return _s;
}
inline const std::string& Job_VehicleRelation::vehicleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.VehicleRelation.vehicleIds)
  return _internal_vehicleids().Get(index);
}
inline std::string* Job_VehicleRelation::mutable_vehicleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.VehicleRelation.vehicleIds)
  return _internal_mutable_vehicleids()->Mutable(index);
}
inline void Job_VehicleRelation::set_vehicleids(int index, const std::string& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, std::string&& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::set_vehicleids(int index, absl::string_view value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.Job.VehicleRelation.vehicleIds)
}
inline void Job_VehicleRelation::add_vehicleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.Job.VehicleRelation.vehicleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_VehicleRelation::vehicleids() const {
  // @@protoc_insertion_point(field_list:NDD.Job.VehicleRelation.vehicleIds)
  return _internal_vehicleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Job_VehicleRelation::mutable_vehicleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.VehicleRelation.vehicleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_VehicleRelation::_internal_vehicleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Job_VehicleRelation::_internal_mutable_vehicleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicleids_;
}

// -------------------------------------------------------------------

// Job_Task_Attribute

// required string dimensionId = 1;
inline bool Job_Task_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_Task_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job_Task_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job_Task_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.dimensionId)
}
inline std::string* Job_Task_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.Attribute.dimensionId)
  return _s;
}
inline const std::string& Job_Task_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Job_Task_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job_Task_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Job_Task_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.Task.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job_Task_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.Task.Attribute.dimensionId)
}

// optional float quantity = 2;
inline bool Job_Task_Attribute::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Job_Task_Attribute::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Job_Task_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.quantity)
  return _internal_quantity();
}
inline void Job_Task_Attribute::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.quantity)
}
inline float Job_Task_Attribute::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Job_Task_Attribute::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quantity_ = value;
}

// repeated .NDD.Window windows = 3;
inline int Job_Task_Attribute::_internal_windows_size() const {
  return _internal_windows().size();
}
inline int Job_Task_Attribute::windows_size() const {
  return _internal_windows_size();
}
inline void Job_Task_Attribute::clear_windows() {
  _internal_mutable_windows()->Clear();
}
inline ::NDD::Window* Job_Task_Attribute::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.Attribute.windows)
  return _internal_mutable_windows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Job_Task_Attribute::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.Attribute.windows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_windows();
}
inline const ::NDD::Window& Job_Task_Attribute::windows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.windows)
    return _internal_windows().Get(index);
}
inline ::NDD::Window* Job_Task_Attribute::add_windows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Window* _add = _internal_mutable_windows()->Add();
  // @@protoc_insertion_point(field_add:NDD.Job.Task.Attribute.windows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Job_Task_Attribute::windows() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.Attribute.windows)
  return _internal_windows();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Window>&
Job_Task_Attribute::_internal_windows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windows_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Window>*
Job_Task_Attribute::_internal_mutable_windows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.windows_;
}

// repeated string vehicleIds = 4;
inline int Job_Task_Attribute::_internal_vehicleids_size() const {
  return _internal_vehicleids().size();
}
inline int Job_Task_Attribute::vehicleids_size() const {
  return _internal_vehicleids_size();
}
inline void Job_Task_Attribute::clear_vehicleids() {
  _internal_mutable_vehicleids()->Clear();
}
inline std::string* Job_Task_Attribute::add_vehicleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_vehicleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.Job.Task.Attribute.vehicleIds)
  return _s;
}
inline const std::string& Job_Task_Attribute::vehicleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.Attribute.vehicleIds)
  return _internal_vehicleids().Get(index);
}
inline std::string* Job_Task_Attribute::mutable_vehicleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.Attribute.vehicleIds)
  return _internal_mutable_vehicleids()->Mutable(index);
}
inline void Job_Task_Attribute::set_vehicleids(int index, const std::string& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, std::string&& value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_vehicleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::set_vehicleids(int index, absl::string_view value) {
  _internal_mutable_vehicleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.Job.Task.Attribute.vehicleIds)
}
inline void Job_Task_Attribute::add_vehicleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.Job.Task.Attribute.vehicleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_Task_Attribute::vehicleids() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.Attribute.vehicleIds)
  return _internal_vehicleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Job_Task_Attribute::mutable_vehicleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.Attribute.vehicleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Job_Task_Attribute::_internal_vehicleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Job_Task_Attribute::_internal_mutable_vehicleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicleids_;
}

// -------------------------------------------------------------------

// Job_Task

// required string taskId = 1;
inline bool Job_Task::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job_Task::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job_Task::taskid() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job_Task::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Job.Task.taskId)
}
inline std::string* Job_Task::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.taskId)
  return _s;
}
inline const std::string& Job_Task::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void Job_Task::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job_Task::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* Job_Task::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.Task.taskId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job_Task::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.Task.taskId)
}

// required string locationId = 2;
inline bool Job_Task::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Job_Task::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Job_Task::locationid() const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job_Task::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Job.Task.locationId)
}
inline std::string* Job_Task::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.locationId)
  return _s;
}
inline const std::string& Job_Task::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void Job_Task::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job_Task::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* Job_Task::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.Task.locationId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job_Task::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.Task.locationId)
}

// repeated .NDD.Job.Task.Attribute attributes = 3;
inline int Job_Task::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int Job_Task::attributes_size() const {
  return _internal_attributes_size();
}
inline void Job_Task::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::Job_Task_Attribute* Job_Task::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Job.Task.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >*
Job_Task::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::Job_Task_Attribute& Job_Task::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::Job_Task_Attribute* Job_Task::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Job_Task_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.Job.Task.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Job_Task_Attribute >&
Job_Task::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Job_Task_Attribute>&
Job_Task::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Job_Task_Attribute>*
Job_Task::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .NDD.Job.Task.TripConstraint tripConstraints = 4;
inline int Job_Task::_internal_tripconstraints_size() const {
  return _internal_tripconstraints().size();
}
inline int Job_Task::tripconstraints_size() const {
  return _internal_tripconstraints_size();
}
inline void Job_Task::clear_tripconstraints() {
  _internal_mutable_tripconstraints()->Clear();
}
inline ::NDD::Job_Task_TripConstraint Job_Task::tripconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Job.Task.tripConstraints)
  return static_cast<::NDD::Job_Task_TripConstraint>(_internal_tripconstraints().Get(index));
}
inline void Job_Task::set_tripconstraints(int index, ::NDD::Job_Task_TripConstraint value) {
  assert(::NDD::Job_Task_TripConstraint_IsValid(value));
  _internal_mutable_tripconstraints()->Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.Job.Task.tripConstraints)
}
inline void Job_Task::add_tripconstraints(::NDD::Job_Task_TripConstraint value) {
  assert(::NDD::Job_Task_TripConstraint_IsValid(value));
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tripconstraints()->Add(value);
  // @@protoc_insertion_point(field_add:NDD.Job.Task.tripConstraints)
}
inline const ::google::protobuf::RepeatedField<int>& Job_Task::tripconstraints() const {
  // @@protoc_insertion_point(field_list:NDD.Job.Task.tripConstraints)
  return _internal_tripconstraints();
}
inline ::google::protobuf::RepeatedField<int>* Job_Task::mutable_tripconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Job.Task.tripConstraints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tripconstraints();
}
inline const ::google::protobuf::RepeatedField<int>& Job_Task::_internal_tripconstraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tripconstraints_;
}
inline ::google::protobuf::RepeatedField<int>* Job_Task::_internal_mutable_tripconstraints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tripconstraints_;
}

// -------------------------------------------------------------------

// Job

// required string id = 1;
inline bool Job::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Job::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job::id() const {
  // @@protoc_insertion_point(field_get:NDD.Job.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Job.id)
}
inline std::string* Job::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.Job.id)
  return _s;
}
inline const std::string& Job::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Job::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Job::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Job::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.id)
}

// optional .NDD.Job.Task pickupTask = 2;
inline bool Job::has_pickuptask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pickuptask_ != nullptr);
  return value;
}
inline void Job::clear_pickuptask() {
  if (_impl_.pickuptask_ != nullptr) _impl_.pickuptask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NDD::Job_Task& Job::_internal_pickuptask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Job_Task* p = _impl_.pickuptask_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Job_Task&>(::NDD::_Job_Task_default_instance_);
}
inline const ::NDD::Job_Task& Job::pickuptask() const {
  // @@protoc_insertion_point(field_get:NDD.Job.pickupTask)
  return _internal_pickuptask();
}
inline void Job::unsafe_arena_set_allocated_pickuptask(::NDD::Job_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pickuptask_);
  }
  _impl_.pickuptask_ = reinterpret_cast<::NDD::Job_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Job.pickupTask)
}
inline ::NDD::Job_Task* Job::release_pickuptask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Job_Task* released = _impl_.pickuptask_;
  _impl_.pickuptask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Job_Task* Job::unsafe_arena_release_pickuptask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.pickupTask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Job_Task* temp = _impl_.pickuptask_;
  _impl_.pickuptask_ = nullptr;
  return temp;
}
inline ::NDD::Job_Task* Job::_internal_mutable_pickuptask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pickuptask_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Job_Task>(GetArenaForAllocation());
    _impl_.pickuptask_ = reinterpret_cast<::NDD::Job_Task*>(p);
  }
  return _impl_.pickuptask_;
}
inline ::NDD::Job_Task* Job::mutable_pickuptask() {
  ::NDD::Job_Task* _msg = _internal_mutable_pickuptask();
  // @@protoc_insertion_point(field_mutable:NDD.Job.pickupTask)
  return _msg;
}
inline void Job::set_allocated_pickuptask(::NDD::Job_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Job_Task*>(_impl_.pickuptask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Job_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pickuptask_ = reinterpret_cast<::NDD::Job_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.pickupTask)
}

// optional .NDD.Job.Task dropoffTask = 3;
inline bool Job::has_dropofftask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dropofftask_ != nullptr);
  return value;
}
inline void Job::clear_dropofftask() {
  if (_impl_.dropofftask_ != nullptr) _impl_.dropofftask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::NDD::Job_Task& Job::_internal_dropofftask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Job_Task* p = _impl_.dropofftask_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Job_Task&>(::NDD::_Job_Task_default_instance_);
}
inline const ::NDD::Job_Task& Job::dropofftask() const {
  // @@protoc_insertion_point(field_get:NDD.Job.dropoffTask)
  return _internal_dropofftask();
}
inline void Job::unsafe_arena_set_allocated_dropofftask(::NDD::Job_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dropofftask_);
  }
  _impl_.dropofftask_ = reinterpret_cast<::NDD::Job_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Job.dropoffTask)
}
inline ::NDD::Job_Task* Job::release_dropofftask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NDD::Job_Task* released = _impl_.dropofftask_;
  _impl_.dropofftask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Job_Task* Job::unsafe_arena_release_dropofftask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.dropoffTask)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NDD::Job_Task* temp = _impl_.dropofftask_;
  _impl_.dropofftask_ = nullptr;
  return temp;
}
inline ::NDD::Job_Task* Job::_internal_mutable_dropofftask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.dropofftask_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Job_Task>(GetArenaForAllocation());
    _impl_.dropofftask_ = reinterpret_cast<::NDD::Job_Task*>(p);
  }
  return _impl_.dropofftask_;
}
inline ::NDD::Job_Task* Job::mutable_dropofftask() {
  ::NDD::Job_Task* _msg = _internal_mutable_dropofftask();
  // @@protoc_insertion_point(field_mutable:NDD.Job.dropoffTask)
  return _msg;
}
inline void Job::set_allocated_dropofftask(::NDD::Job_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Job_Task*>(_impl_.dropofftask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Job_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dropofftask_ = reinterpret_cast<::NDD::Job_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.dropoffTask)
}

// required float penalty = 4;
inline bool Job::has_penalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Job::clear_penalty() {
  _impl_.penalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Job::penalty() const {
  // @@protoc_insertion_point(field_get:NDD.Job.penalty)
  return _internal_penalty();
}
inline void Job::set_penalty(float value) {
  _internal_set_penalty(value);
  // @@protoc_insertion_point(field_set:NDD.Job.penalty)
}
inline float Job::_internal_penalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penalty_;
}
inline void Job::_internal_set_penalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.penalty_ = value;
}

// optional .NDD.Job.VehicleRelation vehicleRelations = 5;
inline bool Job::has_vehiclerelations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehiclerelations_ != nullptr);
  return value;
}
inline void Job::clear_vehiclerelations() {
  if (_impl_.vehiclerelations_ != nullptr) _impl_.vehiclerelations_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::NDD::Job_VehicleRelation& Job::_internal_vehiclerelations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Job_VehicleRelation* p = _impl_.vehiclerelations_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Job_VehicleRelation&>(::NDD::_Job_VehicleRelation_default_instance_);
}
inline const ::NDD::Job_VehicleRelation& Job::vehiclerelations() const {
  // @@protoc_insertion_point(field_get:NDD.Job.vehicleRelations)
  return _internal_vehiclerelations();
}
inline void Job::unsafe_arena_set_allocated_vehiclerelations(::NDD::Job_VehicleRelation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehiclerelations_);
  }
  _impl_.vehiclerelations_ = reinterpret_cast<::NDD::Job_VehicleRelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Job.vehicleRelations)
}
inline ::NDD::Job_VehicleRelation* Job::release_vehiclerelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NDD::Job_VehicleRelation* released = _impl_.vehiclerelations_;
  _impl_.vehiclerelations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Job_VehicleRelation* Job::unsafe_arena_release_vehiclerelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.vehicleRelations)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NDD::Job_VehicleRelation* temp = _impl_.vehiclerelations_;
  _impl_.vehiclerelations_ = nullptr;
  return temp;
}
inline ::NDD::Job_VehicleRelation* Job::_internal_mutable_vehiclerelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vehiclerelations_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Job_VehicleRelation>(GetArenaForAllocation());
    _impl_.vehiclerelations_ = reinterpret_cast<::NDD::Job_VehicleRelation*>(p);
  }
  return _impl_.vehiclerelations_;
}
inline ::NDD::Job_VehicleRelation* Job::mutable_vehiclerelations() {
  ::NDD::Job_VehicleRelation* _msg = _internal_mutable_vehiclerelations();
  // @@protoc_insertion_point(field_mutable:NDD.Job.vehicleRelations)
  return _msg;
}
inline void Job::set_allocated_vehiclerelations(::NDD::Job_VehicleRelation* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Job_VehicleRelation*>(_impl_.vehiclerelations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Job_VehicleRelation*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.vehiclerelations_ = reinterpret_cast<::NDD::Job_VehicleRelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.vehicleRelations)
}

// required .NDD.Profile profile = 6;
inline bool Job::has_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profile_ != nullptr);
  return value;
}
inline void Job::clear_profile() {
  if (_impl_.profile_ != nullptr) _impl_.profile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::NDD::Profile& Job::_internal_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Profile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Profile&>(::NDD::_Profile_default_instance_);
}
inline const ::NDD::Profile& Job::profile() const {
  // @@protoc_insertion_point(field_get:NDD.Job.profile)
  return _internal_profile();
}
inline void Job::unsafe_arena_set_allocated_profile(::NDD::Profile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = reinterpret_cast<::NDD::Profile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Job.profile)
}
inline ::NDD::Profile* Job::release_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::NDD::Profile* released = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Profile* Job::unsafe_arena_release_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Job.profile)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::NDD::Profile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::NDD::Profile* Job::_internal_mutable_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Profile>(GetArenaForAllocation());
    _impl_.profile_ = reinterpret_cast<::NDD::Profile*>(p);
  }
  return _impl_.profile_;
}
inline ::NDD::Profile* Job::mutable_profile() {
  ::NDD::Profile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:NDD.Job.profile)
  return _msg;
}
inline void Job::set_allocated_profile(::NDD::Profile* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Profile*>(_impl_.profile_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Profile*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.profile_ = reinterpret_cast<::NDD::Profile*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Job.profile)
}

// -------------------------------------------------------------------

// TransitSet_TransitValue

// required string fromId = 1;
inline bool TransitSet_TransitValue::has_fromid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitSet_TransitValue::clear_fromid() {
  _impl_.fromid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitSet_TransitValue::fromid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.TransitValue.fromId)
  return _internal_fromid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitSet_TransitValue::set_fromid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitSet.TransitValue.fromId)
}
inline std::string* TransitSet_TransitValue::mutable_fromid() {
  std::string* _s = _internal_mutable_fromid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitSet.TransitValue.fromId)
  return _s;
}
inline const std::string& TransitSet_TransitValue::_internal_fromid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromid_.Get();
}
inline void TransitSet_TransitValue::_internal_set_fromid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::_internal_mutable_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fromid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::release_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitSet.TransitValue.fromId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fromid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fromid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitSet_TransitValue::set_allocated_fromid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fromid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromid_.IsDefault()) {
          _impl_.fromid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitSet.TransitValue.fromId)
}

// required string toId = 2;
inline bool TransitSet_TransitValue::has_toid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitSet_TransitValue::clear_toid() {
  _impl_.toid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitSet_TransitValue::toid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.TransitValue.toId)
  return _internal_toid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitSet_TransitValue::set_toid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitSet.TransitValue.toId)
}
inline std::string* TransitSet_TransitValue::mutable_toid() {
  std::string* _s = _internal_mutable_toid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitSet.TransitValue.toId)
  return _s;
}
inline const std::string& TransitSet_TransitValue::_internal_toid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.toid_.Get();
}
inline void TransitSet_TransitValue::_internal_set_toid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::_internal_mutable_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.toid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitSet_TransitValue::release_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitSet.TransitValue.toId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.toid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.toid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitSet_TransitValue::set_allocated_toid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.toid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.toid_.IsDefault()) {
          _impl_.toid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitSet.TransitValue.toId)
}

// required float value = 3;
inline bool TransitSet_TransitValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TransitSet_TransitValue::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float TransitSet_TransitValue::value() const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.TransitValue.value)
  return _internal_value();
}
inline void TransitSet_TransitValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:NDD.TransitSet.TransitValue.value)
}
inline float TransitSet_TransitValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TransitSet_TransitValue::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TransitSet

// repeated .NDD.TransitSet.TransitValue transits = 1;
inline int TransitSet::_internal_transits_size() const {
  return _internal_transits().size();
}
inline int TransitSet::transits_size() const {
  return _internal_transits_size();
}
inline void TransitSet::clear_transits() {
  _internal_mutable_transits()->Clear();
}
inline ::NDD::TransitSet_TransitValue* TransitSet::mutable_transits(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.TransitSet.transits)
  return _internal_mutable_transits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >*
TransitSet::mutable_transits() {
  // @@protoc_insertion_point(field_mutable_list:NDD.TransitSet.transits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transits();
}
inline const ::NDD::TransitSet_TransitValue& TransitSet::transits(int index) const {
  // @@protoc_insertion_point(field_get:NDD.TransitSet.transits)
    return _internal_transits().Get(index);
}
inline ::NDD::TransitSet_TransitValue* TransitSet::add_transits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TransitSet_TransitValue* _add = _internal_mutable_transits()->Add();
  // @@protoc_insertion_point(field_add:NDD.TransitSet.transits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitSet_TransitValue >&
TransitSet::transits() const {
  // @@protoc_insertion_point(field_list:NDD.TransitSet.transits)
  return _internal_transits();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TransitSet_TransitValue>&
TransitSet::_internal_transits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transits_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TransitSet_TransitValue>*
TransitSet::_internal_mutable_transits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transits_;
}

// -------------------------------------------------------------------

// TransitGenerator

// required string id = 1;
inline bool TransitGenerator::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitGenerator::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitGenerator::id() const {
  // @@protoc_insertion_point(field_get:NDD.TransitGenerator.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitGenerator::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitGenerator.id)
}
inline std::string* TransitGenerator::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.TransitGenerator.id)
  return _s;
}
inline const std::string& TransitGenerator::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TransitGenerator::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitGenerator::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitGenerator::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitGenerator.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitGenerator::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitGenerator.id)
}

// optional string requestId = 2;
inline bool TransitGenerator::has_requestid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitGenerator::clear_requestid() {
  _impl_.requestid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitGenerator::requestid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitGenerator.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitGenerator::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitGenerator.requestId)
}
inline std::string* TransitGenerator::mutable_requestid() {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitGenerator.requestId)
  return _s;
}
inline const std::string& TransitGenerator::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void TransitGenerator::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitGenerator::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.requestid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitGenerator::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitGenerator.requestId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.requestid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.requestid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitGenerator::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.requestid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitGenerator.requestId)
}

// optional .NDD.TransitSet transitSet = 3;
inline bool TransitGenerator::has_transitset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transitset_ != nullptr);
  return value;
}
inline void TransitGenerator::clear_transitset() {
  if (_impl_.transitset_ != nullptr) _impl_.transitset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::NDD::TransitSet& TransitGenerator::_internal_transitset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::TransitSet* p = _impl_.transitset_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::TransitSet&>(::NDD::_TransitSet_default_instance_);
}
inline const ::NDD::TransitSet& TransitGenerator::transitset() const {
  // @@protoc_insertion_point(field_get:NDD.TransitGenerator.transitSet)
  return _internal_transitset();
}
inline void TransitGenerator::unsafe_arena_set_allocated_transitset(::NDD::TransitSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transitset_);
  }
  _impl_.transitset_ = reinterpret_cast<::NDD::TransitSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.TransitGenerator.transitSet)
}
inline ::NDD::TransitSet* TransitGenerator::release_transitset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NDD::TransitSet* released = _impl_.transitset_;
  _impl_.transitset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::TransitSet* TransitGenerator::unsafe_arena_release_transitset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitGenerator.transitSet)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NDD::TransitSet* temp = _impl_.transitset_;
  _impl_.transitset_ = nullptr;
  return temp;
}
inline ::NDD::TransitSet* TransitGenerator::_internal_mutable_transitset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.transitset_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::TransitSet>(GetArenaForAllocation());
    _impl_.transitset_ = reinterpret_cast<::NDD::TransitSet*>(p);
  }
  return _impl_.transitset_;
}
inline ::NDD::TransitSet* TransitGenerator::mutable_transitset() {
  ::NDD::TransitSet* _msg = _internal_mutable_transitset();
  // @@protoc_insertion_point(field_mutable:NDD.TransitGenerator.transitSet)
  return _msg;
}
inline void TransitGenerator::set_allocated_transitset(::NDD::TransitSet* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::TransitSet*>(_impl_.transitset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::TransitSet*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.transitset_ = reinterpret_cast<::NDD::TransitSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitGenerator.transitSet)
}

// -------------------------------------------------------------------

// VehicleClass_Attribute

// required string dimensionId = 1;
inline bool VehicleClass_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleClass_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.dimensionId)
}
inline std::string* VehicleClass_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.Attribute.dimensionId)
  return _s;
}
inline const std::string& VehicleClass_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void VehicleClass_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.VehicleClass.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleClass.Attribute.dimensionId)
}

// optional string transitGeneratorId = 2;
inline bool VehicleClass_Attribute::has_transitgeneratorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_transitgeneratorid() {
  _impl_.transitgeneratorid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehicleClass_Attribute::transitgeneratorid() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.transitGeneratorId)
  return _internal_transitgeneratorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass_Attribute::set_transitgeneratorid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transitgeneratorid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.transitGeneratorId)
}
inline std::string* VehicleClass_Attribute::mutable_transitgeneratorid() {
  std::string* _s = _internal_mutable_transitgeneratorid();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.Attribute.transitGeneratorId)
  return _s;
}
inline const std::string& VehicleClass_Attribute::_internal_transitgeneratorid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitgeneratorid_.Get();
}
inline void VehicleClass_Attribute::_internal_set_transitgeneratorid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transitgeneratorid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::_internal_mutable_transitgeneratorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.transitgeneratorid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass_Attribute::release_transitgeneratorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.VehicleClass.Attribute.transitGeneratorId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.transitgeneratorid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transitgeneratorid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass_Attribute::set_allocated_transitgeneratorid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transitgeneratorid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transitgeneratorid_.IsDefault()) {
          _impl_.transitgeneratorid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleClass.Attribute.transitGeneratorId)
}

// optional float transitCoef = 3;
inline bool VehicleClass_Attribute::has_transitcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_transitcoef() {
  _impl_.transitcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float VehicleClass_Attribute::transitcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.transitCoef)
  return _internal_transitcoef();
}
inline void VehicleClass_Attribute::set_transitcoef(float value) {
  _internal_set_transitcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.transitCoef)
}
inline float VehicleClass_Attribute::_internal_transitcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitcoef_;
}
inline void VehicleClass_Attribute::_internal_set_transitcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transitcoef_ = value;
}

// optional float taskCoef = 4;
inline bool VehicleClass_Attribute::has_taskcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_taskcoef() {
  _impl_.taskcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float VehicleClass_Attribute::taskcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.taskCoef)
  return _internal_taskcoef();
}
inline void VehicleClass_Attribute::set_taskcoef(float value) {
  _internal_set_taskcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.taskCoef)
}
inline float VehicleClass_Attribute::_internal_taskcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskcoef_;
}
inline void VehicleClass_Attribute::_internal_set_taskcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.taskcoef_ = value;
}

// optional float locationCoef = 5;
inline bool VehicleClass_Attribute::has_locationcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehicleClass_Attribute::clear_locationcoef() {
  _impl_.locationcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VehicleClass_Attribute::locationcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.Attribute.locationCoef)
  return _internal_locationcoef();
}
inline void VehicleClass_Attribute::set_locationcoef(float value) {
  _internal_set_locationcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.Attribute.locationCoef)
}
inline float VehicleClass_Attribute::_internal_locationcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationcoef_;
}
inline void VehicleClass_Attribute::_internal_set_locationcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.locationcoef_ = value;
}

// -------------------------------------------------------------------

// VehicleClass

// required string id = 1;
inline bool VehicleClass::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleClass::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleClass::id() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleClass::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.id)
}
inline std::string* VehicleClass::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.id)
  return _s;
}
inline const std::string& VehicleClass::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void VehicleClass::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleClass::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleClass::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.VehicleClass.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleClass::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleClass.id)
}

// repeated .NDD.VehicleClass.Attribute attributes = 2;
inline int VehicleClass::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int VehicleClass::attributes_size() const {
  return _internal_attributes_size();
}
inline void VehicleClass::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::VehicleClass_Attribute* VehicleClass::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >*
VehicleClass::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.VehicleClass.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::VehicleClass_Attribute& VehicleClass::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::VehicleClass_Attribute* VehicleClass::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::VehicleClass_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.VehicleClass.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass_Attribute >&
VehicleClass::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.VehicleClass.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass_Attribute>&
VehicleClass::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass_Attribute>*
VehicleClass::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated string transitRuleIds = 3;
inline int VehicleClass::_internal_transitruleids_size() const {
  return _internal_transitruleids().size();
}
inline int VehicleClass::transitruleids_size() const {
  return _internal_transitruleids_size();
}
inline void VehicleClass::clear_transitruleids() {
  _internal_mutable_transitruleids()->Clear();
}
inline std::string* VehicleClass::add_transitruleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_transitruleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.VehicleClass.transitRuleIds)
  return _s;
}
inline const std::string& VehicleClass::transitruleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.VehicleClass.transitRuleIds)
  return _internal_transitruleids().Get(index);
}
inline std::string* VehicleClass::mutable_transitruleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.VehicleClass.transitRuleIds)
  return _internal_mutable_transitruleids()->Mutable(index);
}
inline void VehicleClass::set_transitruleids(int index, const std::string& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, std::string&& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::set_transitruleids(int index, absl::string_view value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.VehicleClass.transitRuleIds)
}
inline void VehicleClass::add_transitruleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.VehicleClass.transitRuleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VehicleClass::transitruleids() const {
  // @@protoc_insertion_point(field_list:NDD.VehicleClass.transitRuleIds)
  return _internal_transitruleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* VehicleClass::mutable_transitruleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.VehicleClass.transitRuleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VehicleClass::_internal_transitruleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VehicleClass::_internal_mutable_transitruleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleids_;
}

// -------------------------------------------------------------------

// VehicleCostClass_Attribute

// required string dimensionId = 1;
inline bool VehicleCostClass_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleCostClass_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleCostClass_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.dimensionId)
}
inline std::string* VehicleCostClass_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleCostClass.Attribute.dimensionId)
  return _s;
}
inline const std::string& VehicleCostClass_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void VehicleCostClass_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleCostClass_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleCostClass_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.VehicleCostClass.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleCostClass_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleCostClass.Attribute.dimensionId)
}

// optional float transitCostCoef = 2;
inline bool VehicleCostClass_Attribute::has_transitcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_transitcostcoef() {
  _impl_.transitcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float VehicleCostClass_Attribute::transitcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.transitCostCoef)
  return _internal_transitcostcoef();
}
inline void VehicleCostClass_Attribute::set_transitcostcoef(float value) {
  _internal_set_transitcostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.transitCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_transitcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_transitcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transitcostcoef_ = value;
}

// optional float taskCostCoef = 3;
inline bool VehicleCostClass_Attribute::has_taskcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_taskcostcoef() {
  _impl_.taskcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float VehicleCostClass_Attribute::taskcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.taskCostCoef)
  return _internal_taskcostcoef();
}
inline void VehicleCostClass_Attribute::set_taskcostcoef(float value) {
  _internal_set_taskcostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.taskCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_taskcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_taskcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.taskcostcoef_ = value;
}

// optional float locationCostCoef = 4;
inline bool VehicleCostClass_Attribute::has_locationcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_locationcostcoef() {
  _impl_.locationcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float VehicleCostClass_Attribute::locationcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.locationCostCoef)
  return _internal_locationcostcoef();
}
inline void VehicleCostClass_Attribute::set_locationcostcoef(float value) {
  _internal_set_locationcostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.locationCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_locationcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_locationcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.locationcostcoef_ = value;
}

// optional float slackCostCoef = 5;
inline bool VehicleCostClass_Attribute::has_slackcostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_slackcostcoef() {
  _impl_.slackcostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VehicleCostClass_Attribute::slackcostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.slackCostCoef)
  return _internal_slackcostcoef();
}
inline void VehicleCostClass_Attribute::set_slackcostcoef(float value) {
  _internal_set_slackcostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.slackCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_slackcostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_slackcostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackcostcoef_ = value;
}

// optional float tardyCostCoef = 6;
inline bool VehicleCostClass_Attribute::has_tardycostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void VehicleCostClass_Attribute::clear_tardycostcoef() {
  _impl_.tardycostcoef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float VehicleCostClass_Attribute::tardycostcoef() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.Attribute.tardyCostCoef)
  return _internal_tardycostcoef();
}
inline void VehicleCostClass_Attribute::set_tardycostcoef(float value) {
  _internal_set_tardycostcoef(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.Attribute.tardyCostCoef)
}
inline float VehicleCostClass_Attribute::_internal_tardycostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycostcoef_;
}
inline void VehicleCostClass_Attribute::_internal_set_tardycostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tardycostcoef_ = value;
}

// -------------------------------------------------------------------

// VehicleCostClass

// required string id = 1;
inline bool VehicleCostClass::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleCostClass::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleCostClass::id() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleCostClass::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.id)
}
inline std::string* VehicleCostClass::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.VehicleCostClass.id)
  return _s;
}
inline const std::string& VehicleCostClass::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void VehicleCostClass::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleCostClass::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleCostClass::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.VehicleCostClass.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleCostClass::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.VehicleCostClass.id)
}

// required float fixedCost = 2;
inline bool VehicleCostClass::has_fixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleCostClass::clear_fixedcost() {
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float VehicleCostClass::fixedcost() const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.fixedCost)
  return _internal_fixedcost();
}
inline void VehicleCostClass::set_fixedcost(float value) {
  _internal_set_fixedcost(value);
  // @@protoc_insertion_point(field_set:NDD.VehicleCostClass.fixedCost)
}
inline float VehicleCostClass::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline void VehicleCostClass::_internal_set_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fixedcost_ = value;
}

// repeated .NDD.VehicleCostClass.Attribute attributes = 3;
inline int VehicleCostClass::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int VehicleCostClass::attributes_size() const {
  return _internal_attributes_size();
}
inline void VehicleCostClass::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::VehicleCostClass_Attribute* VehicleCostClass::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.VehicleCostClass.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >*
VehicleCostClass::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.VehicleCostClass.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::VehicleCostClass_Attribute& VehicleCostClass::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.VehicleCostClass.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::VehicleCostClass_Attribute* VehicleCostClass::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::VehicleCostClass_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.VehicleCostClass.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass_Attribute >&
VehicleCostClass::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.VehicleCostClass.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass_Attribute>&
VehicleCostClass::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass_Attribute>*
VehicleCostClass::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Vehicle_Task_Attribute

// required string dimensionId = 1;
inline bool Vehicle_Task_Attribute::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle_Task_Attribute::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle_Task_Attribute::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.Attribute.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle_Task_Attribute::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Task.Attribute.dimensionId)
}
inline std::string* Vehicle_Task_Attribute::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.Attribute.dimensionId)
  return _s;
}
inline const std::string& Vehicle_Task_Attribute::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Vehicle_Task_Attribute::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle_Task_Attribute::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle_Task_Attribute::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Task.Attribute.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle_Task_Attribute::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Task.Attribute.dimensionId)
}

// optional float quantity = 2;
inline bool Vehicle_Task_Attribute::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vehicle_Task_Attribute::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vehicle_Task_Attribute::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.Attribute.quantity)
  return _internal_quantity();
}
inline void Vehicle_Task_Attribute::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Task.Attribute.quantity)
}
inline float Vehicle_Task_Attribute::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Vehicle_Task_Attribute::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quantity_ = value;
}

// repeated .NDD.Window windows = 3;
inline int Vehicle_Task_Attribute::_internal_windows_size() const {
  return _internal_windows().size();
}
inline int Vehicle_Task_Attribute::windows_size() const {
  return _internal_windows_size();
}
inline void Vehicle_Task_Attribute::clear_windows() {
  _internal_mutable_windows()->Clear();
}
inline ::NDD::Window* Vehicle_Task_Attribute::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.Attribute.windows)
  return _internal_mutable_windows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Window >*
Vehicle_Task_Attribute::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.Task.Attribute.windows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_windows();
}
inline const ::NDD::Window& Vehicle_Task_Attribute::windows(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.Attribute.windows)
    return _internal_windows().Get(index);
}
inline ::NDD::Window* Vehicle_Task_Attribute::add_windows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Window* _add = _internal_mutable_windows()->Add();
  // @@protoc_insertion_point(field_add:NDD.Vehicle.Task.Attribute.windows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Window >&
Vehicle_Task_Attribute::windows() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.Task.Attribute.windows)
  return _internal_windows();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Window>&
Vehicle_Task_Attribute::_internal_windows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windows_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Window>*
Vehicle_Task_Attribute::_internal_mutable_windows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.windows_;
}

// -------------------------------------------------------------------

// Vehicle_Task

// required string locationId = 1;
inline bool Vehicle_Task::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle_Task::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle_Task::locationid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle_Task::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Task.locationId)
}
inline std::string* Vehicle_Task::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.locationId)
  return _s;
}
inline const std::string& Vehicle_Task::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void Vehicle_Task::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle_Task::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle_Task::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Task.locationId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle_Task::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Task.locationId)
}

// repeated .NDD.Vehicle.Task.Attribute attributes = 2;
inline int Vehicle_Task::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int Vehicle_Task::attributes_size() const {
  return _internal_attributes_size();
}
inline void Vehicle_Task::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::Vehicle_Task_Attribute* Vehicle_Task::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Task.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >*
Vehicle_Task::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.Task.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::Vehicle_Task_Attribute& Vehicle_Task::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Task.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::Vehicle_Task_Attribute* Vehicle_Task::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Vehicle_Task_Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.Vehicle.Task.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Task_Attribute >&
Vehicle_Task::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.Task.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Task_Attribute>&
Vehicle_Task::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Task_Attribute>*
Vehicle_Task::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Vehicle_Shift

// required .NDD.Vehicle.Task shiftStart = 1;
inline bool Vehicle_Shift::has_shiftstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shiftstart_ != nullptr);
  return value;
}
inline void Vehicle_Shift::clear_shiftstart() {
  if (_impl_.shiftstart_ != nullptr) _impl_.shiftstart_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::_internal_shiftstart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Vehicle_Task* p = _impl_.shiftstart_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Vehicle_Task&>(::NDD::_Vehicle_Task_default_instance_);
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::shiftstart() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Shift.shiftStart)
  return _internal_shiftstart();
}
inline void Vehicle_Shift::unsafe_arena_set_allocated_shiftstart(::NDD::Vehicle_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shiftstart_);
  }
  _impl_.shiftstart_ = reinterpret_cast<::NDD::Vehicle_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Vehicle.Shift.shiftStart)
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::release_shiftstart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::Vehicle_Task* released = _impl_.shiftstart_;
  _impl_.shiftstart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::unsafe_arena_release_shiftstart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Shift.shiftStart)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::Vehicle_Task* temp = _impl_.shiftstart_;
  _impl_.shiftstart_ = nullptr;
  return temp;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::_internal_mutable_shiftstart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.shiftstart_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Vehicle_Task>(GetArenaForAllocation());
    _impl_.shiftstart_ = reinterpret_cast<::NDD::Vehicle_Task*>(p);
  }
  return _impl_.shiftstart_;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::mutable_shiftstart() {
  ::NDD::Vehicle_Task* _msg = _internal_mutable_shiftstart();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Shift.shiftStart)
  return _msg;
}
inline void Vehicle_Shift::set_allocated_shiftstart(::NDD::Vehicle_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Vehicle_Task*>(_impl_.shiftstart_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Vehicle_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shiftstart_ = reinterpret_cast<::NDD::Vehicle_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Shift.shiftStart)
}

// optional .NDD.Vehicle.Task shiftEnd = 2;
inline bool Vehicle_Shift::has_shiftend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shiftend_ != nullptr);
  return value;
}
inline void Vehicle_Shift::clear_shiftend() {
  if (_impl_.shiftend_ != nullptr) _impl_.shiftend_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::_internal_shiftend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Vehicle_Task* p = _impl_.shiftend_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Vehicle_Task&>(::NDD::_Vehicle_Task_default_instance_);
}
inline const ::NDD::Vehicle_Task& Vehicle_Shift::shiftend() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Shift.shiftEnd)
  return _internal_shiftend();
}
inline void Vehicle_Shift::unsafe_arena_set_allocated_shiftend(::NDD::Vehicle_Task* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shiftend_);
  }
  _impl_.shiftend_ = reinterpret_cast<::NDD::Vehicle_Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Vehicle.Shift.shiftEnd)
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::release_shiftend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Vehicle_Task* released = _impl_.shiftend_;
  _impl_.shiftend_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::unsafe_arena_release_shiftend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Shift.shiftEnd)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Vehicle_Task* temp = _impl_.shiftend_;
  _impl_.shiftend_ = nullptr;
  return temp;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::_internal_mutable_shiftend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shiftend_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Vehicle_Task>(GetArenaForAllocation());
    _impl_.shiftend_ = reinterpret_cast<::NDD::Vehicle_Task*>(p);
  }
  return _impl_.shiftend_;
}
inline ::NDD::Vehicle_Task* Vehicle_Shift::mutable_shiftend() {
  ::NDD::Vehicle_Task* _msg = _internal_mutable_shiftend();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Shift.shiftEnd)
  return _msg;
}
inline void Vehicle_Shift::set_allocated_shiftend(::NDD::Vehicle_Task* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Vehicle_Task*>(_impl_.shiftend_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Vehicle_Task*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.shiftend_ = reinterpret_cast<::NDD::Vehicle_Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Shift.shiftEnd)
}

// -------------------------------------------------------------------

// Vehicle_Capacity

// required string dimensionId = 1;
inline bool Vehicle_Capacity::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle_Capacity::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle_Capacity::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Capacity.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle_Capacity::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Capacity.dimensionId)
}
inline std::string* Vehicle_Capacity::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.Capacity.dimensionId)
  return _s;
}
inline const std::string& Vehicle_Capacity::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void Vehicle_Capacity::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle_Capacity::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle_Capacity::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.Capacity.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle_Capacity::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.Capacity.dimensionId)
}

// required float capacity = 2;
inline bool Vehicle_Capacity::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vehicle_Capacity::clear_capacity() {
  _impl_.capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vehicle_Capacity::capacity() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.Capacity.capacity)
  return _internal_capacity();
}
inline void Vehicle_Capacity::set_capacity(float value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.Capacity.capacity)
}
inline float Vehicle_Capacity::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void Vehicle_Capacity::_internal_set_capacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.capacity_ = value;
}

// -------------------------------------------------------------------

// Vehicle

// required string id = 1;
inline bool Vehicle::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vehicle::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vehicle::id() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Vehicle.id)
}
inline std::string* Vehicle::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.id)
  return _s;
}
inline const std::string& Vehicle::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Vehicle::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.id)
}

// required string classId = 2;
inline bool Vehicle::has_classid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vehicle::clear_classid() {
  _impl_.classid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Vehicle::classid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.classId)
  return _internal_classid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_classid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.classid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Vehicle.classId)
}
inline std::string* Vehicle::mutable_classid() {
  std::string* _s = _internal_mutable_classid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.classId)
  return _s;
}
inline const std::string& Vehicle::_internal_classid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.classid_.Get();
}
inline void Vehicle::_internal_set_classid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.classid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_classid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.classid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_classid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.classId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.classid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.classid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_classid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.classid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.classid_.IsDefault()) {
          _impl_.classid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.classId)
}

// required string costClassId = 3;
inline bool Vehicle::has_costclassid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Vehicle::clear_costclassid() {
  _impl_.costclassid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Vehicle::costclassid() const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.costClassId)
  return _internal_costclassid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Vehicle::set_costclassid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.costclassid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.Vehicle.costClassId)
}
inline std::string* Vehicle::mutable_costclassid() {
  std::string* _s = _internal_mutable_costclassid();
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.costClassId)
  return _s;
}
inline const std::string& Vehicle::_internal_costclassid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costclassid_.Get();
}
inline void Vehicle::_internal_set_costclassid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.costclassid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vehicle::_internal_mutable_costclassid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.costclassid_.Mutable( GetArenaForAllocation());
}
inline std::string* Vehicle::release_costclassid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Vehicle.costClassId)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.costclassid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.costclassid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Vehicle::set_allocated_costclassid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.costclassid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.costclassid_.IsDefault()) {
          _impl_.costclassid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.Vehicle.costClassId)
}

// repeated .NDD.Vehicle.Shift shift = 4;
inline int Vehicle::_internal_shift_size() const {
  return _internal_shift().size();
}
inline int Vehicle::shift_size() const {
  return _internal_shift_size();
}
inline void Vehicle::clear_shift() {
  _internal_mutable_shift()->Clear();
}
inline ::NDD::Vehicle_Shift* Vehicle::mutable_shift(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.shift)
  return _internal_mutable_shift()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >*
Vehicle::mutable_shift() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.shift)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_shift();
}
inline const ::NDD::Vehicle_Shift& Vehicle::shift(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.shift)
    return _internal_shift().Get(index);
}
inline ::NDD::Vehicle_Shift* Vehicle::add_shift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Vehicle_Shift* _add = _internal_mutable_shift()->Add();
  // @@protoc_insertion_point(field_add:NDD.Vehicle.shift)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Shift >&
Vehicle::shift() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.shift)
  return _internal_shift();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Shift>&
Vehicle::_internal_shift() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shift_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Shift>*
Vehicle::_internal_mutable_shift() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.shift_;
}

// repeated .NDD.Vehicle.Capacity capacities = 5;
inline int Vehicle::_internal_capacities_size() const {
  return _internal_capacities().size();
}
inline int Vehicle::capacities_size() const {
  return _internal_capacities_size();
}
inline void Vehicle::clear_capacities() {
  _internal_mutable_capacities()->Clear();
}
inline ::NDD::Vehicle_Capacity* Vehicle::mutable_capacities(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.capacities)
  return _internal_mutable_capacities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >*
Vehicle::mutable_capacities() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.capacities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capacities();
}
inline const ::NDD::Vehicle_Capacity& Vehicle::capacities(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.capacities)
    return _internal_capacities().Get(index);
}
inline ::NDD::Vehicle_Capacity* Vehicle::add_capacities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Vehicle_Capacity* _add = _internal_mutable_capacities()->Add();
  // @@protoc_insertion_point(field_add:NDD.Vehicle.capacities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle_Capacity >&
Vehicle::capacities() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.capacities)
  return _internal_capacities();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Capacity>&
Vehicle::_internal_capacities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacities_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Vehicle_Capacity>*
Vehicle::_internal_mutable_capacities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capacities_;
}

// repeated string transitRuleIds = 6;
inline int Vehicle::_internal_transitruleids_size() const {
  return _internal_transitruleids().size();
}
inline int Vehicle::transitruleids_size() const {
  return _internal_transitruleids_size();
}
inline void Vehicle::clear_transitruleids() {
  _internal_mutable_transitruleids()->Clear();
}
inline std::string* Vehicle::add_transitruleids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_transitruleids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.Vehicle.transitRuleIds)
  return _s;
}
inline const std::string& Vehicle::transitruleids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Vehicle.transitRuleIds)
  return _internal_transitruleids().Get(index);
}
inline std::string* Vehicle::mutable_transitruleids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Vehicle.transitRuleIds)
  return _internal_mutable_transitruleids()->Mutable(index);
}
inline void Vehicle::set_transitruleids(int index, const std::string& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, std::string&& value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transitruleids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::set_transitruleids(int index, absl::string_view value) {
  _internal_mutable_transitruleids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.Vehicle.transitRuleIds)
}
inline void Vehicle::add_transitruleids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transitruleids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.Vehicle.transitRuleIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Vehicle::transitruleids() const {
  // @@protoc_insertion_point(field_list:NDD.Vehicle.transitRuleIds)
  return _internal_transitruleids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Vehicle::mutable_transitruleids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Vehicle.transitRuleIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Vehicle::_internal_transitruleids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Vehicle::_internal_mutable_transitruleids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleids_;
}

// -------------------------------------------------------------------

// TaskSequence

// required string vehicleId = 1;
inline bool TaskSequence::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TaskSequence::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskSequence::vehicleid() const {
  // @@protoc_insertion_point(field_get:NDD.TaskSequence.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSequence::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.vehicleId)
}
inline std::string* TaskSequence::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:NDD.TaskSequence.vehicleId)
  return _s;
}
inline const std::string& TaskSequence::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void TaskSequence::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskSequence::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskSequence::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TaskSequence.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskSequence::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TaskSequence.vehicleId)
}

// required int32 dayIndex = 2;
inline bool TaskSequence::has_dayindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TaskSequence::clear_dayindex() {
  _impl_.dayindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t TaskSequence::dayindex() const {
  // @@protoc_insertion_point(field_get:NDD.TaskSequence.dayIndex)
  return _internal_dayindex();
}
inline void TaskSequence::set_dayindex(::int32_t value) {
  _internal_set_dayindex(value);
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.dayIndex)
}
inline ::int32_t TaskSequence::_internal_dayindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dayindex_;
}
inline void TaskSequence::_internal_set_dayindex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dayindex_ = value;
}

// repeated string taskId = 3;
inline int TaskSequence::_internal_taskid_size() const {
  return _internal_taskid().size();
}
inline int TaskSequence::taskid_size() const {
  return _internal_taskid_size();
}
inline void TaskSequence::clear_taskid() {
  _internal_mutable_taskid()->Clear();
}
inline std::string* TaskSequence::add_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_taskid()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.TaskSequence.taskId)
  return _s;
}
inline const std::string& TaskSequence::taskid(int index) const {
  // @@protoc_insertion_point(field_get:NDD.TaskSequence.taskId)
  return _internal_taskid().Get(index);
}
inline std::string* TaskSequence::mutable_taskid(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.TaskSequence.taskId)
  return _internal_mutable_taskid()->Mutable(index);
}
inline void TaskSequence::set_taskid(int index, const std::string& value) {
  _internal_mutable_taskid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, std::string&& value) {
  _internal_mutable_taskid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_taskid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_taskid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.TaskSequence.taskId)
}
inline void TaskSequence::set_taskid(int index, absl::string_view value) {
  _internal_mutable_taskid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.TaskSequence.taskId)
}
inline void TaskSequence::add_taskid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.TaskSequence.taskId)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskSequence::taskid() const {
  // @@protoc_insertion_point(field_list:NDD.TaskSequence.taskId)
  return _internal_taskid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* TaskSequence::mutable_taskid() {
  // @@protoc_insertion_point(field_mutable_list:NDD.TaskSequence.taskId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_taskid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskSequence::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TaskSequence::_internal_mutable_taskid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.taskid_;
}

// -------------------------------------------------------------------

// TransitRule_Trigger

// required float value = 1;
inline bool TransitRule_Trigger::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitRule_Trigger::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TransitRule_Trigger::value() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.Trigger.value)
  return _internal_value();
}
inline void TransitRule_Trigger::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.Trigger.value)
}
inline float TransitRule_Trigger::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TransitRule_Trigger::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}

// required float quantity = 2;
inline bool TransitRule_Trigger::has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitRule_Trigger::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TransitRule_Trigger::quantity() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.Trigger.quantity)
  return _internal_quantity();
}
inline void TransitRule_Trigger::set_quantity(float value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.Trigger.quantity)
}
inline float TransitRule_Trigger::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void TransitRule_Trigger::_internal_set_quantity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// TransitRule

// required string id = 1;
inline bool TransitRule::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransitRule::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitRule::id() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRule::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitRule.id)
}
inline std::string* TransitRule::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.id)
  return _s;
}
inline const std::string& TransitRule::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TransitRule::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitRule::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitRule::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitRule.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitRule::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitRule.id)
}

// required string dimensionId = 2;
inline bool TransitRule::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransitRule::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitRule::dimensionid() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRule::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitRule.dimensionId)
}
inline std::string* TransitRule::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.dimensionId)
  return _s;
}
inline const std::string& TransitRule::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void TransitRule::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitRule::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitRule::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitRule.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitRule::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitRule.dimensionId)
}

// optional bool useStandingState = 3 [default = true];
inline bool TransitRule::has_usestandingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TransitRule::clear_usestandingstate() {
  _impl_.usestandingstate_ = true;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TransitRule::usestandingstate() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.useStandingState)
  return _internal_usestandingstate();
}
inline void TransitRule::set_usestandingstate(bool value) {
  _internal_set_usestandingstate(value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.useStandingState)
}
inline bool TransitRule::_internal_usestandingstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usestandingstate_;
}
inline void TransitRule::_internal_set_usestandingstate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.usestandingstate_ = value;
}

// optional bool useTransitState = 4 [default = false];
inline bool TransitRule::has_usetransitstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TransitRule::clear_usetransitstate() {
  _impl_.usetransitstate_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TransitRule::usetransitstate() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.useTransitState)
  return _internal_usetransitstate();
}
inline void TransitRule::set_usetransitstate(bool value) {
  _internal_set_usetransitstate(value);
  // @@protoc_insertion_point(field_set:NDD.TransitRule.useTransitState)
}
inline bool TransitRule::_internal_usetransitstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usetransitstate_;
}
inline void TransitRule::_internal_set_usetransitstate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.usetransitstate_ = value;
}

// required string ruleIdPrefix = 5;
inline bool TransitRule::has_ruleidprefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TransitRule::clear_ruleidprefix() {
  _impl_.ruleidprefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TransitRule::ruleidprefix() const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.ruleIdPrefix)
  return _internal_ruleidprefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRule::set_ruleidprefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ruleidprefix_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.TransitRule.ruleIdPrefix)
}
inline std::string* TransitRule::mutable_ruleidprefix() {
  std::string* _s = _internal_mutable_ruleidprefix();
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.ruleIdPrefix)
  return _s;
}
inline const std::string& TransitRule::_internal_ruleidprefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ruleidprefix_.Get();
}
inline void TransitRule::_internal_set_ruleidprefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ruleidprefix_.Set(value, GetArenaForAllocation());
}
inline std::string* TransitRule::_internal_mutable_ruleidprefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ruleidprefix_.Mutable( GetArenaForAllocation());
}
inline std::string* TransitRule::release_ruleidprefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.TransitRule.ruleIdPrefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ruleidprefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ruleidprefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransitRule::set_allocated_ruleidprefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ruleidprefix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ruleidprefix_.IsDefault()) {
          _impl_.ruleidprefix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.TransitRule.ruleIdPrefix)
}

// repeated .NDD.TransitRule.Trigger triggers = 6;
inline int TransitRule::_internal_triggers_size() const {
  return _internal_triggers().size();
}
inline int TransitRule::triggers_size() const {
  return _internal_triggers_size();
}
inline void TransitRule::clear_triggers() {
  _internal_mutable_triggers()->Clear();
}
inline ::NDD::TransitRule_Trigger* TransitRule::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.TransitRule.triggers)
  return _internal_mutable_triggers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >*
TransitRule::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:NDD.TransitRule.triggers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_triggers();
}
inline const ::NDD::TransitRule_Trigger& TransitRule::triggers(int index) const {
  // @@protoc_insertion_point(field_get:NDD.TransitRule.triggers)
    return _internal_triggers().Get(index);
}
inline ::NDD::TransitRule_Trigger* TransitRule::add_triggers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TransitRule_Trigger* _add = _internal_mutable_triggers()->Add();
  // @@protoc_insertion_point(field_add:NDD.TransitRule.triggers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule_Trigger >&
TransitRule::triggers() const {
  // @@protoc_insertion_point(field_list:NDD.TransitRule.triggers)
  return _internal_triggers();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TransitRule_Trigger>&
TransitRule::_internal_triggers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.triggers_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TransitRule_Trigger>*
TransitRule::_internal_mutable_triggers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.triggers_;
}

// -------------------------------------------------------------------

// Model

// required .NDD.DimensionConfiguration dimensions = 1;
inline bool Model::has_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimensions_ != nullptr);
  return value;
}
inline void Model::clear_dimensions() {
  if (_impl_.dimensions_ != nullptr) _impl_.dimensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NDD::DimensionConfiguration& Model::_internal_dimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::DimensionConfiguration* p = _impl_.dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::DimensionConfiguration&>(::NDD::_DimensionConfiguration_default_instance_);
}
inline const ::NDD::DimensionConfiguration& Model::dimensions() const {
  // @@protoc_insertion_point(field_get:NDD.Model.dimensions)
  return _internal_dimensions();
}
inline void Model::unsafe_arena_set_allocated_dimensions(::NDD::DimensionConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }
  _impl_.dimensions_ = reinterpret_cast<::NDD::DimensionConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.Model.dimensions)
}
inline ::NDD::DimensionConfiguration* Model::release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::DimensionConfiguration* released = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::DimensionConfiguration* Model::unsafe_arena_release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.Model.dimensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::DimensionConfiguration* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  return temp;
}
inline ::NDD::DimensionConfiguration* Model::_internal_mutable_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dimensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::DimensionConfiguration>(GetArenaForAllocation());
    _impl_.dimensions_ = reinterpret_cast<::NDD::DimensionConfiguration*>(p);
  }
  return _impl_.dimensions_;
}
inline ::NDD::DimensionConfiguration* Model::mutable_dimensions() {
  ::NDD::DimensionConfiguration* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:NDD.Model.dimensions)
  return _msg;
}
inline void Model::set_allocated_dimensions(::NDD::DimensionConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::DimensionConfiguration*>(_impl_.dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::DimensionConfiguration*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimensions_ = reinterpret_cast<::NDD::DimensionConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.Model.dimensions)
}

// repeated .NDD.Location locations = 2;
inline int Model::_internal_locations_size() const {
  return _internal_locations().size();
}
inline int Model::locations_size() const {
  return _internal_locations_size();
}
inline void Model::clear_locations() {
  _internal_mutable_locations()->Clear();
}
inline ::NDD::Location* Model::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.locations)
  return _internal_mutable_locations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Location >*
Model::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.locations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_locations();
}
inline const ::NDD::Location& Model::locations(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.locations)
    return _internal_locations().Get(index);
}
inline ::NDD::Location* Model::add_locations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Location* _add = _internal_mutable_locations()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.locations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Location >&
Model::locations() const {
  // @@protoc_insertion_point(field_list:NDD.Model.locations)
  return _internal_locations();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Location>&
Model::_internal_locations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locations_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Location>*
Model::_internal_mutable_locations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.locations_;
}

// repeated .NDD.Job jobs = 3;
inline int Model::_internal_jobs_size() const {
  return _internal_jobs().size();
}
inline int Model::jobs_size() const {
  return _internal_jobs_size();
}
inline void Model::clear_jobs() {
  _internal_mutable_jobs()->Clear();
}
inline ::NDD::Job* Model::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.jobs)
  return _internal_mutable_jobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Job >*
Model::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.jobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jobs();
}
inline const ::NDD::Job& Model::jobs(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.jobs)
    return _internal_jobs().Get(index);
}
inline ::NDD::Job* Model::add_jobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Job* _add = _internal_mutable_jobs()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.jobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Job >&
Model::jobs() const {
  // @@protoc_insertion_point(field_list:NDD.Model.jobs)
  return _internal_jobs();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Job>&
Model::_internal_jobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobs_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Job>*
Model::_internal_mutable_jobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jobs_;
}

// repeated .NDD.Vehicle vehicles = 4;
inline int Model::_internal_vehicles_size() const {
  return _internal_vehicles().size();
}
inline int Model::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void Model::clear_vehicles() {
  _internal_mutable_vehicles()->Clear();
}
inline ::NDD::Vehicle* Model::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.vehicles)
  return _internal_mutable_vehicles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >*
Model::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.vehicles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicles();
}
inline const ::NDD::Vehicle& Model::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.vehicles)
    return _internal_vehicles().Get(index);
}
inline ::NDD::Vehicle* Model::add_vehicles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Vehicle* _add = _internal_mutable_vehicles()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.vehicles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Vehicle >&
Model::vehicles() const {
  // @@protoc_insertion_point(field_list:NDD.Model.vehicles)
  return _internal_vehicles();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Vehicle>&
Model::_internal_vehicles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicles_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Vehicle>*
Model::_internal_mutable_vehicles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicles_;
}

// repeated .NDD.VehicleClass vehicleClasses = 5;
inline int Model::_internal_vehicleclasses_size() const {
  return _internal_vehicleclasses().size();
}
inline int Model::vehicleclasses_size() const {
  return _internal_vehicleclasses_size();
}
inline void Model::clear_vehicleclasses() {
  _internal_mutable_vehicleclasses()->Clear();
}
inline ::NDD::VehicleClass* Model::mutable_vehicleclasses(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.vehicleClasses)
  return _internal_mutable_vehicleclasses()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >*
Model::mutable_vehicleclasses() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.vehicleClasses)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicleclasses();
}
inline const ::NDD::VehicleClass& Model::vehicleclasses(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.vehicleClasses)
    return _internal_vehicleclasses().Get(index);
}
inline ::NDD::VehicleClass* Model::add_vehicleclasses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::VehicleClass* _add = _internal_mutable_vehicleclasses()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.vehicleClasses)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleClass >&
Model::vehicleclasses() const {
  // @@protoc_insertion_point(field_list:NDD.Model.vehicleClasses)
  return _internal_vehicleclasses();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass>&
Model::_internal_vehicleclasses() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleclasses_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::VehicleClass>*
Model::_internal_mutable_vehicleclasses() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicleclasses_;
}

// repeated .NDD.VehicleCostClass vehicleCostClasses = 6;
inline int Model::_internal_vehiclecostclasses_size() const {
  return _internal_vehiclecostclasses().size();
}
inline int Model::vehiclecostclasses_size() const {
  return _internal_vehiclecostclasses_size();
}
inline void Model::clear_vehiclecostclasses() {
  _internal_mutable_vehiclecostclasses()->Clear();
}
inline ::NDD::VehicleCostClass* Model::mutable_vehiclecostclasses(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.vehicleCostClasses)
  return _internal_mutable_vehiclecostclasses()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >*
Model::mutable_vehiclecostclasses() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.vehicleCostClasses)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehiclecostclasses();
}
inline const ::NDD::VehicleCostClass& Model::vehiclecostclasses(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.vehicleCostClasses)
    return _internal_vehiclecostclasses().Get(index);
}
inline ::NDD::VehicleCostClass* Model::add_vehiclecostclasses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::VehicleCostClass* _add = _internal_mutable_vehiclecostclasses()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.vehicleCostClasses)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::VehicleCostClass >&
Model::vehiclecostclasses() const {
  // @@protoc_insertion_point(field_list:NDD.Model.vehicleCostClasses)
  return _internal_vehiclecostclasses();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass>&
Model::_internal_vehiclecostclasses() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehiclecostclasses_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::VehicleCostClass>*
Model::_internal_mutable_vehiclecostclasses() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehiclecostclasses_;
}

// repeated .NDD.TransitRule transitRules = 7;
inline int Model::_internal_transitrules_size() const {
  return _internal_transitrules().size();
}
inline int Model::transitrules_size() const {
  return _internal_transitrules_size();
}
inline void Model::clear_transitrules() {
  _internal_mutable_transitrules()->Clear();
}
inline ::NDD::TransitRule* Model::mutable_transitrules(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.transitRules)
  return _internal_mutable_transitrules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >*
Model::mutable_transitrules() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.transitRules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitrules();
}
inline const ::NDD::TransitRule& Model::transitrules(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.transitRules)
    return _internal_transitrules().Get(index);
}
inline ::NDD::TransitRule* Model::add_transitrules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TransitRule* _add = _internal_mutable_transitrules()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.transitRules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitRule >&
Model::transitrules() const {
  // @@protoc_insertion_point(field_list:NDD.Model.transitRules)
  return _internal_transitrules();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TransitRule>&
Model::_internal_transitrules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitrules_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TransitRule>*
Model::_internal_mutable_transitrules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitrules_;
}

// repeated .NDD.TransitGenerator transitGenerators = 8;
inline int Model::_internal_transitgenerators_size() const {
  return _internal_transitgenerators().size();
}
inline int Model::transitgenerators_size() const {
  return _internal_transitgenerators_size();
}
inline void Model::clear_transitgenerators() {
  _internal_mutable_transitgenerators()->Clear();
}
inline ::NDD::TransitGenerator* Model::mutable_transitgenerators(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.transitGenerators)
  return _internal_mutable_transitgenerators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >*
Model::mutable_transitgenerators() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.transitGenerators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitgenerators();
}
inline const ::NDD::TransitGenerator& Model::transitgenerators(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.transitGenerators)
    return _internal_transitgenerators().Get(index);
}
inline ::NDD::TransitGenerator* Model::add_transitgenerators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TransitGenerator* _add = _internal_mutable_transitgenerators()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.transitGenerators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TransitGenerator >&
Model::transitgenerators() const {
  // @@protoc_insertion_point(field_list:NDD.Model.transitGenerators)
  return _internal_transitgenerators();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TransitGenerator>&
Model::_internal_transitgenerators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitgenerators_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TransitGenerator>*
Model::_internal_mutable_transitgenerators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitgenerators_;
}

// repeated .NDD.TaskSequence taskSequence = 9;
inline int Model::_internal_tasksequence_size() const {
  return _internal_tasksequence().size();
}
inline int Model::tasksequence_size() const {
  return _internal_tasksequence_size();
}
inline void Model::clear_tasksequence() {
  _internal_mutable_tasksequence()->Clear();
}
inline ::NDD::TaskSequence* Model::mutable_tasksequence(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.Model.taskSequence)
  return _internal_mutable_tasksequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
Model::mutable_tasksequence() {
  // @@protoc_insertion_point(field_mutable_list:NDD.Model.taskSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasksequence();
}
inline const ::NDD::TaskSequence& Model::tasksequence(int index) const {
  // @@protoc_insertion_point(field_get:NDD.Model.taskSequence)
    return _internal_tasksequence().Get(index);
}
inline ::NDD::TaskSequence* Model::add_tasksequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TaskSequence* _add = _internal_mutable_tasksequence()->Add();
  // @@protoc_insertion_point(field_add:NDD.Model.taskSequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
Model::tasksequence() const {
  // @@protoc_insertion_point(field_list:NDD.Model.taskSequence)
  return _internal_tasksequence();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>&
Model::_internal_tasksequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasksequence_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>*
Model::_internal_mutable_tasksequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasksequence_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .NDD.Model model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NDD::Model& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::Model&>(::NDD::_Model_default_instance_);
}
inline const ::NDD::Model& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::NDD::Model* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::NDD::Model*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.SolveRequest.model)
}
inline ::NDD::Model* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Model* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::Model* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NDD::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::NDD::Model* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::Model>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::NDD::Model*>(p);
  }
  return _impl_.model_;
}
inline ::NDD::Model* SolveRequest::mutable_model() {
  ::NDD::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:NDD.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::NDD::Model* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::Model*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::Model*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::NDD::Model*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:NDD.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolveRequest.modelID)
}

// repeated .NDD.TaskSequence routes = 3;
inline int SolveRequest::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolveRequest::routes_size() const {
  return _internal_routes_size();
}
inline void SolveRequest::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::NDD::TaskSequence* SolveRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolveRequest.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
SolveRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolveRequest.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::NDD::TaskSequence& SolveRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.routes)
    return _internal_routes().Get(index);
}
inline ::NDD::TaskSequence* SolveRequest::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TaskSequence* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolveRequest.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
SolveRequest::routes() const {
  // @@protoc_insertion_point(field_list:NDD.SolveRequest.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>&
SolveRequest::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>*
SolveRequest::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// optional .NDD.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::NDD::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:NDD.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::NDD::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:NDD.SolveRequest.solveType)
}
inline ::NDD::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NDD::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::NDD::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NDD::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_StopAttribute

// required string dimId = 1;
inline bool SolutionResponse_StopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_StopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_StopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.dimId)
}
inline std::string* SolutionResponse_StopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.StopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_StopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_StopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.StopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_StopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.StopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_StopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_StopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_StopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.startValue)
}
inline float SolutionResponse_StopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_StopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_StopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_StopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.endValue)
}
inline float SolutionResponse_StopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_StopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_StopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_StopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.cost)
}
inline float SolutionResponse_StopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// required float slackValue = 5;
inline bool SolutionResponse_StopAttribute::has_slackvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_slackvalue() {
  _impl_.slackvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_StopAttribute::slackvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.slackValue)
  return _internal_slackvalue();
}
inline void SolutionResponse_StopAttribute::set_slackvalue(float value) {
  _internal_set_slackvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.slackValue)
}
inline float SolutionResponse_StopAttribute::_internal_slackvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_slackvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackvalue_ = value;
}

// required float slackCost = 6;
inline bool SolutionResponse_StopAttribute::has_slackcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_slackcost() {
  _impl_.slackcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_StopAttribute::slackcost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.slackCost)
  return _internal_slackcost();
}
inline void SolutionResponse_StopAttribute::set_slackcost(float value) {
  _internal_set_slackcost(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.slackCost)
}
inline float SolutionResponse_StopAttribute::_internal_slackcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_slackcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.slackcost_ = value;
}

// required float tardyValue = 7;
inline bool SolutionResponse_StopAttribute::has_tardyvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_tardyvalue() {
  _impl_.tardyvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_StopAttribute::tardyvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.tardyValue)
  return _internal_tardyvalue();
}
inline void SolutionResponse_StopAttribute::set_tardyvalue(float value) {
  _internal_set_tardyvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.tardyValue)
}
inline float SolutionResponse_StopAttribute::_internal_tardyvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardyvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_tardyvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tardyvalue_ = value;
}

// required float tardyCost = 8;
inline bool SolutionResponse_StopAttribute::has_tardycost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_tardycost() {
  _impl_.tardycost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float SolutionResponse_StopAttribute::tardycost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.StopAttribute.tardyCost)
  return _internal_tardycost();
}
inline void SolutionResponse_StopAttribute::set_tardycost(float value) {
  _internal_set_tardycost(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.StopAttribute.tardyCost)
}
inline float SolutionResponse_StopAttribute::_internal_tardycost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_tardycost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.tardycost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStopAttribute

// required string dimId = 1;
inline bool SolutionResponse_InterStopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_InterStopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_InterStopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.dimId)
}
inline std::string* SolutionResponse_InterStopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.InterStopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_InterStopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_InterStopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.InterStopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_InterStopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.InterStopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_InterStopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_InterStopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_InterStopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.startValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_InterStopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_InterStopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_InterStopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.endValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_InterStopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_InterStopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_InterStopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStopAttribute.cost)
}
inline float SolutionResponse_InterStopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Stop

// required int32 id = 1;
inline bool SolutionResponse_Stop::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SolutionResponse_Stop::id() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.id)
  return _internal_id();
}
inline void SolutionResponse_Stop::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.id)
}
inline ::int32_t SolutionResponse_Stop::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SolutionResponse_Stop::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}

// required int32 sequence = 2;
inline bool SolutionResponse_Stop::has_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_sequence() {
  _impl_.sequence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SolutionResponse_Stop::sequence() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.sequence)
  return _internal_sequence();
}
inline void SolutionResponse_Stop::set_sequence(::int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.sequence)
}
inline ::int32_t SolutionResponse_Stop::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline void SolutionResponse_Stop::_internal_set_sequence(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sequence_ = value;
}

// required string locationId = 3;
inline bool SolutionResponse_Stop::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Stop::locationid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.locationId)
}
inline std::string* SolutionResponse_Stop::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.locationId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Stop.locationId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Stop.locationId)
}

// required string taskId = 4;
inline bool SolutionResponse_Stop::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Stop::taskid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.taskId)
}
inline std::string* SolutionResponse_Stop::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.taskId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Stop.taskId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Stop.taskId)
}

// required string jobId = 5;
inline bool SolutionResponse_Stop::has_jobid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_jobid() {
  _impl_.jobid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SolutionResponse_Stop::jobid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.jobId)
  return _internal_jobid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_jobid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.jobid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Stop.jobId)
}
inline std::string* SolutionResponse_Stop::mutable_jobid() {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.jobId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_jobid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_jobid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.jobid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.jobid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Stop.jobId)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.jobid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.jobid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_jobid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.jobid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jobid_.IsDefault()) {
          _impl_.jobid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Stop.jobId)
}

// repeated .NDD.SolutionResponse.StopAttribute attributes = 6;
inline int SolutionResponse_Stop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_Stop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_Stop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::SolutionResponse_StopAttribute* SolutionResponse_Stop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Stop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >*
SolutionResponse_Stop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Stop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::SolutionResponse_StopAttribute& SolutionResponse_Stop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Stop.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::SolutionResponse_StopAttribute* SolutionResponse_Stop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_StopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Stop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_StopAttribute >&
SolutionResponse_Stop::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Stop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_StopAttribute>&
SolutionResponse_Stop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_StopAttribute>*
SolutionResponse_Stop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStop

// required int32 fromStopId = 1;
inline bool SolutionResponse_InterStop::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SolutionResponse_InterStop::fromstopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_InterStop::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStop.fromStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_InterStop::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 2;
inline bool SolutionResponse_InterStop::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_InterStop::tostopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_InterStop::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.InterStop.toStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_InterStop::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tostopid_ = value;
}

// repeated .NDD.SolutionResponse.InterStopAttribute attributes = 3;
inline int SolutionResponse_InterStop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_InterStop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_InterStop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NDD::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.InterStop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >*
SolutionResponse_InterStop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.InterStop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NDD::SolutionResponse_InterStopAttribute& SolutionResponse_InterStop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.attributes)
    return _internal_attributes().Get(index);
}
inline ::NDD::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_InterStopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.InterStop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStopAttribute >&
SolutionResponse_InterStop::attributes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.InterStop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStopAttribute>&
SolutionResponse_InterStop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStopAttribute>*
SolutionResponse_InterStop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .NDD.Geocode routeSegments = 4;
inline int SolutionResponse_InterStop::_internal_routesegments_size() const {
  return _internal_routesegments().size();
}
inline int SolutionResponse_InterStop::routesegments_size() const {
  return _internal_routesegments_size();
}
inline void SolutionResponse_InterStop::clear_routesegments() {
  _internal_mutable_routesegments()->Clear();
}
inline ::NDD::Geocode* SolutionResponse_InterStop::mutable_routesegments(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.InterStop.routeSegments)
  return _internal_mutable_routesegments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >*
SolutionResponse_InterStop::mutable_routesegments() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.InterStop.routeSegments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routesegments();
}
inline const ::NDD::Geocode& SolutionResponse_InterStop::routesegments(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.InterStop.routeSegments)
    return _internal_routesegments().Get(index);
}
inline ::NDD::Geocode* SolutionResponse_InterStop::add_routesegments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::Geocode* _add = _internal_mutable_routesegments()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.InterStop.routeSegments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::Geocode >&
SolutionResponse_InterStop::routesegments() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.InterStop.routeSegments)
  return _internal_routesegments();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::Geocode>&
SolutionResponse_InterStop::_internal_routesegments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routesegments_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::Geocode>*
SolutionResponse_InterStop::_internal_mutable_routesegments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routesegments_;
}

// -------------------------------------------------------------------

// SolutionResponse_TransitRuleAttribute

// required string ruleId = 1;
inline bool SolutionResponse_TransitRuleAttribute::has_ruleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_ruleid() {
  _impl_.ruleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::ruleid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
  return _internal_ruleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_TransitRuleAttribute::set_ruleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}
inline std::string* SolutionResponse_TransitRuleAttribute::mutable_ruleid() {
  std::string* _s = _internal_mutable_ruleid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
  return _s;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::_internal_ruleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ruleid_.Get();
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_ruleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::_internal_mutable_ruleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ruleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::release_ruleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ruleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ruleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_ruleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ruleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ruleid_.IsDefault()) {
          _impl_.ruleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.TransitRuleAttribute.ruleId)
}

// required string dimId = 2;
inline bool SolutionResponse_TransitRuleAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_TransitRuleAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}
inline std::string* SolutionResponse_TransitRuleAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.TransitRuleAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.TransitRuleAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.TransitRuleAttribute.dimId)
}

// required int32 fromStopId = 3;
inline bool SolutionResponse_TransitRuleAttribute::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::fromstopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_TransitRuleAttribute::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.fromStopId)
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 4;
inline bool SolutionResponse_TransitRuleAttribute::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::tostopid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_TransitRuleAttribute::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.toStopId)
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tostopid_ = value;
}

// required float startValue = 5;
inline bool SolutionResponse_TransitRuleAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_TransitRuleAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_TransitRuleAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.startValue)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.startvalue_ = value;
}

// required float endValue = 6;
inline bool SolutionResponse_TransitRuleAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_TransitRuleAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_TransitRuleAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.endValue)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.endvalue_ = value;
}

// required float cost = 7;
inline bool SolutionResponse_TransitRuleAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_TransitRuleAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.TransitRuleAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_TransitRuleAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.TransitRuleAttribute.cost)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string vehicleId = 1;
inline bool SolutionResponse_Route::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Route::vehicleid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Route::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Route.vehicleId)
}
inline std::string* SolutionResponse_Route::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.vehicleId)
  return _s;
}
inline const std::string& SolutionResponse_Route::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void SolutionResponse_Route::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Route.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Route::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Route.vehicleId)
}

// repeated .NDD.SolutionResponse.Stop stops = 2;
inline int SolutionResponse_Route::_internal_stops_size() const {
  return _internal_stops().size();
}
inline int SolutionResponse_Route::stops_size() const {
  return _internal_stops_size();
}
inline void SolutionResponse_Route::clear_stops() {
  _internal_mutable_stops()->Clear();
}
inline ::NDD::SolutionResponse_Stop* SolutionResponse_Route::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.stops)
  return _internal_mutable_stops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >*
SolutionResponse_Route::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.stops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stops();
}
inline const ::NDD::SolutionResponse_Stop& SolutionResponse_Route::stops(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.stops)
    return _internal_stops().Get(index);
}
inline ::NDD::SolutionResponse_Stop* SolutionResponse_Route::add_stops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_Stop* _add = _internal_mutable_stops()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.stops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Stop >&
SolutionResponse_Route::stops() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.stops)
  return _internal_stops();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Stop>&
SolutionResponse_Route::_internal_stops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stops_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Stop>*
SolutionResponse_Route::_internal_mutable_stops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stops_;
}

// repeated .NDD.SolutionResponse.InterStop interStops = 3;
inline int SolutionResponse_Route::_internal_interstops_size() const {
  return _internal_interstops().size();
}
inline int SolutionResponse_Route::interstops_size() const {
  return _internal_interstops_size();
}
inline void SolutionResponse_Route::clear_interstops() {
  _internal_mutable_interstops()->Clear();
}
inline ::NDD::SolutionResponse_InterStop* SolutionResponse_Route::mutable_interstops(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.interStops)
  return _internal_mutable_interstops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >*
SolutionResponse_Route::mutable_interstops() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.interStops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_interstops();
}
inline const ::NDD::SolutionResponse_InterStop& SolutionResponse_Route::interstops(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.interStops)
    return _internal_interstops().Get(index);
}
inline ::NDD::SolutionResponse_InterStop* SolutionResponse_Route::add_interstops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_InterStop* _add = _internal_mutable_interstops()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.interStops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_InterStop >&
SolutionResponse_Route::interstops() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.interStops)
  return _internal_interstops();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStop>&
SolutionResponse_Route::_internal_interstops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interstops_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_InterStop>*
SolutionResponse_Route::_internal_mutable_interstops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.interstops_;
}

// repeated float fixedCost = 4;
inline int SolutionResponse_Route::_internal_fixedcost_size() const {
  return _internal_fixedcost().size();
}
inline int SolutionResponse_Route::fixedcost_size() const {
  return _internal_fixedcost_size();
}
inline void SolutionResponse_Route::clear_fixedcost() {
  _internal_mutable_fixedcost()->Clear();
}
inline float SolutionResponse_Route::fixedcost(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.fixedCost)
  return _internal_fixedcost().Get(index);
}
inline void SolutionResponse_Route::set_fixedcost(int index, float value) {
  _internal_mutable_fixedcost()->Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Route.fixedCost)
}
inline void SolutionResponse_Route::add_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fixedcost()->Add(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.fixedCost)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::fixedcost() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.fixedCost)
  return _internal_fixedcost();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::mutable_fixedcost() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.fixedCost)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fixedcost();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::_internal_mutable_fixedcost() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fixedcost_;
}

// repeated .NDD.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
inline int SolutionResponse_Route::_internal_transitruleattributes_size() const {
  return _internal_transitruleattributes().size();
}
inline int SolutionResponse_Route::transitruleattributes_size() const {
  return _internal_transitruleattributes_size();
}
inline void SolutionResponse_Route::clear_transitruleattributes() {
  _internal_mutable_transitruleattributes()->Clear();
}
inline ::NDD::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::mutable_transitruleattributes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Route.transitRuleAttributes)
  return _internal_mutable_transitruleattributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >*
SolutionResponse_Route::mutable_transitruleattributes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Route.transitRuleAttributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleattributes();
}
inline const ::NDD::SolutionResponse_TransitRuleAttribute& SolutionResponse_Route::transitruleattributes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.transitRuleAttributes)
    return _internal_transitruleattributes().Get(index);
}
inline ::NDD::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::add_transitruleattributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_TransitRuleAttribute* _add = _internal_mutable_transitruleattributes()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Route.transitRuleAttributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_TransitRuleAttribute >&
SolutionResponse_Route::transitruleattributes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Route.transitRuleAttributes)
  return _internal_transitruleattributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_TransitRuleAttribute>&
SolutionResponse_Route::_internal_transitruleattributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleattributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_TransitRuleAttribute>*
SolutionResponse_Route::_internal_mutable_transitruleattributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleattributes_;
}

// required int32 day = 6;
inline bool SolutionResponse_Route::has_day() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_day() {
  _impl_.day_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_Route::day() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Route.day)
  return _internal_day();
}
inline void SolutionResponse_Route::set_day(::int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Route.day)
}
inline ::int32_t SolutionResponse_Route::_internal_day() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.day_;
}
inline void SolutionResponse_Route::_internal_set_day(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.day_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility_Info

// required string message = 1;
inline bool SolutionResponse_Infeasibility_Info::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::message() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.message)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.Info.message)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Infeasibility.Info.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Infeasibility.Info.message)
}

// optional string dimId = 2;
inline bool SolutionResponse_Infeasibility_Info::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::dimid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.dimId)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.Info.dimId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Infeasibility.Info.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Infeasibility.Info.dimId)
}

// optional float limit = 3;
inline bool SolutionResponse_Infeasibility_Info::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_limit() {
  _impl_.limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_Infeasibility_Info::limit() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.limit)
  return _internal_limit();
}
inline void SolutionResponse_Infeasibility_Info::set_limit(float value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.limit)
}
inline float SolutionResponse_Infeasibility_Info::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.limit_ = value;
}

// optional float value = 4;
inline bool SolutionResponse_Infeasibility_Info::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_Infeasibility_Info::value() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.value)
  return _internal_value();
}
inline void SolutionResponse_Infeasibility_Info::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.value)
}
inline float SolutionResponse_Infeasibility_Info::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.value_ = value;
}

// optional int64 count = 5;
inline bool SolutionResponse_Infeasibility_Info::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_count() {
  _impl_.count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SolutionResponse_Infeasibility_Info::count() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.count)
  return _internal_count();
}
inline void SolutionResponse_Infeasibility_Info::set_count(::int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.count)
}
inline ::int64_t SolutionResponse_Infeasibility_Info::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_count(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_ = value;
}

// repeated string constrainingTaskIds = 6;
inline int SolutionResponse_Infeasibility_Info::_internal_constrainingtaskids_size() const {
  return _internal_constrainingtaskids().size();
}
inline int SolutionResponse_Infeasibility_Info::constrainingtaskids_size() const {
  return _internal_constrainingtaskids_size();
}
inline void SolutionResponse_Infeasibility_Info::clear_constrainingtaskids() {
  _internal_mutable_constrainingtaskids()->Clear();
}
inline std::string* SolutionResponse_Infeasibility_Info::add_constrainingtaskids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_constrainingtaskids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::constrainingtaskids(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_constrainingtaskids().Get(index);
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_mutable_constrainingtaskids()->Mutable(index);
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const std::string& value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, std::string&& value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, absl::string_view value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::constrainingtaskids() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_constrainingtaskids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_constrainingtaskids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::_internal_constrainingtaskids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.constrainingtaskids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_Infeasibility_Info::_internal_mutable_constrainingtaskids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.constrainingtaskids_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility

// required string taskId = 1;
inline bool SolutionResponse_Infeasibility::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility::taskid() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.Infeasibility.taskId)
}
inline std::string* SolutionResponse_Infeasibility::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.taskId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void SolutionResponse_Infeasibility::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.Infeasibility.taskId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.Infeasibility.taskId)
}

// repeated .NDD.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
inline int SolutionResponse_Infeasibility::_internal_infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo().size();
}
inline int SolutionResponse_Infeasibility::infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo_size();
}
inline void SolutionResponse_Infeasibility::clear_infeasibilityinfo() {
  _internal_mutable_infeasibilityinfo()->Clear();
}
inline ::NDD::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::mutable_infeasibilityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_mutable_infeasibilityinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >*
SolutionResponse_Infeasibility::mutable_infeasibilityinfo() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilityinfo();
}
inline const ::NDD::SolutionResponse_Infeasibility_Info& SolutionResponse_Infeasibility::infeasibilityinfo(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
    return _internal_infeasibilityinfo().Get(index);
}
inline ::NDD::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::add_infeasibilityinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_Infeasibility_Info* _add = _internal_mutable_infeasibilityinfo()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility_Info >&
SolutionResponse_Infeasibility::infeasibilityinfo() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_infeasibilityinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility_Info>&
SolutionResponse_Infeasibility::_internal_infeasibilityinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilityinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility_Info>*
SolutionResponse_Infeasibility::_internal_mutable_infeasibilityinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilityinfo_;
}

// -------------------------------------------------------------------

// SolutionResponse_CompactSolution

// repeated .NDD.TaskSequence taskSequence = 1;
inline int SolutionResponse_CompactSolution::_internal_tasksequence_size() const {
  return _internal_tasksequence().size();
}
inline int SolutionResponse_CompactSolution::tasksequence_size() const {
  return _internal_tasksequence_size();
}
inline void SolutionResponse_CompactSolution::clear_tasksequence() {
  _internal_mutable_tasksequence()->Clear();
}
inline ::NDD::TaskSequence* SolutionResponse_CompactSolution::mutable_tasksequence(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.CompactSolution.taskSequence)
  return _internal_mutable_tasksequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >*
SolutionResponse_CompactSolution::mutable_tasksequence() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.CompactSolution.taskSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasksequence();
}
inline const ::NDD::TaskSequence& SolutionResponse_CompactSolution::tasksequence(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.CompactSolution.taskSequence)
    return _internal_tasksequence().Get(index);
}
inline ::NDD::TaskSequence* SolutionResponse_CompactSolution::add_tasksequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::TaskSequence* _add = _internal_mutable_tasksequence()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.taskSequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::TaskSequence >&
SolutionResponse_CompactSolution::tasksequence() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.CompactSolution.taskSequence)
  return _internal_tasksequence();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>&
SolutionResponse_CompactSolution::_internal_tasksequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasksequence_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::TaskSequence>*
SolutionResponse_CompactSolution::_internal_mutable_tasksequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasksequence_;
}

// repeated float objectives = 2;
inline int SolutionResponse_CompactSolution::_internal_objectives_size() const {
  return _internal_objectives().size();
}
inline int SolutionResponse_CompactSolution::objectives_size() const {
  return _internal_objectives_size();
}
inline void SolutionResponse_CompactSolution::clear_objectives() {
  _internal_mutable_objectives()->Clear();
}
inline float SolutionResponse_CompactSolution::objectives(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.CompactSolution.objectives)
  return _internal_objectives().Get(index);
}
inline void SolutionResponse_CompactSolution::set_objectives(int index, float value) {
  _internal_mutable_objectives()->Set(index, value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.CompactSolution.objectives)
}
inline void SolutionResponse_CompactSolution::add_objectives(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectives()->Add(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.objectives)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_CompactSolution::objectives() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.CompactSolution.objectives)
  return _internal_objectives();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_CompactSolution::mutable_objectives() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.CompactSolution.objectives)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objectives();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_CompactSolution::_internal_objectives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectives_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_CompactSolution::_internal_mutable_objectives() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objectives_;
}

// repeated string objectiveNames = 3;
inline int SolutionResponse_CompactSolution::_internal_objectivenames_size() const {
  return _internal_objectivenames().size();
}
inline int SolutionResponse_CompactSolution::objectivenames_size() const {
  return _internal_objectivenames_size();
}
inline void SolutionResponse_CompactSolution::clear_objectivenames() {
  _internal_mutable_objectivenames()->Clear();
}
inline std::string* SolutionResponse_CompactSolution::add_objectivenames() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_objectivenames()->Add();
  // @@protoc_insertion_point(field_add_mutable:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return _s;
}
inline const std::string& SolutionResponse_CompactSolution::objectivenames(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return _internal_objectivenames().Get(index);
}
inline std::string* SolutionResponse_CompactSolution::mutable_objectivenames(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return _internal_mutable_objectivenames()->Mutable(index);
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const std::string& value) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, std::string&& value) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_objectivenames()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, absl::string_view value) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NDD.SolutionResponse.CompactSolution.objectiveNames)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_CompactSolution::objectivenames() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.CompactSolution.objectiveNames)
  return _internal_objectivenames();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_CompactSolution::mutable_objectivenames() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.CompactSolution.objectiveNames)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objectivenames();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_CompactSolution::_internal_objectivenames() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectivenames_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_CompactSolution::_internal_mutable_objectivenames() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objectivenames_;
}

// -------------------------------------------------------------------

// SolutionResponse_SolutionInstance

// repeated .NDD.SolutionResponse.Route routes = 1;
inline int SolutionResponse_SolutionInstance::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolutionResponse_SolutionInstance::routes_size() const {
  return _internal_routes_size();
}
inline void SolutionResponse_SolutionInstance::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::NDD::SolutionResponse_Route* SolutionResponse_SolutionInstance::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.SolutionInstance.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >*
SolutionResponse_SolutionInstance::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.SolutionInstance.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::NDD::SolutionResponse_Route& SolutionResponse_SolutionInstance::routes(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.SolutionInstance.routes)
    return _internal_routes().Get(index);
}
inline ::NDD::SolutionResponse_Route* SolutionResponse_SolutionInstance::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_Route* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.SolutionInstance.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Route >&
SolutionResponse_SolutionInstance::routes() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.SolutionInstance.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Route>&
SolutionResponse_SolutionInstance::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Route>*
SolutionResponse_SolutionInstance::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// repeated .NDD.SolutionResponse.Infeasibility infeasibilities = 2;
inline int SolutionResponse_SolutionInstance::_internal_infeasibilities_size() const {
  return _internal_infeasibilities().size();
}
inline int SolutionResponse_SolutionInstance::infeasibilities_size() const {
  return _internal_infeasibilities_size();
}
inline void SolutionResponse_SolutionInstance::clear_infeasibilities() {
  _internal_mutable_infeasibilities()->Clear();
}
inline ::NDD::SolutionResponse_Infeasibility* SolutionResponse_SolutionInstance::mutable_infeasibilities(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return _internal_mutable_infeasibilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >*
SolutionResponse_SolutionInstance::mutable_infeasibilities() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilities();
}
inline const ::NDD::SolutionResponse_Infeasibility& SolutionResponse_SolutionInstance::infeasibilities(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.SolutionInstance.infeasibilities)
    return _internal_infeasibilities().Get(index);
}
inline ::NDD::SolutionResponse_Infeasibility* SolutionResponse_SolutionInstance::add_infeasibilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_Infeasibility* _add = _internal_mutable_infeasibilities()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_Infeasibility >&
SolutionResponse_SolutionInstance::infeasibilities() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.SolutionInstance.infeasibilities)
  return _internal_infeasibilities();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility>&
SolutionResponse_SolutionInstance::_internal_infeasibilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilities_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_Infeasibility>*
SolutionResponse_SolutionInstance::_internal_mutable_infeasibilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilities_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated .NDD.SolutionResponse.CompactSolution frontier = 1;
inline int SolutionResponse::_internal_frontier_size() const {
  return _internal_frontier().size();
}
inline int SolutionResponse::frontier_size() const {
  return _internal_frontier_size();
}
inline void SolutionResponse::clear_frontier() {
  _internal_mutable_frontier()->Clear();
}
inline ::NDD::SolutionResponse_CompactSolution* SolutionResponse::mutable_frontier(int index) {
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.frontier)
  return _internal_mutable_frontier()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >*
SolutionResponse::mutable_frontier() {
  // @@protoc_insertion_point(field_mutable_list:NDD.SolutionResponse.frontier)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_frontier();
}
inline const ::NDD::SolutionResponse_CompactSolution& SolutionResponse::frontier(int index) const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.frontier)
    return _internal_frontier().Get(index);
}
inline ::NDD::SolutionResponse_CompactSolution* SolutionResponse::add_frontier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NDD::SolutionResponse_CompactSolution* _add = _internal_mutable_frontier()->Add();
  // @@protoc_insertion_point(field_add:NDD.SolutionResponse.frontier)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NDD::SolutionResponse_CompactSolution >&
SolutionResponse::frontier() const {
  // @@protoc_insertion_point(field_list:NDD.SolutionResponse.frontier)
  return _internal_frontier();
}
inline const ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_CompactSolution>&
SolutionResponse::_internal_frontier() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frontier_;
}
inline ::google::protobuf::RepeatedPtrField<::NDD::SolutionResponse_CompactSolution>*
SolutionResponse::_internal_mutable_frontier() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.frontier_;
}

// optional .NDD.SolutionResponse.SolutionInstance instance = 2;
inline bool SolutionResponse::has_instance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instance_ != nullptr);
  return value;
}
inline void SolutionResponse::clear_instance() {
  if (_impl_.instance_ != nullptr) _impl_.instance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NDD::SolutionResponse_SolutionInstance& SolutionResponse::_internal_instance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NDD::SolutionResponse_SolutionInstance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::NDD::SolutionResponse_SolutionInstance&>(::NDD::_SolutionResponse_SolutionInstance_default_instance_);
}
inline const ::NDD::SolutionResponse_SolutionInstance& SolutionResponse::instance() const {
  // @@protoc_insertion_point(field_get:NDD.SolutionResponse.instance)
  return _internal_instance();
}
inline void SolutionResponse::unsafe_arena_set_allocated_instance(::NDD::SolutionResponse_SolutionInstance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = reinterpret_cast<::NDD::SolutionResponse_SolutionInstance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NDD.SolutionResponse.instance)
}
inline ::NDD::SolutionResponse_SolutionInstance* SolutionResponse::release_instance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::SolutionResponse_SolutionInstance* released = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NDD::SolutionResponse_SolutionInstance* SolutionResponse::unsafe_arena_release_instance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NDD.SolutionResponse.instance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NDD::SolutionResponse_SolutionInstance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::NDD::SolutionResponse_SolutionInstance* SolutionResponse::_internal_mutable_instance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::NDD::SolutionResponse_SolutionInstance>(GetArenaForAllocation());
    _impl_.instance_ = reinterpret_cast<::NDD::SolutionResponse_SolutionInstance*>(p);
  }
  return _impl_.instance_;
}
inline ::NDD::SolutionResponse_SolutionInstance* SolutionResponse::mutable_instance() {
  ::NDD::SolutionResponse_SolutionInstance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:NDD.SolutionResponse.instance)
  return _msg;
}
inline void SolutionResponse::set_allocated_instance(::NDD::SolutionResponse_SolutionInstance* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NDD::SolutionResponse_SolutionInstance*>(_impl_.instance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NDD::SolutionResponse_SolutionInstance*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.instance_ = reinterpret_cast<::NDD::SolutionResponse_SolutionInstance*>(value);
  // @@protoc_insertion_point(field_set_allocated:NDD.SolutionResponse.instance)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace NDD


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::NDD::InternalDimension_eMeasurementUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NDD::InternalDimension_eMeasurementUnit>() {
  return ::NDD::InternalDimension_eMeasurementUnit_descriptor();
}
template <>
struct is_proto_enum<::NDD::Profile_eFrequency> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NDD::Profile_eFrequency>() {
  return ::NDD::Profile_eFrequency_descriptor();
}
template <>
struct is_proto_enum<::NDD::Job_VehicleRelation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NDD::Job_VehicleRelation_Type>() {
  return ::NDD::Job_VehicleRelation_Type_descriptor();
}
template <>
struct is_proto_enum<::NDD::Job_Task_TripConstraint> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NDD::Job_Task_TripConstraint>() {
  return ::NDD::Job_Task_TripConstraint_descriptor();
}
template <>
struct is_proto_enum<::NDD::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NDD::SolveRequest_SolveType>() {
  return ::NDD::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ndd_2dcmibu6krtqja_2eproto_2epb_2eh
