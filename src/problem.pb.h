// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: problem.proto

#ifndef PROTOBUF_INCLUDED_problem_2eproto
#define PROTOBUF_INCLUDED_problem_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_problem_2eproto 

namespace protobuf_problem_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_problem_2eproto
namespace problem {
class ProblemEnvelope;
class ProblemEnvelopeDefaultTypeInternal;
extern ProblemEnvelopeDefaultTypeInternal _ProblemEnvelope_default_instance_;
class SolverInfo;
class SolverInfoDefaultTypeInternal;
extern SolverInfoDefaultTypeInternal _SolverInfo_default_instance_;
class SolverResponse;
class SolverResponseDefaultTypeInternal;
extern SolverResponseDefaultTypeInternal _SolverResponse_default_instance_;
}  // namespace problem
namespace google {
namespace protobuf {
template<> ::problem::ProblemEnvelope* Arena::CreateMaybeMessage<::problem::ProblemEnvelope>(Arena*);
template<> ::problem::SolverInfo* Arena::CreateMaybeMessage<::problem::SolverInfo>(Arena*);
template<> ::problem::SolverResponse* Arena::CreateMaybeMessage<::problem::SolverResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace problem {

enum ProblemEnvelope_SubType {
  ProblemEnvelope_SubType_INPUT = 0,
  ProblemEnvelope_SubType_OUTPUT = 1
};
bool ProblemEnvelope_SubType_IsValid(int value);
const ProblemEnvelope_SubType ProblemEnvelope_SubType_SubType_MIN = ProblemEnvelope_SubType_INPUT;
const ProblemEnvelope_SubType ProblemEnvelope_SubType_SubType_MAX = ProblemEnvelope_SubType_OUTPUT;
const int ProblemEnvelope_SubType_SubType_ARRAYSIZE = ProblemEnvelope_SubType_SubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProblemEnvelope_SubType_descriptor();
inline const ::std::string& ProblemEnvelope_SubType_Name(ProblemEnvelope_SubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProblemEnvelope_SubType_descriptor(), value);
}
inline bool ProblemEnvelope_SubType_Parse(
    const ::std::string& name, ProblemEnvelope_SubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProblemEnvelope_SubType>(
    ProblemEnvelope_SubType_descriptor(), name, value);
}
enum SolverInfo_SolverMessageType {
  SolverInfo_SolverMessageType_INFO = 0,
  SolverInfo_SolverMessageType_WARNING = 1,
  SolverInfo_SolverMessageType_ERROR = 2
};
bool SolverInfo_SolverMessageType_IsValid(int value);
const SolverInfo_SolverMessageType SolverInfo_SolverMessageType_SolverMessageType_MIN = SolverInfo_SolverMessageType_INFO;
const SolverInfo_SolverMessageType SolverInfo_SolverMessageType_SolverMessageType_MAX = SolverInfo_SolverMessageType_ERROR;
const int SolverInfo_SolverMessageType_SolverMessageType_ARRAYSIZE = SolverInfo_SolverMessageType_SolverMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverInfo_SolverMessageType_descriptor();
inline const ::std::string& SolverInfo_SolverMessageType_Name(SolverInfo_SolverMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverInfo_SolverMessageType_descriptor(), value);
}
inline bool SolverInfo_SolverMessageType_Parse(
    const ::std::string& name, SolverInfo_SolverMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverInfo_SolverMessageType>(
    SolverInfo_SolverMessageType_descriptor(), name, value);
}
enum SolverResponse_SolveState {
  SolverResponse_SolveState_WIP = 0,
  SolverResponse_SolveState_COMPLETED = 1,
  SolverResponse_SolveState_FAILED = 2
};
bool SolverResponse_SolveState_IsValid(int value);
const SolverResponse_SolveState SolverResponse_SolveState_SolveState_MIN = SolverResponse_SolveState_WIP;
const SolverResponse_SolveState SolverResponse_SolveState_SolveState_MAX = SolverResponse_SolveState_FAILED;
const int SolverResponse_SolveState_SolveState_ARRAYSIZE = SolverResponse_SolveState_SolveState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverResponse_SolveState_descriptor();
inline const ::std::string& SolverResponse_SolveState_Name(SolverResponse_SolveState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverResponse_SolveState_descriptor(), value);
}
inline bool SolverResponse_SolveState_Parse(
    const ::std::string& name, SolverResponse_SolveState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverResponse_SolveState>(
    SolverResponse_SolveState_descriptor(), name, value);
}
// ===================================================================

class ProblemEnvelope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:problem.ProblemEnvelope) */ {
 public:
  ProblemEnvelope();
  virtual ~ProblemEnvelope();

  ProblemEnvelope(const ProblemEnvelope& from);

  inline ProblemEnvelope& operator=(const ProblemEnvelope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProblemEnvelope(ProblemEnvelope&& from) noexcept
    : ProblemEnvelope() {
    *this = ::std::move(from);
  }

  inline ProblemEnvelope& operator=(ProblemEnvelope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProblemEnvelope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProblemEnvelope* internal_default_instance() {
    return reinterpret_cast<const ProblemEnvelope*>(
               &_ProblemEnvelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ProblemEnvelope* other);
  friend void swap(ProblemEnvelope& a, ProblemEnvelope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProblemEnvelope* New() const final {
    return CreateMaybeMessage<ProblemEnvelope>(NULL);
  }

  ProblemEnvelope* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProblemEnvelope>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProblemEnvelope& from);
  void MergeFrom(const ProblemEnvelope& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProblemEnvelope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProblemEnvelope_SubType SubType;
  static const SubType INPUT =
    ProblemEnvelope_SubType_INPUT;
  static const SubType OUTPUT =
    ProblemEnvelope_SubType_OUTPUT;
  static inline bool SubType_IsValid(int value) {
    return ProblemEnvelope_SubType_IsValid(value);
  }
  static const SubType SubType_MIN =
    ProblemEnvelope_SubType_SubType_MIN;
  static const SubType SubType_MAX =
    ProblemEnvelope_SubType_SubType_MAX;
  static const int SubType_ARRAYSIZE =
    ProblemEnvelope_SubType_SubType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SubType_descriptor() {
    return ProblemEnvelope_SubType_descriptor();
  }
  static inline const ::std::string& SubType_Name(SubType value) {
    return ProblemEnvelope_SubType_Name(value);
  }
  static inline bool SubType_Parse(const ::std::string& name,
      SubType* value) {
    return ProblemEnvelope_SubType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional bytes content = 3;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required .problem.ProblemEnvelope.SubType subType = 2 [default = INPUT];
  bool has_subtype() const;
  void clear_subtype();
  static const int kSubTypeFieldNumber = 2;
  ::problem::ProblemEnvelope_SubType subtype() const;
  void set_subtype(::problem::ProblemEnvelope_SubType value);

  // @@protoc_insertion_point(class_scope:problem.ProblemEnvelope)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_subtype();
  void clear_has_subtype();
  void set_has_content();
  void clear_has_content();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  int subtype_;
  friend struct ::protobuf_problem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolverInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:problem.SolverInfo) */ {
 public:
  SolverInfo();
  virtual ~SolverInfo();

  SolverInfo(const SolverInfo& from);

  inline SolverInfo& operator=(const SolverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolverInfo(SolverInfo&& from) noexcept
    : SolverInfo() {
    *this = ::std::move(from);
  }

  inline SolverInfo& operator=(SolverInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolverInfo* internal_default_instance() {
    return reinterpret_cast<const SolverInfo*>(
               &_SolverInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SolverInfo* other);
  friend void swap(SolverInfo& a, SolverInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolverInfo* New() const final {
    return CreateMaybeMessage<SolverInfo>(NULL);
  }

  SolverInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolverInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolverInfo& from);
  void MergeFrom(const SolverInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolverInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolverInfo_SolverMessageType SolverMessageType;
  static const SolverMessageType INFO =
    SolverInfo_SolverMessageType_INFO;
  static const SolverMessageType WARNING =
    SolverInfo_SolverMessageType_WARNING;
  static const SolverMessageType ERROR =
    SolverInfo_SolverMessageType_ERROR;
  static inline bool SolverMessageType_IsValid(int value) {
    return SolverInfo_SolverMessageType_IsValid(value);
  }
  static const SolverMessageType SolverMessageType_MIN =
    SolverInfo_SolverMessageType_SolverMessageType_MIN;
  static const SolverMessageType SolverMessageType_MAX =
    SolverInfo_SolverMessageType_SolverMessageType_MAX;
  static const int SolverMessageType_ARRAYSIZE =
    SolverInfo_SolverMessageType_SolverMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolverMessageType_descriptor() {
    return SolverInfo_SolverMessageType_descriptor();
  }
  static inline const ::std::string& SolverMessageType_Name(SolverMessageType value) {
    return SolverInfo_SolverMessageType_Name(value);
  }
  static inline bool SolverMessageType_Parse(const ::std::string& name,
      SolverMessageType* value) {
    return SolverInfo_SolverMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string infoMessage = 2;
  bool has_infomessage() const;
  void clear_infomessage();
  static const int kInfoMessageFieldNumber = 2;
  const ::std::string& infomessage() const;
  void set_infomessage(const ::std::string& value);
  #if LANG_CXX11
  void set_infomessage(::std::string&& value);
  #endif
  void set_infomessage(const char* value);
  void set_infomessage(const char* value, size_t size);
  ::std::string* mutable_infomessage();
  ::std::string* release_infomessage();
  void set_allocated_infomessage(::std::string* infomessage);

  // required int64 unixDateTime = 1;
  bool has_unixdatetime() const;
  void clear_unixdatetime();
  static const int kUnixDateTimeFieldNumber = 1;
  ::google::protobuf::int64 unixdatetime() const;
  void set_unixdatetime(::google::protobuf::int64 value);

  // required .problem.SolverInfo.SolverMessageType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::problem::SolverInfo_SolverMessageType type() const;
  void set_type(::problem::SolverInfo_SolverMessageType value);

  // @@protoc_insertion_point(class_scope:problem.SolverInfo)
 private:
  void set_has_unixdatetime();
  void clear_has_unixdatetime();
  void set_has_infomessage();
  void clear_has_infomessage();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr infomessage_;
  ::google::protobuf::int64 unixdatetime_;
  int type_;
  friend struct ::protobuf_problem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolverResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:problem.SolverResponse) */ {
 public:
  SolverResponse();
  virtual ~SolverResponse();

  SolverResponse(const SolverResponse& from);

  inline SolverResponse& operator=(const SolverResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolverResponse(SolverResponse&& from) noexcept
    : SolverResponse() {
    *this = ::std::move(from);
  }

  inline SolverResponse& operator=(SolverResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolverResponse* internal_default_instance() {
    return reinterpret_cast<const SolverResponse*>(
               &_SolverResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SolverResponse* other);
  friend void swap(SolverResponse& a, SolverResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolverResponse* New() const final {
    return CreateMaybeMessage<SolverResponse>(NULL);
  }

  SolverResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolverResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolverResponse& from);
  void MergeFrom(const SolverResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolverResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolverResponse_SolveState SolveState;
  static const SolveState WIP =
    SolverResponse_SolveState_WIP;
  static const SolveState COMPLETED =
    SolverResponse_SolveState_COMPLETED;
  static const SolveState FAILED =
    SolverResponse_SolveState_FAILED;
  static inline bool SolveState_IsValid(int value) {
    return SolverResponse_SolveState_IsValid(value);
  }
  static const SolveState SolveState_MIN =
    SolverResponse_SolveState_SolveState_MIN;
  static const SolveState SolveState_MAX =
    SolverResponse_SolveState_SolveState_MAX;
  static const int SolveState_ARRAYSIZE =
    SolverResponse_SolveState_SolveState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveState_descriptor() {
    return SolverResponse_SolveState_descriptor();
  }
  static inline const ::std::string& SolveState_Name(SolveState value) {
    return SolverResponse_SolveState_Name(value);
  }
  static inline bool SolveState_Parse(const ::std::string& name,
      SolveState* value) {
    return SolverResponse_SolveState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .problem.SolverInfo logs = 1;
  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 1;
  ::problem::SolverInfo* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField< ::problem::SolverInfo >*
      mutable_logs();
  const ::problem::SolverInfo& logs(int index) const;
  ::problem::SolverInfo* add_logs();
  const ::google::protobuf::RepeatedPtrField< ::problem::SolverInfo >&
      logs() const;

  // optional bytes solution = 3;
  bool has_solution() const;
  void clear_solution();
  static const int kSolutionFieldNumber = 3;
  const ::std::string& solution() const;
  void set_solution(const ::std::string& value);
  #if LANG_CXX11
  void set_solution(::std::string&& value);
  #endif
  void set_solution(const char* value);
  void set_solution(const void* value, size_t size);
  ::std::string* mutable_solution();
  ::std::string* release_solution();
  void set_allocated_solution(::std::string* solution);

  // required .problem.SolverResponse.SolveState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::problem::SolverResponse_SolveState state() const;
  void set_state(::problem::SolverResponse_SolveState value);

  // @@protoc_insertion_point(class_scope:problem.SolverResponse)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_solution();
  void clear_has_solution();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::problem::SolverInfo > logs_;
  ::google::protobuf::internal::ArenaStringPtr solution_;
  int state_;
  friend struct ::protobuf_problem_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProblemEnvelope

// required string type = 1;
inline bool ProblemEnvelope::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProblemEnvelope::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProblemEnvelope::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProblemEnvelope::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& ProblemEnvelope::type() const {
  // @@protoc_insertion_point(field_get:problem.ProblemEnvelope.type)
  return type_.GetNoArena();
}
inline void ProblemEnvelope::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:problem.ProblemEnvelope.type)
}
#if LANG_CXX11
inline void ProblemEnvelope::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:problem.ProblemEnvelope.type)
}
#endif
inline void ProblemEnvelope::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:problem.ProblemEnvelope.type)
}
inline void ProblemEnvelope::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:problem.ProblemEnvelope.type)
}
inline ::std::string* ProblemEnvelope::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:problem.ProblemEnvelope.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProblemEnvelope::release_type() {
  // @@protoc_insertion_point(field_release:problem.ProblemEnvelope.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProblemEnvelope::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:problem.ProblemEnvelope.type)
}

// required .problem.ProblemEnvelope.SubType subType = 2 [default = INPUT];
inline bool ProblemEnvelope::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProblemEnvelope::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProblemEnvelope::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProblemEnvelope::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::problem::ProblemEnvelope_SubType ProblemEnvelope::subtype() const {
  // @@protoc_insertion_point(field_get:problem.ProblemEnvelope.subType)
  return static_cast< ::problem::ProblemEnvelope_SubType >(subtype_);
}
inline void ProblemEnvelope::set_subtype(::problem::ProblemEnvelope_SubType value) {
  assert(::problem::ProblemEnvelope_SubType_IsValid(value));
  set_has_subtype();
  subtype_ = value;
  // @@protoc_insertion_point(field_set:problem.ProblemEnvelope.subType)
}

// optional bytes content = 3;
inline bool ProblemEnvelope::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProblemEnvelope::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProblemEnvelope::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProblemEnvelope::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ProblemEnvelope::content() const {
  // @@protoc_insertion_point(field_get:problem.ProblemEnvelope.content)
  return content_.GetNoArena();
}
inline void ProblemEnvelope::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:problem.ProblemEnvelope.content)
}
#if LANG_CXX11
inline void ProblemEnvelope::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:problem.ProblemEnvelope.content)
}
#endif
inline void ProblemEnvelope::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:problem.ProblemEnvelope.content)
}
inline void ProblemEnvelope::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:problem.ProblemEnvelope.content)
}
inline ::std::string* ProblemEnvelope::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:problem.ProblemEnvelope.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProblemEnvelope::release_content() {
  // @@protoc_insertion_point(field_release:problem.ProblemEnvelope.content)
  if (!has_content()) {
    return NULL;
  }
  clear_has_content();
  return content_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProblemEnvelope::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:problem.ProblemEnvelope.content)
}

// -------------------------------------------------------------------

// SolverInfo

// required int64 unixDateTime = 1;
inline bool SolverInfo::has_unixdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverInfo::set_has_unixdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverInfo::clear_has_unixdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverInfo::clear_unixdatetime() {
  unixdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_unixdatetime();
}
inline ::google::protobuf::int64 SolverInfo::unixdatetime() const {
  // @@protoc_insertion_point(field_get:problem.SolverInfo.unixDateTime)
  return unixdatetime_;
}
inline void SolverInfo::set_unixdatetime(::google::protobuf::int64 value) {
  set_has_unixdatetime();
  unixdatetime_ = value;
  // @@protoc_insertion_point(field_set:problem.SolverInfo.unixDateTime)
}

// required string infoMessage = 2;
inline bool SolverInfo::has_infomessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverInfo::set_has_infomessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverInfo::clear_has_infomessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverInfo::clear_infomessage() {
  infomessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infomessage();
}
inline const ::std::string& SolverInfo::infomessage() const {
  // @@protoc_insertion_point(field_get:problem.SolverInfo.infoMessage)
  return infomessage_.GetNoArena();
}
inline void SolverInfo::set_infomessage(const ::std::string& value) {
  set_has_infomessage();
  infomessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:problem.SolverInfo.infoMessage)
}
#if LANG_CXX11
inline void SolverInfo::set_infomessage(::std::string&& value) {
  set_has_infomessage();
  infomessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:problem.SolverInfo.infoMessage)
}
#endif
inline void SolverInfo::set_infomessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_infomessage();
  infomessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:problem.SolverInfo.infoMessage)
}
inline void SolverInfo::set_infomessage(const char* value, size_t size) {
  set_has_infomessage();
  infomessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:problem.SolverInfo.infoMessage)
}
inline ::std::string* SolverInfo::mutable_infomessage() {
  set_has_infomessage();
  // @@protoc_insertion_point(field_mutable:problem.SolverInfo.infoMessage)
  return infomessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolverInfo::release_infomessage() {
  // @@protoc_insertion_point(field_release:problem.SolverInfo.infoMessage)
  if (!has_infomessage()) {
    return NULL;
  }
  clear_has_infomessage();
  return infomessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolverInfo::set_allocated_infomessage(::std::string* infomessage) {
  if (infomessage != NULL) {
    set_has_infomessage();
  } else {
    clear_has_infomessage();
  }
  infomessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infomessage);
  // @@protoc_insertion_point(field_set_allocated:problem.SolverInfo.infoMessage)
}

// required .problem.SolverInfo.SolverMessageType type = 3;
inline bool SolverInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::problem::SolverInfo_SolverMessageType SolverInfo::type() const {
  // @@protoc_insertion_point(field_get:problem.SolverInfo.type)
  return static_cast< ::problem::SolverInfo_SolverMessageType >(type_);
}
inline void SolverInfo::set_type(::problem::SolverInfo_SolverMessageType value) {
  assert(::problem::SolverInfo_SolverMessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:problem.SolverInfo.type)
}

// -------------------------------------------------------------------

// SolverResponse

// repeated .problem.SolverInfo logs = 1;
inline int SolverResponse::logs_size() const {
  return logs_.size();
}
inline void SolverResponse::clear_logs() {
  logs_.Clear();
}
inline ::problem::SolverInfo* SolverResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:problem.SolverResponse.logs)
  return logs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::problem::SolverInfo >*
SolverResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:problem.SolverResponse.logs)
  return &logs_;
}
inline const ::problem::SolverInfo& SolverResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:problem.SolverResponse.logs)
  return logs_.Get(index);
}
inline ::problem::SolverInfo* SolverResponse::add_logs() {
  // @@protoc_insertion_point(field_add:problem.SolverResponse.logs)
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::problem::SolverInfo >&
SolverResponse::logs() const {
  // @@protoc_insertion_point(field_list:problem.SolverResponse.logs)
  return logs_;
}

// required .problem.SolverResponse.SolveState state = 2;
inline bool SolverResponse::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverResponse::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::problem::SolverResponse_SolveState SolverResponse::state() const {
  // @@protoc_insertion_point(field_get:problem.SolverResponse.state)
  return static_cast< ::problem::SolverResponse_SolveState >(state_);
}
inline void SolverResponse::set_state(::problem::SolverResponse_SolveState value) {
  assert(::problem::SolverResponse_SolveState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:problem.SolverResponse.state)
}

// optional bytes solution = 3;
inline bool SolverResponse::has_solution() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverResponse::set_has_solution() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverResponse::clear_has_solution() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverResponse::clear_solution() {
  solution_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_solution();
}
inline const ::std::string& SolverResponse::solution() const {
  // @@protoc_insertion_point(field_get:problem.SolverResponse.solution)
  return solution_.GetNoArena();
}
inline void SolverResponse::set_solution(const ::std::string& value) {
  set_has_solution();
  solution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:problem.SolverResponse.solution)
}
#if LANG_CXX11
inline void SolverResponse::set_solution(::std::string&& value) {
  set_has_solution();
  solution_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:problem.SolverResponse.solution)
}
#endif
inline void SolverResponse::set_solution(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_solution();
  solution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:problem.SolverResponse.solution)
}
inline void SolverResponse::set_solution(const void* value, size_t size) {
  set_has_solution();
  solution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:problem.SolverResponse.solution)
}
inline ::std::string* SolverResponse::mutable_solution() {
  set_has_solution();
  // @@protoc_insertion_point(field_mutable:problem.SolverResponse.solution)
  return solution_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolverResponse::release_solution() {
  // @@protoc_insertion_point(field_release:problem.SolverResponse.solution)
  if (!has_solution()) {
    return NULL;
  }
  clear_has_solution();
  return solution_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolverResponse::set_allocated_solution(::std::string* solution) {
  if (solution != NULL) {
    set_has_solution();
  } else {
    clear_has_solution();
  }
  solution_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), solution);
  // @@protoc_insertion_point(field_set_allocated:problem.SolverResponse.solution)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace problem

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::problem::ProblemEnvelope_SubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::problem::ProblemEnvelope_SubType>() {
  return ::problem::ProblemEnvelope_SubType_descriptor();
}
template <> struct is_proto_enum< ::problem::SolverInfo_SolverMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::problem::SolverInfo_SolverMessageType>() {
  return ::problem::SolverInfo_SolverMessageType_descriptor();
}
template <> struct is_proto_enum< ::problem::SolverResponse_SolveState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::problem::SolverResponse_SolveState>() {
  return ::problem::SolverResponse_SolveState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_problem_2eproto
