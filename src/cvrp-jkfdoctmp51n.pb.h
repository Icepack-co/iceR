// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cvrp-jkfdoctmp51n.proto

#ifndef PROTOBUF_INCLUDED_cvrp_2djkfdoctmp51n_2eproto
#define PROTOBUF_INCLUDED_cvrp_2djkfdoctmp51n_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cvrp_2djkfdoctmp51n_2eproto 

namespace protobuf_cvrp_2djkfdoctmp51n_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cvrp_2djkfdoctmp51n_2eproto
namespace CVRP {
class CVRP;
class CVRPDefaultTypeInternal;
extern CVRPDefaultTypeInternal _CVRP_default_instance_;
class Edge;
class EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Edge_Geometry;
class Edge_GeometryDefaultTypeInternal;
extern Edge_GeometryDefaultTypeInternal _Edge_Geometry_default_instance_;
class Geocode;
class GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class SolutionResponse;
class SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Route;
class SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolveRequest;
class SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
}  // namespace CVRP
namespace google {
namespace protobuf {
template<> ::CVRP::CVRP* Arena::CreateMaybeMessage<::CVRP::CVRP>(Arena*);
template<> ::CVRP::Edge* Arena::CreateMaybeMessage<::CVRP::Edge>(Arena*);
template<> ::CVRP::Edge_Geometry* Arena::CreateMaybeMessage<::CVRP::Edge_Geometry>(Arena*);
template<> ::CVRP::Geocode* Arena::CreateMaybeMessage<::CVRP::Geocode>(Arena*);
template<> ::CVRP::SolutionResponse* Arena::CreateMaybeMessage<::CVRP::SolutionResponse>(Arena*);
template<> ::CVRP::SolutionResponse_Route* Arena::CreateMaybeMessage<::CVRP::SolutionResponse_Route>(Arena*);
template<> ::CVRP::SolveRequest* Arena::CreateMaybeMessage<::CVRP::SolveRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace CVRP {

enum CVRP_eDistanceType {
  CVRP_eDistanceType_RoadNetwork = 1,
  CVRP_eDistanceType_Euclidean = 2,
  CVRP_eDistanceType_Haversine = 3
};
bool CVRP_eDistanceType_IsValid(int value);
const CVRP_eDistanceType CVRP_eDistanceType_eDistanceType_MIN = CVRP_eDistanceType_RoadNetwork;
const CVRP_eDistanceType CVRP_eDistanceType_eDistanceType_MAX = CVRP_eDistanceType_Haversine;
const int CVRP_eDistanceType_eDistanceType_ARRAYSIZE = CVRP_eDistanceType_eDistanceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CVRP_eDistanceType_descriptor();
inline const ::std::string& CVRP_eDistanceType_Name(CVRP_eDistanceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CVRP_eDistanceType_descriptor(), value);
}
inline bool CVRP_eDistanceType_Parse(
    const ::std::string& name, CVRP_eDistanceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CVRP_eDistanceType>(
    CVRP_eDistanceType_descriptor(), name, value);
}
enum SolveRequest_SolveType {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2
};
bool SolveRequest_SolveType_IsValid(int value);
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = SolveRequest_SolveType_Optimise;
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = SolveRequest_SolveType_ReOptimise;
const int SolveRequest_SolveType_SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor();
inline const ::std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_SolveType_descriptor(), value);
}
inline bool SolveRequest_SolveType_Parse(
    const ::std::string& name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
    SolveRequest_SolveType_descriptor(), name, value);
}
// ===================================================================

class Geocode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.Geocode) */ {
 public:
  Geocode();
  virtual ~Geocode();

  Geocode(const Geocode& from);

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(Geocode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geocode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Geocode* other);
  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geocode* New() const final {
    return CreateMaybeMessage<Geocode>(NULL);
  }

  Geocode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geocode& from);
  void MergeFrom(const Geocode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required float x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // required float y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // required float quantity = 4 [default = 0];
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  float quantity() const;
  void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:CVRP.Geocode)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_quantity();
  void clear_has_quantity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  float x_;
  float y_;
  float quantity_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVRP : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.CVRP) */ {
 public:
  CVRP();
  virtual ~CVRP();

  CVRP(const CVRP& from);

  inline CVRP& operator=(const CVRP& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVRP(CVRP&& from) noexcept
    : CVRP() {
    *this = ::std::move(from);
  }

  inline CVRP& operator=(CVRP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVRP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVRP* internal_default_instance() {
    return reinterpret_cast<const CVRP*>(
               &_CVRP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CVRP* other);
  friend void swap(CVRP& a, CVRP& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVRP* New() const final {
    return CreateMaybeMessage<CVRP>(NULL);
  }

  CVRP* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVRP>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVRP& from);
  void MergeFrom(const CVRP& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVRP* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CVRP_eDistanceType eDistanceType;
  static const eDistanceType RoadNetwork =
    CVRP_eDistanceType_RoadNetwork;
  static const eDistanceType Euclidean =
    CVRP_eDistanceType_Euclidean;
  static const eDistanceType Haversine =
    CVRP_eDistanceType_Haversine;
  static inline bool eDistanceType_IsValid(int value) {
    return CVRP_eDistanceType_IsValid(value);
  }
  static const eDistanceType eDistanceType_MIN =
    CVRP_eDistanceType_eDistanceType_MIN;
  static const eDistanceType eDistanceType_MAX =
    CVRP_eDistanceType_eDistanceType_MAX;
  static const int eDistanceType_ARRAYSIZE =
    CVRP_eDistanceType_eDistanceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eDistanceType_descriptor() {
    return CVRP_eDistanceType_descriptor();
  }
  static inline const ::std::string& eDistanceType_Name(eDistanceType value) {
    return CVRP_eDistanceType_Name(value);
  }
  static inline bool eDistanceType_Parse(const ::std::string& name,
      eDistanceType* value) {
    return CVRP_eDistanceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .CVRP.Geocode points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::CVRP::Geocode* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRP::Geocode >*
      mutable_points();
  const ::CVRP::Geocode& points(int index) const;
  ::CVRP::Geocode* add_points();
  const ::google::protobuf::RepeatedPtrField< ::CVRP::Geocode >&
      points() const;

  // required .CVRP.Geocode depot = 2;
  bool has_depot() const;
  void clear_depot();
  static const int kDepotFieldNumber = 2;
  private:
  const ::CVRP::Geocode& _internal_depot() const;
  public:
  const ::CVRP::Geocode& depot() const;
  ::CVRP::Geocode* release_depot();
  ::CVRP::Geocode* mutable_depot();
  void set_allocated_depot(::CVRP::Geocode* depot);

  // required int32 NumberOfVehicles = 3;
  bool has_numberofvehicles() const;
  void clear_numberofvehicles();
  static const int kNumberOfVehiclesFieldNumber = 3;
  ::google::protobuf::int32 numberofvehicles() const;
  void set_numberofvehicles(::google::protobuf::int32 value);

  // required float VehicleCapacity = 4;
  bool has_vehiclecapacity() const;
  void clear_vehiclecapacity();
  static const int kVehicleCapacityFieldNumber = 4;
  float vehiclecapacity() const;
  void set_vehiclecapacity(float value);

  // optional .CVRP.CVRP.eDistanceType distancetype = 5 [default = RoadNetwork];
  bool has_distancetype() const;
  void clear_distancetype();
  static const int kDistancetypeFieldNumber = 5;
  ::CVRP::CVRP_eDistanceType distancetype() const;
  void set_distancetype(::CVRP::CVRP_eDistanceType value);

  // @@protoc_insertion_point(class_scope:CVRP.CVRP)
 private:
  void set_has_depot();
  void clear_has_depot();
  void set_has_numberofvehicles();
  void clear_has_numberofvehicles();
  void set_has_vehiclecapacity();
  void clear_has_vehiclecapacity();
  void set_has_distancetype();
  void clear_has_distancetype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CVRP::Geocode > points_;
  ::CVRP::Geocode* depot_;
  ::google::protobuf::int32 numberofvehicles_;
  float vehiclecapacity_;
  int distancetype_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.SolveRequest) */ {
 public:
  SolveRequest();
  virtual ~SolveRequest();

  SolveRequest(const SolveRequest& from);

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SolveRequest* other);
  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolveRequest* New() const final {
    return CreateMaybeMessage<SolveRequest>(NULL);
  }

  SolveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolveRequest& from);
  void MergeFrom(const SolveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolveRequest_SolveType SolveType;
  static const SolveType Optimise =
    SolveRequest_SolveType_Optimise;
  static const SolveType Evaluate =
    SolveRequest_SolveType_Evaluate;
  static const SolveType ReOptimise =
    SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static const SolveType SolveType_MIN =
    SolveRequest_SolveType_SolveType_MIN;
  static const SolveType SolveType_MAX =
    SolveRequest_SolveType_SolveType_MAX;
  static const int SolveType_ARRAYSIZE =
    SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  static inline const ::std::string& SolveType_Name(SolveType value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(const ::std::string& name,
      SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string visitSequence = 3;
  int visitsequence_size() const;
  void clear_visitsequence();
  static const int kVisitSequenceFieldNumber = 3;
  const ::std::string& visitsequence(int index) const;
  ::std::string* mutable_visitsequence(int index);
  void set_visitsequence(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_visitsequence(int index, ::std::string&& value);
  #endif
  void set_visitsequence(int index, const char* value);
  void set_visitsequence(int index, const char* value, size_t size);
  ::std::string* add_visitsequence();
  void add_visitsequence(const ::std::string& value);
  #if LANG_CXX11
  void add_visitsequence(::std::string&& value);
  #endif
  void add_visitsequence(const char* value);
  void add_visitsequence(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& visitsequence() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_visitsequence();

  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIDFieldNumber = 2;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // optional .CVRP.CVRP model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  private:
  const ::CVRP::CVRP& _internal_model() const;
  public:
  const ::CVRP::CVRP& model() const;
  ::CVRP::CVRP* release_model();
  ::CVRP::CVRP* mutable_model();
  void set_allocated_model(::CVRP::CVRP* model);

  // optional .CVRP.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype();
  static const int kSolveTypeFieldNumber = 4;
  ::CVRP::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::CVRP::SolveRequest_SolveType value);

  // @@protoc_insertion_point(class_scope:CVRP.SolveRequest)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_modelid();
  void clear_has_modelid();
  void set_has_solvetype();
  void clear_has_solvetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> visitsequence_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  ::CVRP::CVRP* model_;
  int solvetype_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge_Geometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.Edge.Geometry) */ {
 public:
  Edge_Geometry();
  virtual ~Edge_Geometry();

  Edge_Geometry(const Edge_Geometry& from);

  inline Edge_Geometry& operator=(const Edge_Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edge_Geometry(Edge_Geometry&& from) noexcept
    : Edge_Geometry() {
    *this = ::std::move(from);
  }

  inline Edge_Geometry& operator=(Edge_Geometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge_Geometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edge_Geometry* internal_default_instance() {
    return reinterpret_cast<const Edge_Geometry*>(
               &_Edge_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Edge_Geometry* other);
  friend void swap(Edge_Geometry& a, Edge_Geometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edge_Geometry* New() const final {
    return CreateMaybeMessage<Edge_Geometry>(NULL);
  }

  Edge_Geometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edge_Geometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edge_Geometry& from);
  void MergeFrom(const Edge_Geometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge_Geometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:CVRP.Edge.Geometry)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(Edge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Edge* other);
  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edge* New() const final {
    return CreateMaybeMessage<Edge>(NULL);
  }

  Edge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Edge_Geometry Geometry;

  // accessors -------------------------------------------------------

  // repeated .CVRP.Edge.Geometry geometry = 4;
  int geometry_size() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 4;
  ::CVRP::Edge_Geometry* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRP::Edge_Geometry >*
      mutable_geometry();
  const ::CVRP::Edge_Geometry& geometry(int index) const;
  ::CVRP::Edge_Geometry* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::CVRP::Edge_Geometry >&
      geometry() const;

  // required string from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // required string to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional float distance = 3;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:CVRP.Edge)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_distance();
  void clear_has_distance();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CVRP::Edge_Geometry > geometry_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  float distance_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.SolutionResponse.Route) */ {
 public:
  SolutionResponse_Route();
  virtual ~SolutionResponse_Route();

  SolutionResponse_Route(const SolutionResponse_Route& from);

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Route& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SolutionResponse_Route* other);
  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Route* New() const final {
    return CreateMaybeMessage<SolutionResponse_Route>(NULL);
  }

  SolutionResponse_Route* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Route& from);
  void MergeFrom(const SolutionResponse_Route& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sequence = 1;
  int sequence_size() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence(int index) const;
  ::std::string* mutable_sequence(int index);
  void set_sequence(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sequence(int index, ::std::string&& value);
  #endif
  void set_sequence(int index, const char* value);
  void set_sequence(int index, const char* value, size_t size);
  ::std::string* add_sequence();
  void add_sequence(const ::std::string& value);
  #if LANG_CXX11
  void add_sequence(::std::string&& value);
  #endif
  void add_sequence(const char* value);
  void add_sequence(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sequence() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sequence();

  // repeated .CVRP.Edge edges = 2;
  int edges_size() const;
  void clear_edges();
  static const int kEdgesFieldNumber = 2;
  ::CVRP::Edge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRP::Edge >*
      mutable_edges();
  const ::CVRP::Edge& edges(int index) const;
  ::CVRP::Edge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::CVRP::Edge >&
      edges() const;

  // repeated float visitCapacities = 3;
  int visitcapacities_size() const;
  void clear_visitcapacities();
  static const int kVisitCapacitiesFieldNumber = 3;
  float visitcapacities(int index) const;
  void set_visitcapacities(int index, float value);
  void add_visitcapacities(float value);
  const ::google::protobuf::RepeatedField< float >&
      visitcapacities() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_visitcapacities();

  // @@protoc_insertion_point(class_scope:CVRP.SolutionResponse.Route)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sequence_;
  ::google::protobuf::RepeatedPtrField< ::CVRP::Edge > edges_;
  ::google::protobuf::RepeatedField< float > visitcapacities_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVRP.SolutionResponse) */ {
 public:
  SolutionResponse();
  virtual ~SolutionResponse();

  SolutionResponse(const SolutionResponse& from);

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SolutionResponse* other);
  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse* New() const final {
    return CreateMaybeMessage<SolutionResponse>(NULL);
  }

  SolutionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse& from);
  void MergeFrom(const SolutionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Route Route;

  // accessors -------------------------------------------------------

  // repeated .CVRP.SolutionResponse.Route routes = 1;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 1;
  ::CVRP::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::CVRP::SolutionResponse_Route >*
      mutable_routes();
  const ::CVRP::SolutionResponse_Route& routes(int index) const;
  ::CVRP::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::CVRP::SolutionResponse_Route >&
      routes() const;

  // required float objective = 2;
  bool has_objective() const;
  void clear_objective();
  static const int kObjectiveFieldNumber = 2;
  float objective() const;
  void set_objective(float value);

  // @@protoc_insertion_point(class_scope:CVRP.SolutionResponse)
 private:
  void set_has_objective();
  void clear_has_objective();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CVRP::SolutionResponse_Route > routes_;
  float objective_;
  friend struct ::protobuf_cvrp_2djkfdoctmp51n_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Geocode

// required string id = 1;
inline bool Geocode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geocode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geocode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geocode::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Geocode::id() const {
  // @@protoc_insertion_point(field_get:CVRP.Geocode.id)
  return id_.GetNoArena();
}
inline void Geocode::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVRP.Geocode.id)
}
#if LANG_CXX11
inline void Geocode::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVRP.Geocode.id)
}
#endif
inline void Geocode::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVRP.Geocode.id)
}
inline void Geocode::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVRP.Geocode.id)
}
inline ::std::string* Geocode::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:CVRP.Geocode.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Geocode::release_id() {
  // @@protoc_insertion_point(field_release:CVRP.Geocode.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Geocode::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:CVRP.Geocode.id)
}

// required float x = 2;
inline bool Geocode::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geocode::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geocode::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geocode::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Geocode::x() const {
  // @@protoc_insertion_point(field_get:CVRP.Geocode.x)
  return x_;
}
inline void Geocode::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:CVRP.Geocode.x)
}

// required float y = 3;
inline bool Geocode::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Geocode::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Geocode::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Geocode::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Geocode::y() const {
  // @@protoc_insertion_point(field_get:CVRP.Geocode.y)
  return y_;
}
inline void Geocode::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:CVRP.Geocode.y)
}

// required float quantity = 4 [default = 0];
inline bool Geocode::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Geocode::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Geocode::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Geocode::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float Geocode::quantity() const {
  // @@protoc_insertion_point(field_get:CVRP.Geocode.quantity)
  return quantity_;
}
inline void Geocode::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:CVRP.Geocode.quantity)
}

// -------------------------------------------------------------------

// CVRP

// repeated .CVRP.Geocode points = 1;
inline int CVRP::points_size() const {
  return points_.size();
}
inline void CVRP::clear_points() {
  points_.Clear();
}
inline ::CVRP::Geocode* CVRP::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:CVRP.CVRP.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRP::Geocode >*
CVRP::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.CVRP.points)
  return &points_;
}
inline const ::CVRP::Geocode& CVRP::points(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.CVRP.points)
  return points_.Get(index);
}
inline ::CVRP::Geocode* CVRP::add_points() {
  // @@protoc_insertion_point(field_add:CVRP.CVRP.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRP::Geocode >&
CVRP::points() const {
  // @@protoc_insertion_point(field_list:CVRP.CVRP.points)
  return points_;
}

// required .CVRP.Geocode depot = 2;
inline bool CVRP::has_depot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVRP::set_has_depot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVRP::clear_has_depot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVRP::clear_depot() {
  if (depot_ != NULL) depot_->Clear();
  clear_has_depot();
}
inline const ::CVRP::Geocode& CVRP::_internal_depot() const {
  return *depot_;
}
inline const ::CVRP::Geocode& CVRP::depot() const {
  const ::CVRP::Geocode* p = depot_;
  // @@protoc_insertion_point(field_get:CVRP.CVRP.depot)
  return p != NULL ? *p : *reinterpret_cast<const ::CVRP::Geocode*>(
      &::CVRP::_Geocode_default_instance_);
}
inline ::CVRP::Geocode* CVRP::release_depot() {
  // @@protoc_insertion_point(field_release:CVRP.CVRP.depot)
  clear_has_depot();
  ::CVRP::Geocode* temp = depot_;
  depot_ = NULL;
  return temp;
}
inline ::CVRP::Geocode* CVRP::mutable_depot() {
  set_has_depot();
  if (depot_ == NULL) {
    auto* p = CreateMaybeMessage<::CVRP::Geocode>(GetArenaNoVirtual());
    depot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CVRP.CVRP.depot)
  return depot_;
}
inline void CVRP::set_allocated_depot(::CVRP::Geocode* depot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete depot_;
  }
  if (depot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      depot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, depot, submessage_arena);
    }
    set_has_depot();
  } else {
    clear_has_depot();
  }
  depot_ = depot;
  // @@protoc_insertion_point(field_set_allocated:CVRP.CVRP.depot)
}

// required int32 NumberOfVehicles = 3;
inline bool CVRP::has_numberofvehicles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVRP::set_has_numberofvehicles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVRP::clear_has_numberofvehicles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVRP::clear_numberofvehicles() {
  numberofvehicles_ = 0;
  clear_has_numberofvehicles();
}
inline ::google::protobuf::int32 CVRP::numberofvehicles() const {
  // @@protoc_insertion_point(field_get:CVRP.CVRP.NumberOfVehicles)
  return numberofvehicles_;
}
inline void CVRP::set_numberofvehicles(::google::protobuf::int32 value) {
  set_has_numberofvehicles();
  numberofvehicles_ = value;
  // @@protoc_insertion_point(field_set:CVRP.CVRP.NumberOfVehicles)
}

// required float VehicleCapacity = 4;
inline bool CVRP::has_vehiclecapacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CVRP::set_has_vehiclecapacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CVRP::clear_has_vehiclecapacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CVRP::clear_vehiclecapacity() {
  vehiclecapacity_ = 0;
  clear_has_vehiclecapacity();
}
inline float CVRP::vehiclecapacity() const {
  // @@protoc_insertion_point(field_get:CVRP.CVRP.VehicleCapacity)
  return vehiclecapacity_;
}
inline void CVRP::set_vehiclecapacity(float value) {
  set_has_vehiclecapacity();
  vehiclecapacity_ = value;
  // @@protoc_insertion_point(field_set:CVRP.CVRP.VehicleCapacity)
}

// optional .CVRP.CVRP.eDistanceType distancetype = 5 [default = RoadNetwork];
inline bool CVRP::has_distancetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CVRP::set_has_distancetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CVRP::clear_has_distancetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CVRP::clear_distancetype() {
  distancetype_ = 1;
  clear_has_distancetype();
}
inline ::CVRP::CVRP_eDistanceType CVRP::distancetype() const {
  // @@protoc_insertion_point(field_get:CVRP.CVRP.distancetype)
  return static_cast< ::CVRP::CVRP_eDistanceType >(distancetype_);
}
inline void CVRP::set_distancetype(::CVRP::CVRP_eDistanceType value) {
  assert(::CVRP::CVRP_eDistanceType_IsValid(value));
  set_has_distancetype();
  distancetype_ = value;
  // @@protoc_insertion_point(field_set:CVRP.CVRP.distancetype)
}

// -------------------------------------------------------------------

// SolveRequest

// optional .CVRP.CVRP model = 1;
inline bool SolveRequest::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolveRequest::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolveRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolveRequest::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::CVRP::CVRP& SolveRequest::_internal_model() const {
  return *model_;
}
inline const ::CVRP::CVRP& SolveRequest::model() const {
  const ::CVRP::CVRP* p = model_;
  // @@protoc_insertion_point(field_get:CVRP.SolveRequest.model)
  return p != NULL ? *p : *reinterpret_cast<const ::CVRP::CVRP*>(
      &::CVRP::_CVRP_default_instance_);
}
inline ::CVRP::CVRP* SolveRequest::release_model() {
  // @@protoc_insertion_point(field_release:CVRP.SolveRequest.model)
  clear_has_model();
  ::CVRP::CVRP* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::CVRP::CVRP* SolveRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    auto* p = CreateMaybeMessage<::CVRP::CVRP>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CVRP.SolveRequest.model)
  return model_;
}
inline void SolveRequest::set_allocated_model(::CVRP::CVRP* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:CVRP.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolveRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolveRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolveRequest::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:CVRP.SolveRequest.modelID)
  return modelid_.GetNoArena();
}
inline void SolveRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVRP.SolveRequest.modelID)
}
#if LANG_CXX11
inline void SolveRequest::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVRP.SolveRequest.modelID)
}
#endif
inline void SolveRequest::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVRP.SolveRequest.modelID)
}
inline void SolveRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVRP.SolveRequest.modelID)
}
inline ::std::string* SolveRequest::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:CVRP.SolveRequest.modelID)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolveRequest::release_modelid() {
  // @@protoc_insertion_point(field_release:CVRP.SolveRequest.modelID)
  if (!has_modelid()) {
    return NULL;
  }
  clear_has_modelid();
  return modelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolveRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:CVRP.SolveRequest.modelID)
}

// repeated string visitSequence = 3;
inline int SolveRequest::visitsequence_size() const {
  return visitsequence_.size();
}
inline void SolveRequest::clear_visitsequence() {
  visitsequence_.Clear();
}
inline const ::std::string& SolveRequest::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.SolveRequest.visitSequence)
  return visitsequence_.Get(index);
}
inline ::std::string* SolveRequest::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:CVRP.SolveRequest.visitSequence)
  return visitsequence_.Mutable(index);
}
inline void SolveRequest::set_visitsequence(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CVRP.SolveRequest.visitSequence)
  visitsequence_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolveRequest::set_visitsequence(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CVRP.SolveRequest.visitSequence)
  visitsequence_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolveRequest::set_visitsequence(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  visitsequence_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CVRP.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value, size_t size) {
  visitsequence_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CVRP.SolveRequest.visitSequence)
}
inline ::std::string* SolveRequest::add_visitsequence() {
  // @@protoc_insertion_point(field_add_mutable:CVRP.SolveRequest.visitSequence)
  return visitsequence_.Add();
}
inline void SolveRequest::add_visitsequence(const ::std::string& value) {
  visitsequence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CVRP.SolveRequest.visitSequence)
}
#if LANG_CXX11
inline void SolveRequest::add_visitsequence(::std::string&& value) {
  visitsequence_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CVRP.SolveRequest.visitSequence)
}
#endif
inline void SolveRequest::add_visitsequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  visitsequence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CVRP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value, size_t size) {
  visitsequence_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CVRP.SolveRequest.visitSequence)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolveRequest::visitsequence() const {
  // @@protoc_insertion_point(field_list:CVRP.SolveRequest.visitSequence)
  return visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolveRequest::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.SolveRequest.visitSequence)
  return &visitsequence_;
}

// optional .CVRP.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolveRequest::set_has_solvetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolveRequest::clear_has_solvetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolveRequest::clear_solvetype() {
  solvetype_ = 0;
  clear_has_solvetype();
}
inline ::CVRP::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:CVRP.SolveRequest.solveType)
  return static_cast< ::CVRP::SolveRequest_SolveType >(solvetype_);
}
inline void SolveRequest::set_solvetype(::CVRP::SolveRequest_SolveType value) {
  assert(::CVRP::SolveRequest_SolveType_IsValid(value));
  set_has_solvetype();
  solvetype_ = value;
  // @@protoc_insertion_point(field_set:CVRP.SolveRequest.solveType)
}

// -------------------------------------------------------------------

// Edge_Geometry

// required float x = 1;
inline bool Edge_Geometry::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge_Geometry::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge_Geometry::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge_Geometry::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Edge_Geometry::x() const {
  // @@protoc_insertion_point(field_get:CVRP.Edge.Geometry.x)
  return x_;
}
inline void Edge_Geometry::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:CVRP.Edge.Geometry.x)
}

// required float y = 2;
inline bool Edge_Geometry::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge_Geometry::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge_Geometry::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge_Geometry::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Edge_Geometry::y() const {
  // @@protoc_insertion_point(field_get:CVRP.Edge.Geometry.y)
  return y_;
}
inline void Edge_Geometry::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:CVRP.Edge.Geometry.y)
}

// -------------------------------------------------------------------

// Edge

// required string from = 1;
inline bool Edge::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& Edge::from() const {
  // @@protoc_insertion_point(field_get:CVRP.Edge.from)
  return from_.GetNoArena();
}
inline void Edge::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVRP.Edge.from)
}
#if LANG_CXX11
inline void Edge::set_from(::std::string&& value) {
  set_has_from();
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVRP.Edge.from)
}
#endif
inline void Edge::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVRP.Edge.from)
}
inline void Edge::set_from(const char* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVRP.Edge.from)
}
inline ::std::string* Edge::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:CVRP.Edge.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_from() {
  // @@protoc_insertion_point(field_release:CVRP.Edge.from)
  if (!has_from()) {
    return NULL;
  }
  clear_has_from();
  return from_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:CVRP.Edge.from)
}

// required string to = 2;
inline bool Edge::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& Edge::to() const {
  // @@protoc_insertion_point(field_get:CVRP.Edge.to)
  return to_.GetNoArena();
}
inline void Edge::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVRP.Edge.to)
}
#if LANG_CXX11
inline void Edge::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVRP.Edge.to)
}
#endif
inline void Edge::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVRP.Edge.to)
}
inline void Edge::set_to(const char* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVRP.Edge.to)
}
inline ::std::string* Edge::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:CVRP.Edge.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_to() {
  // @@protoc_insertion_point(field_release:CVRP.Edge.to)
  if (!has_to()) {
    return NULL;
  }
  clear_has_to();
  return to_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:CVRP.Edge.to)
}

// optional float distance = 3;
inline bool Edge::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Edge::distance() const {
  // @@protoc_insertion_point(field_get:CVRP.Edge.distance)
  return distance_;
}
inline void Edge::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:CVRP.Edge.distance)
}

// repeated .CVRP.Edge.Geometry geometry = 4;
inline int Edge::geometry_size() const {
  return geometry_.size();
}
inline void Edge::clear_geometry() {
  geometry_.Clear();
}
inline ::CVRP::Edge_Geometry* Edge::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:CVRP.Edge.geometry)
  return geometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRP::Edge_Geometry >*
Edge::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.Edge.geometry)
  return &geometry_;
}
inline const ::CVRP::Edge_Geometry& Edge::geometry(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.Edge.geometry)
  return geometry_.Get(index);
}
inline ::CVRP::Edge_Geometry* Edge::add_geometry() {
  // @@protoc_insertion_point(field_add:CVRP.Edge.geometry)
  return geometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRP::Edge_Geometry >&
Edge::geometry() const {
  // @@protoc_insertion_point(field_list:CVRP.Edge.geometry)
  return geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// repeated string sequence = 1;
inline int SolutionResponse_Route::sequence_size() const {
  return sequence_.size();
}
inline void SolutionResponse_Route::clear_sequence() {
  sequence_.Clear();
}
inline const ::std::string& SolutionResponse_Route::sequence(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.SolutionResponse.Route.sequence)
  return sequence_.Get(index);
}
inline ::std::string* SolutionResponse_Route::mutable_sequence(int index) {
  // @@protoc_insertion_point(field_mutable:CVRP.SolutionResponse.Route.sequence)
  return sequence_.Mutable(index);
}
inline void SolutionResponse_Route::set_sequence(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CVRP.SolutionResponse.Route.sequence)
  sequence_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolutionResponse_Route::set_sequence(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CVRP.SolutionResponse.Route.sequence)
  sequence_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolutionResponse_Route::set_sequence(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sequence_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CVRP.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::set_sequence(int index, const char* value, size_t size) {
  sequence_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CVRP.SolutionResponse.Route.sequence)
}
inline ::std::string* SolutionResponse_Route::add_sequence() {
  // @@protoc_insertion_point(field_add_mutable:CVRP.SolutionResponse.Route.sequence)
  return sequence_.Add();
}
inline void SolutionResponse_Route::add_sequence(const ::std::string& value) {
  sequence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CVRP.SolutionResponse.Route.sequence)
}
#if LANG_CXX11
inline void SolutionResponse_Route::add_sequence(::std::string&& value) {
  sequence_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CVRP.SolutionResponse.Route.sequence)
}
#endif
inline void SolutionResponse_Route::add_sequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sequence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CVRP.SolutionResponse.Route.sequence)
}
inline void SolutionResponse_Route::add_sequence(const char* value, size_t size) {
  sequence_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CVRP.SolutionResponse.Route.sequence)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolutionResponse_Route::sequence() const {
  // @@protoc_insertion_point(field_list:CVRP.SolutionResponse.Route.sequence)
  return sequence_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolutionResponse_Route::mutable_sequence() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.SolutionResponse.Route.sequence)
  return &sequence_;
}

// repeated .CVRP.Edge edges = 2;
inline int SolutionResponse_Route::edges_size() const {
  return edges_.size();
}
inline void SolutionResponse_Route::clear_edges() {
  edges_.Clear();
}
inline ::CVRP::Edge* SolutionResponse_Route::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:CVRP.SolutionResponse.Route.edges)
  return edges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRP::Edge >*
SolutionResponse_Route::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.SolutionResponse.Route.edges)
  return &edges_;
}
inline const ::CVRP::Edge& SolutionResponse_Route::edges(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.SolutionResponse.Route.edges)
  return edges_.Get(index);
}
inline ::CVRP::Edge* SolutionResponse_Route::add_edges() {
  // @@protoc_insertion_point(field_add:CVRP.SolutionResponse.Route.edges)
  return edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRP::Edge >&
SolutionResponse_Route::edges() const {
  // @@protoc_insertion_point(field_list:CVRP.SolutionResponse.Route.edges)
  return edges_;
}

// repeated float visitCapacities = 3;
inline int SolutionResponse_Route::visitcapacities_size() const {
  return visitcapacities_.size();
}
inline void SolutionResponse_Route::clear_visitcapacities() {
  visitcapacities_.Clear();
}
inline float SolutionResponse_Route::visitcapacities(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.SolutionResponse.Route.visitCapacities)
  return visitcapacities_.Get(index);
}
inline void SolutionResponse_Route::set_visitcapacities(int index, float value) {
  visitcapacities_.Set(index, value);
  // @@protoc_insertion_point(field_set:CVRP.SolutionResponse.Route.visitCapacities)
}
inline void SolutionResponse_Route::add_visitcapacities(float value) {
  visitcapacities_.Add(value);
  // @@protoc_insertion_point(field_add:CVRP.SolutionResponse.Route.visitCapacities)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_Route::visitcapacities() const {
  // @@protoc_insertion_point(field_list:CVRP.SolutionResponse.Route.visitCapacities)
  return visitcapacities_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_Route::mutable_visitcapacities() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.SolutionResponse.Route.visitCapacities)
  return &visitcapacities_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated .CVRP.SolutionResponse.Route routes = 1;
inline int SolutionResponse::routes_size() const {
  return routes_.size();
}
inline void SolutionResponse::clear_routes() {
  routes_.Clear();
}
inline ::CVRP::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:CVRP.SolutionResponse.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CVRP::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:CVRP.SolutionResponse.routes)
  return &routes_;
}
inline const ::CVRP::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:CVRP.SolutionResponse.routes)
  return routes_.Get(index);
}
inline ::CVRP::SolutionResponse_Route* SolutionResponse::add_routes() {
  // @@protoc_insertion_point(field_add:CVRP.SolutionResponse.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CVRP::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:CVRP.SolutionResponse.routes)
  return routes_;
}

// required float objective = 2;
inline bool SolutionResponse::has_objective() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse::set_has_objective() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse::clear_has_objective() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse::clear_objective() {
  objective_ = 0;
  clear_has_objective();
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:CVRP.SolutionResponse.objective)
  return objective_;
}
inline void SolutionResponse::set_objective(float value) {
  set_has_objective();
  objective_ = value;
  // @@protoc_insertion_point(field_set:CVRP.SolutionResponse.objective)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CVRP

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CVRP::CVRP_eDistanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CVRP::CVRP_eDistanceType>() {
  return ::CVRP::CVRP_eDistanceType_descriptor();
}
template <> struct is_proto_enum< ::CVRP::SolveRequest_SolveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CVRP::SolveRequest_SolveType>() {
  return ::CVRP::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cvrp_2djkfdoctmp51n_2eproto
