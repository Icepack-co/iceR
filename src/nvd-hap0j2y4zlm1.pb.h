// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nvd-hap0j2y4zlm1.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_nvd_2dhap0j2y4zlm1_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_nvd_2dhap0j2y4zlm1_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_nvd_2dhap0j2y4zlm1_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_nvd_2dhap0j2y4zlm1_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_nvd_2dhap0j2y4zlm1_2eproto;
namespace NVD {
class Configuration;
struct ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Profile;
struct ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class Profile_customCycle;
struct Profile_customCycleDefaultTypeInternal;
extern Profile_customCycleDefaultTypeInternal _Profile_customCycle_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_CompactSolution;
struct SolutionResponse_CompactSolutionDefaultTypeInternal;
extern SolutionResponse_CompactSolutionDefaultTypeInternal _SolutionResponse_CompactSolution_default_instance_;
class SolutionResponse_Infeasibility;
struct SolutionResponse_InfeasibilityDefaultTypeInternal;
extern SolutionResponse_InfeasibilityDefaultTypeInternal _SolutionResponse_Infeasibility_default_instance_;
class SolutionResponse_Infeasibility_Info;
struct SolutionResponse_Infeasibility_InfoDefaultTypeInternal;
extern SolutionResponse_Infeasibility_InfoDefaultTypeInternal _SolutionResponse_Infeasibility_Info_default_instance_;
class SolutionResponse_InterStop;
struct SolutionResponse_InterStopDefaultTypeInternal;
extern SolutionResponse_InterStopDefaultTypeInternal _SolutionResponse_InterStop_default_instance_;
class SolutionResponse_InterStopAttribute;
struct SolutionResponse_InterStopAttributeDefaultTypeInternal;
extern SolutionResponse_InterStopAttributeDefaultTypeInternal _SolutionResponse_InterStopAttribute_default_instance_;
class SolutionResponse_Route;
struct SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolutionResponse_SolutionInstance;
struct SolutionResponse_SolutionInstanceDefaultTypeInternal;
extern SolutionResponse_SolutionInstanceDefaultTypeInternal _SolutionResponse_SolutionInstance_default_instance_;
class SolutionResponse_Stop;
struct SolutionResponse_StopDefaultTypeInternal;
extern SolutionResponse_StopDefaultTypeInternal _SolutionResponse_Stop_default_instance_;
class SolutionResponse_StopAttribute;
struct SolutionResponse_StopAttributeDefaultTypeInternal;
extern SolutionResponse_StopAttributeDefaultTypeInternal _SolutionResponse_StopAttribute_default_instance_;
class SolutionResponse_TransitRuleAttribute;
struct SolutionResponse_TransitRuleAttributeDefaultTypeInternal;
extern SolutionResponse_TransitRuleAttributeDefaultTypeInternal _SolutionResponse_TransitRuleAttribute_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class Territory;
struct TerritoryDefaultTypeInternal;
extern TerritoryDefaultTypeInternal _Territory_default_instance_;
class Visit;
struct VisitDefaultTypeInternal;
extern VisitDefaultTypeInternal _Visit_default_instance_;
class VisitSequence;
struct VisitSequenceDefaultTypeInternal;
extern VisitSequenceDefaultTypeInternal _VisitSequence_default_instance_;
class Visit_TerritoryRelation;
struct Visit_TerritoryRelationDefaultTypeInternal;
extern Visit_TerritoryRelationDefaultTypeInternal _Visit_TerritoryRelation_default_instance_;
}  // namespace NVD
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace NVD {
enum Configuration_eMeasurementUnit : int {
  Configuration_eMeasurementUnit_SECONDS = 0,
  Configuration_eMeasurementUnit_MINUTES = 1,
  Configuration_eMeasurementUnit_HOURS = 2,
  Configuration_eMeasurementUnit_DAYS = 3,
  Configuration_eMeasurementUnit_KILOMETRES = 4,
  Configuration_eMeasurementUnit_MILES = 5,
};

bool Configuration_eMeasurementUnit_IsValid(int value);
constexpr Configuration_eMeasurementUnit Configuration_eMeasurementUnit_eMeasurementUnit_MIN = static_cast<Configuration_eMeasurementUnit>(0);
constexpr Configuration_eMeasurementUnit Configuration_eMeasurementUnit_eMeasurementUnit_MAX = static_cast<Configuration_eMeasurementUnit>(5);
constexpr int Configuration_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Configuration_eMeasurementUnit_descriptor();
template <typename T>
const std::string& Configuration_eMeasurementUnit_Name(T value) {
  static_assert(std::is_same<T, Configuration_eMeasurementUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eMeasurementUnit_Name().");
  return Configuration_eMeasurementUnit_Name(static_cast<Configuration_eMeasurementUnit>(value));
}
template <>
inline const std::string& Configuration_eMeasurementUnit_Name(Configuration_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Configuration_eMeasurementUnit_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Configuration_eMeasurementUnit_Parse(absl::string_view name, Configuration_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_eMeasurementUnit>(
      Configuration_eMeasurementUnit_descriptor(), name, value);
}
enum Profile_eFrequency : int {
  Profile_eFrequency_CUSTOM = 0,
  Profile_eFrequency_SEVEN_TIMES_A_WEEK = 1,
  Profile_eFrequency_SIX_TIMES_A_WEEK = 2,
  Profile_eFrequency_FIVE_TIMES_A_WEEK = 3,
  Profile_eFrequency_FOUR_TIMES_A_WEEK = 4,
  Profile_eFrequency_THREE_TIMES_A_WEEK = 5,
  Profile_eFrequency_TWICE_A_WEEK = 6,
  Profile_eFrequency_ONCE_A_WEEK = 7,
  Profile_eFrequency_EVERY_SECOND_WEEK = 8,
  Profile_eFrequency_ONCE_A_MONTH = 9,
};

bool Profile_eFrequency_IsValid(int value);
constexpr Profile_eFrequency Profile_eFrequency_eFrequency_MIN = static_cast<Profile_eFrequency>(0);
constexpr Profile_eFrequency Profile_eFrequency_eFrequency_MAX = static_cast<Profile_eFrequency>(9);
constexpr int Profile_eFrequency_eFrequency_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
Profile_eFrequency_descriptor();
template <typename T>
const std::string& Profile_eFrequency_Name(T value) {
  static_assert(std::is_same<T, Profile_eFrequency>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eFrequency_Name().");
  return Profile_eFrequency_Name(static_cast<Profile_eFrequency>(value));
}
template <>
inline const std::string& Profile_eFrequency_Name(Profile_eFrequency value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Profile_eFrequency_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool Profile_eFrequency_Parse(absl::string_view name, Profile_eFrequency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Profile_eFrequency>(
      Profile_eFrequency_descriptor(), name, value);
}
enum Visit_TerritoryRelation_Type : int {
  Visit_TerritoryRelation_Type_INCLUSIVE = 0,
  Visit_TerritoryRelation_Type_EXCLUSIVE = 1,
};

bool Visit_TerritoryRelation_Type_IsValid(int value);
constexpr Visit_TerritoryRelation_Type Visit_TerritoryRelation_Type_Type_MIN = static_cast<Visit_TerritoryRelation_Type>(0);
constexpr Visit_TerritoryRelation_Type Visit_TerritoryRelation_Type_Type_MAX = static_cast<Visit_TerritoryRelation_Type>(1);
constexpr int Visit_TerritoryRelation_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Visit_TerritoryRelation_Type_descriptor();
template <typename T>
const std::string& Visit_TerritoryRelation_Type_Name(T value) {
  static_assert(std::is_same<T, Visit_TerritoryRelation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Visit_TerritoryRelation_Type_Name(static_cast<Visit_TerritoryRelation_Type>(value));
}
template <>
inline const std::string& Visit_TerritoryRelation_Type_Name(Visit_TerritoryRelation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Visit_TerritoryRelation_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Visit_TerritoryRelation_Type_Parse(absl::string_view name, Visit_TerritoryRelation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Visit_TerritoryRelation_Type>(
      Visit_TerritoryRelation_Type_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(2);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Configuration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Configuration) */ {
 public:
  inline Configuration() : Configuration(nullptr) {}
  ~Configuration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Configuration(::google::protobuf::internal::ConstantInitialized);

  Configuration(const Configuration& from);
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Configuration& operator=(Configuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Configuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(Configuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Configuration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Configuration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Configuration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Configuration& from) {
    Configuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Configuration";
  }
  protected:
  explicit Configuration(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eMeasurementUnit = Configuration_eMeasurementUnit;
  static constexpr eMeasurementUnit SECONDS = Configuration_eMeasurementUnit_SECONDS;
  static constexpr eMeasurementUnit MINUTES = Configuration_eMeasurementUnit_MINUTES;
  static constexpr eMeasurementUnit HOURS = Configuration_eMeasurementUnit_HOURS;
  static constexpr eMeasurementUnit DAYS = Configuration_eMeasurementUnit_DAYS;
  static constexpr eMeasurementUnit KILOMETRES = Configuration_eMeasurementUnit_KILOMETRES;
  static constexpr eMeasurementUnit MILES = Configuration_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return Configuration_eMeasurementUnit_IsValid(value);
  }
  static constexpr eMeasurementUnit eMeasurementUnit_MIN = Configuration_eMeasurementUnit_eMeasurementUnit_MIN;
  static constexpr eMeasurementUnit eMeasurementUnit_MAX = Configuration_eMeasurementUnit_eMeasurementUnit_MAX;
  static constexpr int eMeasurementUnit_ARRAYSIZE = Configuration_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eMeasurementUnit_descriptor() {
    return Configuration_eMeasurementUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eMeasurementUnit_Name(T value) {
    return Configuration_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(absl::string_view name, eMeasurementUnit* value) {
    return Configuration_eMeasurementUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWeekLengthFieldNumber = 8,
    kPeriodLengthFieldNumber = 9,
    kInterTerritoryBalanceFieldNumber = 7,
    kTimeUnitFieldNumber = 1,
    kTimeCoefFieldNumber = 2,
    kTimeCostCoefFieldNumber = 3,
    kDistanceUnitFieldNumber = 4,
    kDistanceCostCoefFieldNumber = 5,
    kIntraTerritoryBalanceFieldNumber = 6,
  };
  // required int32 weekLength = 8;
  bool has_weeklength() const;
  void clear_weeklength() ;
  ::int32_t weeklength() const;
  void set_weeklength(::int32_t value);

  private:
  ::int32_t _internal_weeklength() const;
  void _internal_set_weeklength(::int32_t value);

  public:
  // required int32 periodLength = 9;
  bool has_periodlength() const;
  void clear_periodlength() ;
  ::int32_t periodlength() const;
  void set_periodlength(::int32_t value);

  private:
  ::int32_t _internal_periodlength() const;
  void _internal_set_periodlength(::int32_t value);

  public:
  // required float interTerritoryBalance = 7 [default = 1];
  bool has_interterritorybalance() const;
  void clear_interterritorybalance() ;
  float interterritorybalance() const;
  void set_interterritorybalance(float value);

  private:
  float _internal_interterritorybalance() const;
  void _internal_set_interterritorybalance(float value);

  public:
  // required .NVD.Configuration.eMeasurementUnit timeUnit = 1 [default = MINUTES];
  bool has_timeunit() const;
  void clear_timeunit() ;
  ::NVD::Configuration_eMeasurementUnit timeunit() const;
  void set_timeunit(::NVD::Configuration_eMeasurementUnit value);

  private:
  ::NVD::Configuration_eMeasurementUnit _internal_timeunit() const;
  void _internal_set_timeunit(::NVD::Configuration_eMeasurementUnit value);

  public:
  // required float timeCoef = 2 [default = 1];
  bool has_timecoef() const;
  void clear_timecoef() ;
  float timecoef() const;
  void set_timecoef(float value);

  private:
  float _internal_timecoef() const;
  void _internal_set_timecoef(float value);

  public:
  // required float timeCostCoef = 3 [default = 1];
  bool has_timecostcoef() const;
  void clear_timecostcoef() ;
  float timecostcoef() const;
  void set_timecostcoef(float value);

  private:
  float _internal_timecostcoef() const;
  void _internal_set_timecostcoef(float value);

  public:
  // required .NVD.Configuration.eMeasurementUnit distanceUnit = 4 [default = KILOMETRES];
  bool has_distanceunit() const;
  void clear_distanceunit() ;
  ::NVD::Configuration_eMeasurementUnit distanceunit() const;
  void set_distanceunit(::NVD::Configuration_eMeasurementUnit value);

  private:
  ::NVD::Configuration_eMeasurementUnit _internal_distanceunit() const;
  void _internal_set_distanceunit(::NVD::Configuration_eMeasurementUnit value);

  public:
  // required float distanceCostCoef = 5 [default = 1];
  bool has_distancecostcoef() const;
  void clear_distancecostcoef() ;
  float distancecostcoef() const;
  void set_distancecostcoef(float value);

  private:
  float _internal_distancecostcoef() const;
  void _internal_set_distancecostcoef(float value);

  public:
  // required float intraTerritoryBalance = 6 [default = 1];
  bool has_intraterritorybalance() const;
  void clear_intraterritorybalance() ;
  float intraterritorybalance() const;
  void set_intraterritorybalance(float value);

  private:
  float _internal_intraterritorybalance() const;
  void _internal_set_intraterritorybalance(float value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.Configuration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t weeklength_;
    ::int32_t periodlength_;
    float interterritorybalance_;
    int timeunit_;
    float timecoef_;
    float timecostcoef_;
    int distanceunit_;
    float distancecostcoef_;
    float intraterritorybalance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float longitude_;
    float latitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Profile_customCycle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Profile.customCycle) */ {
 public:
  inline Profile_customCycle() : Profile_customCycle(nullptr) {}
  ~Profile_customCycle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_customCycle(::google::protobuf::internal::ConstantInitialized);

  Profile_customCycle(const Profile_customCycle& from);
  Profile_customCycle(Profile_customCycle&& from) noexcept
    : Profile_customCycle() {
    *this = ::std::move(from);
  }

  inline Profile_customCycle& operator=(const Profile_customCycle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_customCycle& operator=(Profile_customCycle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_customCycle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_customCycle* internal_default_instance() {
    return reinterpret_cast<const Profile_customCycle*>(
               &_Profile_customCycle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Profile_customCycle& a, Profile_customCycle& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_customCycle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_customCycle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_customCycle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_customCycle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_customCycle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_customCycle& from) {
    Profile_customCycle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile_customCycle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Profile.customCycle";
  }
  protected:
  explicit Profile_customCycle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisitProfileFieldNumber = 2,
  };
  // repeated bool visitProfile = 2;
  int visitprofile_size() const;
  private:
  int _internal_visitprofile_size() const;

  public:
  void clear_visitprofile() ;
  bool visitprofile(int index) const;
  void set_visitprofile(int index, bool value);
  void add_visitprofile(bool value);
  const ::google::protobuf::RepeatedField<bool>& visitprofile() const;
  ::google::protobuf::RepeatedField<bool>* mutable_visitprofile();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_visitprofile() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_visitprofile();

  public:
  // @@protoc_insertion_point(class_scope:NVD.Profile.customCycle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<bool> visitprofile_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Profile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Profile) */ {
 public:
  inline Profile() : Profile(nullptr) {}
  ~Profile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile(::google::protobuf::internal::ConstantInitialized);

  Profile(const Profile& from);
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile& operator=(Profile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile& from) {
    Profile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Profile";
  }
  protected:
  explicit Profile(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Profile_customCycle customCycle;

  using eFrequency = Profile_eFrequency;
  static constexpr eFrequency CUSTOM = Profile_eFrequency_CUSTOM;
  static constexpr eFrequency SEVEN_TIMES_A_WEEK = Profile_eFrequency_SEVEN_TIMES_A_WEEK;
  static constexpr eFrequency SIX_TIMES_A_WEEK = Profile_eFrequency_SIX_TIMES_A_WEEK;
  static constexpr eFrequency FIVE_TIMES_A_WEEK = Profile_eFrequency_FIVE_TIMES_A_WEEK;
  static constexpr eFrequency FOUR_TIMES_A_WEEK = Profile_eFrequency_FOUR_TIMES_A_WEEK;
  static constexpr eFrequency THREE_TIMES_A_WEEK = Profile_eFrequency_THREE_TIMES_A_WEEK;
  static constexpr eFrequency TWICE_A_WEEK = Profile_eFrequency_TWICE_A_WEEK;
  static constexpr eFrequency ONCE_A_WEEK = Profile_eFrequency_ONCE_A_WEEK;
  static constexpr eFrequency EVERY_SECOND_WEEK = Profile_eFrequency_EVERY_SECOND_WEEK;
  static constexpr eFrequency ONCE_A_MONTH = Profile_eFrequency_ONCE_A_MONTH;
  static inline bool eFrequency_IsValid(int value) {
    return Profile_eFrequency_IsValid(value);
  }
  static constexpr eFrequency eFrequency_MIN = Profile_eFrequency_eFrequency_MIN;
  static constexpr eFrequency eFrequency_MAX = Profile_eFrequency_eFrequency_MAX;
  static constexpr int eFrequency_ARRAYSIZE = Profile_eFrequency_eFrequency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eFrequency_descriptor() {
    return Profile_eFrequency_descriptor();
  }
  template <typename T>
  static inline const std::string& eFrequency_Name(T value) {
    return Profile_eFrequency_Name(value);
  }
  static inline bool eFrequency_Parse(absl::string_view name, eFrequency* value) {
    return Profile_eFrequency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowableCyclesFieldNumber = 2,
    kFrequencyTypeFieldNumber = 1,
    kNumVisitsFieldNumber = 3,
  };
  // repeated .NVD.Profile.customCycle allowableCycles = 2;
  int allowablecycles_size() const;
  private:
  int _internal_allowablecycles_size() const;

  public:
  void clear_allowablecycles() ;
  ::NVD::Profile_customCycle* mutable_allowablecycles(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::Profile_customCycle >*
      mutable_allowablecycles();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::Profile_customCycle>& _internal_allowablecycles() const;
  ::google::protobuf::RepeatedPtrField<::NVD::Profile_customCycle>* _internal_mutable_allowablecycles();
  public:
  const ::NVD::Profile_customCycle& allowablecycles(int index) const;
  ::NVD::Profile_customCycle* add_allowablecycles();
  const ::google::protobuf::RepeatedPtrField< ::NVD::Profile_customCycle >&
      allowablecycles() const;
  // required .NVD.Profile.eFrequency frequencyType = 1;
  bool has_frequencytype() const;
  void clear_frequencytype() ;
  ::NVD::Profile_eFrequency frequencytype() const;
  void set_frequencytype(::NVD::Profile_eFrequency value);

  private:
  ::NVD::Profile_eFrequency _internal_frequencytype() const;
  void _internal_set_frequencytype(::NVD::Profile_eFrequency value);

  public:
  // optional int32 numVisits = 3;
  bool has_numvisits() const;
  void clear_numvisits() ;
  ::int32_t numvisits() const;
  void set_numvisits(::int32_t value);

  private:
  ::int32_t _internal_numvisits() const;
  void _internal_set_numvisits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.Profile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::Profile_customCycle > allowablecycles_;
    int frequencytype_;
    ::int32_t numvisits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Visit_TerritoryRelation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Visit.TerritoryRelation) */ {
 public:
  inline Visit_TerritoryRelation() : Visit_TerritoryRelation(nullptr) {}
  ~Visit_TerritoryRelation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Visit_TerritoryRelation(::google::protobuf::internal::ConstantInitialized);

  Visit_TerritoryRelation(const Visit_TerritoryRelation& from);
  Visit_TerritoryRelation(Visit_TerritoryRelation&& from) noexcept
    : Visit_TerritoryRelation() {
    *this = ::std::move(from);
  }

  inline Visit_TerritoryRelation& operator=(const Visit_TerritoryRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Visit_TerritoryRelation& operator=(Visit_TerritoryRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Visit_TerritoryRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Visit_TerritoryRelation* internal_default_instance() {
    return reinterpret_cast<const Visit_TerritoryRelation*>(
               &_Visit_TerritoryRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Visit_TerritoryRelation& a, Visit_TerritoryRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(Visit_TerritoryRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Visit_TerritoryRelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Visit_TerritoryRelation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Visit_TerritoryRelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Visit_TerritoryRelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Visit_TerritoryRelation& from) {
    Visit_TerritoryRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Visit_TerritoryRelation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Visit.TerritoryRelation";
  }
  protected:
  explicit Visit_TerritoryRelation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Visit_TerritoryRelation_Type;
  static constexpr Type INCLUSIVE = Visit_TerritoryRelation_Type_INCLUSIVE;
  static constexpr Type EXCLUSIVE = Visit_TerritoryRelation_Type_EXCLUSIVE;
  static inline bool Type_IsValid(int value) {
    return Visit_TerritoryRelation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Visit_TerritoryRelation_Type_Type_MIN;
  static constexpr Type Type_MAX = Visit_TerritoryRelation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Visit_TerritoryRelation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Visit_TerritoryRelation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Visit_TerritoryRelation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Visit_TerritoryRelation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTerritoryIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string territoryIds = 2;
  int territoryids_size() const;
  private:
  int _internal_territoryids_size() const;

  public:
  void clear_territoryids() ;
  const std::string& territoryids(int index) const;
  std::string* mutable_territoryids(int index);
  void set_territoryids(int index, const std::string& value);
  void set_territoryids(int index, std::string&& value);
  void set_territoryids(int index, const char* value);
  void set_territoryids(int index, const char* value, std::size_t size);
  void set_territoryids(int index, absl::string_view value);
  std::string* add_territoryids();
  void add_territoryids(const std::string& value);
  void add_territoryids(std::string&& value);
  void add_territoryids(const char* value);
  void add_territoryids(const char* value, std::size_t size);
  void add_territoryids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& territoryids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_territoryids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_territoryids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_territoryids();

  public:
  // required .NVD.Visit.TerritoryRelation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::NVD::Visit_TerritoryRelation_Type type() const;
  void set_type(::NVD::Visit_TerritoryRelation_Type value);

  private:
  ::NVD::Visit_TerritoryRelation_Type _internal_type() const;
  void _internal_set_type(::NVD::Visit_TerritoryRelation_Type value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.Visit.TerritoryRelation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> territoryids_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Visit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Visit) */ {
 public:
  inline Visit() : Visit(nullptr) {}
  ~Visit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Visit(::google::protobuf::internal::ConstantInitialized);

  Visit(const Visit& from);
  Visit(Visit&& from) noexcept
    : Visit() {
    *this = ::std::move(from);
  }

  inline Visit& operator=(const Visit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Visit& operator=(Visit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Visit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Visit* internal_default_instance() {
    return reinterpret_cast<const Visit*>(
               &_Visit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Visit& a, Visit& b) {
    a.Swap(&b);
  }
  inline void Swap(Visit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Visit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Visit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Visit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Visit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Visit& from) {
    Visit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Visit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Visit";
  }
  protected:
  explicit Visit(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Visit_TerritoryRelation TerritoryRelation;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLocationFieldNumber = 2,
    kProfileFieldNumber = 4,
    kTerritoryRelationsFieldNumber = 5,
    kVisitTimeFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .NVD.Geocode location = 2;
  bool has_location() const;
  void clear_location() ;
  const ::NVD::Geocode& location() const;
  PROTOBUF_NODISCARD ::NVD::Geocode* release_location();
  ::NVD::Geocode* mutable_location();
  void set_allocated_location(::NVD::Geocode* value);
  void unsafe_arena_set_allocated_location(::NVD::Geocode* value);
  ::NVD::Geocode* unsafe_arena_release_location();

  private:
  const ::NVD::Geocode& _internal_location() const;
  ::NVD::Geocode* _internal_mutable_location();

  public:
  // required .NVD.Profile profile = 4;
  bool has_profile() const;
  void clear_profile() ;
  const ::NVD::Profile& profile() const;
  PROTOBUF_NODISCARD ::NVD::Profile* release_profile();
  ::NVD::Profile* mutable_profile();
  void set_allocated_profile(::NVD::Profile* value);
  void unsafe_arena_set_allocated_profile(::NVD::Profile* value);
  ::NVD::Profile* unsafe_arena_release_profile();

  private:
  const ::NVD::Profile& _internal_profile() const;
  ::NVD::Profile* _internal_mutable_profile();

  public:
  // optional .NVD.Visit.TerritoryRelation territoryRelations = 5;
  bool has_territoryrelations() const;
  void clear_territoryrelations() ;
  const ::NVD::Visit_TerritoryRelation& territoryrelations() const;
  PROTOBUF_NODISCARD ::NVD::Visit_TerritoryRelation* release_territoryrelations();
  ::NVD::Visit_TerritoryRelation* mutable_territoryrelations();
  void set_allocated_territoryrelations(::NVD::Visit_TerritoryRelation* value);
  void unsafe_arena_set_allocated_territoryrelations(::NVD::Visit_TerritoryRelation* value);
  ::NVD::Visit_TerritoryRelation* unsafe_arena_release_territoryrelations();

  private:
  const ::NVD::Visit_TerritoryRelation& _internal_territoryrelations() const;
  ::NVD::Visit_TerritoryRelation* _internal_mutable_territoryrelations();

  public:
  // required float visitTime = 3 [default = 0];
  bool has_visittime() const;
  void clear_visittime() ;
  float visittime() const;
  void set_visittime(float value);

  private:
  float _internal_visittime() const;
  void _internal_set_visittime(float value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.Visit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 20, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::NVD::Geocode* location_;
    ::NVD::Profile* profile_;
    ::NVD::Visit_TerritoryRelation* territoryrelations_;
    float visittime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Territory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Territory) */ {
 public:
  inline Territory() : Territory(nullptr) {}
  ~Territory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Territory(::google::protobuf::internal::ConstantInitialized);

  Territory(const Territory& from);
  Territory(Territory&& from) noexcept
    : Territory() {
    *this = ::std::move(from);
  }

  inline Territory& operator=(const Territory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Territory& operator=(Territory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Territory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Territory* internal_default_instance() {
    return reinterpret_cast<const Territory*>(
               &_Territory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Territory& a, Territory& b) {
    a.Swap(&b);
  }
  inline void Swap(Territory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Territory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Territory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Territory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Territory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Territory& from) {
    Territory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Territory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Territory";
  }
  protected:
  explicit Territory(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDailyStartTimeFieldNumber = 2,
    kDailyEndTimeFieldNumber = 3,
    kIdFieldNumber = 1,
    kLocationFieldNumber = 4,
  };
  // repeated float dailyStartTime = 2;
  int dailystarttime_size() const;
  private:
  int _internal_dailystarttime_size() const;

  public:
  void clear_dailystarttime() ;
  float dailystarttime(int index) const;
  void set_dailystarttime(int index, float value);
  void add_dailystarttime(float value);
  const ::google::protobuf::RepeatedField<float>& dailystarttime() const;
  ::google::protobuf::RepeatedField<float>* mutable_dailystarttime();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_dailystarttime() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_dailystarttime();

  public:
  // repeated float dailyEndTime = 3;
  int dailyendtime_size() const;
  private:
  int _internal_dailyendtime_size() const;

  public:
  void clear_dailyendtime() ;
  float dailyendtime(int index) const;
  void set_dailyendtime(int index, float value);
  void add_dailyendtime(float value);
  const ::google::protobuf::RepeatedField<float>& dailyendtime() const;
  ::google::protobuf::RepeatedField<float>* mutable_dailyendtime();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_dailyendtime() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_dailyendtime();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .NVD.Geocode location = 4;
  bool has_location() const;
  void clear_location() ;
  const ::NVD::Geocode& location() const;
  PROTOBUF_NODISCARD ::NVD::Geocode* release_location();
  ::NVD::Geocode* mutable_location();
  void set_allocated_location(::NVD::Geocode* value);
  void unsafe_arena_set_allocated_location(::NVD::Geocode* value);
  ::NVD::Geocode* unsafe_arena_release_location();

  private:
  const ::NVD::Geocode& _internal_location() const;
  ::NVD::Geocode* _internal_mutable_location();

  public:
  // @@protoc_insertion_point(class_scope:NVD.Territory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 24, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> dailystarttime_;
    ::google::protobuf::RepeatedField<float> dailyendtime_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::NVD::Geocode* location_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class VisitSequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.VisitSequence) */ {
 public:
  inline VisitSequence() : VisitSequence(nullptr) {}
  ~VisitSequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisitSequence(::google::protobuf::internal::ConstantInitialized);

  VisitSequence(const VisitSequence& from);
  VisitSequence(VisitSequence&& from) noexcept
    : VisitSequence() {
    *this = ::std::move(from);
  }

  inline VisitSequence& operator=(const VisitSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisitSequence& operator=(VisitSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisitSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisitSequence* internal_default_instance() {
    return reinterpret_cast<const VisitSequence*>(
               &_VisitSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VisitSequence& a, VisitSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(VisitSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisitSequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisitSequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisitSequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisitSequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisitSequence& from) {
    VisitSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisitSequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.VisitSequence";
  }
  protected:
  explicit VisitSequence(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisitIdFieldNumber = 3,
    kTerritoryIdFieldNumber = 1,
    kDayIndexFieldNumber = 2,
  };
  // repeated string visitId = 3;
  int visitid_size() const;
  private:
  int _internal_visitid_size() const;

  public:
  void clear_visitid() ;
  const std::string& visitid(int index) const;
  std::string* mutable_visitid(int index);
  void set_visitid(int index, const std::string& value);
  void set_visitid(int index, std::string&& value);
  void set_visitid(int index, const char* value);
  void set_visitid(int index, const char* value, std::size_t size);
  void set_visitid(int index, absl::string_view value);
  std::string* add_visitid();
  void add_visitid(const std::string& value);
  void add_visitid(std::string&& value);
  void add_visitid(const char* value);
  void add_visitid(const char* value, std::size_t size);
  void add_visitid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& visitid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_visitid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_visitid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_visitid();

  public:
  // required string territoryId = 1;
  bool has_territoryid() const;
  void clear_territoryid() ;
  const std::string& territoryid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_territoryid(Arg_&& arg, Args_... args);
  std::string* mutable_territoryid();
  PROTOBUF_NODISCARD std::string* release_territoryid();
  void set_allocated_territoryid(std::string* ptr);

  private:
  const std::string& _internal_territoryid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_territoryid(
      const std::string& value);
  std::string* _internal_mutable_territoryid();

  public:
  // required int32 dayIndex = 2;
  bool has_dayindex() const;
  void clear_dayindex() ;
  ::int32_t dayindex() const;
  void set_dayindex(::int32_t value);

  private:
  ::int32_t _internal_dayindex() const;
  void _internal_set_dayindex(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.VisitSequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> visitid_;
    ::google::protobuf::internal::ArenaStringPtr territoryid_;
    ::int32_t dayindex_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::google::protobuf::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.Model";
  }
  protected:
  explicit Model(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisitsFieldNumber = 2,
    kTerritoriesFieldNumber = 3,
    kVisitSequenceFieldNumber = 4,
    kConfigurationFieldNumber = 1,
  };
  // repeated .NVD.Visit visits = 2;
  int visits_size() const;
  private:
  int _internal_visits_size() const;

  public:
  void clear_visits() ;
  ::NVD::Visit* mutable_visits(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::Visit >*
      mutable_visits();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::Visit>& _internal_visits() const;
  ::google::protobuf::RepeatedPtrField<::NVD::Visit>* _internal_mutable_visits();
  public:
  const ::NVD::Visit& visits(int index) const;
  ::NVD::Visit* add_visits();
  const ::google::protobuf::RepeatedPtrField< ::NVD::Visit >&
      visits() const;
  // repeated .NVD.Territory territories = 3;
  int territories_size() const;
  private:
  int _internal_territories_size() const;

  public:
  void clear_territories() ;
  ::NVD::Territory* mutable_territories(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::Territory >*
      mutable_territories();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::Territory>& _internal_territories() const;
  ::google::protobuf::RepeatedPtrField<::NVD::Territory>* _internal_mutable_territories();
  public:
  const ::NVD::Territory& territories(int index) const;
  ::NVD::Territory* add_territories();
  const ::google::protobuf::RepeatedPtrField< ::NVD::Territory >&
      territories() const;
  // repeated .NVD.VisitSequence visitSequence = 4;
  int visitsequence_size() const;
  private:
  int _internal_visitsequence_size() const;

  public:
  void clear_visitsequence() ;
  ::NVD::VisitSequence* mutable_visitsequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >*
      mutable_visitsequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>& _internal_visitsequence() const;
  ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>* _internal_mutable_visitsequence();
  public:
  const ::NVD::VisitSequence& visitsequence(int index) const;
  ::NVD::VisitSequence* add_visitsequence();
  const ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >&
      visitsequence() const;
  // required .NVD.Configuration configuration = 1;
  bool has_configuration() const;
  void clear_configuration() ;
  const ::NVD::Configuration& configuration() const;
  PROTOBUF_NODISCARD ::NVD::Configuration* release_configuration();
  ::NVD::Configuration* mutable_configuration();
  void set_allocated_configuration(::NVD::Configuration* value);
  void unsafe_arena_set_allocated_configuration(::NVD::Configuration* value);
  ::NVD::Configuration* unsafe_arena_release_configuration();

  private:
  const ::NVD::Configuration& _internal_configuration() const;
  ::NVD::Configuration* _internal_mutable_configuration();

  public:
  // @@protoc_insertion_point(class_scope:NVD.Model)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 4, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::Visit > visits_;
    ::google::protobuf::RepeatedPtrField< ::NVD::Territory > territories_;
    ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence > visitsequence_;
    ::NVD::Configuration* configuration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated .NVD.VisitSequence routes = 3;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::NVD::VisitSequence* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>* _internal_mutable_routes();
  public:
  const ::NVD::VisitSequence& routes(int index) const;
  ::NVD::VisitSequence* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >&
      routes() const;
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .NVD.Model model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::NVD::Model& model() const;
  PROTOBUF_NODISCARD ::NVD::Model* release_model();
  ::NVD::Model* mutable_model();
  void set_allocated_model(::NVD::Model* value);
  void unsafe_arena_set_allocated_model(::NVD::Model* value);
  ::NVD::Model* unsafe_arena_release_model();

  private:
  const ::NVD::Model& _internal_model() const;
  ::NVD::Model* _internal_mutable_model();

  public:
  // optional .NVD.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::NVD::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::NVD::SolveRequest_SolveType value);

  private:
  ::NVD::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::NVD::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 3, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence > routes_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::NVD::Model* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_StopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.StopAttribute) */ {
 public:
  inline SolutionResponse_StopAttribute() : SolutionResponse_StopAttribute(nullptr) {}
  ~SolutionResponse_StopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_StopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_StopAttribute(const SolutionResponse_StopAttribute& from);
  SolutionResponse_StopAttribute(SolutionResponse_StopAttribute&& from) noexcept
    : SolutionResponse_StopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_StopAttribute& operator=(const SolutionResponse_StopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_StopAttribute& operator=(SolutionResponse_StopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_StopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_StopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_StopAttribute*>(
               &_SolutionResponse_StopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SolutionResponse_StopAttribute& a, SolutionResponse_StopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_StopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_StopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_StopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_StopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_StopAttribute& from) {
    SolutionResponse_StopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_StopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.StopAttribute";
  }
  protected:
  explicit SolutionResponse_StopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
    kSlackValueFieldNumber = 5,
    kSlackCostFieldNumber = 6,
    kTardyValueFieldNumber = 7,
    kTardyCostFieldNumber = 8,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // required float slackValue = 5;
  bool has_slackvalue() const;
  void clear_slackvalue() ;
  float slackvalue() const;
  void set_slackvalue(float value);

  private:
  float _internal_slackvalue() const;
  void _internal_set_slackvalue(float value);

  public:
  // required float slackCost = 6;
  bool has_slackcost() const;
  void clear_slackcost() ;
  float slackcost() const;
  void set_slackcost(float value);

  private:
  float _internal_slackcost() const;
  void _internal_set_slackcost(float value);

  public:
  // required float tardyValue = 7;
  bool has_tardyvalue() const;
  void clear_tardyvalue() ;
  float tardyvalue() const;
  void set_tardyvalue(float value);

  private:
  float _internal_tardyvalue() const;
  void _internal_set_tardyvalue(float value);

  public:
  // required float tardyCost = 8;
  bool has_tardycost() const;
  void clear_tardycost() ;
  float tardycost() const;
  void set_tardycost(float value);

  private:
  float _internal_tardycost() const;
  void _internal_set_tardycost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.StopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8, 0, 56, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    float slackvalue_;
    float slackcost_;
    float tardyvalue_;
    float tardycost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStopAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.InterStopAttribute) */ {
 public:
  inline SolutionResponse_InterStopAttribute() : SolutionResponse_InterStopAttribute(nullptr) {}
  ~SolutionResponse_InterStopAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStopAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStopAttribute(const SolutionResponse_InterStopAttribute& from);
  SolutionResponse_InterStopAttribute(SolutionResponse_InterStopAttribute&& from) noexcept
    : SolutionResponse_InterStopAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStopAttribute& operator=(const SolutionResponse_InterStopAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStopAttribute& operator=(SolutionResponse_InterStopAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStopAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStopAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStopAttribute*>(
               &_SolutionResponse_InterStopAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SolutionResponse_InterStopAttribute& a, SolutionResponse_InterStopAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStopAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStopAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStopAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStopAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStopAttribute& from) {
    SolutionResponse_InterStopAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStopAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.InterStopAttribute";
  }
  protected:
  explicit SolutionResponse_InterStopAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimIdFieldNumber = 1,
    kStartValueFieldNumber = 2,
    kEndValueFieldNumber = 3,
    kCostFieldNumber = 4,
  };
  // required string dimId = 1;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required float startValue = 2;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 3;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.InterStopAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Stop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.Stop) */ {
 public:
  inline SolutionResponse_Stop() : SolutionResponse_Stop(nullptr) {}
  ~SolutionResponse_Stop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Stop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Stop(const SolutionResponse_Stop& from);
  SolutionResponse_Stop(SolutionResponse_Stop&& from) noexcept
    : SolutionResponse_Stop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Stop& operator=(const SolutionResponse_Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Stop& operator=(SolutionResponse_Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Stop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Stop*>(
               &_SolutionResponse_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SolutionResponse_Stop& a, SolutionResponse_Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Stop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Stop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Stop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Stop& from) {
    SolutionResponse_Stop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Stop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.Stop";
  }
  protected:
  explicit SolutionResponse_Stop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kLocationIdFieldNumber = 3,
    kVisitIdFieldNumber = 4,
    kIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
  };
  // repeated .NVD.SolutionResponse.StopAttribute attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NVD::SolutionResponse_StopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_StopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_StopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_StopAttribute>* _internal_mutable_attributes();
  public:
  const ::NVD::SolutionResponse_StopAttribute& attributes(int index) const;
  ::NVD::SolutionResponse_StopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_StopAttribute >&
      attributes() const;
  // required string locationId = 3;
  bool has_locationid() const;
  void clear_locationid() ;
  const std::string& locationid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locationid(Arg_&& arg, Args_... args);
  std::string* mutable_locationid();
  PROTOBUF_NODISCARD std::string* release_locationid();
  void set_allocated_locationid(std::string* ptr);

  private:
  const std::string& _internal_locationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locationid(
      const std::string& value);
  std::string* _internal_mutable_locationid();

  public:
  // required string visitId = 4;
  bool has_visitid() const;
  void clear_visitid() ;
  const std::string& visitid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_visitid(Arg_&& arg, Args_... args);
  std::string* mutable_visitid();
  PROTOBUF_NODISCARD std::string* release_visitid();
  void set_allocated_visitid(std::string* ptr);

  private:
  const std::string& _internal_visitid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_visitid(
      const std::string& value);
  std::string* _internal_mutable_visitid();

  public:
  // required int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // required int32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence() ;
  ::int32_t sequence() const;
  void set_sequence(::int32_t value);

  private:
  ::int32_t _internal_sequence() const;
  void _internal_set_sequence(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.Stop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 1, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_StopAttribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr locationid_;
    ::google::protobuf::internal::ArenaStringPtr visitid_;
    ::int32_t id_;
    ::int32_t sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_InterStop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.InterStop) */ {
 public:
  inline SolutionResponse_InterStop() : SolutionResponse_InterStop(nullptr) {}
  ~SolutionResponse_InterStop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_InterStop(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_InterStop(const SolutionResponse_InterStop& from);
  SolutionResponse_InterStop(SolutionResponse_InterStop&& from) noexcept
    : SolutionResponse_InterStop() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_InterStop& operator=(const SolutionResponse_InterStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_InterStop& operator=(SolutionResponse_InterStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_InterStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_InterStop* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_InterStop*>(
               &_SolutionResponse_InterStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SolutionResponse_InterStop& a, SolutionResponse_InterStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_InterStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_InterStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_InterStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_InterStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_InterStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_InterStop& from) {
    SolutionResponse_InterStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_InterStop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.InterStop";
  }
  protected:
  explicit SolutionResponse_InterStop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kRouteSegmentsFieldNumber = 4,
    kFromStopIdFieldNumber = 1,
    kToStopIdFieldNumber = 2,
  };
  // repeated .NVD.SolutionResponse.InterStopAttribute attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::NVD::SolutionResponse_InterStopAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStopAttribute >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStopAttribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStopAttribute>* _internal_mutable_attributes();
  public:
  const ::NVD::SolutionResponse_InterStopAttribute& attributes(int index) const;
  ::NVD::SolutionResponse_InterStopAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStopAttribute >&
      attributes() const;
  // repeated .NVD.Geocode routeSegments = 4;
  int routesegments_size() const;
  private:
  int _internal_routesegments_size() const;

  public:
  void clear_routesegments() ;
  ::NVD::Geocode* mutable_routesegments(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::Geocode >*
      mutable_routesegments();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::Geocode>& _internal_routesegments() const;
  ::google::protobuf::RepeatedPtrField<::NVD::Geocode>* _internal_mutable_routesegments();
  public:
  const ::NVD::Geocode& routesegments(int index) const;
  ::NVD::Geocode* add_routesegments();
  const ::google::protobuf::RepeatedPtrField< ::NVD::Geocode >&
      routesegments() const;
  // required int32 fromStopId = 1;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 2;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.InterStop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStopAttribute > attributes_;
    ::google::protobuf::RepeatedPtrField< ::NVD::Geocode > routesegments_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_TransitRuleAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.TransitRuleAttribute) */ {
 public:
  inline SolutionResponse_TransitRuleAttribute() : SolutionResponse_TransitRuleAttribute(nullptr) {}
  ~SolutionResponse_TransitRuleAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_TransitRuleAttribute(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_TransitRuleAttribute(const SolutionResponse_TransitRuleAttribute& from);
  SolutionResponse_TransitRuleAttribute(SolutionResponse_TransitRuleAttribute&& from) noexcept
    : SolutionResponse_TransitRuleAttribute() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_TransitRuleAttribute& operator=(const SolutionResponse_TransitRuleAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_TransitRuleAttribute& operator=(SolutionResponse_TransitRuleAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_TransitRuleAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_TransitRuleAttribute* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_TransitRuleAttribute*>(
               &_SolutionResponse_TransitRuleAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SolutionResponse_TransitRuleAttribute& a, SolutionResponse_TransitRuleAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_TransitRuleAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_TransitRuleAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_TransitRuleAttribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_TransitRuleAttribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_TransitRuleAttribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_TransitRuleAttribute& from) {
    SolutionResponse_TransitRuleAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_TransitRuleAttribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.TransitRuleAttribute";
  }
  protected:
  explicit SolutionResponse_TransitRuleAttribute(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleIdFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kFromStopIdFieldNumber = 3,
    kToStopIdFieldNumber = 4,
    kStartValueFieldNumber = 5,
    kEndValueFieldNumber = 6,
    kCostFieldNumber = 7,
  };
  // required string ruleId = 1;
  bool has_ruleid() const;
  void clear_ruleid() ;
  const std::string& ruleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ruleid(Arg_&& arg, Args_... args);
  std::string* mutable_ruleid();
  PROTOBUF_NODISCARD std::string* release_ruleid();
  void set_allocated_ruleid(std::string* ptr);

  private:
  const std::string& _internal_ruleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruleid(
      const std::string& value);
  std::string* _internal_mutable_ruleid();

  public:
  // required string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // required int32 fromStopId = 3;
  bool has_fromstopid() const;
  void clear_fromstopid() ;
  ::int32_t fromstopid() const;
  void set_fromstopid(::int32_t value);

  private:
  ::int32_t _internal_fromstopid() const;
  void _internal_set_fromstopid(::int32_t value);

  public:
  // required int32 toStopId = 4;
  bool has_tostopid() const;
  void clear_tostopid() ;
  ::int32_t tostopid() const;
  void set_tostopid(::int32_t value);

  private:
  ::int32_t _internal_tostopid() const;
  void _internal_set_tostopid(::int32_t value);

  public:
  // required float startValue = 5;
  bool has_startvalue() const;
  void clear_startvalue() ;
  float startvalue() const;
  void set_startvalue(float value);

  private:
  float _internal_startvalue() const;
  void _internal_set_startvalue(float value);

  public:
  // required float endValue = 6;
  bool has_endvalue() const;
  void clear_endvalue() ;
  float endvalue() const;
  void set_endvalue(float value);

  private:
  float _internal_endvalue() const;
  void _internal_set_endvalue(float value);

  public:
  // required float cost = 7;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.TransitRuleAttribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 61, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ruleid_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    ::int32_t fromstopid_;
    ::int32_t tostopid_;
    float startvalue_;
    float endvalue_;
    float cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Route final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.Route) */ {
 public:
  inline SolutionResponse_Route() : SolutionResponse_Route(nullptr) {}
  ~SolutionResponse_Route() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Route(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Route(const SolutionResponse_Route& from);
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Route* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Route* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Route& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Route& from) {
    SolutionResponse_Route::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.Route";
  }
  protected:
  explicit SolutionResponse_Route(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 2,
    kInterStopsFieldNumber = 3,
    kFixedCostFieldNumber = 4,
    kTransitRuleAttributesFieldNumber = 5,
    kVehicleIdFieldNumber = 1,
    kDayFieldNumber = 6,
  };
  // repeated .NVD.SolutionResponse.Stop stops = 2;
  int stops_size() const;
  private:
  int _internal_stops_size() const;

  public:
  void clear_stops() ;
  ::NVD::SolutionResponse_Stop* mutable_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Stop >*
      mutable_stops();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Stop>& _internal_stops() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Stop>* _internal_mutable_stops();
  public:
  const ::NVD::SolutionResponse_Stop& stops(int index) const;
  ::NVD::SolutionResponse_Stop* add_stops();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Stop >&
      stops() const;
  // repeated .NVD.SolutionResponse.InterStop interStops = 3;
  int interstops_size() const;
  private:
  int _internal_interstops_size() const;

  public:
  void clear_interstops() ;
  ::NVD::SolutionResponse_InterStop* mutable_interstops(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStop >*
      mutable_interstops();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStop>& _internal_interstops() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStop>* _internal_mutable_interstops();
  public:
  const ::NVD::SolutionResponse_InterStop& interstops(int index) const;
  ::NVD::SolutionResponse_InterStop* add_interstops();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStop >&
      interstops() const;
  // repeated float fixedCost = 4;
  int fixedcost_size() const;
  private:
  int _internal_fixedcost_size() const;

  public:
  void clear_fixedcost() ;
  float fixedcost(int index) const;
  void set_fixedcost(int index, float value);
  void add_fixedcost(float value);
  const ::google::protobuf::RepeatedField<float>& fixedcost() const;
  ::google::protobuf::RepeatedField<float>* mutable_fixedcost();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_fixedcost() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_fixedcost();

  public:
  // repeated .NVD.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
  int transitruleattributes_size() const;
  private:
  int _internal_transitruleattributes_size() const;

  public:
  void clear_transitruleattributes() ;
  ::NVD::SolutionResponse_TransitRuleAttribute* mutable_transitruleattributes(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_TransitRuleAttribute >*
      mutable_transitruleattributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_TransitRuleAttribute>& _internal_transitruleattributes() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_TransitRuleAttribute>* _internal_mutable_transitruleattributes();
  public:
  const ::NVD::SolutionResponse_TransitRuleAttribute& transitruleattributes(int index) const;
  ::NVD::SolutionResponse_TransitRuleAttribute* add_transitruleattributes();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_TransitRuleAttribute >&
      transitruleattributes() const;
  // required string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid() ;
  const std::string& vehicleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicleid(Arg_&& arg, Args_... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* ptr);

  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(
      const std::string& value);
  std::string* _internal_mutable_vehicleid();

  public:
  // required int32 day = 6;
  bool has_day() const;
  void clear_day() ;
  ::int32_t day() const;
  void set_day(::int32_t value);

  private:
  ::int32_t _internal_day() const;
  void _internal_set_day(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.Route)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 3, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Stop > stops_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStop > interstops_;
    ::google::protobuf::RepeatedField<float> fixedcost_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_TransitRuleAttribute > transitruleattributes_;
    ::google::protobuf::internal::ArenaStringPtr vehicleid_;
    ::int32_t day_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility_Info final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.Infeasibility.Info) */ {
 public:
  inline SolutionResponse_Infeasibility_Info() : SolutionResponse_Infeasibility_Info(nullptr) {}
  ~SolutionResponse_Infeasibility_Info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility_Info(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility_Info(const SolutionResponse_Infeasibility_Info& from);
  SolutionResponse_Infeasibility_Info(SolutionResponse_Infeasibility_Info&& from) noexcept
    : SolutionResponse_Infeasibility_Info() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility_Info& operator=(const SolutionResponse_Infeasibility_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility_Info& operator=(SolutionResponse_Infeasibility_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility_Info* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility_Info*>(
               &_SolutionResponse_Infeasibility_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SolutionResponse_Infeasibility_Info& a, SolutionResponse_Infeasibility_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility_Info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility_Info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility_Info>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility_Info& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility_Info& from) {
    SolutionResponse_Infeasibility_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility_Info* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.Infeasibility.Info";
  }
  protected:
  explicit SolutionResponse_Infeasibility_Info(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstrainingTaskIdsFieldNumber = 6,
    kMessageFieldNumber = 1,
    kDimIdFieldNumber = 2,
    kLimitFieldNumber = 3,
    kValueFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // repeated string constrainingTaskIds = 6;
  int constrainingtaskids_size() const;
  private:
  int _internal_constrainingtaskids_size() const;

  public:
  void clear_constrainingtaskids() ;
  const std::string& constrainingtaskids(int index) const;
  std::string* mutable_constrainingtaskids(int index);
  void set_constrainingtaskids(int index, const std::string& value);
  void set_constrainingtaskids(int index, std::string&& value);
  void set_constrainingtaskids(int index, const char* value);
  void set_constrainingtaskids(int index, const char* value, std::size_t size);
  void set_constrainingtaskids(int index, absl::string_view value);
  std::string* add_constrainingtaskids();
  void add_constrainingtaskids(const std::string& value);
  void add_constrainingtaskids(std::string&& value);
  void add_constrainingtaskids(const char* value);
  void add_constrainingtaskids(const char* value, std::size_t size);
  void add_constrainingtaskids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_constrainingtaskids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_constrainingtaskids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_constrainingtaskids();

  public:
  // required string message = 1;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional string dimId = 2;
  bool has_dimid() const;
  void clear_dimid() ;
  const std::string& dimid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimid(Arg_&& arg, Args_... args);
  std::string* mutable_dimid();
  PROTOBUF_NODISCARD std::string* release_dimid();
  void set_allocated_dimid(std::string* ptr);

  private:
  const std::string& _internal_dimid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimid(
      const std::string& value);
  std::string* _internal_mutable_dimid();

  public:
  // optional float limit = 3;
  bool has_limit() const;
  void clear_limit() ;
  float limit() const;
  void set_limit(float value);

  private:
  float _internal_limit() const;
  void _internal_set_limit(float value);

  public:
  // optional float value = 4;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // optional int64 count = 5;
  bool has_count() const;
  void clear_count() ;
  ::int64_t count() const;
  void set_count(::int64_t value);

  private:
  ::int64_t _internal_count() const;
  void _internal_set_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.Infeasibility.Info)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 79, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> constrainingtaskids_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr dimid_;
    float limit_;
    float value_;
    ::int64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Infeasibility final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.Infeasibility) */ {
 public:
  inline SolutionResponse_Infeasibility() : SolutionResponse_Infeasibility(nullptr) {}
  ~SolutionResponse_Infeasibility() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Infeasibility(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Infeasibility(const SolutionResponse_Infeasibility& from);
  SolutionResponse_Infeasibility(SolutionResponse_Infeasibility&& from) noexcept
    : SolutionResponse_Infeasibility() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Infeasibility& operator=(const SolutionResponse_Infeasibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Infeasibility& operator=(SolutionResponse_Infeasibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Infeasibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Infeasibility* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Infeasibility*>(
               &_SolutionResponse_Infeasibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SolutionResponse_Infeasibility& a, SolutionResponse_Infeasibility& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Infeasibility* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Infeasibility* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Infeasibility>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Infeasibility& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Infeasibility& from) {
    SolutionResponse_Infeasibility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Infeasibility* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.Infeasibility";
  }
  protected:
  explicit SolutionResponse_Infeasibility(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Infeasibility_Info Info;

  // accessors -------------------------------------------------------

  enum : int {
    kInfeasibilityInfoFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // repeated .NVD.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
  int infeasibilityinfo_size() const;
  private:
  int _internal_infeasibilityinfo_size() const;

  public:
  void clear_infeasibilityinfo() ;
  ::NVD::SolutionResponse_Infeasibility_Info* mutable_infeasibilityinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility_Info >*
      mutable_infeasibilityinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility_Info>& _internal_infeasibilityinfo() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility_Info>* _internal_mutable_infeasibilityinfo();
  public:
  const ::NVD::SolutionResponse_Infeasibility_Info& infeasibilityinfo(int index) const;
  ::NVD::SolutionResponse_Infeasibility_Info* add_infeasibilityinfo();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility_Info >&
      infeasibilityinfo() const;
  // required string taskId = 1;
  bool has_taskid() const;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* ptr);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.Infeasibility)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility_Info > infeasibilityinfo_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_CompactSolution final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.CompactSolution) */ {
 public:
  inline SolutionResponse_CompactSolution() : SolutionResponse_CompactSolution(nullptr) {}
  ~SolutionResponse_CompactSolution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_CompactSolution(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_CompactSolution(const SolutionResponse_CompactSolution& from);
  SolutionResponse_CompactSolution(SolutionResponse_CompactSolution&& from) noexcept
    : SolutionResponse_CompactSolution() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_CompactSolution& operator=(const SolutionResponse_CompactSolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_CompactSolution& operator=(SolutionResponse_CompactSolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_CompactSolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_CompactSolution* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_CompactSolution*>(
               &_SolutionResponse_CompactSolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SolutionResponse_CompactSolution& a, SolutionResponse_CompactSolution& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_CompactSolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_CompactSolution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_CompactSolution* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_CompactSolution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_CompactSolution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_CompactSolution& from) {
    SolutionResponse_CompactSolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_CompactSolution* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.CompactSolution";
  }
  protected:
  explicit SolutionResponse_CompactSolution(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisitSequenceFieldNumber = 1,
    kObjectivesFieldNumber = 2,
    kObjectiveNamesFieldNumber = 3,
  };
  // repeated .NVD.VisitSequence visitSequence = 1;
  int visitsequence_size() const;
  private:
  int _internal_visitsequence_size() const;

  public:
  void clear_visitsequence() ;
  ::NVD::VisitSequence* mutable_visitsequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >*
      mutable_visitsequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>& _internal_visitsequence() const;
  ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>* _internal_mutable_visitsequence();
  public:
  const ::NVD::VisitSequence& visitsequence(int index) const;
  ::NVD::VisitSequence* add_visitsequence();
  const ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >&
      visitsequence() const;
  // repeated float objectives = 2;
  int objectives_size() const;
  private:
  int _internal_objectives_size() const;

  public:
  void clear_objectives() ;
  float objectives(int index) const;
  void set_objectives(int index, float value);
  void add_objectives(float value);
  const ::google::protobuf::RepeatedField<float>& objectives() const;
  ::google::protobuf::RepeatedField<float>* mutable_objectives();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_objectives() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_objectives();

  public:
  // repeated string objectiveNames = 3;
  int objectivenames_size() const;
  private:
  int _internal_objectivenames_size() const;

  public:
  void clear_objectivenames() ;
  const std::string& objectivenames(int index) const;
  std::string* mutable_objectivenames(int index);
  void set_objectivenames(int index, const std::string& value);
  void set_objectivenames(int index, std::string&& value);
  void set_objectivenames(int index, const char* value);
  void set_objectivenames(int index, const char* value, std::size_t size);
  void set_objectivenames(int index, absl::string_view value);
  std::string* add_objectivenames();
  void add_objectivenames(const std::string& value);
  void add_objectivenames(std::string&& value);
  void add_objectivenames(const char* value);
  void add_objectivenames(const char* value, std::size_t size);
  void add_objectivenames(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& objectivenames() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_objectivenames();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_objectivenames() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_objectivenames();

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.CompactSolution)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence > visitsequence_;
    ::google::protobuf::RepeatedField<float> objectives_;
    ::google::protobuf::RepeatedPtrField<std::string> objectivenames_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_SolutionInstance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse.SolutionInstance) */ {
 public:
  inline SolutionResponse_SolutionInstance() : SolutionResponse_SolutionInstance(nullptr) {}
  ~SolutionResponse_SolutionInstance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_SolutionInstance(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_SolutionInstance(const SolutionResponse_SolutionInstance& from);
  SolutionResponse_SolutionInstance(SolutionResponse_SolutionInstance&& from) noexcept
    : SolutionResponse_SolutionInstance() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_SolutionInstance& operator=(const SolutionResponse_SolutionInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_SolutionInstance& operator=(SolutionResponse_SolutionInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_SolutionInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_SolutionInstance* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_SolutionInstance*>(
               &_SolutionResponse_SolutionInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SolutionResponse_SolutionInstance& a, SolutionResponse_SolutionInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_SolutionInstance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_SolutionInstance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_SolutionInstance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_SolutionInstance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_SolutionInstance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_SolutionInstance& from) {
    SolutionResponse_SolutionInstance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_SolutionInstance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse.SolutionInstance";
  }
  protected:
  explicit SolutionResponse_SolutionInstance(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
    kInfeasibilitiesFieldNumber = 2,
  };
  // repeated .NVD.SolutionResponse.Route routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::NVD::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Route >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Route>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Route>* _internal_mutable_routes();
  public:
  const ::NVD::SolutionResponse_Route& routes(int index) const;
  ::NVD::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Route >&
      routes() const;
  // repeated .NVD.SolutionResponse.Infeasibility infeasibilities = 2;
  int infeasibilities_size() const;
  private:
  int _internal_infeasibilities_size() const;

  public:
  void clear_infeasibilities() ;
  ::NVD::SolutionResponse_Infeasibility* mutable_infeasibilities(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility >*
      mutable_infeasibilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility>& _internal_infeasibilities() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility>* _internal_mutable_infeasibilities();
  public:
  const ::NVD::SolutionResponse_Infeasibility& infeasibilities(int index) const;
  ::NVD::SolutionResponse_Infeasibility* add_infeasibilities();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility >&
      infeasibilities() const;
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse.SolutionInstance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Route > routes_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility > infeasibilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NVD.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NVD.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_StopAttribute StopAttribute;
  typedef SolutionResponse_InterStopAttribute InterStopAttribute;
  typedef SolutionResponse_Stop Stop;
  typedef SolutionResponse_InterStop InterStop;
  typedef SolutionResponse_TransitRuleAttribute TransitRuleAttribute;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_Infeasibility Infeasibility;
  typedef SolutionResponse_CompactSolution CompactSolution;
  typedef SolutionResponse_SolutionInstance SolutionInstance;

  // accessors -------------------------------------------------------

  enum : int {
    kFrontierFieldNumber = 1,
    kInstanceFieldNumber = 2,
  };
  // repeated .NVD.SolutionResponse.CompactSolution frontier = 1;
  int frontier_size() const;
  private:
  int _internal_frontier_size() const;

  public:
  void clear_frontier() ;
  ::NVD::SolutionResponse_CompactSolution* mutable_frontier(int index);
  ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_CompactSolution >*
      mutable_frontier();
  private:
  const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_CompactSolution>& _internal_frontier() const;
  ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_CompactSolution>* _internal_mutable_frontier();
  public:
  const ::NVD::SolutionResponse_CompactSolution& frontier(int index) const;
  ::NVD::SolutionResponse_CompactSolution* add_frontier();
  const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_CompactSolution >&
      frontier() const;
  // optional .NVD.SolutionResponse.SolutionInstance instance = 2;
  bool has_instance() const;
  void clear_instance() ;
  const ::NVD::SolutionResponse_SolutionInstance& instance() const;
  PROTOBUF_NODISCARD ::NVD::SolutionResponse_SolutionInstance* release_instance();
  ::NVD::SolutionResponse_SolutionInstance* mutable_instance();
  void set_allocated_instance(::NVD::SolutionResponse_SolutionInstance* value);
  void unsafe_arena_set_allocated_instance(::NVD::SolutionResponse_SolutionInstance* value);
  ::NVD::SolutionResponse_SolutionInstance* unsafe_arena_release_instance();

  private:
  const ::NVD::SolutionResponse_SolutionInstance& _internal_instance() const;
  ::NVD::SolutionResponse_SolutionInstance* _internal_mutable_instance();

  public:
  // @@protoc_insertion_point(class_scope:NVD.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_CompactSolution > frontier_;
    ::NVD::SolutionResponse_SolutionInstance* instance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nvd_2dhap0j2y4zlm1_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Configuration

// required .NVD.Configuration.eMeasurementUnit timeUnit = 1 [default = MINUTES];
inline bool Configuration::has_timeunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Configuration::clear_timeunit() {
  _impl_.timeunit_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::NVD::Configuration_eMeasurementUnit Configuration::timeunit() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.timeUnit)
  return _internal_timeunit();
}
inline void Configuration::set_timeunit(::NVD::Configuration_eMeasurementUnit value) {
  _internal_set_timeunit(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.timeUnit)
}
inline ::NVD::Configuration_eMeasurementUnit Configuration::_internal_timeunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NVD::Configuration_eMeasurementUnit>(_impl_.timeunit_);
}
inline void Configuration::_internal_set_timeunit(::NVD::Configuration_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NVD::Configuration_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timeunit_ = value;
}

// required float timeCoef = 2 [default = 1];
inline bool Configuration::has_timecoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Configuration::clear_timecoef() {
  _impl_.timecoef_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Configuration::timecoef() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.timeCoef)
  return _internal_timecoef();
}
inline void Configuration::set_timecoef(float value) {
  _internal_set_timecoef(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.timeCoef)
}
inline float Configuration::_internal_timecoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timecoef_;
}
inline void Configuration::_internal_set_timecoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timecoef_ = value;
}

// required float timeCostCoef = 3 [default = 1];
inline bool Configuration::has_timecostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Configuration::clear_timecostcoef() {
  _impl_.timecostcoef_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Configuration::timecostcoef() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.timeCostCoef)
  return _internal_timecostcoef();
}
inline void Configuration::set_timecostcoef(float value) {
  _internal_set_timecostcoef(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.timeCostCoef)
}
inline float Configuration::_internal_timecostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timecostcoef_;
}
inline void Configuration::_internal_set_timecostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.timecostcoef_ = value;
}

// required .NVD.Configuration.eMeasurementUnit distanceUnit = 4 [default = KILOMETRES];
inline bool Configuration::has_distanceunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Configuration::clear_distanceunit() {
  _impl_.distanceunit_ = 4;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::NVD::Configuration_eMeasurementUnit Configuration::distanceunit() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.distanceUnit)
  return _internal_distanceunit();
}
inline void Configuration::set_distanceunit(::NVD::Configuration_eMeasurementUnit value) {
  _internal_set_distanceunit(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.distanceUnit)
}
inline ::NVD::Configuration_eMeasurementUnit Configuration::_internal_distanceunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NVD::Configuration_eMeasurementUnit>(_impl_.distanceunit_);
}
inline void Configuration::_internal_set_distanceunit(::NVD::Configuration_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NVD::Configuration_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.distanceunit_ = value;
}

// required float distanceCostCoef = 5 [default = 1];
inline bool Configuration::has_distancecostcoef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Configuration::clear_distancecostcoef() {
  _impl_.distancecostcoef_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Configuration::distancecostcoef() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.distanceCostCoef)
  return _internal_distancecostcoef();
}
inline void Configuration::set_distancecostcoef(float value) {
  _internal_set_distancecostcoef(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.distanceCostCoef)
}
inline float Configuration::_internal_distancecostcoef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distancecostcoef_;
}
inline void Configuration::_internal_set_distancecostcoef(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.distancecostcoef_ = value;
}

// required float intraTerritoryBalance = 6 [default = 1];
inline bool Configuration::has_intraterritorybalance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Configuration::clear_intraterritorybalance() {
  _impl_.intraterritorybalance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Configuration::intraterritorybalance() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.intraTerritoryBalance)
  return _internal_intraterritorybalance();
}
inline void Configuration::set_intraterritorybalance(float value) {
  _internal_set_intraterritorybalance(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.intraTerritoryBalance)
}
inline float Configuration::_internal_intraterritorybalance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.intraterritorybalance_;
}
inline void Configuration::_internal_set_intraterritorybalance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.intraterritorybalance_ = value;
}

// required float interTerritoryBalance = 7 [default = 1];
inline bool Configuration::has_interterritorybalance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Configuration::clear_interterritorybalance() {
  _impl_.interterritorybalance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Configuration::interterritorybalance() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.interTerritoryBalance)
  return _internal_interterritorybalance();
}
inline void Configuration::set_interterritorybalance(float value) {
  _internal_set_interterritorybalance(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.interTerritoryBalance)
}
inline float Configuration::_internal_interterritorybalance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interterritorybalance_;
}
inline void Configuration::_internal_set_interterritorybalance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.interterritorybalance_ = value;
}

// required int32 weekLength = 8;
inline bool Configuration::has_weeklength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Configuration::clear_weeklength() {
  _impl_.weeklength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Configuration::weeklength() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.weekLength)
  return _internal_weeklength();
}
inline void Configuration::set_weeklength(::int32_t value) {
  _internal_set_weeklength(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.weekLength)
}
inline ::int32_t Configuration::_internal_weeklength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weeklength_;
}
inline void Configuration::_internal_set_weeklength(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.weeklength_ = value;
}

// required int32 periodLength = 9;
inline bool Configuration::has_periodlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Configuration::clear_periodlength() {
  _impl_.periodlength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Configuration::periodlength() const {
  // @@protoc_insertion_point(field_get:NVD.Configuration.periodLength)
  return _internal_periodlength();
}
inline void Configuration::set_periodlength(::int32_t value) {
  _internal_set_periodlength(value);
  // @@protoc_insertion_point(field_set:NVD.Configuration.periodLength)
}
inline ::int32_t Configuration::_internal_periodlength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.periodlength_;
}
inline void Configuration::_internal_set_periodlength(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.periodlength_ = value;
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:NVD.Geocode.longitude)
  return _internal_longitude();
}
inline void Geocode::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:NVD.Geocode.longitude)
}
inline float Geocode::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Geocode::_internal_set_longitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_ = value;
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:NVD.Geocode.latitude)
  return _internal_latitude();
}
inline void Geocode::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:NVD.Geocode.latitude)
}
inline float Geocode::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Geocode::_internal_set_latitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// Profile_customCycle

// repeated bool visitProfile = 2;
inline int Profile_customCycle::_internal_visitprofile_size() const {
  return _internal_visitprofile().size();
}
inline int Profile_customCycle::visitprofile_size() const {
  return _internal_visitprofile_size();
}
inline void Profile_customCycle::clear_visitprofile() {
  _internal_mutable_visitprofile()->Clear();
}
inline bool Profile_customCycle::visitprofile(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Profile.customCycle.visitProfile)
  return _internal_visitprofile().Get(index);
}
inline void Profile_customCycle::set_visitprofile(int index, bool value) {
  _internal_mutable_visitprofile()->Set(index, value);
  // @@protoc_insertion_point(field_set:NVD.Profile.customCycle.visitProfile)
}
inline void Profile_customCycle::add_visitprofile(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitprofile()->Add(value);
  // @@protoc_insertion_point(field_add:NVD.Profile.customCycle.visitProfile)
}
inline const ::google::protobuf::RepeatedField<bool>& Profile_customCycle::visitprofile() const {
  // @@protoc_insertion_point(field_list:NVD.Profile.customCycle.visitProfile)
  return _internal_visitprofile();
}
inline ::google::protobuf::RepeatedField<bool>* Profile_customCycle::mutable_visitprofile() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Profile.customCycle.visitProfile)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitprofile();
}

inline const ::google::protobuf::RepeatedField<bool>& Profile_customCycle::_internal_visitprofile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitprofile_;
}
inline ::google::protobuf::RepeatedField<bool>* Profile_customCycle::_internal_mutable_visitprofile() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitprofile_;
}

// -------------------------------------------------------------------

// Profile

// required .NVD.Profile.eFrequency frequencyType = 1;
inline bool Profile::has_frequencytype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Profile::clear_frequencytype() {
  _impl_.frequencytype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::NVD::Profile_eFrequency Profile::frequencytype() const {
  // @@protoc_insertion_point(field_get:NVD.Profile.frequencyType)
  return _internal_frequencytype();
}
inline void Profile::set_frequencytype(::NVD::Profile_eFrequency value) {
  _internal_set_frequencytype(value);
  // @@protoc_insertion_point(field_set:NVD.Profile.frequencyType)
}
inline ::NVD::Profile_eFrequency Profile::_internal_frequencytype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NVD::Profile_eFrequency>(_impl_.frequencytype_);
}
inline void Profile::_internal_set_frequencytype(::NVD::Profile_eFrequency value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NVD::Profile_eFrequency_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.frequencytype_ = value;
}

// repeated .NVD.Profile.customCycle allowableCycles = 2;
inline int Profile::_internal_allowablecycles_size() const {
  return _internal_allowablecycles().size();
}
inline int Profile::allowablecycles_size() const {
  return _internal_allowablecycles_size();
}
inline void Profile::clear_allowablecycles() {
  _internal_mutable_allowablecycles()->Clear();
}
inline ::NVD::Profile_customCycle* Profile::mutable_allowablecycles(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.Profile.allowableCycles)
  return _internal_mutable_allowablecycles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::Profile_customCycle >*
Profile::mutable_allowablecycles() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Profile.allowableCycles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allowablecycles();
}
inline const ::NVD::Profile_customCycle& Profile::allowablecycles(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Profile.allowableCycles)
    return _internal_allowablecycles().Get(index);
}
inline ::NVD::Profile_customCycle* Profile::add_allowablecycles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::Profile_customCycle* _add = _internal_mutable_allowablecycles()->Add();
  // @@protoc_insertion_point(field_add:NVD.Profile.allowableCycles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::Profile_customCycle >&
Profile::allowablecycles() const {
  // @@protoc_insertion_point(field_list:NVD.Profile.allowableCycles)
  return _internal_allowablecycles();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::Profile_customCycle>&
Profile::_internal_allowablecycles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowablecycles_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::Profile_customCycle>*
Profile::_internal_mutable_allowablecycles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allowablecycles_;
}

// optional int32 numVisits = 3;
inline bool Profile::has_numvisits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Profile::clear_numvisits() {
  _impl_.numvisits_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Profile::numvisits() const {
  // @@protoc_insertion_point(field_get:NVD.Profile.numVisits)
  return _internal_numvisits();
}
inline void Profile::set_numvisits(::int32_t value) {
  _internal_set_numvisits(value);
  // @@protoc_insertion_point(field_set:NVD.Profile.numVisits)
}
inline ::int32_t Profile::_internal_numvisits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numvisits_;
}
inline void Profile::_internal_set_numvisits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.numvisits_ = value;
}

// -------------------------------------------------------------------

// Visit_TerritoryRelation

// required .NVD.Visit.TerritoryRelation.Type type = 1;
inline bool Visit_TerritoryRelation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Visit_TerritoryRelation::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::NVD::Visit_TerritoryRelation_Type Visit_TerritoryRelation::type() const {
  // @@protoc_insertion_point(field_get:NVD.Visit.TerritoryRelation.type)
  return _internal_type();
}
inline void Visit_TerritoryRelation::set_type(::NVD::Visit_TerritoryRelation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:NVD.Visit.TerritoryRelation.type)
}
inline ::NVD::Visit_TerritoryRelation_Type Visit_TerritoryRelation::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NVD::Visit_TerritoryRelation_Type>(_impl_.type_);
}
inline void Visit_TerritoryRelation::_internal_set_type(::NVD::Visit_TerritoryRelation_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NVD::Visit_TerritoryRelation_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// repeated string territoryIds = 2;
inline int Visit_TerritoryRelation::_internal_territoryids_size() const {
  return _internal_territoryids().size();
}
inline int Visit_TerritoryRelation::territoryids_size() const {
  return _internal_territoryids_size();
}
inline void Visit_TerritoryRelation::clear_territoryids() {
  _internal_mutable_territoryids()->Clear();
}
inline std::string* Visit_TerritoryRelation::add_territoryids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_territoryids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NVD.Visit.TerritoryRelation.territoryIds)
  return _s;
}
inline const std::string& Visit_TerritoryRelation::territoryids(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Visit.TerritoryRelation.territoryIds)
  return _internal_territoryids().Get(index);
}
inline std::string* Visit_TerritoryRelation::mutable_territoryids(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.Visit.TerritoryRelation.territoryIds)
  return _internal_mutable_territoryids()->Mutable(index);
}
inline void Visit_TerritoryRelation::set_territoryids(int index, const std::string& value) {
  _internal_mutable_territoryids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::set_territoryids(int index, std::string&& value) {
  _internal_mutable_territoryids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::set_territoryids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_territoryids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::set_territoryids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_territoryids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::set_territoryids(int index, absl::string_view value) {
  _internal_mutable_territoryids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::add_territoryids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_territoryids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::add_territoryids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_territoryids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::add_territoryids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_territoryids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::add_territoryids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_territoryids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NVD.Visit.TerritoryRelation.territoryIds)
}
inline void Visit_TerritoryRelation::add_territoryids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_territoryids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NVD.Visit.TerritoryRelation.territoryIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Visit_TerritoryRelation::territoryids() const {
  // @@protoc_insertion_point(field_list:NVD.Visit.TerritoryRelation.territoryIds)
  return _internal_territoryids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Visit_TerritoryRelation::mutable_territoryids() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Visit.TerritoryRelation.territoryIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_territoryids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Visit_TerritoryRelation::_internal_territoryids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.territoryids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Visit_TerritoryRelation::_internal_mutable_territoryids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.territoryids_;
}

// -------------------------------------------------------------------

// Visit

// required string id = 1;
inline bool Visit::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Visit::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Visit::id() const {
  // @@protoc_insertion_point(field_get:NVD.Visit.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Visit::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.Visit.id)
}
inline std::string* Visit::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NVD.Visit.id)
  return _s;
}
inline const std::string& Visit::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Visit::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Visit::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Visit::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Visit.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Visit::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.Visit.id)
}

// required .NVD.Geocode location = 2;
inline bool Visit::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Visit::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NVD::Geocode& Visit::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::Geocode* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::Geocode&>(::NVD::_Geocode_default_instance_);
}
inline const ::NVD::Geocode& Visit::location() const {
  // @@protoc_insertion_point(field_get:NVD.Visit.location)
  return _internal_location();
}
inline void Visit::unsafe_arena_set_allocated_location(::NVD::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::NVD::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.Visit.location)
}
inline ::NVD::Geocode* Visit::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NVD::Geocode* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::Geocode* Visit::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Visit.location)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NVD::Geocode* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::NVD::Geocode* Visit::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::Geocode>(GetArenaForAllocation());
    _impl_.location_ = reinterpret_cast<::NVD::Geocode*>(p);
  }
  return _impl_.location_;
}
inline ::NVD::Geocode* Visit::mutable_location() {
  ::NVD::Geocode* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:NVD.Visit.location)
  return _msg;
}
inline void Visit::set_allocated_location(::NVD::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::Geocode*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.location_ = reinterpret_cast<::NVD::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.Visit.location)
}

// required float visitTime = 3 [default = 0];
inline bool Visit::has_visittime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Visit::clear_visittime() {
  _impl_.visittime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Visit::visittime() const {
  // @@protoc_insertion_point(field_get:NVD.Visit.visitTime)
  return _internal_visittime();
}
inline void Visit::set_visittime(float value) {
  _internal_set_visittime(value);
  // @@protoc_insertion_point(field_set:NVD.Visit.visitTime)
}
inline float Visit::_internal_visittime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visittime_;
}
inline void Visit::_internal_set_visittime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.visittime_ = value;
}

// required .NVD.Profile profile = 4;
inline bool Visit::has_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profile_ != nullptr);
  return value;
}
inline void Visit::clear_profile() {
  if (_impl_.profile_ != nullptr) _impl_.profile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::NVD::Profile& Visit::_internal_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::Profile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::Profile&>(::NVD::_Profile_default_instance_);
}
inline const ::NVD::Profile& Visit::profile() const {
  // @@protoc_insertion_point(field_get:NVD.Visit.profile)
  return _internal_profile();
}
inline void Visit::unsafe_arena_set_allocated_profile(::NVD::Profile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = reinterpret_cast<::NVD::Profile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.Visit.profile)
}
inline ::NVD::Profile* Visit::release_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NVD::Profile* released = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::Profile* Visit::unsafe_arena_release_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Visit.profile)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NVD::Profile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::NVD::Profile* Visit::_internal_mutable_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::Profile>(GetArenaForAllocation());
    _impl_.profile_ = reinterpret_cast<::NVD::Profile*>(p);
  }
  return _impl_.profile_;
}
inline ::NVD::Profile* Visit::mutable_profile() {
  ::NVD::Profile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:NVD.Visit.profile)
  return _msg;
}
inline void Visit::set_allocated_profile(::NVD::Profile* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::Profile*>(_impl_.profile_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::Profile*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.profile_ = reinterpret_cast<::NVD::Profile*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.Visit.profile)
}

// optional .NVD.Visit.TerritoryRelation territoryRelations = 5;
inline bool Visit::has_territoryrelations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.territoryrelations_ != nullptr);
  return value;
}
inline void Visit::clear_territoryrelations() {
  if (_impl_.territoryrelations_ != nullptr) _impl_.territoryrelations_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::NVD::Visit_TerritoryRelation& Visit::_internal_territoryrelations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::Visit_TerritoryRelation* p = _impl_.territoryrelations_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::Visit_TerritoryRelation&>(::NVD::_Visit_TerritoryRelation_default_instance_);
}
inline const ::NVD::Visit_TerritoryRelation& Visit::territoryrelations() const {
  // @@protoc_insertion_point(field_get:NVD.Visit.territoryRelations)
  return _internal_territoryrelations();
}
inline void Visit::unsafe_arena_set_allocated_territoryrelations(::NVD::Visit_TerritoryRelation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.territoryrelations_);
  }
  _impl_.territoryrelations_ = reinterpret_cast<::NVD::Visit_TerritoryRelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.Visit.territoryRelations)
}
inline ::NVD::Visit_TerritoryRelation* Visit::release_territoryrelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NVD::Visit_TerritoryRelation* released = _impl_.territoryrelations_;
  _impl_.territoryrelations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::Visit_TerritoryRelation* Visit::unsafe_arena_release_territoryrelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Visit.territoryRelations)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NVD::Visit_TerritoryRelation* temp = _impl_.territoryrelations_;
  _impl_.territoryrelations_ = nullptr;
  return temp;
}
inline ::NVD::Visit_TerritoryRelation* Visit::_internal_mutable_territoryrelations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.territoryrelations_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::Visit_TerritoryRelation>(GetArenaForAllocation());
    _impl_.territoryrelations_ = reinterpret_cast<::NVD::Visit_TerritoryRelation*>(p);
  }
  return _impl_.territoryrelations_;
}
inline ::NVD::Visit_TerritoryRelation* Visit::mutable_territoryrelations() {
  ::NVD::Visit_TerritoryRelation* _msg = _internal_mutable_territoryrelations();
  // @@protoc_insertion_point(field_mutable:NVD.Visit.territoryRelations)
  return _msg;
}
inline void Visit::set_allocated_territoryrelations(::NVD::Visit_TerritoryRelation* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::Visit_TerritoryRelation*>(_impl_.territoryrelations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::Visit_TerritoryRelation*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.territoryrelations_ = reinterpret_cast<::NVD::Visit_TerritoryRelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.Visit.territoryRelations)
}

// -------------------------------------------------------------------

// Territory

// required string id = 1;
inline bool Territory::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Territory::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Territory::id() const {
  // @@protoc_insertion_point(field_get:NVD.Territory.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Territory::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.Territory.id)
}
inline std::string* Territory::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NVD.Territory.id)
  return _s;
}
inline const std::string& Territory::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Territory::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Territory::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Territory::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Territory.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Territory::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.Territory.id)
}

// repeated float dailyStartTime = 2;
inline int Territory::_internal_dailystarttime_size() const {
  return _internal_dailystarttime().size();
}
inline int Territory::dailystarttime_size() const {
  return _internal_dailystarttime_size();
}
inline void Territory::clear_dailystarttime() {
  _internal_mutable_dailystarttime()->Clear();
}
inline float Territory::dailystarttime(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Territory.dailyStartTime)
  return _internal_dailystarttime().Get(index);
}
inline void Territory::set_dailystarttime(int index, float value) {
  _internal_mutable_dailystarttime()->Set(index, value);
  // @@protoc_insertion_point(field_set:NVD.Territory.dailyStartTime)
}
inline void Territory::add_dailystarttime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dailystarttime()->Add(value);
  // @@protoc_insertion_point(field_add:NVD.Territory.dailyStartTime)
}
inline const ::google::protobuf::RepeatedField<float>& Territory::dailystarttime() const {
  // @@protoc_insertion_point(field_list:NVD.Territory.dailyStartTime)
  return _internal_dailystarttime();
}
inline ::google::protobuf::RepeatedField<float>* Territory::mutable_dailystarttime() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Territory.dailyStartTime)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dailystarttime();
}

inline const ::google::protobuf::RepeatedField<float>& Territory::_internal_dailystarttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dailystarttime_;
}
inline ::google::protobuf::RepeatedField<float>* Territory::_internal_mutable_dailystarttime() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dailystarttime_;
}

// repeated float dailyEndTime = 3;
inline int Territory::_internal_dailyendtime_size() const {
  return _internal_dailyendtime().size();
}
inline int Territory::dailyendtime_size() const {
  return _internal_dailyendtime_size();
}
inline void Territory::clear_dailyendtime() {
  _internal_mutable_dailyendtime()->Clear();
}
inline float Territory::dailyendtime(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Territory.dailyEndTime)
  return _internal_dailyendtime().Get(index);
}
inline void Territory::set_dailyendtime(int index, float value) {
  _internal_mutable_dailyendtime()->Set(index, value);
  // @@protoc_insertion_point(field_set:NVD.Territory.dailyEndTime)
}
inline void Territory::add_dailyendtime(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dailyendtime()->Add(value);
  // @@protoc_insertion_point(field_add:NVD.Territory.dailyEndTime)
}
inline const ::google::protobuf::RepeatedField<float>& Territory::dailyendtime() const {
  // @@protoc_insertion_point(field_list:NVD.Territory.dailyEndTime)
  return _internal_dailyendtime();
}
inline ::google::protobuf::RepeatedField<float>* Territory::mutable_dailyendtime() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Territory.dailyEndTime)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dailyendtime();
}

inline const ::google::protobuf::RepeatedField<float>& Territory::_internal_dailyendtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dailyendtime_;
}
inline ::google::protobuf::RepeatedField<float>* Territory::_internal_mutable_dailyendtime() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dailyendtime_;
}

// required .NVD.Geocode location = 4;
inline bool Territory::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Territory::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NVD::Geocode& Territory::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::Geocode* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::Geocode&>(::NVD::_Geocode_default_instance_);
}
inline const ::NVD::Geocode& Territory::location() const {
  // @@protoc_insertion_point(field_get:NVD.Territory.location)
  return _internal_location();
}
inline void Territory::unsafe_arena_set_allocated_location(::NVD::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::NVD::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.Territory.location)
}
inline ::NVD::Geocode* Territory::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NVD::Geocode* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::Geocode* Territory::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Territory.location)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NVD::Geocode* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::NVD::Geocode* Territory::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::Geocode>(GetArenaForAllocation());
    _impl_.location_ = reinterpret_cast<::NVD::Geocode*>(p);
  }
  return _impl_.location_;
}
inline ::NVD::Geocode* Territory::mutable_location() {
  ::NVD::Geocode* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:NVD.Territory.location)
  return _msg;
}
inline void Territory::set_allocated_location(::NVD::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::Geocode*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.location_ = reinterpret_cast<::NVD::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.Territory.location)
}

// -------------------------------------------------------------------

// VisitSequence

// required string territoryId = 1;
inline bool VisitSequence::has_territoryid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VisitSequence::clear_territoryid() {
  _impl_.territoryid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VisitSequence::territoryid() const {
  // @@protoc_insertion_point(field_get:NVD.VisitSequence.territoryId)
  return _internal_territoryid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisitSequence::set_territoryid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.territoryid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.VisitSequence.territoryId)
}
inline std::string* VisitSequence::mutable_territoryid() {
  std::string* _s = _internal_mutable_territoryid();
  // @@protoc_insertion_point(field_mutable:NVD.VisitSequence.territoryId)
  return _s;
}
inline const std::string& VisitSequence::_internal_territoryid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.territoryid_.Get();
}
inline void VisitSequence::_internal_set_territoryid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.territoryid_.Set(value, GetArenaForAllocation());
}
inline std::string* VisitSequence::_internal_mutable_territoryid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.territoryid_.Mutable( GetArenaForAllocation());
}
inline std::string* VisitSequence::release_territoryid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.VisitSequence.territoryId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.territoryid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.territoryid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VisitSequence::set_allocated_territoryid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.territoryid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.territoryid_.IsDefault()) {
          _impl_.territoryid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.VisitSequence.territoryId)
}

// required int32 dayIndex = 2;
inline bool VisitSequence::has_dayindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VisitSequence::clear_dayindex() {
  _impl_.dayindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t VisitSequence::dayindex() const {
  // @@protoc_insertion_point(field_get:NVD.VisitSequence.dayIndex)
  return _internal_dayindex();
}
inline void VisitSequence::set_dayindex(::int32_t value) {
  _internal_set_dayindex(value);
  // @@protoc_insertion_point(field_set:NVD.VisitSequence.dayIndex)
}
inline ::int32_t VisitSequence::_internal_dayindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dayindex_;
}
inline void VisitSequence::_internal_set_dayindex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dayindex_ = value;
}

// repeated string visitId = 3;
inline int VisitSequence::_internal_visitid_size() const {
  return _internal_visitid().size();
}
inline int VisitSequence::visitid_size() const {
  return _internal_visitid_size();
}
inline void VisitSequence::clear_visitid() {
  _internal_mutable_visitid()->Clear();
}
inline std::string* VisitSequence::add_visitid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_visitid()->Add();
  // @@protoc_insertion_point(field_add_mutable:NVD.VisitSequence.visitId)
  return _s;
}
inline const std::string& VisitSequence::visitid(int index) const {
  // @@protoc_insertion_point(field_get:NVD.VisitSequence.visitId)
  return _internal_visitid().Get(index);
}
inline std::string* VisitSequence::mutable_visitid(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.VisitSequence.visitId)
  return _internal_mutable_visitid()->Mutable(index);
}
inline void VisitSequence::set_visitid(int index, const std::string& value) {
  _internal_mutable_visitid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NVD.VisitSequence.visitId)
}
inline void VisitSequence::set_visitid(int index, std::string&& value) {
  _internal_mutable_visitid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NVD.VisitSequence.visitId)
}
inline void VisitSequence::set_visitid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_visitid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NVD.VisitSequence.visitId)
}
inline void VisitSequence::set_visitid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_visitid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NVD.VisitSequence.visitId)
}
inline void VisitSequence::set_visitid(int index, absl::string_view value) {
  _internal_mutable_visitid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NVD.VisitSequence.visitId)
}
inline void VisitSequence::add_visitid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NVD.VisitSequence.visitId)
}
inline void VisitSequence::add_visitid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NVD.VisitSequence.visitId)
}
inline void VisitSequence::add_visitid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NVD.VisitSequence.visitId)
}
inline void VisitSequence::add_visitid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NVD.VisitSequence.visitId)
}
inline void VisitSequence::add_visitid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NVD.VisitSequence.visitId)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VisitSequence::visitid() const {
  // @@protoc_insertion_point(field_list:NVD.VisitSequence.visitId)
  return _internal_visitid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* VisitSequence::mutable_visitid() {
  // @@protoc_insertion_point(field_mutable_list:NVD.VisitSequence.visitId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VisitSequence::_internal_visitid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VisitSequence::_internal_mutable_visitid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitid_;
}

// -------------------------------------------------------------------

// Model

// required .NVD.Configuration configuration = 1;
inline bool Model::has_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.configuration_ != nullptr);
  return value;
}
inline void Model::clear_configuration() {
  if (_impl_.configuration_ != nullptr) _impl_.configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NVD::Configuration& Model::_internal_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::Configuration* p = _impl_.configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::Configuration&>(::NVD::_Configuration_default_instance_);
}
inline const ::NVD::Configuration& Model::configuration() const {
  // @@protoc_insertion_point(field_get:NVD.Model.configuration)
  return _internal_configuration();
}
inline void Model::unsafe_arena_set_allocated_configuration(::NVD::Configuration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.configuration_);
  }
  _impl_.configuration_ = reinterpret_cast<::NVD::Configuration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.Model.configuration)
}
inline ::NVD::Configuration* Model::release_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NVD::Configuration* released = _impl_.configuration_;
  _impl_.configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::Configuration* Model::unsafe_arena_release_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.Model.configuration)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NVD::Configuration* temp = _impl_.configuration_;
  _impl_.configuration_ = nullptr;
  return temp;
}
inline ::NVD::Configuration* Model::_internal_mutable_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::Configuration>(GetArenaForAllocation());
    _impl_.configuration_ = reinterpret_cast<::NVD::Configuration*>(p);
  }
  return _impl_.configuration_;
}
inline ::NVD::Configuration* Model::mutable_configuration() {
  ::NVD::Configuration* _msg = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:NVD.Model.configuration)
  return _msg;
}
inline void Model::set_allocated_configuration(::NVD::Configuration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::Configuration*>(_impl_.configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::Configuration*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.configuration_ = reinterpret_cast<::NVD::Configuration*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.Model.configuration)
}

// repeated .NVD.Visit visits = 2;
inline int Model::_internal_visits_size() const {
  return _internal_visits().size();
}
inline int Model::visits_size() const {
  return _internal_visits_size();
}
inline void Model::clear_visits() {
  _internal_mutable_visits()->Clear();
}
inline ::NVD::Visit* Model::mutable_visits(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.Model.visits)
  return _internal_mutable_visits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::Visit >*
Model::mutable_visits() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Model.visits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visits();
}
inline const ::NVD::Visit& Model::visits(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Model.visits)
    return _internal_visits().Get(index);
}
inline ::NVD::Visit* Model::add_visits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::Visit* _add = _internal_mutable_visits()->Add();
  // @@protoc_insertion_point(field_add:NVD.Model.visits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::Visit >&
Model::visits() const {
  // @@protoc_insertion_point(field_list:NVD.Model.visits)
  return _internal_visits();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::Visit>&
Model::_internal_visits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visits_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::Visit>*
Model::_internal_mutable_visits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visits_;
}

// repeated .NVD.Territory territories = 3;
inline int Model::_internal_territories_size() const {
  return _internal_territories().size();
}
inline int Model::territories_size() const {
  return _internal_territories_size();
}
inline void Model::clear_territories() {
  _internal_mutable_territories()->Clear();
}
inline ::NVD::Territory* Model::mutable_territories(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.Model.territories)
  return _internal_mutable_territories()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::Territory >*
Model::mutable_territories() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Model.territories)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_territories();
}
inline const ::NVD::Territory& Model::territories(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Model.territories)
    return _internal_territories().Get(index);
}
inline ::NVD::Territory* Model::add_territories() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::Territory* _add = _internal_mutable_territories()->Add();
  // @@protoc_insertion_point(field_add:NVD.Model.territories)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::Territory >&
Model::territories() const {
  // @@protoc_insertion_point(field_list:NVD.Model.territories)
  return _internal_territories();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::Territory>&
Model::_internal_territories() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.territories_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::Territory>*
Model::_internal_mutable_territories() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.territories_;
}

// repeated .NVD.VisitSequence visitSequence = 4;
inline int Model::_internal_visitsequence_size() const {
  return _internal_visitsequence().size();
}
inline int Model::visitsequence_size() const {
  return _internal_visitsequence_size();
}
inline void Model::clear_visitsequence() {
  _internal_mutable_visitsequence()->Clear();
}
inline ::NVD::VisitSequence* Model::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.Model.visitSequence)
  return _internal_mutable_visitsequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >*
Model::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:NVD.Model.visitSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitsequence();
}
inline const ::NVD::VisitSequence& Model::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:NVD.Model.visitSequence)
    return _internal_visitsequence().Get(index);
}
inline ::NVD::VisitSequence* Model::add_visitsequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::VisitSequence* _add = _internal_mutable_visitsequence()->Add();
  // @@protoc_insertion_point(field_add:NVD.Model.visitSequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >&
Model::visitsequence() const {
  // @@protoc_insertion_point(field_list:NVD.Model.visitSequence)
  return _internal_visitsequence();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>&
Model::_internal_visitsequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>*
Model::_internal_mutable_visitsequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitsequence_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .NVD.Model model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NVD::Model& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::Model&>(::NVD::_Model_default_instance_);
}
inline const ::NVD::Model& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:NVD.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::NVD::Model* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::NVD::Model*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.SolveRequest.model)
}
inline ::NVD::Model* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NVD::Model* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::Model* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NVD::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::NVD::Model* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::Model>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::NVD::Model*>(p);
  }
  return _impl_.model_;
}
inline ::NVD::Model* SolveRequest::mutable_model() {
  ::NVD::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:NVD.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::NVD::Model* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::Model*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::Model*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::NVD::Model*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:NVD.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:NVD.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolveRequest.modelID)
}

// repeated .NVD.VisitSequence routes = 3;
inline int SolveRequest::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolveRequest::routes_size() const {
  return _internal_routes_size();
}
inline void SolveRequest::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::NVD::VisitSequence* SolveRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolveRequest.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >*
SolveRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolveRequest.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::NVD::VisitSequence& SolveRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolveRequest.routes)
    return _internal_routes().Get(index);
}
inline ::NVD::VisitSequence* SolveRequest::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::VisitSequence* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolveRequest.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >&
SolveRequest::routes() const {
  // @@protoc_insertion_point(field_list:NVD.SolveRequest.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>&
SolveRequest::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>*
SolveRequest::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// optional .NVD.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::NVD::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:NVD.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::NVD::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:NVD.SolveRequest.solveType)
}
inline ::NVD::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NVD::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::NVD::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NVD::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_StopAttribute

// required string dimId = 1;
inline bool SolutionResponse_StopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_StopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_StopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.dimId)
}
inline std::string* SolutionResponse_StopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.StopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_StopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_StopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_StopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.StopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_StopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.StopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_StopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_StopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_StopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.startValue)
}
inline float SolutionResponse_StopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_StopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_StopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_StopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.endValue)
}
inline float SolutionResponse_StopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_StopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_StopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_StopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.cost)
}
inline float SolutionResponse_StopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// required float slackValue = 5;
inline bool SolutionResponse_StopAttribute::has_slackvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_slackvalue() {
  _impl_.slackvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_StopAttribute::slackvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.slackValue)
  return _internal_slackvalue();
}
inline void SolutionResponse_StopAttribute::set_slackvalue(float value) {
  _internal_set_slackvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.slackValue)
}
inline float SolutionResponse_StopAttribute::_internal_slackvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_slackvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.slackvalue_ = value;
}

// required float slackCost = 6;
inline bool SolutionResponse_StopAttribute::has_slackcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_slackcost() {
  _impl_.slackcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_StopAttribute::slackcost() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.slackCost)
  return _internal_slackcost();
}
inline void SolutionResponse_StopAttribute::set_slackcost(float value) {
  _internal_set_slackcost(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.slackCost)
}
inline float SolutionResponse_StopAttribute::_internal_slackcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slackcost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_slackcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.slackcost_ = value;
}

// required float tardyValue = 7;
inline bool SolutionResponse_StopAttribute::has_tardyvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_tardyvalue() {
  _impl_.tardyvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_StopAttribute::tardyvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.tardyValue)
  return _internal_tardyvalue();
}
inline void SolutionResponse_StopAttribute::set_tardyvalue(float value) {
  _internal_set_tardyvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.tardyValue)
}
inline float SolutionResponse_StopAttribute::_internal_tardyvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardyvalue_;
}
inline void SolutionResponse_StopAttribute::_internal_set_tardyvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tardyvalue_ = value;
}

// required float tardyCost = 8;
inline bool SolutionResponse_StopAttribute::has_tardycost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SolutionResponse_StopAttribute::clear_tardycost() {
  _impl_.tardycost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float SolutionResponse_StopAttribute::tardycost() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.StopAttribute.tardyCost)
  return _internal_tardycost();
}
inline void SolutionResponse_StopAttribute::set_tardycost(float value) {
  _internal_set_tardycost(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.StopAttribute.tardyCost)
}
inline float SolutionResponse_StopAttribute::_internal_tardycost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tardycost_;
}
inline void SolutionResponse_StopAttribute::_internal_set_tardycost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.tardycost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStopAttribute

// required string dimId = 1;
inline bool SolutionResponse_InterStopAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_InterStopAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStopAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_InterStopAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.InterStopAttribute.dimId)
}
inline std::string* SolutionResponse_InterStopAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.InterStopAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_InterStopAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_InterStopAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_InterStopAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.InterStopAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_InterStopAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.InterStopAttribute.dimId)
}

// required float startValue = 2;
inline bool SolutionResponse_InterStopAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_InterStopAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStopAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_InterStopAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.InterStopAttribute.startValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.startvalue_ = value;
}

// required float endValue = 3;
inline bool SolutionResponse_InterStopAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_InterStopAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStopAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_InterStopAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.InterStopAttribute.endValue)
}
inline float SolutionResponse_InterStopAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endvalue_ = value;
}

// required float cost = 4;
inline bool SolutionResponse_InterStopAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_InterStopAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_InterStopAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStopAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_InterStopAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.InterStopAttribute.cost)
}
inline float SolutionResponse_InterStopAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_InterStopAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Stop

// required int32 id = 1;
inline bool SolutionResponse_Stop::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SolutionResponse_Stop::id() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Stop.id)
  return _internal_id();
}
inline void SolutionResponse_Stop::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Stop.id)
}
inline ::int32_t SolutionResponse_Stop::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SolutionResponse_Stop::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}

// required int32 sequence = 2;
inline bool SolutionResponse_Stop::has_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_sequence() {
  _impl_.sequence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SolutionResponse_Stop::sequence() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Stop.sequence)
  return _internal_sequence();
}
inline void SolutionResponse_Stop::set_sequence(::int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Stop.sequence)
}
inline ::int32_t SolutionResponse_Stop::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline void SolutionResponse_Stop::_internal_set_sequence(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sequence_ = value;
}

// required string locationId = 3;
inline bool SolutionResponse_Stop::has_locationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_locationid() {
  _impl_.locationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Stop::locationid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Stop.locationId)
  return _internal_locationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_locationid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Stop.locationId)
}
inline std::string* SolutionResponse_Stop::mutable_locationid() {
  std::string* _s = _internal_mutable_locationid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Stop.locationId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_locationid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_locationid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locationid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_locationid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.Stop.locationId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.locationid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_locationid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locationid_.IsDefault()) {
          _impl_.locationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.Stop.locationId)
}

// required string visitId = 4;
inline bool SolutionResponse_Stop::has_visitid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Stop::clear_visitid() {
  _impl_.visitid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Stop::visitid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Stop.visitId)
  return _internal_visitid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Stop::set_visitid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.visitid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Stop.visitId)
}
inline std::string* SolutionResponse_Stop::mutable_visitid() {
  std::string* _s = _internal_mutable_visitid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Stop.visitId)
  return _s;
}
inline const std::string& SolutionResponse_Stop::_internal_visitid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitid_.Get();
}
inline void SolutionResponse_Stop::_internal_set_visitid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.visitid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::_internal_mutable_visitid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.visitid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Stop::release_visitid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.Stop.visitId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.visitid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.visitid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Stop::set_allocated_visitid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.visitid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.visitid_.IsDefault()) {
          _impl_.visitid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.Stop.visitId)
}

// repeated .NVD.SolutionResponse.StopAttribute attributes = 5;
inline int SolutionResponse_Stop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_Stop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_Stop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NVD::SolutionResponse_StopAttribute* SolutionResponse_Stop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Stop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_StopAttribute >*
SolutionResponse_Stop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Stop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NVD::SolutionResponse_StopAttribute& SolutionResponse_Stop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Stop.attributes)
    return _internal_attributes().Get(index);
}
inline ::NVD::SolutionResponse_StopAttribute* SolutionResponse_Stop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_StopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Stop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_StopAttribute >&
SolutionResponse_Stop::attributes() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Stop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_StopAttribute>&
SolutionResponse_Stop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_StopAttribute>*
SolutionResponse_Stop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// SolutionResponse_InterStop

// required int32 fromStopId = 1;
inline bool SolutionResponse_InterStop::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SolutionResponse_InterStop::fromstopid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStop.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_InterStop::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.InterStop.fromStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_InterStop::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 2;
inline bool SolutionResponse_InterStop::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_InterStop::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_InterStop::tostopid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStop.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_InterStop::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.InterStop.toStopId)
}
inline ::int32_t SolutionResponse_InterStop::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_InterStop::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tostopid_ = value;
}

// repeated .NVD.SolutionResponse.InterStopAttribute attributes = 3;
inline int SolutionResponse_InterStop::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int SolutionResponse_InterStop::attributes_size() const {
  return _internal_attributes_size();
}
inline void SolutionResponse_InterStop::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::NVD::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.InterStop.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStopAttribute >*
SolutionResponse_InterStop::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.InterStop.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::NVD::SolutionResponse_InterStopAttribute& SolutionResponse_InterStop::attributes(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStop.attributes)
    return _internal_attributes().Get(index);
}
inline ::NVD::SolutionResponse_InterStopAttribute* SolutionResponse_InterStop::add_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_InterStopAttribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.InterStop.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStopAttribute >&
SolutionResponse_InterStop::attributes() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.InterStop.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStopAttribute>&
SolutionResponse_InterStop::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStopAttribute>*
SolutionResponse_InterStop::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .NVD.Geocode routeSegments = 4;
inline int SolutionResponse_InterStop::_internal_routesegments_size() const {
  return _internal_routesegments().size();
}
inline int SolutionResponse_InterStop::routesegments_size() const {
  return _internal_routesegments_size();
}
inline void SolutionResponse_InterStop::clear_routesegments() {
  _internal_mutable_routesegments()->Clear();
}
inline ::NVD::Geocode* SolutionResponse_InterStop::mutable_routesegments(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.InterStop.routeSegments)
  return _internal_mutable_routesegments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::Geocode >*
SolutionResponse_InterStop::mutable_routesegments() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.InterStop.routeSegments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routesegments();
}
inline const ::NVD::Geocode& SolutionResponse_InterStop::routesegments(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.InterStop.routeSegments)
    return _internal_routesegments().Get(index);
}
inline ::NVD::Geocode* SolutionResponse_InterStop::add_routesegments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::Geocode* _add = _internal_mutable_routesegments()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.InterStop.routeSegments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::Geocode >&
SolutionResponse_InterStop::routesegments() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.InterStop.routeSegments)
  return _internal_routesegments();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::Geocode>&
SolutionResponse_InterStop::_internal_routesegments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routesegments_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::Geocode>*
SolutionResponse_InterStop::_internal_mutable_routesegments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routesegments_;
}

// -------------------------------------------------------------------

// SolutionResponse_TransitRuleAttribute

// required string ruleId = 1;
inline bool SolutionResponse_TransitRuleAttribute::has_ruleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_ruleid() {
  _impl_.ruleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::ruleid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.ruleId)
  return _internal_ruleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_TransitRuleAttribute::set_ruleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.ruleId)
}
inline std::string* SolutionResponse_TransitRuleAttribute::mutable_ruleid() {
  std::string* _s = _internal_mutable_ruleid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.TransitRuleAttribute.ruleId)
  return _s;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::_internal_ruleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ruleid_.Get();
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_ruleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::_internal_mutable_ruleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ruleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::release_ruleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.TransitRuleAttribute.ruleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ruleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ruleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_ruleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ruleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ruleid_.IsDefault()) {
          _impl_.ruleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.TransitRuleAttribute.ruleId)
}

// required string dimId = 2;
inline bool SolutionResponse_TransitRuleAttribute::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::dimid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_TransitRuleAttribute::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.dimId)
}
inline std::string* SolutionResponse_TransitRuleAttribute::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.TransitRuleAttribute.dimId)
  return _s;
}
inline const std::string& SolutionResponse_TransitRuleAttribute::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_TransitRuleAttribute::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.TransitRuleAttribute.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_TransitRuleAttribute::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.TransitRuleAttribute.dimId)
}

// required int32 fromStopId = 3;
inline bool SolutionResponse_TransitRuleAttribute::has_fromstopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_fromstopid() {
  _impl_.fromstopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::fromstopid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.fromStopId)
  return _internal_fromstopid();
}
inline void SolutionResponse_TransitRuleAttribute::set_fromstopid(::int32_t value) {
  _internal_set_fromstopid(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.fromStopId)
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::_internal_fromstopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromstopid_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_fromstopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fromstopid_ = value;
}

// required int32 toStopId = 4;
inline bool SolutionResponse_TransitRuleAttribute::has_tostopid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_tostopid() {
  _impl_.tostopid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::tostopid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.toStopId)
  return _internal_tostopid();
}
inline void SolutionResponse_TransitRuleAttribute::set_tostopid(::int32_t value) {
  _internal_set_tostopid(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.toStopId)
}
inline ::int32_t SolutionResponse_TransitRuleAttribute::_internal_tostopid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tostopid_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_tostopid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tostopid_ = value;
}

// required float startValue = 5;
inline bool SolutionResponse_TransitRuleAttribute::has_startvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_startvalue() {
  _impl_.startvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_TransitRuleAttribute::startvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.startValue)
  return _internal_startvalue();
}
inline void SolutionResponse_TransitRuleAttribute::set_startvalue(float value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.startValue)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_startvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_startvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.startvalue_ = value;
}

// required float endValue = 6;
inline bool SolutionResponse_TransitRuleAttribute::has_endvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_endvalue() {
  _impl_.endvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_TransitRuleAttribute::endvalue() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.endValue)
  return _internal_endvalue();
}
inline void SolutionResponse_TransitRuleAttribute::set_endvalue(float value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.endValue)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_endvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endvalue_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_endvalue(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.endvalue_ = value;
}

// required float cost = 7;
inline bool SolutionResponse_TransitRuleAttribute::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_TransitRuleAttribute::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_TransitRuleAttribute::cost() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.TransitRuleAttribute.cost)
  return _internal_cost();
}
inline void SolutionResponse_TransitRuleAttribute::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.TransitRuleAttribute.cost)
}
inline float SolutionResponse_TransitRuleAttribute::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_TransitRuleAttribute::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string vehicleId = 1;
inline bool SolutionResponse_Route::has_vehicleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Route::vehicleid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Route.vehicleId)
  return _internal_vehicleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Route::set_vehicleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Route.vehicleId)
}
inline std::string* SolutionResponse_Route::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Route.vehicleId)
  return _s;
}
inline const std::string& SolutionResponse_Route::_internal_vehicleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicleid_.Get();
}
inline void SolutionResponse_Route::_internal_set_vehicleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::_internal_mutable_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vehicleid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::release_vehicleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.Route.vehicleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vehicleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vehicleid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Route::set_allocated_vehicleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicleid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicleid_.IsDefault()) {
          _impl_.vehicleid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.Route.vehicleId)
}

// repeated .NVD.SolutionResponse.Stop stops = 2;
inline int SolutionResponse_Route::_internal_stops_size() const {
  return _internal_stops().size();
}
inline int SolutionResponse_Route::stops_size() const {
  return _internal_stops_size();
}
inline void SolutionResponse_Route::clear_stops() {
  _internal_mutable_stops()->Clear();
}
inline ::NVD::SolutionResponse_Stop* SolutionResponse_Route::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Route.stops)
  return _internal_mutable_stops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Stop >*
SolutionResponse_Route::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Route.stops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stops();
}
inline const ::NVD::SolutionResponse_Stop& SolutionResponse_Route::stops(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Route.stops)
    return _internal_stops().Get(index);
}
inline ::NVD::SolutionResponse_Stop* SolutionResponse_Route::add_stops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_Stop* _add = _internal_mutable_stops()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Route.stops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Stop >&
SolutionResponse_Route::stops() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Route.stops)
  return _internal_stops();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Stop>&
SolutionResponse_Route::_internal_stops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stops_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Stop>*
SolutionResponse_Route::_internal_mutable_stops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stops_;
}

// repeated .NVD.SolutionResponse.InterStop interStops = 3;
inline int SolutionResponse_Route::_internal_interstops_size() const {
  return _internal_interstops().size();
}
inline int SolutionResponse_Route::interstops_size() const {
  return _internal_interstops_size();
}
inline void SolutionResponse_Route::clear_interstops() {
  _internal_mutable_interstops()->Clear();
}
inline ::NVD::SolutionResponse_InterStop* SolutionResponse_Route::mutable_interstops(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Route.interStops)
  return _internal_mutable_interstops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStop >*
SolutionResponse_Route::mutable_interstops() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Route.interStops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_interstops();
}
inline const ::NVD::SolutionResponse_InterStop& SolutionResponse_Route::interstops(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Route.interStops)
    return _internal_interstops().Get(index);
}
inline ::NVD::SolutionResponse_InterStop* SolutionResponse_Route::add_interstops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_InterStop* _add = _internal_mutable_interstops()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Route.interStops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_InterStop >&
SolutionResponse_Route::interstops() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Route.interStops)
  return _internal_interstops();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStop>&
SolutionResponse_Route::_internal_interstops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interstops_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_InterStop>*
SolutionResponse_Route::_internal_mutable_interstops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.interstops_;
}

// repeated float fixedCost = 4;
inline int SolutionResponse_Route::_internal_fixedcost_size() const {
  return _internal_fixedcost().size();
}
inline int SolutionResponse_Route::fixedcost_size() const {
  return _internal_fixedcost_size();
}
inline void SolutionResponse_Route::clear_fixedcost() {
  _internal_mutable_fixedcost()->Clear();
}
inline float SolutionResponse_Route::fixedcost(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Route.fixedCost)
  return _internal_fixedcost().Get(index);
}
inline void SolutionResponse_Route::set_fixedcost(int index, float value) {
  _internal_mutable_fixedcost()->Set(index, value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Route.fixedCost)
}
inline void SolutionResponse_Route::add_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fixedcost()->Add(value);
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Route.fixedCost)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::fixedcost() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Route.fixedCost)
  return _internal_fixedcost();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::mutable_fixedcost() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Route.fixedCost)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fixedcost();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_Route::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_Route::_internal_mutable_fixedcost() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fixedcost_;
}

// repeated .NVD.SolutionResponse.TransitRuleAttribute transitRuleAttributes = 5;
inline int SolutionResponse_Route::_internal_transitruleattributes_size() const {
  return _internal_transitruleattributes().size();
}
inline int SolutionResponse_Route::transitruleattributes_size() const {
  return _internal_transitruleattributes_size();
}
inline void SolutionResponse_Route::clear_transitruleattributes() {
  _internal_mutable_transitruleattributes()->Clear();
}
inline ::NVD::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::mutable_transitruleattributes(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Route.transitRuleAttributes)
  return _internal_mutable_transitruleattributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_TransitRuleAttribute >*
SolutionResponse_Route::mutable_transitruleattributes() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Route.transitRuleAttributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transitruleattributes();
}
inline const ::NVD::SolutionResponse_TransitRuleAttribute& SolutionResponse_Route::transitruleattributes(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Route.transitRuleAttributes)
    return _internal_transitruleattributes().Get(index);
}
inline ::NVD::SolutionResponse_TransitRuleAttribute* SolutionResponse_Route::add_transitruleattributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_TransitRuleAttribute* _add = _internal_mutable_transitruleattributes()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Route.transitRuleAttributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_TransitRuleAttribute >&
SolutionResponse_Route::transitruleattributes() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Route.transitRuleAttributes)
  return _internal_transitruleattributes();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_TransitRuleAttribute>&
SolutionResponse_Route::_internal_transitruleattributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transitruleattributes_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_TransitRuleAttribute>*
SolutionResponse_Route::_internal_mutable_transitruleattributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transitruleattributes_;
}

// required int32 day = 6;
inline bool SolutionResponse_Route::has_day() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_day() {
  _impl_.day_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SolutionResponse_Route::day() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Route.day)
  return _internal_day();
}
inline void SolutionResponse_Route::set_day(::int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Route.day)
}
inline ::int32_t SolutionResponse_Route::_internal_day() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.day_;
}
inline void SolutionResponse_Route::_internal_set_day(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.day_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility_Info

// required string message = 1;
inline bool SolutionResponse_Infeasibility_Info::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::message() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.Info.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.message)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Infeasibility.Info.message)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.Infeasibility.Info.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.Infeasibility.Info.message)
}

// optional string dimId = 2;
inline bool SolutionResponse_Infeasibility_Info::has_dimid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_dimid() {
  _impl_.dimid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Infeasibility_Info::dimid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.Info.dimId)
  return _internal_dimid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility_Info::set_dimid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.dimId)
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_dimid() {
  std::string* _s = _internal_mutable_dimid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Infeasibility.Info.dimId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::_internal_dimid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimid_.Get();
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_dimid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dimid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::_internal_mutable_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dimid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility_Info::release_dimid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.Infeasibility.Info.dimId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dimid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility_Info::set_allocated_dimid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimid_.IsDefault()) {
          _impl_.dimid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.Infeasibility.Info.dimId)
}

// optional float limit = 3;
inline bool SolutionResponse_Infeasibility_Info::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_limit() {
  _impl_.limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_Infeasibility_Info::limit() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.Info.limit)
  return _internal_limit();
}
inline void SolutionResponse_Infeasibility_Info::set_limit(float value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.limit)
}
inline float SolutionResponse_Infeasibility_Info::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.limit_ = value;
}

// optional float value = 4;
inline bool SolutionResponse_Infeasibility_Info::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_Infeasibility_Info::value() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.Info.value)
  return _internal_value();
}
inline void SolutionResponse_Infeasibility_Info::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.value)
}
inline float SolutionResponse_Infeasibility_Info::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.value_ = value;
}

// optional int64 count = 5;
inline bool SolutionResponse_Infeasibility_Info::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility_Info::clear_count() {
  _impl_.count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SolutionResponse_Infeasibility_Info::count() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.Info.count)
  return _internal_count();
}
inline void SolutionResponse_Infeasibility_Info::set_count(::int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.count)
}
inline ::int64_t SolutionResponse_Infeasibility_Info::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SolutionResponse_Infeasibility_Info::_internal_set_count(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_ = value;
}

// repeated string constrainingTaskIds = 6;
inline int SolutionResponse_Infeasibility_Info::_internal_constrainingtaskids_size() const {
  return _internal_constrainingtaskids().size();
}
inline int SolutionResponse_Infeasibility_Info::constrainingtaskids_size() const {
  return _internal_constrainingtaskids_size();
}
inline void SolutionResponse_Infeasibility_Info::clear_constrainingtaskids() {
  _internal_mutable_constrainingtaskids()->Clear();
}
inline std::string* SolutionResponse_Infeasibility_Info::add_constrainingtaskids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_constrainingtaskids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility_Info::constrainingtaskids(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_constrainingtaskids().Get(index);
}
inline std::string* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_mutable_constrainingtaskids()->Mutable(index);
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const std::string& value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, std::string&& value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::set_constrainingtaskids(int index, absl::string_view value) {
  _internal_mutable_constrainingtaskids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline void SolutionResponse_Infeasibility_Info::add_constrainingtaskids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_constrainingtaskids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::constrainingtaskids() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  return _internal_constrainingtaskids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_Infeasibility_Info::mutable_constrainingtaskids() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Infeasibility.Info.constrainingTaskIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_constrainingtaskids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_Infeasibility_Info::_internal_constrainingtaskids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.constrainingtaskids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_Infeasibility_Info::_internal_mutable_constrainingtaskids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.constrainingtaskids_;
}

// -------------------------------------------------------------------

// SolutionResponse_Infeasibility

// required string taskId = 1;
inline bool SolutionResponse_Infeasibility::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Infeasibility::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Infeasibility::taskid() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Infeasibility::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.Infeasibility.taskId)
}
inline std::string* SolutionResponse_Infeasibility::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Infeasibility.taskId)
  return _s;
}
inline const std::string& SolutionResponse_Infeasibility::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void SolutionResponse_Infeasibility::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.taskid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Infeasibility::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.Infeasibility.taskId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.taskid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Infeasibility::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.taskid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.Infeasibility.taskId)
}

// repeated .NVD.SolutionResponse.Infeasibility.Info infeasibilityInfo = 2;
inline int SolutionResponse_Infeasibility::_internal_infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo().size();
}
inline int SolutionResponse_Infeasibility::infeasibilityinfo_size() const {
  return _internal_infeasibilityinfo_size();
}
inline void SolutionResponse_Infeasibility::clear_infeasibilityinfo() {
  _internal_mutable_infeasibilityinfo()->Clear();
}
inline ::NVD::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::mutable_infeasibilityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_mutable_infeasibilityinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility_Info >*
SolutionResponse_Infeasibility::mutable_infeasibilityinfo() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.Infeasibility.infeasibilityInfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilityinfo();
}
inline const ::NVD::SolutionResponse_Infeasibility_Info& SolutionResponse_Infeasibility::infeasibilityinfo(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.Infeasibility.infeasibilityInfo)
    return _internal_infeasibilityinfo().Get(index);
}
inline ::NVD::SolutionResponse_Infeasibility_Info* SolutionResponse_Infeasibility::add_infeasibilityinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_Infeasibility_Info* _add = _internal_mutable_infeasibilityinfo()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility_Info >&
SolutionResponse_Infeasibility::infeasibilityinfo() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.Infeasibility.infeasibilityInfo)
  return _internal_infeasibilityinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility_Info>&
SolutionResponse_Infeasibility::_internal_infeasibilityinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilityinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility_Info>*
SolutionResponse_Infeasibility::_internal_mutable_infeasibilityinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilityinfo_;
}

// -------------------------------------------------------------------

// SolutionResponse_CompactSolution

// repeated .NVD.VisitSequence visitSequence = 1;
inline int SolutionResponse_CompactSolution::_internal_visitsequence_size() const {
  return _internal_visitsequence().size();
}
inline int SolutionResponse_CompactSolution::visitsequence_size() const {
  return _internal_visitsequence_size();
}
inline void SolutionResponse_CompactSolution::clear_visitsequence() {
  _internal_mutable_visitsequence()->Clear();
}
inline ::NVD::VisitSequence* SolutionResponse_CompactSolution::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.CompactSolution.visitSequence)
  return _internal_mutable_visitsequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >*
SolutionResponse_CompactSolution::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.CompactSolution.visitSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitsequence();
}
inline const ::NVD::VisitSequence& SolutionResponse_CompactSolution::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.CompactSolution.visitSequence)
    return _internal_visitsequence().Get(index);
}
inline ::NVD::VisitSequence* SolutionResponse_CompactSolution::add_visitsequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::VisitSequence* _add = _internal_mutable_visitsequence()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.CompactSolution.visitSequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::VisitSequence >&
SolutionResponse_CompactSolution::visitsequence() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.CompactSolution.visitSequence)
  return _internal_visitsequence();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>&
SolutionResponse_CompactSolution::_internal_visitsequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::VisitSequence>*
SolutionResponse_CompactSolution::_internal_mutable_visitsequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitsequence_;
}

// repeated float objectives = 2;
inline int SolutionResponse_CompactSolution::_internal_objectives_size() const {
  return _internal_objectives().size();
}
inline int SolutionResponse_CompactSolution::objectives_size() const {
  return _internal_objectives_size();
}
inline void SolutionResponse_CompactSolution::clear_objectives() {
  _internal_mutable_objectives()->Clear();
}
inline float SolutionResponse_CompactSolution::objectives(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.CompactSolution.objectives)
  return _internal_objectives().Get(index);
}
inline void SolutionResponse_CompactSolution::set_objectives(int index, float value) {
  _internal_mutable_objectives()->Set(index, value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.CompactSolution.objectives)
}
inline void SolutionResponse_CompactSolution::add_objectives(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectives()->Add(value);
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.CompactSolution.objectives)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_CompactSolution::objectives() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.CompactSolution.objectives)
  return _internal_objectives();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_CompactSolution::mutable_objectives() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.CompactSolution.objectives)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objectives();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_CompactSolution::_internal_objectives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectives_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_CompactSolution::_internal_mutable_objectives() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objectives_;
}

// repeated string objectiveNames = 3;
inline int SolutionResponse_CompactSolution::_internal_objectivenames_size() const {
  return _internal_objectivenames().size();
}
inline int SolutionResponse_CompactSolution::objectivenames_size() const {
  return _internal_objectivenames_size();
}
inline void SolutionResponse_CompactSolution::clear_objectivenames() {
  _internal_mutable_objectivenames()->Clear();
}
inline std::string* SolutionResponse_CompactSolution::add_objectivenames() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_objectivenames()->Add();
  // @@protoc_insertion_point(field_add_mutable:NVD.SolutionResponse.CompactSolution.objectiveNames)
  return _s;
}
inline const std::string& SolutionResponse_CompactSolution::objectivenames(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.CompactSolution.objectiveNames)
  return _internal_objectivenames().Get(index);
}
inline std::string* SolutionResponse_CompactSolution::mutable_objectivenames(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.CompactSolution.objectiveNames)
  return _internal_mutable_objectivenames()->Mutable(index);
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const std::string& value) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, std::string&& value) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_objectivenames()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::set_objectivenames(int index, absl::string_view value) {
  _internal_mutable_objectivenames()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline void SolutionResponse_CompactSolution::add_objectivenames(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_objectivenames()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NVD.SolutionResponse.CompactSolution.objectiveNames)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_CompactSolution::objectivenames() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.CompactSolution.objectiveNames)
  return _internal_objectivenames();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse_CompactSolution::mutable_objectivenames() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.CompactSolution.objectiveNames)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objectivenames();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse_CompactSolution::_internal_objectivenames() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectivenames_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse_CompactSolution::_internal_mutable_objectivenames() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objectivenames_;
}

// -------------------------------------------------------------------

// SolutionResponse_SolutionInstance

// repeated .NVD.SolutionResponse.Route routes = 1;
inline int SolutionResponse_SolutionInstance::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolutionResponse_SolutionInstance::routes_size() const {
  return _internal_routes_size();
}
inline void SolutionResponse_SolutionInstance::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::NVD::SolutionResponse_Route* SolutionResponse_SolutionInstance::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.SolutionInstance.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Route >*
SolutionResponse_SolutionInstance::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.SolutionInstance.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::NVD::SolutionResponse_Route& SolutionResponse_SolutionInstance::routes(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.SolutionInstance.routes)
    return _internal_routes().Get(index);
}
inline ::NVD::SolutionResponse_Route* SolutionResponse_SolutionInstance::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_Route* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.SolutionInstance.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Route >&
SolutionResponse_SolutionInstance::routes() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.SolutionInstance.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Route>&
SolutionResponse_SolutionInstance::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Route>*
SolutionResponse_SolutionInstance::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// repeated .NVD.SolutionResponse.Infeasibility infeasibilities = 2;
inline int SolutionResponse_SolutionInstance::_internal_infeasibilities_size() const {
  return _internal_infeasibilities().size();
}
inline int SolutionResponse_SolutionInstance::infeasibilities_size() const {
  return _internal_infeasibilities_size();
}
inline void SolutionResponse_SolutionInstance::clear_infeasibilities() {
  _internal_mutable_infeasibilities()->Clear();
}
inline ::NVD::SolutionResponse_Infeasibility* SolutionResponse_SolutionInstance::mutable_infeasibilities(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.SolutionInstance.infeasibilities)
  return _internal_mutable_infeasibilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility >*
SolutionResponse_SolutionInstance::mutable_infeasibilities() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.SolutionInstance.infeasibilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_infeasibilities();
}
inline const ::NVD::SolutionResponse_Infeasibility& SolutionResponse_SolutionInstance::infeasibilities(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.SolutionInstance.infeasibilities)
    return _internal_infeasibilities().Get(index);
}
inline ::NVD::SolutionResponse_Infeasibility* SolutionResponse_SolutionInstance::add_infeasibilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_Infeasibility* _add = _internal_mutable_infeasibilities()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.SolutionInstance.infeasibilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_Infeasibility >&
SolutionResponse_SolutionInstance::infeasibilities() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.SolutionInstance.infeasibilities)
  return _internal_infeasibilities();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility>&
SolutionResponse_SolutionInstance::_internal_infeasibilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infeasibilities_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_Infeasibility>*
SolutionResponse_SolutionInstance::_internal_mutable_infeasibilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.infeasibilities_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated .NVD.SolutionResponse.CompactSolution frontier = 1;
inline int SolutionResponse::_internal_frontier_size() const {
  return _internal_frontier().size();
}
inline int SolutionResponse::frontier_size() const {
  return _internal_frontier_size();
}
inline void SolutionResponse::clear_frontier() {
  _internal_mutable_frontier()->Clear();
}
inline ::NVD::SolutionResponse_CompactSolution* SolutionResponse::mutable_frontier(int index) {
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.frontier)
  return _internal_mutable_frontier()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_CompactSolution >*
SolutionResponse::mutable_frontier() {
  // @@protoc_insertion_point(field_mutable_list:NVD.SolutionResponse.frontier)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_frontier();
}
inline const ::NVD::SolutionResponse_CompactSolution& SolutionResponse::frontier(int index) const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.frontier)
    return _internal_frontier().Get(index);
}
inline ::NVD::SolutionResponse_CompactSolution* SolutionResponse::add_frontier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NVD::SolutionResponse_CompactSolution* _add = _internal_mutable_frontier()->Add();
  // @@protoc_insertion_point(field_add:NVD.SolutionResponse.frontier)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NVD::SolutionResponse_CompactSolution >&
SolutionResponse::frontier() const {
  // @@protoc_insertion_point(field_list:NVD.SolutionResponse.frontier)
  return _internal_frontier();
}
inline const ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_CompactSolution>&
SolutionResponse::_internal_frontier() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frontier_;
}
inline ::google::protobuf::RepeatedPtrField<::NVD::SolutionResponse_CompactSolution>*
SolutionResponse::_internal_mutable_frontier() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.frontier_;
}

// optional .NVD.SolutionResponse.SolutionInstance instance = 2;
inline bool SolutionResponse::has_instance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instance_ != nullptr);
  return value;
}
inline void SolutionResponse::clear_instance() {
  if (_impl_.instance_ != nullptr) _impl_.instance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NVD::SolutionResponse_SolutionInstance& SolutionResponse::_internal_instance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NVD::SolutionResponse_SolutionInstance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::NVD::SolutionResponse_SolutionInstance&>(::NVD::_SolutionResponse_SolutionInstance_default_instance_);
}
inline const ::NVD::SolutionResponse_SolutionInstance& SolutionResponse::instance() const {
  // @@protoc_insertion_point(field_get:NVD.SolutionResponse.instance)
  return _internal_instance();
}
inline void SolutionResponse::unsafe_arena_set_allocated_instance(::NVD::SolutionResponse_SolutionInstance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = reinterpret_cast<::NVD::SolutionResponse_SolutionInstance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NVD.SolutionResponse.instance)
}
inline ::NVD::SolutionResponse_SolutionInstance* SolutionResponse::release_instance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NVD::SolutionResponse_SolutionInstance* released = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NVD::SolutionResponse_SolutionInstance* SolutionResponse::unsafe_arena_release_instance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NVD.SolutionResponse.instance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NVD::SolutionResponse_SolutionInstance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::NVD::SolutionResponse_SolutionInstance* SolutionResponse::_internal_mutable_instance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::NVD::SolutionResponse_SolutionInstance>(GetArenaForAllocation());
    _impl_.instance_ = reinterpret_cast<::NVD::SolutionResponse_SolutionInstance*>(p);
  }
  return _impl_.instance_;
}
inline ::NVD::SolutionResponse_SolutionInstance* SolutionResponse::mutable_instance() {
  ::NVD::SolutionResponse_SolutionInstance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:NVD.SolutionResponse.instance)
  return _msg;
}
inline void SolutionResponse::set_allocated_instance(::NVD::SolutionResponse_SolutionInstance* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NVD::SolutionResponse_SolutionInstance*>(_impl_.instance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NVD::SolutionResponse_SolutionInstance*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.instance_ = reinterpret_cast<::NVD::SolutionResponse_SolutionInstance*>(value);
  // @@protoc_insertion_point(field_set_allocated:NVD.SolutionResponse.instance)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace NVD


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::NVD::Configuration_eMeasurementUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NVD::Configuration_eMeasurementUnit>() {
  return ::NVD::Configuration_eMeasurementUnit_descriptor();
}
template <>
struct is_proto_enum<::NVD::Profile_eFrequency> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NVD::Profile_eFrequency>() {
  return ::NVD::Profile_eFrequency_descriptor();
}
template <>
struct is_proto_enum<::NVD::Visit_TerritoryRelation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NVD::Visit_TerritoryRelation_Type>() {
  return ::NVD::Visit_TerritoryRelation_Type_descriptor();
}
template <>
struct is_proto_enum<::NVD::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NVD::SolveRequest_SolveType>() {
  return ::NVD::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_nvd_2dhap0j2y4zlm1_2eproto_2epb_2eh
