// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tsp-mcvfz472gty6.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tsp_2dmcvfz472gty6_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tsp_2dmcvfz472gty6_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tsp_2dmcvfz472gty6_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_tsp_2dmcvfz472gty6_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tsp_2dmcvfz472gty6_2eproto;
namespace TSP {
class Edge;
struct EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Edge_Geometry;
struct Edge_GeometryDefaultTypeInternal;
extern Edge_GeometryDefaultTypeInternal _Edge_Geometry_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class TSP;
struct TSPDefaultTypeInternal;
extern TSPDefaultTypeInternal _TSP_default_instance_;
}  // namespace TSP
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace TSP {
enum TSP_eDistanceType : int {
  TSP_eDistanceType_RoadNetwork = 1,
  TSP_eDistanceType_Euclidean = 2,
  TSP_eDistanceType_Haversine = 3,
};

bool TSP_eDistanceType_IsValid(int value);
constexpr TSP_eDistanceType TSP_eDistanceType_eDistanceType_MIN = static_cast<TSP_eDistanceType>(1);
constexpr TSP_eDistanceType TSP_eDistanceType_eDistanceType_MAX = static_cast<TSP_eDistanceType>(3);
constexpr int TSP_eDistanceType_eDistanceType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TSP_eDistanceType_descriptor();
template <typename T>
const std::string& TSP_eDistanceType_Name(T value) {
  static_assert(std::is_same<T, TSP_eDistanceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eDistanceType_Name().");
  return TSP_eDistanceType_Name(static_cast<TSP_eDistanceType>(value));
}
template <>
inline const std::string& TSP_eDistanceType_Name(TSP_eDistanceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TSP_eDistanceType_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool TSP_eDistanceType_Parse(absl::string_view name, TSP_eDistanceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TSP_eDistanceType>(
      TSP_eDistanceType_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(2);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSP.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float x = 2;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 3;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:TSP.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 22, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsp_2dmcvfz472gty6_2eproto;
};// -------------------------------------------------------------------

class TSP final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.TSP) */ {
 public:
  inline TSP() : TSP(nullptr) {}
  ~TSP() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TSP(::google::protobuf::internal::ConstantInitialized);

  TSP(const TSP& from);
  TSP(TSP&& from) noexcept
    : TSP() {
    *this = ::std::move(from);
  }

  inline TSP& operator=(const TSP& from) {
    CopyFrom(from);
    return *this;
  }
  inline TSP& operator=(TSP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TSP& default_instance() {
    return *internal_default_instance();
  }
  static inline const TSP* internal_default_instance() {
    return reinterpret_cast<const TSP*>(
               &_TSP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TSP& a, TSP& b) {
    a.Swap(&b);
  }
  inline void Swap(TSP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TSP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TSP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TSP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TSP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TSP& from) {
    TSP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TSP* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSP.TSP";
  }
  protected:
  explicit TSP(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eDistanceType = TSP_eDistanceType;
  static constexpr eDistanceType RoadNetwork = TSP_eDistanceType_RoadNetwork;
  static constexpr eDistanceType Euclidean = TSP_eDistanceType_Euclidean;
  static constexpr eDistanceType Haversine = TSP_eDistanceType_Haversine;
  static inline bool eDistanceType_IsValid(int value) {
    return TSP_eDistanceType_IsValid(value);
  }
  static constexpr eDistanceType eDistanceType_MIN = TSP_eDistanceType_eDistanceType_MIN;
  static constexpr eDistanceType eDistanceType_MAX = TSP_eDistanceType_eDistanceType_MAX;
  static constexpr int eDistanceType_ARRAYSIZE = TSP_eDistanceType_eDistanceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eDistanceType_descriptor() {
    return TSP_eDistanceType_descriptor();
  }
  template <typename T>
  static inline const std::string& eDistanceType_Name(T value) {
    return TSP_eDistanceType_Name(value);
  }
  static inline bool eDistanceType_Parse(absl::string_view name, eDistanceType* value) {
    return TSP_eDistanceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kDistancetypeFieldNumber = 2,
  };
  // repeated .TSP.Geocode points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::TSP::Geocode* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::TSP::Geocode>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::TSP::Geocode>* _internal_mutable_points();
  public:
  const ::TSP::Geocode& points(int index) const;
  ::TSP::Geocode* add_points();
  const ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >&
      points() const;
  // optional .TSP.TSP.eDistanceType distancetype = 2 [default = RoadNetwork];
  bool has_distancetype() const;
  void clear_distancetype() ;
  ::TSP::TSP_eDistanceType distancetype() const;
  void set_distancetype(::TSP::TSP_eDistanceType value);

  private:
  ::TSP::TSP_eDistanceType _internal_distancetype() const;
  void _internal_set_distancetype(::TSP::TSP_eDistanceType value);

  public:
  // @@protoc_insertion_point(class_scope:TSP.TSP)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::TSP::Geocode > points_;
    int distancetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsp_2dmcvfz472gty6_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSP.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static constexpr SolveType Evaluate = SolveRequest_SolveType_Evaluate;
  static constexpr SolveType ReOptimise = SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVisitSequenceFieldNumber = 3,
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
  };
  // repeated string visitSequence = 3;
  int visitsequence_size() const;
  private:
  int _internal_visitsequence_size() const;

  public:
  void clear_visitsequence() ;
  const std::string& visitsequence(int index) const;
  std::string* mutable_visitsequence(int index);
  void set_visitsequence(int index, const std::string& value);
  void set_visitsequence(int index, std::string&& value);
  void set_visitsequence(int index, const char* value);
  void set_visitsequence(int index, const char* value, std::size_t size);
  void set_visitsequence(int index, absl::string_view value);
  std::string* add_visitsequence();
  void add_visitsequence(const std::string& value);
  void add_visitsequence(std::string&& value);
  void add_visitsequence(const char* value);
  void add_visitsequence(const char* value, std::size_t size);
  void add_visitsequence(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& visitsequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_visitsequence();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_visitsequence() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_visitsequence();

  public:
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .TSP.TSP model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::TSP::TSP& model() const;
  PROTOBUF_NODISCARD ::TSP::TSP* release_model();
  ::TSP::TSP* mutable_model();
  void set_allocated_model(::TSP::TSP* value);
  void unsafe_arena_set_allocated_model(::TSP::TSP* value);
  ::TSP::TSP* unsafe_arena_release_model();

  private:
  const ::TSP::TSP& _internal_model() const;
  ::TSP::TSP* _internal_mutable_model();

  public:
  // optional .TSP.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::TSP::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::TSP::SolveRequest_SolveType value);

  private:
  ::TSP::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::TSP::SolveRequest_SolveType value);

  public:
  // @@protoc_insertion_point(class_scope:TSP.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> visitsequence_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::TSP::TSP* model_;
    int solvetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsp_2dmcvfz472gty6_2eproto;
};// -------------------------------------------------------------------

class Edge_Geometry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.Edge.Geometry) */ {
 public:
  inline Edge_Geometry() : Edge_Geometry(nullptr) {}
  ~Edge_Geometry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Edge_Geometry(::google::protobuf::internal::ConstantInitialized);

  Edge_Geometry(const Edge_Geometry& from);
  Edge_Geometry(Edge_Geometry&& from) noexcept
    : Edge_Geometry() {
    *this = ::std::move(from);
  }

  inline Edge_Geometry& operator=(const Edge_Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge_Geometry& operator=(Edge_Geometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge_Geometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge_Geometry* internal_default_instance() {
    return reinterpret_cast<const Edge_Geometry*>(
               &_Edge_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Edge_Geometry& a, Edge_Geometry& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge_Geometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge_Geometry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge_Geometry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge_Geometry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Edge_Geometry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Edge_Geometry& from) {
    Edge_Geometry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge_Geometry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSP.Edge.Geometry";
  }
  protected:
  explicit Edge_Geometry(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:TSP.Edge.Geometry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsp_2dmcvfz472gty6_2eproto;
};// -------------------------------------------------------------------

class Edge final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.Edge) */ {
 public:
  inline Edge() : Edge(nullptr) {}
  ~Edge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Edge(::google::protobuf::internal::ConstantInitialized);

  Edge(const Edge& from);
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge& operator=(Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Edge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Edge& from) {
    Edge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSP.Edge";
  }
  protected:
  explicit Edge(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Edge_Geometry Geometry;

  // accessors -------------------------------------------------------

  enum : int {
    kGeometryFieldNumber = 4,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // repeated .TSP.Edge.Geometry geometry = 4;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;

  public:
  void clear_geometry() ;
  ::TSP::Edge_Geometry* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >*
      mutable_geometry();
  private:
  const ::google::protobuf::RepeatedPtrField<::TSP::Edge_Geometry>& _internal_geometry() const;
  ::google::protobuf::RepeatedPtrField<::TSP::Edge_Geometry>* _internal_mutable_geometry();
  public:
  const ::TSP::Edge_Geometry& geometry(int index) const;
  ::TSP::Edge_Geometry* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >&
      geometry() const;
  // required string from = 1;
  bool has_from() const;
  void clear_from() ;
  const std::string& from() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from(Arg_&& arg, Args_... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* ptr);

  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(
      const std::string& value);
  std::string* _internal_mutable_from();

  public:
  // required string to = 2;
  bool has_to() const;
  void clear_to() ;
  const std::string& to() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to(Arg_&& arg, Args_... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* ptr);

  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(
      const std::string& value);
  std::string* _internal_mutable_to();

  public:
  // optional float distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  // @@protoc_insertion_point(class_scope:TSP.Edge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 23, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry > geometry_;
    ::google::protobuf::internal::ArenaStringPtr from_;
    ::google::protobuf::internal::ArenaStringPtr to_;
    float distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsp_2dmcvfz472gty6_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TSP.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTourFieldNumber = 1,
    kEdgesFieldNumber = 2,
  };
  // repeated string tour = 1;
  int tour_size() const;
  private:
  int _internal_tour_size() const;

  public:
  void clear_tour() ;
  const std::string& tour(int index) const;
  std::string* mutable_tour(int index);
  void set_tour(int index, const std::string& value);
  void set_tour(int index, std::string&& value);
  void set_tour(int index, const char* value);
  void set_tour(int index, const char* value, std::size_t size);
  void set_tour(int index, absl::string_view value);
  std::string* add_tour();
  void add_tour(const std::string& value);
  void add_tour(std::string&& value);
  void add_tour(const char* value);
  void add_tour(const char* value, std::size_t size);
  void add_tour(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tour() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tour();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tour() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tour();

  public:
  // repeated .TSP.Edge edges = 2;
  int edges_size() const;
  private:
  int _internal_edges_size() const;

  public:
  void clear_edges() ;
  ::TSP::Edge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::TSP::Edge >*
      mutable_edges();
  private:
  const ::google::protobuf::RepeatedPtrField<::TSP::Edge>& _internal_edges() const;
  ::google::protobuf::RepeatedPtrField<::TSP::Edge>* _internal_mutable_edges();
  public:
  const ::TSP::Edge& edges(int index) const;
  ::TSP::Edge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::TSP::Edge >&
      edges() const;
  // @@protoc_insertion_point(class_scope:TSP.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 33, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> tour_;
    ::google::protobuf::RepeatedPtrField< ::TSP::Edge > edges_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tsp_2dmcvfz472gty6_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Geocode

// required string id = 1;
inline bool Geocode::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Geocode::id() const {
  // @@protoc_insertion_point(field_get:TSP.Geocode.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Geocode::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSP.Geocode.id)
}
inline std::string* Geocode::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:TSP.Geocode.id)
  return _s;
}
inline const std::string& Geocode::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Geocode::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Geocode::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Geocode::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSP.Geocode.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Geocode::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSP.Geocode.id)
}

// required float x = 2;
inline bool Geocode::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::x() const {
  // @@protoc_insertion_point(field_get:TSP.Geocode.x)
  return _internal_x();
}
inline void Geocode::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TSP.Geocode.x)
}
inline float Geocode::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Geocode::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}

// required float y = 3;
inline bool Geocode::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Geocode::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Geocode::y() const {
  // @@protoc_insertion_point(field_get:TSP.Geocode.y)
  return _internal_y();
}
inline void Geocode::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TSP.Geocode.y)
}
inline float Geocode::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Geocode::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TSP

// repeated .TSP.Geocode points = 1;
inline int TSP::_internal_points_size() const {
  return _internal_points().size();
}
inline int TSP::points_size() const {
  return _internal_points_size();
}
inline void TSP::clear_points() {
  _internal_mutable_points()->Clear();
}
inline ::TSP::Geocode* TSP::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.TSP.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >*
TSP::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:TSP.TSP.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::TSP::Geocode& TSP::points(int index) const {
  // @@protoc_insertion_point(field_get:TSP.TSP.points)
    return _internal_points().Get(index);
}
inline ::TSP::Geocode* TSP::add_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TSP::Geocode* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:TSP.TSP.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >&
TSP::points() const {
  // @@protoc_insertion_point(field_list:TSP.TSP.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::TSP::Geocode>&
TSP::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::TSP::Geocode>*
TSP::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// optional .TSP.TSP.eDistanceType distancetype = 2 [default = RoadNetwork];
inline bool TSP::has_distancetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TSP::clear_distancetype() {
  _impl_.distancetype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TSP::TSP_eDistanceType TSP::distancetype() const {
  // @@protoc_insertion_point(field_get:TSP.TSP.distancetype)
  return _internal_distancetype();
}
inline void TSP::set_distancetype(::TSP::TSP_eDistanceType value) {
  _internal_set_distancetype(value);
  // @@protoc_insertion_point(field_set:TSP.TSP.distancetype)
}
inline ::TSP::TSP_eDistanceType TSP::_internal_distancetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TSP::TSP_eDistanceType>(_impl_.distancetype_);
}
inline void TSP::_internal_set_distancetype(::TSP::TSP_eDistanceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::TSP::TSP_eDistanceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.distancetype_ = value;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .TSP.TSP model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSP::TSP& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TSP::TSP* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::TSP&>(::TSP::_TSP_default_instance_);
}
inline const ::TSP::TSP& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::TSP::TSP* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::TSP::TSP*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.SolveRequest.model)
}
inline ::TSP::TSP* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::TSP* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TSP::TSP* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSP.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::TSP* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::TSP::TSP* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::TSP>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::TSP::TSP*>(p);
  }
  return _impl_.model_;
}
inline ::TSP::TSP* SolveRequest::mutable_model() {
  ::TSP::TSP* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:TSP.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::TSP::TSP* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TSP::TSP*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::TSP::TSP*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::TSP::TSP*>(value);
  // @@protoc_insertion_point(field_set_allocated:TSP.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:TSP.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSP.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSP.SolveRequest.modelID)
}

// repeated string visitSequence = 3;
inline int SolveRequest::_internal_visitsequence_size() const {
  return _internal_visitsequence().size();
}
inline int SolveRequest::visitsequence_size() const {
  return _internal_visitsequence_size();
}
inline void SolveRequest::clear_visitsequence() {
  _internal_mutable_visitsequence()->Clear();
}
inline std::string* SolveRequest::add_visitsequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_visitsequence()->Add();
  // @@protoc_insertion_point(field_add_mutable:TSP.SolveRequest.visitSequence)
  return _s;
}
inline const std::string& SolveRequest::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.visitSequence)
  return _internal_visitsequence().Get(index);
}
inline std::string* SolveRequest::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.SolveRequest.visitSequence)
  return _internal_mutable_visitsequence()->Mutable(index);
}
inline void SolveRequest::set_visitsequence(int index, const std::string& value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, std::string&& value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_visitsequence()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, absl::string_view value) {
  _internal_mutable_visitsequence()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_visitsequence()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TSP.SolveRequest.visitSequence)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolveRequest::visitsequence() const {
  // @@protoc_insertion_point(field_list:TSP.SolveRequest.visitSequence)
  return _internal_visitsequence();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolveRequest::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:TSP.SolveRequest.visitSequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_visitsequence();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolveRequest::_internal_visitsequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolveRequest::_internal_mutable_visitsequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.visitsequence_;
}

// optional .TSP.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TSP::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::TSP::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.solveType)
}
inline ::TSP::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TSP::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::TSP::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::TSP::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// -------------------------------------------------------------------

// Edge_Geometry

// required float x = 1;
inline bool Edge_Geometry::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Edge_Geometry::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Edge_Geometry::x() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.Geometry.x)
  return _internal_x();
}
inline void Edge_Geometry::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TSP.Edge.Geometry.x)
}
inline float Edge_Geometry::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Edge_Geometry::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Edge_Geometry::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Edge_Geometry::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Edge_Geometry::y() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.Geometry.y)
  return _internal_y();
}
inline void Edge_Geometry::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TSP.Edge.Geometry.y)
}
inline float Edge_Geometry::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Edge_Geometry::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Edge

// required string from = 1;
inline bool Edge::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Edge::clear_from() {
  _impl_.from_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Edge::from() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.from)
  return _internal_from();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Edge::set_from(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSP.Edge.from)
}
inline std::string* Edge::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:TSP.Edge.from)
  return _s;
}
inline const std::string& Edge::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_.Get();
}
inline void Edge::_internal_set_from(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* Edge::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.from_.Mutable( GetArenaForAllocation());
}
inline std::string* Edge::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSP.Edge.from)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.from_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Edge::set_allocated_from(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_.IsDefault()) {
          _impl_.from_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSP.Edge.from)
}

// required string to = 2;
inline bool Edge::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Edge::clear_to() {
  _impl_.to_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Edge::to() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.to)
  return _internal_to();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Edge::set_to(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSP.Edge.to)
}
inline std::string* Edge::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:TSP.Edge.to)
  return _s;
}
inline const std::string& Edge::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_.Get();
}
inline void Edge::_internal_set_to(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* Edge::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.to_.Mutable( GetArenaForAllocation());
}
inline std::string* Edge::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TSP.Edge.to)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.to_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.to_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Edge::set_allocated_to(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.to_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_.IsDefault()) {
          _impl_.to_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSP.Edge.to)
}

// optional float distance = 3;
inline bool Edge::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Edge::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Edge::distance() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.distance)
  return _internal_distance();
}
inline void Edge::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:TSP.Edge.distance)
}
inline float Edge::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void Edge::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.distance_ = value;
}

// repeated .TSP.Edge.Geometry geometry = 4;
inline int Edge::_internal_geometry_size() const {
  return _internal_geometry().size();
}
inline int Edge::geometry_size() const {
  return _internal_geometry_size();
}
inline void Edge::clear_geometry() {
  _internal_mutable_geometry()->Clear();
}
inline ::TSP::Edge_Geometry* Edge::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.Edge.geometry)
  return _internal_mutable_geometry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >*
Edge::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:TSP.Edge.geometry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometry();
}
inline const ::TSP::Edge_Geometry& Edge::geometry(int index) const {
  // @@protoc_insertion_point(field_get:TSP.Edge.geometry)
    return _internal_geometry().Get(index);
}
inline ::TSP::Edge_Geometry* Edge::add_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TSP::Edge_Geometry* _add = _internal_mutable_geometry()->Add();
  // @@protoc_insertion_point(field_add:TSP.Edge.geometry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >&
Edge::geometry() const {
  // @@protoc_insertion_point(field_list:TSP.Edge.geometry)
  return _internal_geometry();
}
inline const ::google::protobuf::RepeatedPtrField<::TSP::Edge_Geometry>&
Edge::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometry_;
}
inline ::google::protobuf::RepeatedPtrField<::TSP::Edge_Geometry>*
Edge::_internal_mutable_geometry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated string tour = 1;
inline int SolutionResponse::_internal_tour_size() const {
  return _internal_tour().size();
}
inline int SolutionResponse::tour_size() const {
  return _internal_tour_size();
}
inline void SolutionResponse::clear_tour() {
  _internal_mutable_tour()->Clear();
}
inline std::string* SolutionResponse::add_tour() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tour()->Add();
  // @@protoc_insertion_point(field_add_mutable:TSP.SolutionResponse.tour)
  return _s;
}
inline const std::string& SolutionResponse::tour(int index) const {
  // @@protoc_insertion_point(field_get:TSP.SolutionResponse.tour)
  return _internal_tour().Get(index);
}
inline std::string* SolutionResponse::mutable_tour(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.SolutionResponse.tour)
  return _internal_mutable_tour()->Mutable(index);
}
inline void SolutionResponse::set_tour(int index, const std::string& value) {
  _internal_mutable_tour()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, std::string&& value) {
  _internal_mutable_tour()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tour()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tour()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, absl::string_view value) {
  _internal_mutable_tour()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tour()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TSP.SolutionResponse.tour)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse::tour() const {
  // @@protoc_insertion_point(field_list:TSP.SolutionResponse.tour)
  return _internal_tour();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SolutionResponse::mutable_tour() {
  // @@protoc_insertion_point(field_mutable_list:TSP.SolutionResponse.tour)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tour();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SolutionResponse::_internal_tour() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tour_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SolutionResponse::_internal_mutable_tour() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tour_;
}

// repeated .TSP.Edge edges = 2;
inline int SolutionResponse::_internal_edges_size() const {
  return _internal_edges().size();
}
inline int SolutionResponse::edges_size() const {
  return _internal_edges_size();
}
inline void SolutionResponse::clear_edges() {
  _internal_mutable_edges()->Clear();
}
inline ::TSP::Edge* SolutionResponse::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.SolutionResponse.edges)
  return _internal_mutable_edges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Edge >*
SolutionResponse::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:TSP.SolutionResponse.edges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_edges();
}
inline const ::TSP::Edge& SolutionResponse::edges(int index) const {
  // @@protoc_insertion_point(field_get:TSP.SolutionResponse.edges)
    return _internal_edges().Get(index);
}
inline ::TSP::Edge* SolutionResponse::add_edges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TSP::Edge* _add = _internal_mutable_edges()->Add();
  // @@protoc_insertion_point(field_add:TSP.SolutionResponse.edges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Edge >&
SolutionResponse::edges() const {
  // @@protoc_insertion_point(field_list:TSP.SolutionResponse.edges)
  return _internal_edges();
}
inline const ::google::protobuf::RepeatedPtrField<::TSP::Edge>&
SolutionResponse::_internal_edges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.edges_;
}
inline ::google::protobuf::RepeatedPtrField<::TSP::Edge>*
SolutionResponse::_internal_mutable_edges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.edges_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSP


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::TSP::TSP_eDistanceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TSP::TSP_eDistanceType>() {
  return ::TSP::TSP_eDistanceType_descriptor();
}
template <>
struct is_proto_enum<::TSP::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TSP::SolveRequest_SolveType>() {
  return ::TSP::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tsp_2dmcvfz472gty6_2eproto_2epb_2eh
