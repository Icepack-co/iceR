// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tsp-mcvfz472gty6.proto

#ifndef PROTOBUF_INCLUDED_tsp_2dmcvfz472gty6_2eproto
#define PROTOBUF_INCLUDED_tsp_2dmcvfz472gty6_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tsp_2dmcvfz472gty6_2eproto 

namespace protobuf_tsp_2dmcvfz472gty6_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tsp_2dmcvfz472gty6_2eproto
namespace TSP {
class Edge;
class EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Edge_Geometry;
class Edge_GeometryDefaultTypeInternal;
extern Edge_GeometryDefaultTypeInternal _Edge_Geometry_default_instance_;
class Geocode;
class GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class SolutionResponse;
class SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolveRequest;
class SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class TSP;
class TSPDefaultTypeInternal;
extern TSPDefaultTypeInternal _TSP_default_instance_;
}  // namespace TSP
namespace google {
namespace protobuf {
template<> ::TSP::Edge* Arena::CreateMaybeMessage<::TSP::Edge>(Arena*);
template<> ::TSP::Edge_Geometry* Arena::CreateMaybeMessage<::TSP::Edge_Geometry>(Arena*);
template<> ::TSP::Geocode* Arena::CreateMaybeMessage<::TSP::Geocode>(Arena*);
template<> ::TSP::SolutionResponse* Arena::CreateMaybeMessage<::TSP::SolutionResponse>(Arena*);
template<> ::TSP::SolveRequest* Arena::CreateMaybeMessage<::TSP::SolveRequest>(Arena*);
template<> ::TSP::TSP* Arena::CreateMaybeMessage<::TSP::TSP>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace TSP {

enum TSP_eDistanceType {
  TSP_eDistanceType_RoadNetwork = 1,
  TSP_eDistanceType_Euclidean = 2,
  TSP_eDistanceType_Haversine = 3
};
bool TSP_eDistanceType_IsValid(int value);
const TSP_eDistanceType TSP_eDistanceType_eDistanceType_MIN = TSP_eDistanceType_RoadNetwork;
const TSP_eDistanceType TSP_eDistanceType_eDistanceType_MAX = TSP_eDistanceType_Haversine;
const int TSP_eDistanceType_eDistanceType_ARRAYSIZE = TSP_eDistanceType_eDistanceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TSP_eDistanceType_descriptor();
inline const ::std::string& TSP_eDistanceType_Name(TSP_eDistanceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TSP_eDistanceType_descriptor(), value);
}
inline bool TSP_eDistanceType_Parse(
    const ::std::string& name, TSP_eDistanceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TSP_eDistanceType>(
    TSP_eDistanceType_descriptor(), name, value);
}
enum SolveRequest_SolveType {
  SolveRequest_SolveType_Optimise = 0,
  SolveRequest_SolveType_Evaluate = 1,
  SolveRequest_SolveType_ReOptimise = 2
};
bool SolveRequest_SolveType_IsValid(int value);
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = SolveRequest_SolveType_Optimise;
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = SolveRequest_SolveType_ReOptimise;
const int SolveRequest_SolveType_SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor();
inline const ::std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_SolveType_descriptor(), value);
}
inline bool SolveRequest_SolveType_Parse(
    const ::std::string& name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
    SolveRequest_SolveType_descriptor(), name, value);
}
// ===================================================================

class Geocode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.Geocode) */ {
 public:
  Geocode();
  virtual ~Geocode();

  Geocode(const Geocode& from);

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(Geocode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geocode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Geocode* other);
  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geocode* New() const final {
    return CreateMaybeMessage<Geocode>(NULL);
  }

  Geocode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geocode& from);
  void MergeFrom(const Geocode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required float x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // required float y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:TSP.Geocode)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  float x_;
  float y_;
  friend struct ::protobuf_tsp_2dmcvfz472gty6_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TSP : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.TSP) */ {
 public:
  TSP();
  virtual ~TSP();

  TSP(const TSP& from);

  inline TSP& operator=(const TSP& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TSP(TSP&& from) noexcept
    : TSP() {
    *this = ::std::move(from);
  }

  inline TSP& operator=(TSP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TSP* internal_default_instance() {
    return reinterpret_cast<const TSP*>(
               &_TSP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TSP* other);
  friend void swap(TSP& a, TSP& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TSP* New() const final {
    return CreateMaybeMessage<TSP>(NULL);
  }

  TSP* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TSP>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TSP& from);
  void MergeFrom(const TSP& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TSP* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TSP_eDistanceType eDistanceType;
  static const eDistanceType RoadNetwork =
    TSP_eDistanceType_RoadNetwork;
  static const eDistanceType Euclidean =
    TSP_eDistanceType_Euclidean;
  static const eDistanceType Haversine =
    TSP_eDistanceType_Haversine;
  static inline bool eDistanceType_IsValid(int value) {
    return TSP_eDistanceType_IsValid(value);
  }
  static const eDistanceType eDistanceType_MIN =
    TSP_eDistanceType_eDistanceType_MIN;
  static const eDistanceType eDistanceType_MAX =
    TSP_eDistanceType_eDistanceType_MAX;
  static const int eDistanceType_ARRAYSIZE =
    TSP_eDistanceType_eDistanceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eDistanceType_descriptor() {
    return TSP_eDistanceType_descriptor();
  }
  static inline const ::std::string& eDistanceType_Name(eDistanceType value) {
    return TSP_eDistanceType_Name(value);
  }
  static inline bool eDistanceType_Parse(const ::std::string& name,
      eDistanceType* value) {
    return TSP_eDistanceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TSP.Geocode points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::TSP::Geocode* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >*
      mutable_points();
  const ::TSP::Geocode& points(int index) const;
  ::TSP::Geocode* add_points();
  const ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >&
      points() const;

  // optional .TSP.TSP.eDistanceType distancetype = 2 [default = RoadNetwork];
  bool has_distancetype() const;
  void clear_distancetype();
  static const int kDistancetypeFieldNumber = 2;
  ::TSP::TSP_eDistanceType distancetype() const;
  void set_distancetype(::TSP::TSP_eDistanceType value);

  // @@protoc_insertion_point(class_scope:TSP.TSP)
 private:
  void set_has_distancetype();
  void clear_has_distancetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Geocode > points_;
  int distancetype_;
  friend struct ::protobuf_tsp_2dmcvfz472gty6_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.SolveRequest) */ {
 public:
  SolveRequest();
  virtual ~SolveRequest();

  SolveRequest(const SolveRequest& from);

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SolveRequest* other);
  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolveRequest* New() const final {
    return CreateMaybeMessage<SolveRequest>(NULL);
  }

  SolveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolveRequest& from);
  void MergeFrom(const SolveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolveRequest_SolveType SolveType;
  static const SolveType Optimise =
    SolveRequest_SolveType_Optimise;
  static const SolveType Evaluate =
    SolveRequest_SolveType_Evaluate;
  static const SolveType ReOptimise =
    SolveRequest_SolveType_ReOptimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static const SolveType SolveType_MIN =
    SolveRequest_SolveType_SolveType_MIN;
  static const SolveType SolveType_MAX =
    SolveRequest_SolveType_SolveType_MAX;
  static const int SolveType_ARRAYSIZE =
    SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  static inline const ::std::string& SolveType_Name(SolveType value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(const ::std::string& name,
      SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string visitSequence = 3;
  int visitsequence_size() const;
  void clear_visitsequence();
  static const int kVisitSequenceFieldNumber = 3;
  const ::std::string& visitsequence(int index) const;
  ::std::string* mutable_visitsequence(int index);
  void set_visitsequence(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_visitsequence(int index, ::std::string&& value);
  #endif
  void set_visitsequence(int index, const char* value);
  void set_visitsequence(int index, const char* value, size_t size);
  ::std::string* add_visitsequence();
  void add_visitsequence(const ::std::string& value);
  #if LANG_CXX11
  void add_visitsequence(::std::string&& value);
  #endif
  void add_visitsequence(const char* value);
  void add_visitsequence(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& visitsequence() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_visitsequence();

  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIDFieldNumber = 2;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // optional .TSP.TSP model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  private:
  const ::TSP::TSP& _internal_model() const;
  public:
  const ::TSP::TSP& model() const;
  ::TSP::TSP* release_model();
  ::TSP::TSP* mutable_model();
  void set_allocated_model(::TSP::TSP* model);

  // optional .TSP.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype();
  static const int kSolveTypeFieldNumber = 4;
  ::TSP::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::TSP::SolveRequest_SolveType value);

  // @@protoc_insertion_point(class_scope:TSP.SolveRequest)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_modelid();
  void clear_has_modelid();
  void set_has_solvetype();
  void clear_has_solvetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> visitsequence_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  ::TSP::TSP* model_;
  int solvetype_;
  friend struct ::protobuf_tsp_2dmcvfz472gty6_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge_Geometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.Edge.Geometry) */ {
 public:
  Edge_Geometry();
  virtual ~Edge_Geometry();

  Edge_Geometry(const Edge_Geometry& from);

  inline Edge_Geometry& operator=(const Edge_Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edge_Geometry(Edge_Geometry&& from) noexcept
    : Edge_Geometry() {
    *this = ::std::move(from);
  }

  inline Edge_Geometry& operator=(Edge_Geometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge_Geometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edge_Geometry* internal_default_instance() {
    return reinterpret_cast<const Edge_Geometry*>(
               &_Edge_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Edge_Geometry* other);
  friend void swap(Edge_Geometry& a, Edge_Geometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edge_Geometry* New() const final {
    return CreateMaybeMessage<Edge_Geometry>(NULL);
  }

  Edge_Geometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edge_Geometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edge_Geometry& from);
  void MergeFrom(const Edge_Geometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge_Geometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:TSP.Edge.Geometry)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_tsp_2dmcvfz472gty6_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(Edge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Edge* other);
  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edge* New() const final {
    return CreateMaybeMessage<Edge>(NULL);
  }

  Edge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Edge_Geometry Geometry;

  // accessors -------------------------------------------------------

  // repeated .TSP.Edge.Geometry geometry = 4;
  int geometry_size() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 4;
  ::TSP::Edge_Geometry* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >*
      mutable_geometry();
  const ::TSP::Edge_Geometry& geometry(int index) const;
  ::TSP::Edge_Geometry* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >&
      geometry() const;

  // required string from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // required string to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional float distance = 3;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:TSP.Edge)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_distance();
  void clear_has_distance();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry > geometry_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  float distance_;
  friend struct ::protobuf_tsp_2dmcvfz472gty6_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TSP.SolutionResponse) */ {
 public:
  SolutionResponse();
  virtual ~SolutionResponse();

  SolutionResponse(const SolutionResponse& from);

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SolutionResponse* other);
  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse* New() const final {
    return CreateMaybeMessage<SolutionResponse>(NULL);
  }

  SolutionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse& from);
  void MergeFrom(const SolutionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tour = 1;
  int tour_size() const;
  void clear_tour();
  static const int kTourFieldNumber = 1;
  const ::std::string& tour(int index) const;
  ::std::string* mutable_tour(int index);
  void set_tour(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tour(int index, ::std::string&& value);
  #endif
  void set_tour(int index, const char* value);
  void set_tour(int index, const char* value, size_t size);
  ::std::string* add_tour();
  void add_tour(const ::std::string& value);
  #if LANG_CXX11
  void add_tour(::std::string&& value);
  #endif
  void add_tour(const char* value);
  void add_tour(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tour() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tour();

  // repeated .TSP.Edge edges = 2;
  int edges_size() const;
  void clear_edges();
  static const int kEdgesFieldNumber = 2;
  ::TSP::Edge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::TSP::Edge >*
      mutable_edges();
  const ::TSP::Edge& edges(int index) const;
  ::TSP::Edge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::TSP::Edge >&
      edges() const;

  // @@protoc_insertion_point(class_scope:TSP.SolutionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tour_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Edge > edges_;
  friend struct ::protobuf_tsp_2dmcvfz472gty6_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Geocode

// required string id = 1;
inline bool Geocode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geocode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geocode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geocode::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Geocode::id() const {
  // @@protoc_insertion_point(field_get:TSP.Geocode.id)
  return id_.GetNoArena();
}
inline void Geocode::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TSP.Geocode.id)
}
#if LANG_CXX11
inline void Geocode::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TSP.Geocode.id)
}
#endif
inline void Geocode::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TSP.Geocode.id)
}
inline void Geocode::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TSP.Geocode.id)
}
inline ::std::string* Geocode::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:TSP.Geocode.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Geocode::release_id() {
  // @@protoc_insertion_point(field_release:TSP.Geocode.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Geocode::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:TSP.Geocode.id)
}

// required float x = 2;
inline bool Geocode::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geocode::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geocode::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geocode::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Geocode::x() const {
  // @@protoc_insertion_point(field_get:TSP.Geocode.x)
  return x_;
}
inline void Geocode::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:TSP.Geocode.x)
}

// required float y = 3;
inline bool Geocode::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Geocode::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Geocode::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Geocode::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Geocode::y() const {
  // @@protoc_insertion_point(field_get:TSP.Geocode.y)
  return y_;
}
inline void Geocode::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:TSP.Geocode.y)
}

// -------------------------------------------------------------------

// TSP

// repeated .TSP.Geocode points = 1;
inline int TSP::points_size() const {
  return points_.size();
}
inline void TSP::clear_points() {
  points_.Clear();
}
inline ::TSP::Geocode* TSP::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.TSP.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >*
TSP::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:TSP.TSP.points)
  return &points_;
}
inline const ::TSP::Geocode& TSP::points(int index) const {
  // @@protoc_insertion_point(field_get:TSP.TSP.points)
  return points_.Get(index);
}
inline ::TSP::Geocode* TSP::add_points() {
  // @@protoc_insertion_point(field_add:TSP.TSP.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Geocode >&
TSP::points() const {
  // @@protoc_insertion_point(field_list:TSP.TSP.points)
  return points_;
}

// optional .TSP.TSP.eDistanceType distancetype = 2 [default = RoadNetwork];
inline bool TSP::has_distancetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TSP::set_has_distancetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TSP::clear_has_distancetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TSP::clear_distancetype() {
  distancetype_ = 1;
  clear_has_distancetype();
}
inline ::TSP::TSP_eDistanceType TSP::distancetype() const {
  // @@protoc_insertion_point(field_get:TSP.TSP.distancetype)
  return static_cast< ::TSP::TSP_eDistanceType >(distancetype_);
}
inline void TSP::set_distancetype(::TSP::TSP_eDistanceType value) {
  assert(::TSP::TSP_eDistanceType_IsValid(value));
  set_has_distancetype();
  distancetype_ = value;
  // @@protoc_insertion_point(field_set:TSP.TSP.distancetype)
}

// -------------------------------------------------------------------

// SolveRequest

// optional .TSP.TSP model = 1;
inline bool SolveRequest::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolveRequest::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolveRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolveRequest::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::TSP::TSP& SolveRequest::_internal_model() const {
  return *model_;
}
inline const ::TSP::TSP& SolveRequest::model() const {
  const ::TSP::TSP* p = model_;
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.model)
  return p != NULL ? *p : *reinterpret_cast<const ::TSP::TSP*>(
      &::TSP::_TSP_default_instance_);
}
inline ::TSP::TSP* SolveRequest::release_model() {
  // @@protoc_insertion_point(field_release:TSP.SolveRequest.model)
  clear_has_model();
  ::TSP::TSP* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::TSP::TSP* SolveRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    auto* p = CreateMaybeMessage<::TSP::TSP>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TSP.SolveRequest.model)
  return model_;
}
inline void SolveRequest::set_allocated_model(::TSP::TSP* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:TSP.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolveRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolveRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolveRequest::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.modelID)
  return modelid_.GetNoArena();
}
inline void SolveRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.modelID)
}
#if LANG_CXX11
inline void SolveRequest::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TSP.SolveRequest.modelID)
}
#endif
inline void SolveRequest::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TSP.SolveRequest.modelID)
}
inline void SolveRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TSP.SolveRequest.modelID)
}
inline ::std::string* SolveRequest::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:TSP.SolveRequest.modelID)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolveRequest::release_modelid() {
  // @@protoc_insertion_point(field_release:TSP.SolveRequest.modelID)
  if (!has_modelid()) {
    return NULL;
  }
  clear_has_modelid();
  return modelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolveRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:TSP.SolveRequest.modelID)
}

// repeated string visitSequence = 3;
inline int SolveRequest::visitsequence_size() const {
  return visitsequence_.size();
}
inline void SolveRequest::clear_visitsequence() {
  visitsequence_.Clear();
}
inline const ::std::string& SolveRequest::visitsequence(int index) const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.visitSequence)
  return visitsequence_.Get(index);
}
inline ::std::string* SolveRequest::mutable_visitsequence(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.SolveRequest.visitSequence)
  return visitsequence_.Mutable(index);
}
inline void SolveRequest::set_visitsequence(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.visitSequence)
  visitsequence_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolveRequest::set_visitsequence(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.visitSequence)
  visitsequence_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolveRequest::set_visitsequence(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  visitsequence_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::set_visitsequence(int index, const char* value, size_t size) {
  visitsequence_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSP.SolveRequest.visitSequence)
}
inline ::std::string* SolveRequest::add_visitsequence() {
  // @@protoc_insertion_point(field_add_mutable:TSP.SolveRequest.visitSequence)
  return visitsequence_.Add();
}
inline void SolveRequest::add_visitsequence(const ::std::string& value) {
  visitsequence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSP.SolveRequest.visitSequence)
}
#if LANG_CXX11
inline void SolveRequest::add_visitsequence(::std::string&& value) {
  visitsequence_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSP.SolveRequest.visitSequence)
}
#endif
inline void SolveRequest::add_visitsequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  visitsequence_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSP.SolveRequest.visitSequence)
}
inline void SolveRequest::add_visitsequence(const char* value, size_t size) {
  visitsequence_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSP.SolveRequest.visitSequence)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolveRequest::visitsequence() const {
  // @@protoc_insertion_point(field_list:TSP.SolveRequest.visitSequence)
  return visitsequence_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolveRequest::mutable_visitsequence() {
  // @@protoc_insertion_point(field_mutable_list:TSP.SolveRequest.visitSequence)
  return &visitsequence_;
}

// optional .TSP.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolveRequest::set_has_solvetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolveRequest::clear_has_solvetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolveRequest::clear_solvetype() {
  solvetype_ = 0;
  clear_has_solvetype();
}
inline ::TSP::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:TSP.SolveRequest.solveType)
  return static_cast< ::TSP::SolveRequest_SolveType >(solvetype_);
}
inline void SolveRequest::set_solvetype(::TSP::SolveRequest_SolveType value) {
  assert(::TSP::SolveRequest_SolveType_IsValid(value));
  set_has_solvetype();
  solvetype_ = value;
  // @@protoc_insertion_point(field_set:TSP.SolveRequest.solveType)
}

// -------------------------------------------------------------------

// Edge_Geometry

// required float x = 1;
inline bool Edge_Geometry::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge_Geometry::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge_Geometry::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge_Geometry::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Edge_Geometry::x() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.Geometry.x)
  return x_;
}
inline void Edge_Geometry::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:TSP.Edge.Geometry.x)
}

// required float y = 2;
inline bool Edge_Geometry::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge_Geometry::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge_Geometry::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge_Geometry::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Edge_Geometry::y() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.Geometry.y)
  return y_;
}
inline void Edge_Geometry::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:TSP.Edge.Geometry.y)
}

// -------------------------------------------------------------------

// Edge

// required string from = 1;
inline bool Edge::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& Edge::from() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.from)
  return from_.GetNoArena();
}
inline void Edge::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TSP.Edge.from)
}
#if LANG_CXX11
inline void Edge::set_from(::std::string&& value) {
  set_has_from();
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TSP.Edge.from)
}
#endif
inline void Edge::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TSP.Edge.from)
}
inline void Edge::set_from(const char* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TSP.Edge.from)
}
inline ::std::string* Edge::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:TSP.Edge.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_from() {
  // @@protoc_insertion_point(field_release:TSP.Edge.from)
  if (!has_from()) {
    return NULL;
  }
  clear_has_from();
  return from_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:TSP.Edge.from)
}

// required string to = 2;
inline bool Edge::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& Edge::to() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.to)
  return to_.GetNoArena();
}
inline void Edge::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TSP.Edge.to)
}
#if LANG_CXX11
inline void Edge::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TSP.Edge.to)
}
#endif
inline void Edge::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TSP.Edge.to)
}
inline void Edge::set_to(const char* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TSP.Edge.to)
}
inline ::std::string* Edge::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:TSP.Edge.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_to() {
  // @@protoc_insertion_point(field_release:TSP.Edge.to)
  if (!has_to()) {
    return NULL;
  }
  clear_has_to();
  return to_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:TSP.Edge.to)
}

// optional float distance = 3;
inline bool Edge::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Edge::distance() const {
  // @@protoc_insertion_point(field_get:TSP.Edge.distance)
  return distance_;
}
inline void Edge::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:TSP.Edge.distance)
}

// repeated .TSP.Edge.Geometry geometry = 4;
inline int Edge::geometry_size() const {
  return geometry_.size();
}
inline void Edge::clear_geometry() {
  geometry_.Clear();
}
inline ::TSP::Edge_Geometry* Edge::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.Edge.geometry)
  return geometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >*
Edge::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:TSP.Edge.geometry)
  return &geometry_;
}
inline const ::TSP::Edge_Geometry& Edge::geometry(int index) const {
  // @@protoc_insertion_point(field_get:TSP.Edge.geometry)
  return geometry_.Get(index);
}
inline ::TSP::Edge_Geometry* Edge::add_geometry() {
  // @@protoc_insertion_point(field_add:TSP.Edge.geometry)
  return geometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Edge_Geometry >&
Edge::geometry() const {
  // @@protoc_insertion_point(field_list:TSP.Edge.geometry)
  return geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse

// repeated string tour = 1;
inline int SolutionResponse::tour_size() const {
  return tour_.size();
}
inline void SolutionResponse::clear_tour() {
  tour_.Clear();
}
inline const ::std::string& SolutionResponse::tour(int index) const {
  // @@protoc_insertion_point(field_get:TSP.SolutionResponse.tour)
  return tour_.Get(index);
}
inline ::std::string* SolutionResponse::mutable_tour(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.SolutionResponse.tour)
  return tour_.Mutable(index);
}
inline void SolutionResponse::set_tour(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TSP.SolutionResponse.tour)
  tour_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SolutionResponse::set_tour(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TSP.SolutionResponse.tour)
  tour_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SolutionResponse::set_tour(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tour_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::set_tour(int index, const char* value, size_t size) {
  tour_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSP.SolutionResponse.tour)
}
inline ::std::string* SolutionResponse::add_tour() {
  // @@protoc_insertion_point(field_add_mutable:TSP.SolutionResponse.tour)
  return tour_.Add();
}
inline void SolutionResponse::add_tour(const ::std::string& value) {
  tour_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSP.SolutionResponse.tour)
}
#if LANG_CXX11
inline void SolutionResponse::add_tour(::std::string&& value) {
  tour_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSP.SolutionResponse.tour)
}
#endif
inline void SolutionResponse::add_tour(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tour_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSP.SolutionResponse.tour)
}
inline void SolutionResponse::add_tour(const char* value, size_t size) {
  tour_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSP.SolutionResponse.tour)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SolutionResponse::tour() const {
  // @@protoc_insertion_point(field_list:TSP.SolutionResponse.tour)
  return tour_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SolutionResponse::mutable_tour() {
  // @@protoc_insertion_point(field_mutable_list:TSP.SolutionResponse.tour)
  return &tour_;
}

// repeated .TSP.Edge edges = 2;
inline int SolutionResponse::edges_size() const {
  return edges_.size();
}
inline void SolutionResponse::clear_edges() {
  edges_.Clear();
}
inline ::TSP::Edge* SolutionResponse::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.SolutionResponse.edges)
  return edges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Edge >*
SolutionResponse::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:TSP.SolutionResponse.edges)
  return &edges_;
}
inline const ::TSP::Edge& SolutionResponse::edges(int index) const {
  // @@protoc_insertion_point(field_get:TSP.SolutionResponse.edges)
  return edges_.Get(index);
}
inline ::TSP::Edge* SolutionResponse::add_edges() {
  // @@protoc_insertion_point(field_add:TSP.SolutionResponse.edges)
  return edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Edge >&
SolutionResponse::edges() const {
  // @@protoc_insertion_point(field_list:TSP.SolutionResponse.edges)
  return edges_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSP

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TSP::TSP_eDistanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSP::TSP_eDistanceType>() {
  return ::TSP::TSP_eDistanceType_descriptor();
}
template <> struct is_proto_enum< ::TSP::SolveRequest_SolveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSP::SolveRequest_SolveType>() {
  return ::TSP::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tsp_2dmcvfz472gty6_2eproto
