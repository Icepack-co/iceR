// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ns3-tbfvuwtge2iq.proto

#include "ns3-tbfvuwtge2iq.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace NS3 {
        template <typename>
PROTOBUF_CONSTEXPR InternalDimension::InternalDimension(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.id_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.measurementunit_)*/ 0,
    } {}
struct InternalDimensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternalDimensionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternalDimensionDefaultTypeInternal() {}
  union {
    InternalDimension _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternalDimensionDefaultTypeInternal _InternalDimension_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR UserDimension::UserDimension(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.id_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.units_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct UserDimensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDimensionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDimensionDefaultTypeInternal() {}
  union {
    UserDimension _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDimensionDefaultTypeInternal _UserDimension_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR DimensionConfiguration::DimensionConfiguration(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.userdimensions_)*/ {},
      /*decltype(_impl_.timeconfig_)*/ nullptr,
      /*decltype(_impl_.distanceconfig_)*/ nullptr,
    } {}
struct DimensionConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DimensionConfigurationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DimensionConfigurationDefaultTypeInternal() {}
  union {
    DimensionConfiguration _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DimensionConfigurationDefaultTypeInternal _DimensionConfiguration_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Geocode::Geocode(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.longitude_)*/ 0,
      /*decltype(_impl_.latitude_)*/ 0,
    } {}
struct GeocodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeocodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeocodeDefaultTypeInternal() {}
  union {
    Geocode _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeocodeDefaultTypeInternal _Geocode_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR UnitDimensionCost::UnitDimensionCost(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.dimensionids_)*/ {},
      /*decltype(_impl_.dimensioncoefficients_)*/ {},
      /*decltype(_impl_.costperunit_)*/ 0,
    } {}
struct UnitDimensionCostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitDimensionCostDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitDimensionCostDefaultTypeInternal() {}
  union {
    UnitDimensionCost _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitDimensionCostDefaultTypeInternal _UnitDimensionCost_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR FixedDimensionCost::FixedDimensionCost(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.dimensionids_)*/ {},
      /*decltype(_impl_.fixedcost_)*/ 0,
    } {}
struct FixedDimensionCostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FixedDimensionCostDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FixedDimensionCostDefaultTypeInternal() {}
  union {
    FixedDimensionCost _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FixedDimensionCostDefaultTypeInternal _FixedDimensionCost_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR FlowDimensionalConstraint::FlowDimensionalConstraint(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.dimensionids_)*/ {},
      /*decltype(_impl_.dimensioncoefficients_)*/ {},
      /*decltype(_impl_.flowmin_)*/ 0,
      /*decltype(_impl_.flowmax_)*/ 0,
    } {}
struct FlowDimensionalConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowDimensionalConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowDimensionalConstraintDefaultTypeInternal() {}
  union {
    FlowDimensionalConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowDimensionalConstraintDefaultTypeInternal _FlowDimensionalConstraint_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR DimensionRange::DimensionRange(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.dimensionid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.minrange_)*/ 0,
      /*decltype(_impl_.maxrange_)*/ 0,
      /*decltype(_impl_.flowpenalty_)*/ 0,
    } {}
struct DimensionRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DimensionRangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DimensionRangeDefaultTypeInternal() {}
  union {
    DimensionRange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DimensionRangeDefaultTypeInternal _DimensionRange_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Node_ProductFlow::Node_ProductFlow(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.dimensionranges_)*/ {},
      /*decltype(_impl_.fixeddimensioncosts_)*/ {},
      /*decltype(_impl_.unitdimensioncosts_)*/ {},
      /*decltype(_impl_.productid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct Node_ProductFlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Node_ProductFlowDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Node_ProductFlowDefaultTypeInternal() {}
  union {
    Node_ProductFlow _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Node_ProductFlowDefaultTypeInternal _Node_ProductFlow_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Node_Flow::Node_Flow(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.dimensionranges_)*/ {},
      /*decltype(_impl_.fixeddimensioncosts_)*/ {},
      /*decltype(_impl_.unitdimensioncosts_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct Node_FlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Node_FlowDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Node_FlowDefaultTypeInternal() {}
  union {
    Node_Flow _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Node_FlowDefaultTypeInternal _Node_Flow_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Node_ProductTransform_Item::Node_ProductTransform_Item(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.dimensionranges_)*/ {},
      /*decltype(_impl_.fixeddimensioncosts_)*/ {},
      /*decltype(_impl_.unitdimensioncosts_)*/ {},
      /*decltype(_impl_.productid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.productratio_)*/ 0,
    } {}
struct Node_ProductTransform_ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Node_ProductTransform_ItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Node_ProductTransform_ItemDefaultTypeInternal() {}
  union {
    Node_ProductTransform_Item _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Node_ProductTransform_ItemDefaultTypeInternal _Node_ProductTransform_Item_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Node_ProductTransform::Node_ProductTransform(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.inputitems_)*/ {},
      /*decltype(_impl_.outputitems_)*/ {},
      /*decltype(_impl_.producttransformid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct Node_ProductTransformDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Node_ProductTransformDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Node_ProductTransformDefaultTypeInternal() {}
  union {
    Node_ProductTransform _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Node_ProductTransformDefaultTypeInternal _Node_ProductTransform_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Node::Node(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.production_)*/ {},
      /*decltype(_impl_.consumption_)*/ {},
      /*decltype(_impl_.productflows_)*/ {},
      /*decltype(_impl_.allowablesources_)*/ {},
      /*decltype(_impl_.flowconstraints_)*/ {},
      /*decltype(_impl_.producttransforms_)*/ {},
      /*decltype(_impl_.id_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.geocode_)*/ nullptr,
      /*decltype(_impl_.flow_)*/ nullptr,
      /*decltype(_impl_.maximumsources_)*/ -1,
    } {}
struct NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDefaultTypeInternal _Node_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ProductGroup_ProductSpecification::ProductGroup_ProductSpecification(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.targetdimension_)*/ {},
      /*decltype(_impl_.targetperbase_)*/ {},
      /*decltype(_impl_.basedimension_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct ProductGroup_ProductSpecificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductGroup_ProductSpecificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductGroup_ProductSpecificationDefaultTypeInternal() {}
  union {
    ProductGroup_ProductSpecification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductGroup_ProductSpecificationDefaultTypeInternal _ProductGroup_ProductSpecification_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR ProductGroup::ProductGroup(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.productspecification_)*/ {},
      /*decltype(_impl_.productid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.productgroupid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct ProductGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductGroupDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductGroupDefaultTypeInternal() {}
  union {
    ProductGroup _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductGroupDefaultTypeInternal _ProductGroup_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR LaneRate::LaneRate(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.productids_)*/ {},
      /*decltype(_impl_.productgroupids_)*/ {},
      /*decltype(_impl_.unitdimensioncosts_)*/ {},
      /*decltype(_impl_.flowconstraints_)*/ {},
      /*decltype(_impl_.id_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.source_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.destination_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct LaneRateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaneRateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaneRateDefaultTypeInternal() {}
  union {
    LaneRate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaneRateDefaultTypeInternal _LaneRate_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CostModel::CostModel(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.productgroupids_)*/ {},
      /*decltype(_impl_.unitdimensioncosts_)*/ {},
      /*decltype(_impl_.flowconstraints_)*/ {},
      /*decltype(_impl_.id_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.source_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct CostModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CostModelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CostModelDefaultTypeInternal() {}
  union {
    CostModel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CostModelDefaultTypeInternal _CostModel_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Model::Model(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.nodes_)*/ {},
      /*decltype(_impl_.lanerates_)*/ {},
      /*decltype(_impl_.costmodels_)*/ {},
      /*decltype(_impl_.productgroups_)*/ {},
      /*decltype(_impl_.dimensions_)*/ nullptr,
    } {}
struct ModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelDefaultTypeInternal() {}
  union {
    Model _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelDefaultTypeInternal _Model_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolveRequest::SolveRequest(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.modelid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.model_)*/ nullptr,
      /*decltype(_impl_.solvetype_)*/ 0,
      /*decltype(_impl_.geometryoutput_)*/ 0,
    } {}
struct SolveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolveRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolveRequestDefaultTypeInternal() {}
  union {
    SolveRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_Assignment::SolutionResponse_Assignment(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.source_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.destination_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.productid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.lanerateid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.costmodelid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.amount_)*/ 0,
      /*decltype(_impl_.cost_)*/ 0,
      /*decltype(_impl_.distance_)*/ 0,
      /*decltype(_impl_.duration_)*/ 0,
    } {}
struct SolutionResponse_AssignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_AssignmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_AssignmentDefaultTypeInternal() {}
  union {
    SolutionResponse_Assignment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_AssignmentDefaultTypeInternal _SolutionResponse_Assignment_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_NodeProductFlow::SolutionResponse_NodeProductFlow(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.nodeid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.productid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.inflow_)*/ 0,
      /*decltype(_impl_.outflow_)*/ 0,
      /*decltype(_impl_.flowcost_)*/ 0,
      /*decltype(_impl_.fixedcost_)*/ 0,
      /*decltype(_impl_.productionamount_)*/ 0,
      /*decltype(_impl_.productionpenalty_)*/ 0,
      /*decltype(_impl_.productioncost_)*/ 0,
      /*decltype(_impl_.consumptionamount_)*/ 0,
      /*decltype(_impl_.consumptionpenalty_)*/ 0,
      /*decltype(_impl_.consumptioncost_)*/ 0,
    } {}
struct SolutionResponse_NodeProductFlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_NodeProductFlowDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_NodeProductFlowDefaultTypeInternal() {}
  union {
    SolutionResponse_NodeProductFlow _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_NodeProductFlowDefaultTypeInternal _SolutionResponse_NodeProductFlow_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_NodeFlow::SolutionResponse_NodeFlow(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.nodeid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.inflow_)*/ 0,
      /*decltype(_impl_.outflow_)*/ 0,
      /*decltype(_impl_.flowcost_)*/ 0,
      /*decltype(_impl_.fixedcost_)*/ 0,
      /*decltype(_impl_.productflowcost_)*/ 0,
      /*decltype(_impl_.productfixedcost_)*/ 0,
      /*decltype(_impl_.productionamount_)*/ 0,
      /*decltype(_impl_.productionpenalty_)*/ 0,
      /*decltype(_impl_.productioncost_)*/ 0,
      /*decltype(_impl_.consumptionamount_)*/ 0,
      /*decltype(_impl_.consumptionpenalty_)*/ 0,
      /*decltype(_impl_.consumptioncost_)*/ 0,
    } {}
struct SolutionResponse_NodeFlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_NodeFlowDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_NodeFlowDefaultTypeInternal() {}
  union {
    SolutionResponse_NodeFlow _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_NodeFlowDefaultTypeInternal _SolutionResponse_NodeFlow_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_GeometrySequence::SolutionResponse_GeometrySequence(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.x_)*/ {},
      /*decltype(_impl_.y_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct SolutionResponse_GeometrySequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_GeometrySequenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_GeometrySequenceDefaultTypeInternal() {}
  union {
    SolutionResponse_GeometrySequence _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_GeometrySequenceDefaultTypeInternal _SolutionResponse_GeometrySequence_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_Route::SolutionResponse_Route(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.geometrysequence_)*/ {},
      /*decltype(_impl_.fromid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.toid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct SolutionResponse_RouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_RouteDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_RouteDefaultTypeInternal() {}
  union {
    SolutionResponse_Route _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_NodeProductTransformAssignment_Item::SolutionResponse_NodeProductTransformAssignment_Item(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.productid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.amount_)*/ 0,
      /*decltype(_impl_.cost_)*/ 0,
      /*decltype(_impl_.fixedcost_)*/ 0,
      /*decltype(_impl_.penaltyamount_)*/ 0,
      /*decltype(_impl_.penaltycost_)*/ 0,
    } {}
struct SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal() {}
  union {
    SolutionResponse_NodeProductTransformAssignment_Item _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal _SolutionResponse_NodeProductTransformAssignment_Item_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse_NodeProductTransformAssignment::SolutionResponse_NodeProductTransformAssignment(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.inputitems_)*/ {},
      /*decltype(_impl_.outputitems_)*/ {},
      /*decltype(_impl_.nodeid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.producttransformid_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
    } {}
struct SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal() {}
  union {
    SolutionResponse_NodeProductTransformAssignment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal _SolutionResponse_NodeProductTransformAssignment_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SolutionResponse::SolutionResponse(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.assignments_)*/ {},
      /*decltype(_impl_.nodeflows_)*/ {},
      /*decltype(_impl_.nodeproductflows_)*/ {},
      /*decltype(_impl_.geometrysequence_)*/ {},
      /*decltype(_impl_.routes_)*/ {},
      /*decltype(_impl_.nodeproducttransformassignments_)*/ {},
      /*decltype(_impl_.objective_)*/ 0,
      /*decltype(_impl_.lowerbound_)*/ 0,
      /*decltype(_impl_.optimalitygap_)*/ 0,
    } {}
struct SolutionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SolutionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SolutionResponseDefaultTypeInternal() {}
  union {
    SolutionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
}  // namespace NS3
static ::_pb::Metadata file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[27];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ns3_2dtbfvuwtge2iq_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_ns3_2dtbfvuwtge2iq_2eproto = nullptr;
const ::uint32_t TableStruct_ns3_2dtbfvuwtge2iq_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::NS3::InternalDimension, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::InternalDimension, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::InternalDimension, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::NS3::InternalDimension, _impl_.measurementunit_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::NS3::UserDimension, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::UserDimension, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::UserDimension, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::NS3::UserDimension, _impl_.units_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionConfiguration, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionConfiguration, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionConfiguration, _impl_.timeconfig_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionConfiguration, _impl_.distanceconfig_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionConfiguration, _impl_.userdimensions_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::Geocode, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::Geocode, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Geocode, _impl_.longitude_),
    PROTOBUF_FIELD_OFFSET(::NS3::Geocode, _impl_.latitude_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::NS3::UnitDimensionCost, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::UnitDimensionCost, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::UnitDimensionCost, _impl_.dimensionids_),
    PROTOBUF_FIELD_OFFSET(::NS3::UnitDimensionCost, _impl_.dimensioncoefficients_),
    PROTOBUF_FIELD_OFFSET(::NS3::UnitDimensionCost, _impl_.costperunit_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::NS3::FixedDimensionCost, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::FixedDimensionCost, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::FixedDimensionCost, _impl_.dimensionids_),
    PROTOBUF_FIELD_OFFSET(::NS3::FixedDimensionCost, _impl_.fixedcost_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::NS3::FlowDimensionalConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::FlowDimensionalConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::FlowDimensionalConstraint, _impl_.dimensionids_),
    PROTOBUF_FIELD_OFFSET(::NS3::FlowDimensionalConstraint, _impl_.dimensioncoefficients_),
    PROTOBUF_FIELD_OFFSET(::NS3::FlowDimensionalConstraint, _impl_.flowmin_),
    PROTOBUF_FIELD_OFFSET(::NS3::FlowDimensionalConstraint, _impl_.flowmax_),
    ~0u,
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionRange, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionRange, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionRange, _impl_.dimensionid_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionRange, _impl_.minrange_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionRange, _impl_.maxrange_),
    PROTOBUF_FIELD_OFFSET(::NS3::DimensionRange, _impl_.flowpenalty_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductFlow, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductFlow, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductFlow, _impl_.productid_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductFlow, _impl_.dimensionranges_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductFlow, _impl_.fixeddimensioncosts_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductFlow, _impl_.unitdimensioncosts_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::NS3::Node_Flow, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Node_Flow, _impl_.dimensionranges_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_Flow, _impl_.fixeddimensioncosts_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_Flow, _impl_.unitdimensioncosts_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _impl_.productid_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _impl_.productratio_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _impl_.dimensionranges_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _impl_.fixeddimensioncosts_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform_Item, _impl_.unitdimensioncosts_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform, _impl_.producttransformid_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform, _impl_.inputitems_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node_ProductTransform, _impl_.outputitems_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.geocode_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.production_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.consumption_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.flow_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.productflows_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.allowablesources_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.maximumsources_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.flowconstraints_),
    PROTOBUF_FIELD_OFFSET(::NS3::Node, _impl_.producttransforms_),
    0,
    1,
    ~0u,
    ~0u,
    2,
    ~0u,
    ~0u,
    3,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup_ProductSpecification, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup_ProductSpecification, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup_ProductSpecification, _impl_.basedimension_),
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup_ProductSpecification, _impl_.targetdimension_),
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup_ProductSpecification, _impl_.targetperbase_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup, _impl_.productid_),
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup, _impl_.productgroupid_),
    PROTOBUF_FIELD_OFFSET(::NS3::ProductGroup, _impl_.productspecification_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.destination_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.productids_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.productgroupids_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.unitdimensioncosts_),
    PROTOBUF_FIELD_OFFSET(::NS3::LaneRate, _impl_.flowconstraints_),
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _impl_.productgroupids_),
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _impl_.unitdimensioncosts_),
    PROTOBUF_FIELD_OFFSET(::NS3::CostModel, _impl_.flowconstraints_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _impl_.dimensions_),
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _impl_.nodes_),
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _impl_.lanerates_),
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _impl_.costmodels_),
    PROTOBUF_FIELD_OFFSET(::NS3::Model, _impl_.productgroups_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::SolveRequest, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolveRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolveRequest, _impl_.model_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolveRequest, _impl_.modelid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolveRequest, _impl_.solvetype_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolveRequest, _impl_.geometryoutput_),
    1,
    0,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.destination_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.productid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.amount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.cost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.lanerateid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.costmodelid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.distance_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Assignment, _impl_.duration_),
    0,
    1,
    2,
    5,
    6,
    3,
    4,
    7,
    8,
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.nodeid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.productid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.inflow_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.outflow_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.flowcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.fixedcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.productionamount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.productionpenalty_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.productioncost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.consumptionamount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.consumptionpenalty_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductFlow, _impl_.consumptioncost_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.nodeid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.inflow_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.outflow_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.flowcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.fixedcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.productflowcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.productfixedcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.productionamount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.productionpenalty_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.productioncost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.consumptionamount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.consumptionpenalty_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeFlow, _impl_.consumptioncost_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_GeometrySequence, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_GeometrySequence, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_GeometrySequence, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Route, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Route, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Route, _impl_.fromid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Route, _impl_.toid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_Route, _impl_.geometrysequence_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_.productid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_.amount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_.cost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_.fixedcost_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltyamount_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltycost_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment, _impl_.nodeid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment, _impl_.producttransformid_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment, _impl_.inputitems_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse_NodeProductTransformAssignment, _impl_.outputitems_),
    0,
    1,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.objective_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.lowerbound_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.optimalitygap_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.assignments_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.nodeflows_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.nodeproductflows_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.geometrysequence_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.routes_),
    PROTOBUF_FIELD_OFFSET(::NS3::SolutionResponse, _impl_.nodeproducttransformassignments_),
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::NS3::InternalDimension)},
        {12, 22, -1, sizeof(::NS3::UserDimension)},
        {24, 35, -1, sizeof(::NS3::DimensionConfiguration)},
        {38, 48, -1, sizeof(::NS3::Geocode)},
        {50, 61, -1, sizeof(::NS3::UnitDimensionCost)},
        {64, 74, -1, sizeof(::NS3::FixedDimensionCost)},
        {76, 88, -1, sizeof(::NS3::FlowDimensionalConstraint)},
        {92, 104, -1, sizeof(::NS3::DimensionRange)},
        {108, 120, -1, sizeof(::NS3::Node_ProductFlow)},
        {124, -1, -1, sizeof(::NS3::Node_Flow)},
        {135, 148, -1, sizeof(::NS3::Node_ProductTransform_Item)},
        {153, 164, -1, sizeof(::NS3::Node_ProductTransform)},
        {167, 185, -1, sizeof(::NS3::Node)},
        {195, 206, -1, sizeof(::NS3::ProductGroup_ProductSpecification)},
        {209, 220, -1, sizeof(::NS3::ProductGroup)},
        {223, 238, -1, sizeof(::NS3::LaneRate)},
        {245, 258, -1, sizeof(::NS3::CostModel)},
        {263, 276, -1, sizeof(::NS3::Model)},
        {281, 293, -1, sizeof(::NS3::SolveRequest)},
        {297, 314, -1, sizeof(::NS3::SolutionResponse_Assignment)},
        {323, 343, -1, sizeof(::NS3::SolutionResponse_NodeProductFlow)},
        {355, 376, -1, sizeof(::NS3::SolutionResponse_NodeFlow)},
        {389, -1, -1, sizeof(::NS3::SolutionResponse_GeometrySequence)},
        {399, 410, -1, sizeof(::NS3::SolutionResponse_Route)},
        {413, 427, -1, sizeof(::NS3::SolutionResponse_NodeProductTransformAssignment_Item)},
        {433, 445, -1, sizeof(::NS3::SolutionResponse_NodeProductTransformAssignment)},
        {449, 466, -1, sizeof(::NS3::SolutionResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::NS3::_InternalDimension_default_instance_._instance,
    &::NS3::_UserDimension_default_instance_._instance,
    &::NS3::_DimensionConfiguration_default_instance_._instance,
    &::NS3::_Geocode_default_instance_._instance,
    &::NS3::_UnitDimensionCost_default_instance_._instance,
    &::NS3::_FixedDimensionCost_default_instance_._instance,
    &::NS3::_FlowDimensionalConstraint_default_instance_._instance,
    &::NS3::_DimensionRange_default_instance_._instance,
    &::NS3::_Node_ProductFlow_default_instance_._instance,
    &::NS3::_Node_Flow_default_instance_._instance,
    &::NS3::_Node_ProductTransform_Item_default_instance_._instance,
    &::NS3::_Node_ProductTransform_default_instance_._instance,
    &::NS3::_Node_default_instance_._instance,
    &::NS3::_ProductGroup_ProductSpecification_default_instance_._instance,
    &::NS3::_ProductGroup_default_instance_._instance,
    &::NS3::_LaneRate_default_instance_._instance,
    &::NS3::_CostModel_default_instance_._instance,
    &::NS3::_Model_default_instance_._instance,
    &::NS3::_SolveRequest_default_instance_._instance,
    &::NS3::_SolutionResponse_Assignment_default_instance_._instance,
    &::NS3::_SolutionResponse_NodeProductFlow_default_instance_._instance,
    &::NS3::_SolutionResponse_NodeFlow_default_instance_._instance,
    &::NS3::_SolutionResponse_GeometrySequence_default_instance_._instance,
    &::NS3::_SolutionResponse_Route_default_instance_._instance,
    &::NS3::_SolutionResponse_NodeProductTransformAssignment_Item_default_instance_._instance,
    &::NS3::_SolutionResponse_NodeProductTransformAssignment_default_instance_._instance,
    &::NS3::_SolutionResponse_default_instance_._instance,
};
const char descriptor_table_protodef_ns3_2dtbfvuwtge2iq_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\026ns3-tbfvuwtge2iq.proto\022\003NS3\"\277\001\n\021Intern"
    "alDimension\022\n\n\002id\030\001 \002(\t\022@\n\017measurementUn"
    "it\030\002 \002(\0162\'.NS3.InternalDimension.eMeasur"
    "ementUnit\"\\\n\020eMeasurementUnit\022\013\n\007SECONDS"
    "\020\000\022\013\n\007MINUTES\020\001\022\t\n\005HOURS\020\002\022\010\n\004DAYS\020\003\022\016\n\n"
    "KILOMETRES\020\004\022\t\n\005MILES\020\005\"*\n\rUserDimension"
    "\022\n\n\002id\030\001 \002(\t\022\r\n\005units\030\002 \002(\t\"\240\001\n\026Dimensio"
    "nConfiguration\022*\n\ntimeConfig\030\001 \001(\0132\026.NS3"
    ".InternalDimension\022.\n\016distanceConfig\030\002 \001"
    "(\0132\026.NS3.InternalDimension\022*\n\016userDimens"
    "ions\030\003 \003(\0132\022.NS3.UserDimension\".\n\007Geocod"
    "e\022\021\n\tlongitude\030\001 \002(\002\022\020\n\010latitude\030\002 \002(\002\"]"
    "\n\021UnitDimensionCost\022\024\n\014dimensionIds\030\001 \003("
    "\t\022\035\n\025dimensionCoefficients\030\002 \003(\002\022\023\n\013cost"
    "PerUnit\030\003 \002(\002\"=\n\022FixedDimensionCost\022\024\n\014d"
    "imensionIds\030\001 \003(\t\022\021\n\tfixedCost\030\002 \002(\002\"r\n\031"
    "FlowDimensionalConstraint\022\024\n\014dimensionId"
    "s\030\001 \003(\t\022\035\n\025dimensionCoefficients\030\002 \003(\002\022\017"
    "\n\007flowMin\030\003 \002(\002\022\017\n\007flowMax\030\004 \002(\002\"d\n\016Dime"
    "nsionRange\022\023\n\013dimensionId\030\001 \002(\t\022\023\n\010minRa"
    "nge\030\002 \002(\002:\0010\022\020\n\010maxRange\030\003 \002(\002\022\026\n\013flowPe"
    "nalty\030\004 \002(\002:\0010\"\273\010\n\004Node\022\n\n\002id\030\001 \002(\t\022\035\n\007g"
    "eocode\030\002 \002(\0132\014.NS3.Geocode\022)\n\nproduction"
    "\030\003 \003(\0132\025.NS3.Node.ProductFlow\022*\n\013consump"
    "tion\030\004 \003(\0132\025.NS3.Node.ProductFlow\022\034\n\004flo"
    "w\030\005 \001(\0132\016.NS3.Node.Flow\022+\n\014productFlows\030"
    "\006 \003(\0132\025.NS3.Node.ProductFlow\022\030\n\020allowabl"
    "eSources\030\007 \003(\t\022\032\n\016maximumSources\030\010 \001(\005:\002"
    "-1\0227\n\017flowConstraints\030\t \003(\0132\036.NS3.FlowDi"
    "mensionalConstraint\0225\n\021productTransforms"
    "\030\n \003(\0132\032.NS3.Node.ProductTransform\032\270\001\n\013P"
    "roductFlow\022\021\n\tproductId\030\001 \002(\t\022,\n\017dimensi"
    "onRanges\030\002 \003(\0132\023.NS3.DimensionRange\0224\n\023F"
    "ixedDimensionCosts\030\003 \003(\0132\027.NS3.FixedDime"
    "nsionCost\0222\n\022unitDimensionCosts\030\004 \003(\0132\026."
    "NS3.UnitDimensionCost\032\236\001\n\004Flow\022,\n\017dimens"
    "ionRanges\030\001 \003(\0132\023.NS3.DimensionRange\0224\n\023"
    "FixedDimensionCosts\030\002 \003(\0132\027.NS3.FixedDim"
    "ensionCost\0222\n\022unitDimensionCosts\030\003 \003(\0132\026"
    ".NS3.UnitDimensionCost\032\343\002\n\020ProductTransf"
    "orm\022\032\n\022productTransformId\030\001 \002(\t\0223\n\ninput"
    "Items\030\002 \003(\0132\037.NS3.Node.ProductTransform."
    "Item\0224\n\013outputItems\030\003 \003(\0132\037.NS3.Node.Pro"
    "ductTransform.Item\032\307\001\n\004Item\022\021\n\tproductId"
    "\030\001 \002(\t\022\024\n\014productRatio\030\002 \002(\005\022,\n\017dimensio"
    "nRanges\030\003 \003(\0132\023.NS3.DimensionRange\0224\n\023fi"
    "xedDimensionCosts\030\004 \003(\0132\027.NS3.FixedDimen"
    "sionCost\0222\n\022unitDimensionCosts\030\005 \003(\0132\026.N"
    "S3.UnitDimensionCost\"\336\001\n\014ProductGroup\022\021\n"
    "\tproductId\030\001 \002(\t\022\026\n\016productGroupId\030\002 \002(\t"
    "\022D\n\024productSpecification\030\003 \003(\0132&.NS3.Pro"
    "ductGroup.ProductSpecification\032]\n\024Produc"
    "tSpecification\022\025\n\rbaseDimension\030\001 \002(\t\022\027\n"
    "\017targetDimension\030\002 \003(\t\022\025\n\rtargetPerBase\030"
    "\003 \003(\002\"\325\001\n\010LaneRate\022\n\n\002id\030\001 \002(\t\022\016\n\006source"
    "\030\003 \002(\t\022\023\n\013destination\030\004 \002(\t\022\022\n\nproductId"
    "s\030\005 \003(\t\022\027\n\017productGroupIds\030\006 \003(\t\0222\n\022unit"
    "DimensionCosts\030\007 \003(\0132\026.NS3.UnitDimension"
    "Cost\0227\n\017flowConstraints\030\010 \003(\0132\036.NS3.Flow"
    "DimensionalConstraint\"\255\001\n\tCostModel\022\n\n\002i"
    "d\030\001 \002(\t\022\016\n\006source\030\002 \002(\t\022\027\n\017productGroupI"
    "ds\030\003 \003(\t\0222\n\022unitDimensionCosts\030\004 \003(\0132\026.N"
    "S3.UnitDimensionCost\0227\n\017flowConstraints\030"
    "\005 \003(\0132\036.NS3.FlowDimensionalConstraint\"\302\001"
    "\n\005Model\022/\n\ndimensions\030\001 \002(\0132\033.NS3.Dimens"
    "ionConfiguration\022\030\n\005nodes\030\002 \003(\0132\t.NS3.No"
    "de\022 \n\tlaneRates\030\003 \003(\0132\r.NS3.LaneRate\022\"\n\n"
    "costModels\030\004 \003(\0132\016.NS3.CostModel\022(\n\rprod"
    "uctGroups\030\005 \003(\0132\021.NS3.ProductGroup\"\372\001\n\014S"
    "olveRequest\022\031\n\005model\030\001 \001(\0132\n.NS3.Model\022\017"
    "\n\007modelID\030\002 \001(\t\0228\n\tsolveType\030\004 \001(\0162\033.NS3"
    ".SolveRequest.SolveType:\010Optimise\022>\n\016geo"
    "metryOutput\030\005 \001(\0162 .NS3.SolveRequest.Geo"
    "metryOutput:\004None\"\031\n\tSolveType\022\014\n\010Optimi"
    "se\020\000\")\n\016GeometryOutput\022\010\n\004None\020\000\022\r\n\tAggr"
    "egate\020\001\"\231\r\n\020SolutionResponse\022\021\n\tobjectiv"
    "e\030\001 \002(\002\022\022\n\nlowerBound\030\002 \001(\002\022\025\n\roptimalit"
    "yGap\030\003 \001(\002\0225\n\013assignments\030\004 \003(\0132 .NS3.So"
    "lutionResponse.Assignment\0221\n\tnodeFlows\030\005"
    " \003(\0132\036.NS3.SolutionResponse.NodeFlow\022\?\n\020"
    "nodeProductFlows\030\006 \003(\0132%.NS3.SolutionRes"
    "ponse.NodeProductFlow\022@\n\020geometrySequenc"
    "e\030\007 \003(\0132&.NS3.SolutionResponse.GeometryS"
    "equence\022+\n\006routes\030\010 \003(\0132\033.NS3.SolutionRe"
    "sponse.Route\022]\n\037nodeProductTransformAssi"
    "gnments\030\t \003(\01324.NS3.SolutionResponse.Nod"
    "eProductTransformAssignment\032\257\001\n\nAssignme"
    "nt\022\016\n\006source\030\001 \002(\t\022\023\n\013destination\030\002 \002(\t\022"
    "\021\n\tproductId\030\003 \002(\t\022\016\n\006amount\030\004 \002(\002\022\014\n\004co"
    "st\030\005 \002(\002\022\022\n\nlaneRateId\030\006 \001(\t\022\023\n\013costMode"
    "lId\030\007 \001(\t\022\020\n\010distance\030\010 \002(\002\022\020\n\010duration\030"
    "\t \002(\002\032\227\002\n\017NodeProductFlow\022\016\n\006nodeId\030\001 \002("
    "\t\022\021\n\tproductId\030\002 \002(\t\022\016\n\006inFlow\030\003 \002(\002\022\017\n\007"
    "outFlow\030\004 \002(\002\022\020\n\010flowCost\030\005 \002(\002\022\021\n\tfixed"
    "Cost\030\006 \002(\002\022\030\n\020productionAmount\030\007 \002(\002\022\031\n\021"
    "productionPenalty\030\010 \002(\002\022\026\n\016productionCos"
    "t\030\t \002(\002\022\031\n\021consumptionAmount\030\n \002(\002\022\032\n\022co"
    "nsumptionPenalty\030\013 \002(\002\022\027\n\017consumptionCos"
    "t\030\014 \002(\002\032\260\002\n\010NodeFlow\022\016\n\006nodeId\030\001 \002(\t\022\016\n\006"
    "inFlow\030\002 \002(\002\022\017\n\007outFlow\030\003 \002(\002\022\020\n\010flowCos"
    "t\030\004 \002(\002\022\021\n\tfixedCost\030\005 \002(\002\022\027\n\017productFlo"
    "wCost\030\006 \002(\002\022\030\n\020productFixedCost\030\007 \002(\002\022\030\n"
    "\020productionAmount\030\010 \002(\002\022\031\n\021productionPen"
    "alty\030\t \002(\002\022\026\n\016productionCost\030\n \002(\002\022\031\n\021co"
    "nsumptionAmount\030\013 \002(\002\022\032\n\022consumptionPena"
    "lty\030\014 \002(\002\022\027\n\017consumptionCost\030\r \002(\002\032(\n\020Ge"
    "ometrySequence\022\t\n\001x\030\001 \003(\002\022\t\n\001y\030\002 \003(\002\032\?\n\005"
    "Route\022\016\n\006fromId\030\001 \002(\t\022\014\n\004toId\030\002 \002(\t\022\030\n\020g"
    "eometrySequence\030\003 \003(\005\032\343\002\n\036NodeProductTra"
    "nsformAssignment\022\016\n\006nodeId\030\001 \002(\t\022\032\n\022prod"
    "uctTransformId\030\002 \002(\t\022M\n\ninputItems\030\003 \003(\013"
    "29.NS3.SolutionResponse.NodeProductTrans"
    "formAssignment.Item\022N\n\013outputItems\030\004 \003(\013"
    "29.NS3.SolutionResponse.NodeProductTrans"
    "formAssignment.Item\032v\n\004Item\022\021\n\tproductId"
    "\030\001 \002(\t\022\016\n\006amount\030\002 \002(\002\022\014\n\004cost\030\003 \002(\002\022\021\n\t"
    "fixedCost\030\004 \002(\002\022\025\n\rpenaltyAmount\030\005 \002(\002\022\023"
    "\n\013penaltyCost\030\006 \002(\002B\017\n\ricepackai.NS3"
};
static ::absl::once_flag descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ns3_2dtbfvuwtge2iq_2eproto = {
    false,
    false,
    4716,
    descriptor_table_protodef_ns3_2dtbfvuwtge2iq_2eproto,
    "ns3-tbfvuwtge2iq.proto",
    &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
    nullptr,
    0,
    27,
    schemas,
    file_default_instances,
    TableStruct_ns3_2dtbfvuwtge2iq_2eproto::offsets,
    file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto,
    file_level_enum_descriptors_ns3_2dtbfvuwtge2iq_2eproto,
    file_level_service_descriptors_ns3_2dtbfvuwtge2iq_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter() {
  return &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ns3_2dtbfvuwtge2iq_2eproto(&descriptor_table_ns3_2dtbfvuwtge2iq_2eproto);
namespace NS3 {
const ::google::protobuf::EnumDescriptor* InternalDimension_eMeasurementUnit_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ns3_2dtbfvuwtge2iq_2eproto);
  return file_level_enum_descriptors_ns3_2dtbfvuwtge2iq_2eproto[0];
}
bool InternalDimension_eMeasurementUnit_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr InternalDimension_eMeasurementUnit InternalDimension::SECONDS;
constexpr InternalDimension_eMeasurementUnit InternalDimension::MINUTES;
constexpr InternalDimension_eMeasurementUnit InternalDimension::HOURS;
constexpr InternalDimension_eMeasurementUnit InternalDimension::DAYS;
constexpr InternalDimension_eMeasurementUnit InternalDimension::KILOMETRES;
constexpr InternalDimension_eMeasurementUnit InternalDimension::MILES;
constexpr InternalDimension_eMeasurementUnit InternalDimension::eMeasurementUnit_MIN;
constexpr InternalDimension_eMeasurementUnit InternalDimension::eMeasurementUnit_MAX;
constexpr int InternalDimension::eMeasurementUnit_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ns3_2dtbfvuwtge2iq_2eproto);
  return file_level_enum_descriptors_ns3_2dtbfvuwtge2iq_2eproto[1];
}
bool SolveRequest_SolveType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr SolveRequest_SolveType SolveRequest::Optimise;
constexpr SolveRequest_SolveType SolveRequest::SolveType_MIN;
constexpr SolveRequest_SolveType SolveRequest::SolveType_MAX;
constexpr int SolveRequest::SolveType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* SolveRequest_GeometryOutput_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ns3_2dtbfvuwtge2iq_2eproto);
  return file_level_enum_descriptors_ns3_2dtbfvuwtge2iq_2eproto[2];
}
bool SolveRequest_GeometryOutput_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr SolveRequest_GeometryOutput SolveRequest::None;
constexpr SolveRequest_GeometryOutput SolveRequest::Aggregate;
constexpr SolveRequest_GeometryOutput SolveRequest::GeometryOutput_MIN;
constexpr SolveRequest_GeometryOutput SolveRequest::GeometryOutput_MAX;
constexpr int SolveRequest::GeometryOutput_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class InternalDimension::_Internal {
 public:
  using HasBits = decltype(std::declval<InternalDimension>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InternalDimension, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_measurementunit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

InternalDimension::InternalDimension(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.InternalDimension)
}
InternalDimension::InternalDimension(const InternalDimension& from) : ::google::protobuf::Message() {
  InternalDimension* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.id_){},
      decltype(_impl_.measurementunit_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.measurementunit_ = from._impl_.measurementunit_;

  // @@protoc_insertion_point(copy_constructor:NS3.InternalDimension)
}
inline void InternalDimension::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.id_){},
      decltype(_impl_.measurementunit_){0},
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
InternalDimension::~InternalDimension() {
  // @@protoc_insertion_point(destructor:NS3.InternalDimension)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void InternalDimension::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}
void InternalDimension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void InternalDimension::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.InternalDimension)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  _impl_.measurementunit_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* InternalDimension::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 32, 2> InternalDimension::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InternalDimension, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_InternalDimension_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 5, PROTOBUF_FIELD_OFFSET(InternalDimension, _impl_.measurementunit_)}},
    // required string id = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(InternalDimension, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string id = 1;
    {PROTOBUF_FIELD_OFFSET(InternalDimension, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
    {PROTOBUF_FIELD_OFFSET(InternalDimension, _impl_.measurementunit_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {0, 6},
  }}, {{
    "\25\2\0\0\0\0\0\0"
    "NS3.InternalDimension"
    "id"
  }},
};

::uint8_t* InternalDimension::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.InternalDimension)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.InternalDimension.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_measurementunit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.InternalDimension)
  return target;
}

::size_t InternalDimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.InternalDimension)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_measurementunit());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData InternalDimension::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    InternalDimension::MergeImpl
};
const ::google::protobuf::Message::ClassData*InternalDimension::GetClassData() const { return &_class_data_; }


void InternalDimension::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<InternalDimension*>(&to_msg);
  auto& from = static_cast<const InternalDimension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.InternalDimension)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.measurementunit_ = from._impl_.measurementunit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void InternalDimension::CopyFrom(const InternalDimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.InternalDimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool InternalDimension::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void InternalDimension::InternalSwap(InternalDimension* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  swap(_impl_.measurementunit_, other->_impl_.measurementunit_);
}

::google::protobuf::Metadata InternalDimension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[0]);
}
// ===================================================================

class UserDimension::_Internal {
 public:
  using HasBits = decltype(std::declval<UserDimension>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UserDimension, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_units(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UserDimension::UserDimension(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.UserDimension)
}
UserDimension::UserDimension(const UserDimension& from) : ::google::protobuf::Message() {
  UserDimension* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.id_){},
      decltype(_impl_.units_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _impl_.units_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.units_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.units_.Set(from._internal_units(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.UserDimension)
}
inline void UserDimension::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.id_){},
      decltype(_impl_.units_){},
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.units_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.units_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
UserDimension::~UserDimension() {
  // @@protoc_insertion_point(destructor:NS3.UserDimension)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void UserDimension::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.units_.Destroy();
}
void UserDimension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void UserDimension::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.UserDimension)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.units_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* UserDimension::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 33, 2> UserDimension::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserDimension, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_UserDimension_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // required string units = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(UserDimension, _impl_.units_)}},
    // required string id = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(UserDimension, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string id = 1;
    {PROTOBUF_FIELD_OFFSET(UserDimension, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string units = 2;
    {PROTOBUF_FIELD_OFFSET(UserDimension, _impl_.units_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\21\2\5\0\0\0\0\0"
    "NS3.UserDimension"
    "id"
    "units"
  }},
};

::uint8_t* UserDimension::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.UserDimension)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.UserDimension.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string units = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_units();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.UserDimension.units");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.UserDimension)
  return target;
}

::size_t UserDimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.UserDimension)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // required string units = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_units());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData UserDimension::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    UserDimension::MergeImpl
};
const ::google::protobuf::Message::ClassData*UserDimension::GetClassData() const { return &_class_data_; }


void UserDimension::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<UserDimension*>(&to_msg);
  auto& from = static_cast<const UserDimension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.UserDimension)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_units(from._internal_units());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UserDimension::CopyFrom(const UserDimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.UserDimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserDimension::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UserDimension::InternalSwap(UserDimension* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.units_, lhs_arena,
                                       &other->_impl_.units_, rhs_arena);
}

::google::protobuf::Metadata UserDimension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[1]);
}
// ===================================================================

class DimensionConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<DimensionConfiguration>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_._has_bits_);
  static const ::NS3::InternalDimension& timeconfig(const DimensionConfiguration* msg);
  static void set_has_timeconfig(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::NS3::InternalDimension& distanceconfig(const DimensionConfiguration* msg);
  static void set_has_distanceconfig(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::NS3::InternalDimension& DimensionConfiguration::_Internal::timeconfig(const DimensionConfiguration* msg) {
  return *msg->_impl_.timeconfig_;
}
const ::NS3::InternalDimension& DimensionConfiguration::_Internal::distanceconfig(const DimensionConfiguration* msg) {
  return *msg->_impl_.distanceconfig_;
}
DimensionConfiguration::DimensionConfiguration(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.DimensionConfiguration)
}
DimensionConfiguration::DimensionConfiguration(const DimensionConfiguration& from) : ::google::protobuf::Message() {
  DimensionConfiguration* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.userdimensions_){from._impl_.userdimensions_},
      decltype(_impl_.timeconfig_){nullptr},
      decltype(_impl_.distanceconfig_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timeconfig_ = new ::NS3::InternalDimension(*from._impl_.timeconfig_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.distanceconfig_ = new ::NS3::InternalDimension(*from._impl_.distanceconfig_);
  }

  // @@protoc_insertion_point(copy_constructor:NS3.DimensionConfiguration)
}
inline void DimensionConfiguration::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.userdimensions_){arena},
      decltype(_impl_.timeconfig_){nullptr},
      decltype(_impl_.distanceconfig_){nullptr},
  };
}
DimensionConfiguration::~DimensionConfiguration() {
  // @@protoc_insertion_point(destructor:NS3.DimensionConfiguration)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DimensionConfiguration::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userdimensions_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.timeconfig_;
  if (this != internal_default_instance()) delete _impl_.distanceconfig_;
}
void DimensionConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void DimensionConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.DimensionConfiguration)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_userdimensions()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.timeconfig_ != nullptr);
      _impl_.timeconfig_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.distanceconfig_ != nullptr);
      _impl_.distanceconfig_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* DimensionConfiguration::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> DimensionConfiguration::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_DimensionConfiguration_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .NS3.InternalDimension timeConfig = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.timeconfig_)}},
    // optional .NS3.InternalDimension distanceConfig = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.distanceconfig_)}},
    // repeated .NS3.UserDimension userDimensions = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.userdimensions_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .NS3.InternalDimension timeConfig = 1;
    {PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.timeconfig_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .NS3.InternalDimension distanceConfig = 2;
    {PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.distanceconfig_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.UserDimension userDimensions = 3;
    {PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.userdimensions_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::InternalDimension>()},
    {::_pbi::TcParser::GetTable<::NS3::InternalDimension>()},
    {::_pbi::TcParser::GetTable<::NS3::UserDimension>()},
  }}, {{
  }},
};

::uint8_t* DimensionConfiguration::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.DimensionConfiguration)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .NS3.InternalDimension timeConfig = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timeconfig(this),
        _Internal::timeconfig(this).GetCachedSize(), target, stream);
  }

  // optional .NS3.InternalDimension distanceConfig = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::distanceconfig(this),
        _Internal::distanceconfig(this).GetCachedSize(), target, stream);
  }

  // repeated .NS3.UserDimension userDimensions = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_userdimensions_size()); i < n; i++) {
    const auto& repfield = this->_internal_userdimensions().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.DimensionConfiguration)
  return target;
}

::size_t DimensionConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.DimensionConfiguration)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.UserDimension userDimensions = 3;
  total_size += 1UL * this->_internal_userdimensions_size();
  for (const auto& msg : this->_internal_userdimensions()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .NS3.InternalDimension timeConfig = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.timeconfig_);
    }

    // optional .NS3.InternalDimension distanceConfig = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.distanceconfig_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData DimensionConfiguration::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    DimensionConfiguration::MergeImpl
};
const ::google::protobuf::Message::ClassData*DimensionConfiguration::GetClassData() const { return &_class_data_; }


void DimensionConfiguration::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<DimensionConfiguration*>(&to_msg);
  auto& from = static_cast<const DimensionConfiguration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.DimensionConfiguration)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_userdimensions()->MergeFrom(from._internal_userdimensions());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timeconfig()->::NS3::InternalDimension::MergeFrom(
          from._internal_timeconfig());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_distanceconfig()->::NS3::InternalDimension::MergeFrom(
          from._internal_distanceconfig());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DimensionConfiguration::CopyFrom(const DimensionConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.DimensionConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DimensionConfiguration::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(_internal_userdimensions()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.timeconfig_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.distanceconfig_->IsInitialized()) return false;
  }
  return true;
}

void DimensionConfiguration::InternalSwap(DimensionConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.userdimensions_.InternalSwap(&other->_impl_.userdimensions_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.distanceconfig_)
      + sizeof(DimensionConfiguration::_impl_.distanceconfig_)
      - PROTOBUF_FIELD_OFFSET(DimensionConfiguration, _impl_.timeconfig_)>(
          reinterpret_cast<char*>(&_impl_.timeconfig_),
          reinterpret_cast<char*>(&other->_impl_.timeconfig_));
}

::google::protobuf::Metadata DimensionConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[2]);
}
// ===================================================================

class Geocode::_Internal {
 public:
  using HasBits = decltype(std::declval<Geocode>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Geocode, _impl_._has_bits_);
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Geocode::Geocode(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Geocode)
}
Geocode::Geocode(const Geocode& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:NS3.Geocode)
}
inline void Geocode::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.longitude_){0},
      decltype(_impl_.latitude_){0},
  };
}
Geocode::~Geocode() {
  // @@protoc_insertion_point(destructor:NS3.Geocode)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Geocode::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void Geocode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Geocode::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Geocode)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.longitude_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.latitude_) -
        reinterpret_cast<char*>(&_impl_.longitude_)) + sizeof(_impl_.latitude_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Geocode::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> Geocode::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Geocode, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Geocode_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // required float latitude = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(Geocode, _impl_.latitude_)}},
    // required float longitude = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(Geocode, _impl_.longitude_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required float longitude = 1;
    {PROTOBUF_FIELD_OFFSET(Geocode, _impl_.longitude_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float latitude = 2;
    {PROTOBUF_FIELD_OFFSET(Geocode, _impl_.latitude_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Geocode::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Geocode)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float longitude = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_longitude(), target);
  }

  // required float latitude = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_latitude(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Geocode)
  return target;
}

::size_t Geocode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Geocode)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required float longitude = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // required float latitude = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Geocode::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Geocode::MergeImpl
};
const ::google::protobuf::Message::ClassData*Geocode::GetClassData() const { return &_class_data_; }


void Geocode::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Geocode*>(&to_msg);
  auto& from = static_cast<const Geocode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Geocode)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Geocode::CopyFrom(const Geocode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Geocode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Geocode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void Geocode::InternalSwap(Geocode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Geocode, _impl_.latitude_)
      + sizeof(Geocode::_impl_.latitude_)
      - PROTOBUF_FIELD_OFFSET(Geocode, _impl_.longitude_)>(
          reinterpret_cast<char*>(&_impl_.longitude_),
          reinterpret_cast<char*>(&other->_impl_.longitude_));
}

::google::protobuf::Metadata Geocode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[3]);
}
// ===================================================================

class UnitDimensionCost::_Internal {
 public:
  using HasBits = decltype(std::declval<UnitDimensionCost>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_._has_bits_);
  static void set_has_costperunit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

UnitDimensionCost::UnitDimensionCost(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.UnitDimensionCost)
}
UnitDimensionCost::UnitDimensionCost(const UnitDimensionCost& from) : ::google::protobuf::Message() {
  UnitDimensionCost* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionids_){from._impl_.dimensionids_},
      decltype(_impl_.dimensioncoefficients_){from._impl_.dimensioncoefficients_},
      decltype(_impl_.costperunit_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.costperunit_ = from._impl_.costperunit_;

  // @@protoc_insertion_point(copy_constructor:NS3.UnitDimensionCost)
}
inline void UnitDimensionCost::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionids_){arena},
      decltype(_impl_.dimensioncoefficients_){arena},
      decltype(_impl_.costperunit_){0},
  };
}
UnitDimensionCost::~UnitDimensionCost() {
  // @@protoc_insertion_point(destructor:NS3.UnitDimensionCost)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void UnitDimensionCost::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_dimensionids()->~RepeatedPtrField();
  _impl_.dimensioncoefficients_.~RepeatedField();
}
void UnitDimensionCost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void UnitDimensionCost::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.UnitDimensionCost)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_dimensionids()->Clear();
  _internal_mutable_dimensioncoefficients()->Clear();
  _impl_.costperunit_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* UnitDimensionCost::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 42, 2> UnitDimensionCost::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_UnitDimensionCost_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated string dimensionIds = 1;
    {::_pbi::TcParser::FastSR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_.dimensionids_)}},
    // repeated float dimensionCoefficients = 2;
    {::_pbi::TcParser::FastF32R1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_.dimensioncoefficients_)}},
    // required float costPerUnit = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 0, 0, PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_.costperunit_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string dimensionIds = 1;
    {PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_.dimensionids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated float dimensionCoefficients = 2;
    {PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_.dimensioncoefficients_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // required float costPerUnit = 3;
    {PROTOBUF_FIELD_OFFSET(UnitDimensionCost, _impl_.costperunit_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\25\14\0\0\0\0\0\0"
    "NS3.UnitDimensionCost"
    "dimensionIds"
  }},
};

::uint8_t* UnitDimensionCost::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.UnitDimensionCost)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string dimensionIds = 1;
  for (int i = 0, n = this->_internal_dimensionids_size(); i < n; ++i) {
    const auto& s = this->_internal_dimensionids().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.UnitDimensionCost.dimensionIds");
    target = stream->WriteString(1, s, target);
  }

  // repeated float dimensionCoefficients = 2;
  for (int i = 0, n = this->_internal_dimensioncoefficients_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_dimensioncoefficients().Get(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required float costPerUnit = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_costperunit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.UnitDimensionCost)
  return target;
}

::size_t UnitDimensionCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.UnitDimensionCost)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string dimensionIds = 1;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_dimensionids().size());
  for (int i = 0, n = _internal_dimensionids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_dimensionids().Get(i));
  }
  // repeated float dimensionCoefficients = 2;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_dimensioncoefficients_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_dimensioncoefficients_size());
    ;
    total_size += tag_size + data_size;
  }
  // required float costPerUnit = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData UnitDimensionCost::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    UnitDimensionCost::MergeImpl
};
const ::google::protobuf::Message::ClassData*UnitDimensionCost::GetClassData() const { return &_class_data_; }


void UnitDimensionCost::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<UnitDimensionCost*>(&to_msg);
  auto& from = static_cast<const UnitDimensionCost&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.UnitDimensionCost)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_dimensionids()->MergeFrom(from._internal_dimensionids());
  _this->_internal_mutable_dimensioncoefficients()->MergeFrom(from._internal_dimensioncoefficients());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_costperunit(from._internal_costperunit());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UnitDimensionCost::CopyFrom(const UnitDimensionCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.UnitDimensionCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UnitDimensionCost::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UnitDimensionCost::InternalSwap(UnitDimensionCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dimensionids_.InternalSwap(&other->_impl_.dimensionids_);
  _impl_.dimensioncoefficients_.InternalSwap(&other->_impl_.dimensioncoefficients_);
        swap(_impl_.costperunit_, other->_impl_.costperunit_);
}

::google::protobuf::Metadata UnitDimensionCost::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[4]);
}
// ===================================================================

class FixedDimensionCost::_Internal {
 public:
  using HasBits = decltype(std::declval<FixedDimensionCost>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FixedDimensionCost, _impl_._has_bits_);
  static void set_has_fixedcost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FixedDimensionCost::FixedDimensionCost(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.FixedDimensionCost)
}
FixedDimensionCost::FixedDimensionCost(const FixedDimensionCost& from) : ::google::protobuf::Message() {
  FixedDimensionCost* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionids_){from._impl_.dimensionids_},
      decltype(_impl_.fixedcost_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.fixedcost_ = from._impl_.fixedcost_;

  // @@protoc_insertion_point(copy_constructor:NS3.FixedDimensionCost)
}
inline void FixedDimensionCost::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionids_){arena},
      decltype(_impl_.fixedcost_){0},
  };
}
FixedDimensionCost::~FixedDimensionCost() {
  // @@protoc_insertion_point(destructor:NS3.FixedDimensionCost)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FixedDimensionCost::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_dimensionids()->~RepeatedPtrField();
}
void FixedDimensionCost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void FixedDimensionCost::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.FixedDimensionCost)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_dimensionids()->Clear();
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* FixedDimensionCost::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 43, 2> FixedDimensionCost::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FixedDimensionCost, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_FixedDimensionCost_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // required float fixedCost = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 0, 0, PROTOBUF_FIELD_OFFSET(FixedDimensionCost, _impl_.fixedcost_)}},
    // repeated string dimensionIds = 1;
    {::_pbi::TcParser::FastSR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(FixedDimensionCost, _impl_.dimensionids_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string dimensionIds = 1;
    {PROTOBUF_FIELD_OFFSET(FixedDimensionCost, _impl_.dimensionids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // required float fixedCost = 2;
    {PROTOBUF_FIELD_OFFSET(FixedDimensionCost, _impl_.fixedcost_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\26\14\0\0\0\0\0\0"
    "NS3.FixedDimensionCost"
    "dimensionIds"
  }},
};

::uint8_t* FixedDimensionCost::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.FixedDimensionCost)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string dimensionIds = 1;
  for (int i = 0, n = this->_internal_dimensionids_size(); i < n; ++i) {
    const auto& s = this->_internal_dimensionids().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.FixedDimensionCost.dimensionIds");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required float fixedCost = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_fixedcost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.FixedDimensionCost)
  return target;
}

::size_t FixedDimensionCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.FixedDimensionCost)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string dimensionIds = 1;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_dimensionids().size());
  for (int i = 0, n = _internal_dimensionids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_dimensionids().Get(i));
  }
  // required float fixedCost = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData FixedDimensionCost::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    FixedDimensionCost::MergeImpl
};
const ::google::protobuf::Message::ClassData*FixedDimensionCost::GetClassData() const { return &_class_data_; }


void FixedDimensionCost::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<FixedDimensionCost*>(&to_msg);
  auto& from = static_cast<const FixedDimensionCost&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.FixedDimensionCost)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_dimensionids()->MergeFrom(from._internal_dimensionids());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_fixedcost(from._internal_fixedcost());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FixedDimensionCost::CopyFrom(const FixedDimensionCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.FixedDimensionCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FixedDimensionCost::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void FixedDimensionCost::InternalSwap(FixedDimensionCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dimensionids_.InternalSwap(&other->_impl_.dimensionids_);
        swap(_impl_.fixedcost_, other->_impl_.fixedcost_);
}

::google::protobuf::Metadata FixedDimensionCost::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[5]);
}
// ===================================================================

class FlowDimensionalConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<FlowDimensionalConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_._has_bits_);
  static void set_has_flowmin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flowmax(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

FlowDimensionalConstraint::FlowDimensionalConstraint(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.FlowDimensionalConstraint)
}
FlowDimensionalConstraint::FlowDimensionalConstraint(const FlowDimensionalConstraint& from) : ::google::protobuf::Message() {
  FlowDimensionalConstraint* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionids_){from._impl_.dimensionids_},
      decltype(_impl_.dimensioncoefficients_){from._impl_.dimensioncoefficients_},
      decltype(_impl_.flowmin_){},
      decltype(_impl_.flowmax_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.flowmin_, &from._impl_.flowmin_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.flowmax_) -
    reinterpret_cast<char*>(&_impl_.flowmin_)) + sizeof(_impl_.flowmax_));

  // @@protoc_insertion_point(copy_constructor:NS3.FlowDimensionalConstraint)
}
inline void FlowDimensionalConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionids_){arena},
      decltype(_impl_.dimensioncoefficients_){arena},
      decltype(_impl_.flowmin_){0},
      decltype(_impl_.flowmax_){0},
  };
}
FlowDimensionalConstraint::~FlowDimensionalConstraint() {
  // @@protoc_insertion_point(destructor:NS3.FlowDimensionalConstraint)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FlowDimensionalConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_dimensionids()->~RepeatedPtrField();
  _impl_.dimensioncoefficients_.~RepeatedField();
}
void FlowDimensionalConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void FlowDimensionalConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.FlowDimensionalConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_dimensionids()->Clear();
  _internal_mutable_dimensioncoefficients()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.flowmin_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flowmax_) -
        reinterpret_cast<char*>(&_impl_.flowmin_)) + sizeof(_impl_.flowmax_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* FlowDimensionalConstraint::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 50, 2> FlowDimensionalConstraint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_FlowDimensionalConstraint_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // required float flowMax = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 1, 0, PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.flowmax_)}},
    // repeated string dimensionIds = 1;
    {::_pbi::TcParser::FastSR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.dimensionids_)}},
    // repeated float dimensionCoefficients = 2;
    {::_pbi::TcParser::FastF32R1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.dimensioncoefficients_)}},
    // required float flowMin = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 0, 0, PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.flowmin_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string dimensionIds = 1;
    {PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.dimensionids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated float dimensionCoefficients = 2;
    {PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.dimensioncoefficients_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // required float flowMin = 3;
    {PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.flowmin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float flowMax = 4;
    {PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.flowmax_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\35\14\0\0\0\0\0\0"
    "NS3.FlowDimensionalConstraint"
    "dimensionIds"
  }},
};

::uint8_t* FlowDimensionalConstraint::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.FlowDimensionalConstraint)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string dimensionIds = 1;
  for (int i = 0, n = this->_internal_dimensionids_size(); i < n; ++i) {
    const auto& s = this->_internal_dimensionids().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.FlowDimensionalConstraint.dimensionIds");
    target = stream->WriteString(1, s, target);
  }

  // repeated float dimensionCoefficients = 2;
  for (int i = 0, n = this->_internal_dimensioncoefficients_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_dimensioncoefficients().Get(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required float flowMin = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_flowmin(), target);
  }

  // required float flowMax = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_flowmax(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.FlowDimensionalConstraint)
  return target;
}

::size_t FlowDimensionalConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.FlowDimensionalConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string dimensionIds = 1;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_dimensionids().size());
  for (int i = 0, n = _internal_dimensionids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_dimensionids().Get(i));
  }
  // repeated float dimensionCoefficients = 2;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_dimensioncoefficients_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_dimensioncoefficients_size());
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required float flowMin = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // required float flowMax = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData FlowDimensionalConstraint::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    FlowDimensionalConstraint::MergeImpl
};
const ::google::protobuf::Message::ClassData*FlowDimensionalConstraint::GetClassData() const { return &_class_data_; }


void FlowDimensionalConstraint::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<FlowDimensionalConstraint*>(&to_msg);
  auto& from = static_cast<const FlowDimensionalConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.FlowDimensionalConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_dimensionids()->MergeFrom(from._internal_dimensionids());
  _this->_internal_mutable_dimensioncoefficients()->MergeFrom(from._internal_dimensioncoefficients());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.flowmin_ = from._impl_.flowmin_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.flowmax_ = from._impl_.flowmax_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FlowDimensionalConstraint::CopyFrom(const FlowDimensionalConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.FlowDimensionalConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FlowDimensionalConstraint::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void FlowDimensionalConstraint::InternalSwap(FlowDimensionalConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dimensionids_.InternalSwap(&other->_impl_.dimensionids_);
  _impl_.dimensioncoefficients_.InternalSwap(&other->_impl_.dimensioncoefficients_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.flowmax_)
      + sizeof(FlowDimensionalConstraint::_impl_.flowmax_)
      - PROTOBUF_FIELD_OFFSET(FlowDimensionalConstraint, _impl_.flowmin_)>(
          reinterpret_cast<char*>(&_impl_.flowmin_),
          reinterpret_cast<char*>(&other->_impl_.flowmin_));
}

::google::protobuf::Metadata FlowDimensionalConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[6]);
}
// ===================================================================

class DimensionRange::_Internal {
 public:
  using HasBits = decltype(std::declval<DimensionRange>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_._has_bits_);
  static void set_has_dimensionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minrange(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_maxrange(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flowpenalty(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

DimensionRange::DimensionRange(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.DimensionRange)
}
DimensionRange::DimensionRange(const DimensionRange& from) : ::google::protobuf::Message() {
  DimensionRange* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionid_){},
      decltype(_impl_.minrange_){},
      decltype(_impl_.maxrange_){},
      decltype(_impl_.flowpenalty_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.dimensionid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.dimensionid_.Set(from._internal_dimensionid(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.minrange_, &from._impl_.minrange_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.flowpenalty_) -
    reinterpret_cast<char*>(&_impl_.minrange_)) + sizeof(_impl_.flowpenalty_));

  // @@protoc_insertion_point(copy_constructor:NS3.DimensionRange)
}
inline void DimensionRange::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionid_){},
      decltype(_impl_.minrange_){0},
      decltype(_impl_.maxrange_){0},
      decltype(_impl_.flowpenalty_){0},
  };
  _impl_.dimensionid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
DimensionRange::~DimensionRange() {
  // @@protoc_insertion_point(destructor:NS3.DimensionRange)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DimensionRange::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dimensionid_.Destroy();
}
void DimensionRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void DimensionRange::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.DimensionRange)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.dimensionid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.minrange_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flowpenalty_) -
        reinterpret_cast<char*>(&_impl_.minrange_)) + sizeof(_impl_.flowpenalty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* DimensionRange::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 38, 2> DimensionRange::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_DimensionRange_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // required float flowPenalty = 4 [default = 0];
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.flowpenalty_)}},
    // required string dimensionId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.dimensionid_)}},
    // required float minRange = 2 [default = 0];
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.minrange_)}},
    // required float maxRange = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.maxrange_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string dimensionId = 1;
    {PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.dimensionid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required float minRange = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.minrange_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float maxRange = 3;
    {PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.maxrange_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float flowPenalty = 4 [default = 0];
    {PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.flowpenalty_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\22\13\0\0\0\0\0\0"
    "NS3.DimensionRange"
    "dimensionId"
  }},
};

::uint8_t* DimensionRange::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.DimensionRange)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string dimensionId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_dimensionid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.DimensionRange.dimensionId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required float minRange = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_minrange(), target);
  }

  // required float maxRange = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_maxrange(), target);
  }

  // required float flowPenalty = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_flowpenalty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.DimensionRange)
  return target;
}

::size_t DimensionRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.DimensionRange)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // required string dimensionId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_dimensionid());
    }

    // required float minRange = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // required float maxRange = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // required float flowPenalty = 4 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData DimensionRange::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    DimensionRange::MergeImpl
};
const ::google::protobuf::Message::ClassData*DimensionRange::GetClassData() const { return &_class_data_; }


void DimensionRange::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<DimensionRange*>(&to_msg);
  auto& from = static_cast<const DimensionRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.DimensionRange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dimensionid(from._internal_dimensionid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.minrange_ = from._impl_.minrange_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.maxrange_ = from._impl_.maxrange_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flowpenalty_ = from._impl_.flowpenalty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DimensionRange::CopyFrom(const DimensionRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.DimensionRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DimensionRange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void DimensionRange::InternalSwap(DimensionRange* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dimensionid_, lhs_arena,
                                       &other->_impl_.dimensionid_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.flowpenalty_)
      + sizeof(DimensionRange::_impl_.flowpenalty_)
      - PROTOBUF_FIELD_OFFSET(DimensionRange, _impl_.minrange_)>(
          reinterpret_cast<char*>(&_impl_.minrange_),
          reinterpret_cast<char*>(&other->_impl_.minrange_));
}

::google::protobuf::Metadata DimensionRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[7]);
}
// ===================================================================

class Node_ProductFlow::_Internal {
 public:
  using HasBits = decltype(std::declval<Node_ProductFlow>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_._has_bits_);
  static void set_has_productid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Node_ProductFlow::Node_ProductFlow(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Node.ProductFlow)
}
Node_ProductFlow::Node_ProductFlow(const Node_ProductFlow& from) : ::google::protobuf::Message() {
  Node_ProductFlow* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionranges_){from._impl_.dimensionranges_},
      decltype(_impl_.fixeddimensioncosts_){from._impl_.fixeddimensioncosts_},
      decltype(_impl_.unitdimensioncosts_){from._impl_.unitdimensioncosts_},
      decltype(_impl_.productid_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.productid_.Set(from._internal_productid(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.Node.ProductFlow)
}
inline void Node_ProductFlow::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionranges_){arena},
      decltype(_impl_.fixeddimensioncosts_){arena},
      decltype(_impl_.unitdimensioncosts_){arena},
      decltype(_impl_.productid_){},
  };
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Node_ProductFlow::~Node_ProductFlow() {
  // @@protoc_insertion_point(destructor:NS3.Node.ProductFlow)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Node_ProductFlow::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dimensionranges_.~RepeatedPtrField();
  _impl_.fixeddimensioncosts_.~RepeatedPtrField();
  _impl_.unitdimensioncosts_.~RepeatedPtrField();
  _impl_.productid_.Destroy();
}
void Node_ProductFlow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Node_ProductFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Node.ProductFlow)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_dimensionranges()->Clear();
  _internal_mutable_fixeddimensioncosts()->Clear();
  _internal_mutable_unitdimensioncosts()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.productid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Node_ProductFlow::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 3, 38, 2> Node_ProductFlow::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Node_ProductFlow_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 2, PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.unitdimensioncosts_)}},
    // required string productId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.productid_)}},
    // repeated .NS3.DimensionRange dimensionRanges = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.dimensionranges_)}},
    // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.fixeddimensioncosts_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string productId = 1;
    {PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.productid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated .NS3.DimensionRange dimensionRanges = 2;
    {PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.dimensionranges_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
    {PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.fixeddimensioncosts_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
    {PROTOBUF_FIELD_OFFSET(Node_ProductFlow, _impl_.unitdimensioncosts_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::DimensionRange>()},
    {::_pbi::TcParser::GetTable<::NS3::FixedDimensionCost>()},
    {::_pbi::TcParser::GetTable<::NS3::UnitDimensionCost>()},
  }}, {{
    "\24\11\0\0\0\0\0\0"
    "NS3.Node.ProductFlow"
    "productId"
  }},
};

::uint8_t* Node_ProductFlow::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Node.ProductFlow)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string productId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_productid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.Node.ProductFlow.productId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .NS3.DimensionRange dimensionRanges = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dimensionranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_dimensionranges().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fixeddimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_fixeddimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unitdimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_unitdimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Node.ProductFlow)
  return target;
}

::size_t Node_ProductFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Node.ProductFlow)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.DimensionRange dimensionRanges = 2;
  total_size += 1UL * this->_internal_dimensionranges_size();
  for (const auto& msg : this->_internal_dimensionranges()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
  total_size += 1UL * this->_internal_fixeddimensioncosts_size();
  for (const auto& msg : this->_internal_fixeddimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  total_size += 1UL * this->_internal_unitdimensioncosts_size();
  for (const auto& msg : this->_internal_unitdimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required string productId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_productid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Node_ProductFlow::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Node_ProductFlow::MergeImpl
};
const ::google::protobuf::Message::ClassData*Node_ProductFlow::GetClassData() const { return &_class_data_; }


void Node_ProductFlow::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Node_ProductFlow*>(&to_msg);
  auto& from = static_cast<const Node_ProductFlow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Node.ProductFlow)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_dimensionranges()->MergeFrom(from._internal_dimensionranges());
  _this->_internal_mutable_fixeddimensioncosts()->MergeFrom(from._internal_fixeddimensioncosts());
  _this->_internal_mutable_unitdimensioncosts()->MergeFrom(from._internal_unitdimensioncosts());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_productid(from._internal_productid());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Node_ProductFlow::CopyFrom(const Node_ProductFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Node.ProductFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Node_ProductFlow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_dimensionranges()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_fixeddimensioncosts()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_unitdimensioncosts()))
    return false;
  return true;
}

void Node_ProductFlow::InternalSwap(Node_ProductFlow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dimensionranges_.InternalSwap(&other->_impl_.dimensionranges_);
  _impl_.fixeddimensioncosts_.InternalSwap(&other->_impl_.fixeddimensioncosts_);
  _impl_.unitdimensioncosts_.InternalSwap(&other->_impl_.unitdimensioncosts_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productid_, lhs_arena,
                                       &other->_impl_.productid_, rhs_arena);
}

::google::protobuf::Metadata Node_ProductFlow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[8]);
}
// ===================================================================

class Node_Flow::_Internal {
 public:
};

Node_Flow::Node_Flow(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Node.Flow)
}
Node_Flow::Node_Flow(const Node_Flow& from) : ::google::protobuf::Message() {
  Node_Flow* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dimensionranges_){from._impl_.dimensionranges_},
      decltype(_impl_.fixeddimensioncosts_){from._impl_.fixeddimensioncosts_},
      decltype(_impl_.unitdimensioncosts_){from._impl_.unitdimensioncosts_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:NS3.Node.Flow)
}
inline void Node_Flow::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.dimensionranges_){arena},
      decltype(_impl_.fixeddimensioncosts_){arena},
      decltype(_impl_.unitdimensioncosts_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
Node_Flow::~Node_Flow() {
  // @@protoc_insertion_point(destructor:NS3.Node.Flow)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Node_Flow::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dimensionranges_.~RepeatedPtrField();
  _impl_.fixeddimensioncosts_.~RepeatedPtrField();
  _impl_.unitdimensioncosts_.~RepeatedPtrField();
}
void Node_Flow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Node_Flow::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Node.Flow)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_dimensionranges()->Clear();
  _internal_mutable_fixeddimensioncosts()->Clear();
  _internal_mutable_unitdimensioncosts()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Node_Flow::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> Node_Flow::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Node_Flow_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .NS3.DimensionRange dimensionRanges = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Node_Flow, _impl_.dimensionranges_)}},
    // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(Node_Flow, _impl_.fixeddimensioncosts_)}},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(Node_Flow, _impl_.unitdimensioncosts_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .NS3.DimensionRange dimensionRanges = 1;
    {PROTOBUF_FIELD_OFFSET(Node_Flow, _impl_.dimensionranges_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
    {PROTOBUF_FIELD_OFFSET(Node_Flow, _impl_.fixeddimensioncosts_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
    {PROTOBUF_FIELD_OFFSET(Node_Flow, _impl_.unitdimensioncosts_), 0, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::DimensionRange>()},
    {::_pbi::TcParser::GetTable<::NS3::FixedDimensionCost>()},
    {::_pbi::TcParser::GetTable<::NS3::UnitDimensionCost>()},
  }}, {{
  }},
};

::uint8_t* Node_Flow::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Node.Flow)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .NS3.DimensionRange dimensionRanges = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dimensionranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_dimensionranges().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fixeddimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_fixeddimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unitdimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_unitdimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Node.Flow)
  return target;
}

::size_t Node_Flow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Node.Flow)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.DimensionRange dimensionRanges = 1;
  total_size += 1UL * this->_internal_dimensionranges_size();
  for (const auto& msg : this->_internal_dimensionranges()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
  total_size += 1UL * this->_internal_fixeddimensioncosts_size();
  for (const auto& msg : this->_internal_fixeddimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
  total_size += 1UL * this->_internal_unitdimensioncosts_size();
  for (const auto& msg : this->_internal_unitdimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Node_Flow::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Node_Flow::MergeImpl
};
const ::google::protobuf::Message::ClassData*Node_Flow::GetClassData() const { return &_class_data_; }


void Node_Flow::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Node_Flow*>(&to_msg);
  auto& from = static_cast<const Node_Flow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Node.Flow)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_dimensionranges()->MergeFrom(from._internal_dimensionranges());
  _this->_internal_mutable_fixeddimensioncosts()->MergeFrom(from._internal_fixeddimensioncosts());
  _this->_internal_mutable_unitdimensioncosts()->MergeFrom(from._internal_unitdimensioncosts());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Node_Flow::CopyFrom(const Node_Flow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Node.Flow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Node_Flow::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(_internal_dimensionranges()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_fixeddimensioncosts()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_unitdimensioncosts()))
    return false;
  return true;
}

void Node_Flow::InternalSwap(Node_Flow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dimensionranges_.InternalSwap(&other->_impl_.dimensionranges_);
  _impl_.fixeddimensioncosts_.InternalSwap(&other->_impl_.fixeddimensioncosts_);
  _impl_.unitdimensioncosts_.InternalSwap(&other->_impl_.unitdimensioncosts_);
}

::google::protobuf::Metadata Node_Flow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[9]);
}
// ===================================================================

class Node_ProductTransform_Item::_Internal {
 public:
  using HasBits = decltype(std::declval<Node_ProductTransform_Item>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_._has_bits_);
  static void set_has_productid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_productratio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Node_ProductTransform_Item::Node_ProductTransform_Item(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Node.ProductTransform.Item)
}
Node_ProductTransform_Item::Node_ProductTransform_Item(const Node_ProductTransform_Item& from) : ::google::protobuf::Message() {
  Node_ProductTransform_Item* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionranges_){from._impl_.dimensionranges_},
      decltype(_impl_.fixeddimensioncosts_){from._impl_.fixeddimensioncosts_},
      decltype(_impl_.unitdimensioncosts_){from._impl_.unitdimensioncosts_},
      decltype(_impl_.productid_){},
      decltype(_impl_.productratio_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.productid_.Set(from._internal_productid(), _this->GetArenaForAllocation());
  }
  _this->_impl_.productratio_ = from._impl_.productratio_;

  // @@protoc_insertion_point(copy_constructor:NS3.Node.ProductTransform.Item)
}
inline void Node_ProductTransform_Item::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.dimensionranges_){arena},
      decltype(_impl_.fixeddimensioncosts_){arena},
      decltype(_impl_.unitdimensioncosts_){arena},
      decltype(_impl_.productid_){},
      decltype(_impl_.productratio_){0},
  };
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Node_ProductTransform_Item::~Node_ProductTransform_Item() {
  // @@protoc_insertion_point(destructor:NS3.Node.ProductTransform.Item)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Node_ProductTransform_Item::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dimensionranges_.~RepeatedPtrField();
  _impl_.fixeddimensioncosts_.~RepeatedPtrField();
  _impl_.unitdimensioncosts_.~RepeatedPtrField();
  _impl_.productid_.Destroy();
}
void Node_ProductTransform_Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Node_ProductTransform_Item::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Node.ProductTransform.Item)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_dimensionranges()->Clear();
  _internal_mutable_fixeddimensioncosts()->Clear();
  _internal_mutable_unitdimensioncosts()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.productid_.ClearNonDefaultToEmpty();
  }
  _impl_.productratio_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Node_ProductTransform_Item::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 3, 48, 2> Node_ProductTransform_Item::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Node_ProductTransform_Item_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string productId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.productid_)}},
    // required int32 productRatio = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Node_ProductTransform_Item, _impl_.productratio_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.productratio_)}},
    // repeated .NS3.DimensionRange dimensionRanges = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.dimensionranges_)}},
    // repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 1, PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.fixeddimensioncosts_)}},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 2, PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.unitdimensioncosts_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string productId = 1;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.productid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required int32 productRatio = 2;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.productratio_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .NS3.DimensionRange dimensionRanges = 3;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.dimensionranges_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.fixeddimensioncosts_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform_Item, _impl_.unitdimensioncosts_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::DimensionRange>()},
    {::_pbi::TcParser::GetTable<::NS3::FixedDimensionCost>()},
    {::_pbi::TcParser::GetTable<::NS3::UnitDimensionCost>()},
  }}, {{
    "\36\11\0\0\0\0\0\0"
    "NS3.Node.ProductTransform.Item"
    "productId"
  }},
};

::uint8_t* Node_ProductTransform_Item::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Node.ProductTransform.Item)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string productId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_productid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.Node.ProductTransform.Item.productId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required int32 productRatio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_productratio(), target);
  }

  // repeated .NS3.DimensionRange dimensionRanges = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dimensionranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_dimensionranges().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fixeddimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_fixeddimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unitdimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_unitdimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Node.ProductTransform.Item)
  return target;
}

::size_t Node_ProductTransform_Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Node.ProductTransform.Item)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.DimensionRange dimensionRanges = 3;
  total_size += 1UL * this->_internal_dimensionranges_size();
  for (const auto& msg : this->_internal_dimensionranges()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
  total_size += 1UL * this->_internal_fixeddimensioncosts_size();
  for (const auto& msg : this->_internal_fixeddimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
  total_size += 1UL * this->_internal_unitdimensioncosts_size();
  for (const auto& msg : this->_internal_unitdimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string productId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_productid());
    }

    // required int32 productRatio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_productratio());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Node_ProductTransform_Item::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Node_ProductTransform_Item::MergeImpl
};
const ::google::protobuf::Message::ClassData*Node_ProductTransform_Item::GetClassData() const { return &_class_data_; }


void Node_ProductTransform_Item::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Node_ProductTransform_Item*>(&to_msg);
  auto& from = static_cast<const Node_ProductTransform_Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Node.ProductTransform.Item)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_dimensionranges()->MergeFrom(from._internal_dimensionranges());
  _this->_internal_mutable_fixeddimensioncosts()->MergeFrom(from._internal_fixeddimensioncosts());
  _this->_internal_mutable_unitdimensioncosts()->MergeFrom(from._internal_unitdimensioncosts());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_productid(from._internal_productid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.productratio_ = from._impl_.productratio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Node_ProductTransform_Item::CopyFrom(const Node_ProductTransform_Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Node.ProductTransform.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Node_ProductTransform_Item::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_dimensionranges()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_fixeddimensioncosts()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_unitdimensioncosts()))
    return false;
  return true;
}

void Node_ProductTransform_Item::InternalSwap(Node_ProductTransform_Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dimensionranges_.InternalSwap(&other->_impl_.dimensionranges_);
  _impl_.fixeddimensioncosts_.InternalSwap(&other->_impl_.fixeddimensioncosts_);
  _impl_.unitdimensioncosts_.InternalSwap(&other->_impl_.unitdimensioncosts_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productid_, lhs_arena,
                                       &other->_impl_.productid_, rhs_arena);
        swap(_impl_.productratio_, other->_impl_.productratio_);
}

::google::protobuf::Metadata Node_ProductTransform_Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[10]);
}
// ===================================================================

class Node_ProductTransform::_Internal {
 public:
  using HasBits = decltype(std::declval<Node_ProductTransform>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_._has_bits_);
  static void set_has_producttransformid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Node_ProductTransform::Node_ProductTransform(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Node.ProductTransform)
}
Node_ProductTransform::Node_ProductTransform(const Node_ProductTransform& from) : ::google::protobuf::Message() {
  Node_ProductTransform* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.inputitems_){from._impl_.inputitems_},
      decltype(_impl_.outputitems_){from._impl_.outputitems_},
      decltype(_impl_.producttransformid_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.producttransformid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.producttransformid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.producttransformid_.Set(from._internal_producttransformid(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.Node.ProductTransform)
}
inline void Node_ProductTransform::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.inputitems_){arena},
      decltype(_impl_.outputitems_){arena},
      decltype(_impl_.producttransformid_){},
  };
  _impl_.producttransformid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.producttransformid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Node_ProductTransform::~Node_ProductTransform() {
  // @@protoc_insertion_point(destructor:NS3.Node.ProductTransform)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Node_ProductTransform::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.inputitems_.~RepeatedPtrField();
  _impl_.outputitems_.~RepeatedPtrField();
  _impl_.producttransformid_.Destroy();
}
void Node_ProductTransform::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Node_ProductTransform::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Node.ProductTransform)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_inputitems()->Clear();
  _internal_mutable_outputitems()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.producttransformid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Node_ProductTransform::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 52, 2> Node_ProductTransform::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Node_ProductTransform_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string productTransformId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_.producttransformid_)}},
    // repeated .NS3.Node.ProductTransform.Item inputItems = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_.inputitems_)}},
    // repeated .NS3.Node.ProductTransform.Item outputItems = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_.outputitems_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string productTransformId = 1;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_.producttransformid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated .NS3.Node.ProductTransform.Item inputItems = 2;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_.inputitems_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.Node.ProductTransform.Item outputItems = 3;
    {PROTOBUF_FIELD_OFFSET(Node_ProductTransform, _impl_.outputitems_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::Node_ProductTransform_Item>()},
    {::_pbi::TcParser::GetTable<::NS3::Node_ProductTransform_Item>()},
  }}, {{
    "\31\22\0\0\0\0\0\0"
    "NS3.Node.ProductTransform"
    "productTransformId"
  }},
};

::uint8_t* Node_ProductTransform::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Node.ProductTransform)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string productTransformId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_producttransformid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.Node.ProductTransform.productTransformId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .NS3.Node.ProductTransform.Item inputItems = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inputitems_size()); i < n; i++) {
    const auto& repfield = this->_internal_inputitems().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.Node.ProductTransform.Item outputItems = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outputitems_size()); i < n; i++) {
    const auto& repfield = this->_internal_outputitems().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Node.ProductTransform)
  return target;
}

::size_t Node_ProductTransform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Node.ProductTransform)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.Node.ProductTransform.Item inputItems = 2;
  total_size += 1UL * this->_internal_inputitems_size();
  for (const auto& msg : this->_internal_inputitems()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.Node.ProductTransform.Item outputItems = 3;
  total_size += 1UL * this->_internal_outputitems_size();
  for (const auto& msg : this->_internal_outputitems()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required string productTransformId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_producttransformid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Node_ProductTransform::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Node_ProductTransform::MergeImpl
};
const ::google::protobuf::Message::ClassData*Node_ProductTransform::GetClassData() const { return &_class_data_; }


void Node_ProductTransform::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Node_ProductTransform*>(&to_msg);
  auto& from = static_cast<const Node_ProductTransform&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Node.ProductTransform)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_inputitems()->MergeFrom(from._internal_inputitems());
  _this->_internal_mutable_outputitems()->MergeFrom(from._internal_outputitems());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_producttransformid(from._internal_producttransformid());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Node_ProductTransform::CopyFrom(const Node_ProductTransform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Node.ProductTransform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Node_ProductTransform::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_inputitems()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_outputitems()))
    return false;
  return true;
}

void Node_ProductTransform::InternalSwap(Node_ProductTransform* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.inputitems_.InternalSwap(&other->_impl_.inputitems_);
  _impl_.outputitems_.InternalSwap(&other->_impl_.outputitems_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.producttransformid_, lhs_arena,
                                       &other->_impl_.producttransformid_, rhs_arena);
}

::google::protobuf::Metadata Node_ProductTransform::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[11]);
}
// ===================================================================

class Node::_Internal {
 public:
  using HasBits = decltype(std::declval<Node>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Node, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::NS3::Geocode& geocode(const Node* msg);
  static void set_has_geocode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::NS3::Node_Flow& flow(const Node* msg);
  static void set_has_flow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_maximumsources(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::NS3::Geocode& Node::_Internal::geocode(const Node* msg) {
  return *msg->_impl_.geocode_;
}
const ::NS3::Node_Flow& Node::_Internal::flow(const Node* msg) {
  return *msg->_impl_.flow_;
}
Node::Node(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Node)
}
Node::Node(const Node& from) : ::google::protobuf::Message() {
  Node* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.production_){from._impl_.production_},
      decltype(_impl_.consumption_){from._impl_.consumption_},
      decltype(_impl_.productflows_){from._impl_.productflows_},
      decltype(_impl_.allowablesources_){from._impl_.allowablesources_},
      decltype(_impl_.flowconstraints_){from._impl_.flowconstraints_},
      decltype(_impl_.producttransforms_){from._impl_.producttransforms_},
      decltype(_impl_.id_){},
      decltype(_impl_.geocode_){nullptr},
      decltype(_impl_.flow_){nullptr},
      decltype(_impl_.maximumsources_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.geocode_ = new ::NS3::Geocode(*from._impl_.geocode_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.flow_ = new ::NS3::Node_Flow(*from._impl_.flow_);
  }
  _this->_impl_.maximumsources_ = from._impl_.maximumsources_;

  // @@protoc_insertion_point(copy_constructor:NS3.Node)
}
inline void Node::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.production_){arena},
      decltype(_impl_.consumption_){arena},
      decltype(_impl_.productflows_){arena},
      decltype(_impl_.allowablesources_){arena},
      decltype(_impl_.flowconstraints_){arena},
      decltype(_impl_.producttransforms_){arena},
      decltype(_impl_.id_){},
      decltype(_impl_.geocode_){nullptr},
      decltype(_impl_.flow_){nullptr},
      decltype(_impl_.maximumsources_){-1},
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Node::~Node() {
  // @@protoc_insertion_point(destructor:NS3.Node)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Node::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.production_.~RepeatedPtrField();
  _impl_.consumption_.~RepeatedPtrField();
  _impl_.productflows_.~RepeatedPtrField();
  _internal_mutable_allowablesources()->~RepeatedPtrField();
  _impl_.flowconstraints_.~RepeatedPtrField();
  _impl_.producttransforms_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.geocode_;
  if (this != internal_default_instance()) delete _impl_.flow_;
}
void Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Node)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_production()->Clear();
  _internal_mutable_consumption()->Clear();
  _internal_mutable_productflows()->Clear();
  _internal_mutable_allowablesources()->Clear();
  _internal_mutable_flowconstraints()->Clear();
  _internal_mutable_producttransforms()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.geocode_ != nullptr);
      _impl_.geocode_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.flow_ != nullptr);
      _impl_.flow_->Clear();
    }
    _impl_.maximumsources_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Node::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 7, 43, 2> Node::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Node, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Node_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string id = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Node, _impl_.id_)}},
    // required .NS3.Geocode geocode = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(Node, _impl_.geocode_)}},
    // repeated .NS3.Node.ProductFlow production = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(Node, _impl_.production_)}},
    // repeated .NS3.Node.ProductFlow consumption = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 2, PROTOBUF_FIELD_OFFSET(Node, _impl_.consumption_)}},
    // optional .NS3.Node.Flow flow = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 2, 3, PROTOBUF_FIELD_OFFSET(Node, _impl_.flow_)}},
    // repeated .NS3.Node.ProductFlow productFlows = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 4, PROTOBUF_FIELD_OFFSET(Node, _impl_.productflows_)}},
    // repeated string allowableSources = 7;
    {::_pbi::TcParser::FastSR1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Node, _impl_.allowablesources_)}},
    // optional int32 maximumSources = 8 [default = -1];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Node, _impl_.maximumsources_), 3>(),
     {64, 3, 0, PROTOBUF_FIELD_OFFSET(Node, _impl_.maximumsources_)}},
    // repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
    {::_pbi::TcParser::FastMtR1,
     {74, 63, 5, PROTOBUF_FIELD_OFFSET(Node, _impl_.flowconstraints_)}},
    // repeated .NS3.Node.ProductTransform productTransforms = 10;
    {::_pbi::TcParser::FastMtR1,
     {82, 63, 6, PROTOBUF_FIELD_OFFSET(Node, _impl_.producttransforms_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string id = 1;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required .NS3.Geocode geocode = 2;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.geocode_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.Node.ProductFlow production = 3;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.production_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.Node.ProductFlow consumption = 4;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.consumption_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .NS3.Node.Flow flow = 5;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.flow_), _Internal::kHasBitsOffset + 2, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.Node.ProductFlow productFlows = 6;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.productflows_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated string allowableSources = 7;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.allowablesources_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // optional int32 maximumSources = 8 [default = -1];
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.maximumsources_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.flowconstraints_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.Node.ProductTransform productTransforms = 10;
    {PROTOBUF_FIELD_OFFSET(Node, _impl_.producttransforms_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::Geocode>()},
    {::_pbi::TcParser::GetTable<::NS3::Node_ProductFlow>()},
    {::_pbi::TcParser::GetTable<::NS3::Node_ProductFlow>()},
    {::_pbi::TcParser::GetTable<::NS3::Node_Flow>()},
    {::_pbi::TcParser::GetTable<::NS3::Node_ProductFlow>()},
    {::_pbi::TcParser::GetTable<::NS3::FlowDimensionalConstraint>()},
    {::_pbi::TcParser::GetTable<::NS3::Node_ProductTransform>()},
  }}, {{
    "\10\2\0\0\0\0\0\20\0\0\0\0\0\0\0\0"
    "NS3.Node"
    "id"
    "allowableSources"
  }},
};

::uint8_t* Node::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Node)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.Node.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required .NS3.Geocode geocode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::geocode(this),
        _Internal::geocode(this).GetCachedSize(), target, stream);
  }

  // repeated .NS3.Node.ProductFlow production = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_production_size()); i < n; i++) {
    const auto& repfield = this->_internal_production().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.Node.ProductFlow consumption = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_consumption_size()); i < n; i++) {
    const auto& repfield = this->_internal_consumption().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .NS3.Node.Flow flow = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::flow(this),
        _Internal::flow(this).GetCachedSize(), target, stream);
  }

  // repeated .NS3.Node.ProductFlow productFlows = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_productflows_size()); i < n; i++) {
    const auto& repfield = this->_internal_productflows().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string allowableSources = 7;
  for (int i = 0, n = this->_internal_allowablesources_size(); i < n; ++i) {
    const auto& s = this->_internal_allowablesources().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.Node.allowableSources");
    target = stream->WriteString(7, s, target);
  }

  // optional int32 maximumSources = 8 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<8>(
            stream, this->_internal_maximumsources(), target);
  }

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_flowconstraints_size()); i < n; i++) {
    const auto& repfield = this->_internal_flowconstraints().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.Node.ProductTransform productTransforms = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_producttransforms_size()); i < n; i++) {
    const auto& repfield = this->_internal_producttransforms().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Node)
  return target;
}

::size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Node)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.Node.ProductFlow production = 3;
  total_size += 1UL * this->_internal_production_size();
  for (const auto& msg : this->_internal_production()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.Node.ProductFlow consumption = 4;
  total_size += 1UL * this->_internal_consumption_size();
  for (const auto& msg : this->_internal_consumption()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.Node.ProductFlow productFlows = 6;
  total_size += 1UL * this->_internal_productflows_size();
  for (const auto& msg : this->_internal_productflows()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated string allowableSources = 7;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_allowablesources().size());
  for (int i = 0, n = _internal_allowablesources().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_allowablesources().Get(i));
  }
  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
  total_size += 1UL * this->_internal_flowconstraints_size();
  for (const auto& msg : this->_internal_flowconstraints()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.Node.ProductTransform productTransforms = 10;
  total_size += 1UL * this->_internal_producttransforms_size();
  for (const auto& msg : this->_internal_producttransforms()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // required .NS3.Geocode geocode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.geocode_);
    }

  }
  if (cached_has_bits & 0x0000000cu) {
    // optional .NS3.Node.Flow flow = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.flow_);
    }

    // optional int32 maximumSources = 8 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_maximumsources());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Node::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Node::MergeImpl
};
const ::google::protobuf::Message::ClassData*Node::GetClassData() const { return &_class_data_; }


void Node::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Node*>(&to_msg);
  auto& from = static_cast<const Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Node)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_production()->MergeFrom(from._internal_production());
  _this->_internal_mutable_consumption()->MergeFrom(from._internal_consumption());
  _this->_internal_mutable_productflows()->MergeFrom(from._internal_productflows());
  _this->_internal_mutable_allowablesources()->MergeFrom(from._internal_allowablesources());
  _this->_internal_mutable_flowconstraints()->MergeFrom(from._internal_flowconstraints());
  _this->_internal_mutable_producttransforms()->MergeFrom(from._internal_producttransforms());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_geocode()->::NS3::Geocode::MergeFrom(
          from._internal_geocode());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_flow()->::NS3::Node_Flow::MergeFrom(
          from._internal_flow());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.maximumsources_ = from._impl_.maximumsources_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Node::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_production()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_consumption()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_productflows()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_flowconstraints()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_producttransforms()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.geocode_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.flow_->IsInitialized()) return false;
  }
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.production_.InternalSwap(&other->_impl_.production_);
  _impl_.consumption_.InternalSwap(&other->_impl_.consumption_);
  _impl_.productflows_.InternalSwap(&other->_impl_.productflows_);
  _impl_.allowablesources_.InternalSwap(&other->_impl_.allowablesources_);
  _impl_.flowconstraints_.InternalSwap(&other->_impl_.flowconstraints_);
  _impl_.producttransforms_.InternalSwap(&other->_impl_.producttransforms_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Node, _impl_.maximumsources_)
      + sizeof(Node::_impl_.maximumsources_)
      - PROTOBUF_FIELD_OFFSET(Node, _impl_.geocode_)>(
          reinterpret_cast<char*>(&_impl_.geocode_),
          reinterpret_cast<char*>(&other->_impl_.geocode_));
}

::google::protobuf::Metadata Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[12]);
}
// ===================================================================

class ProductGroup_ProductSpecification::_Internal {
 public:
  using HasBits = decltype(std::declval<ProductGroup_ProductSpecification>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_._has_bits_);
  static void set_has_basedimension(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ProductGroup_ProductSpecification::ProductGroup_ProductSpecification(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.ProductGroup.ProductSpecification)
}
ProductGroup_ProductSpecification::ProductGroup_ProductSpecification(const ProductGroup_ProductSpecification& from) : ::google::protobuf::Message() {
  ProductGroup_ProductSpecification* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.targetdimension_){from._impl_.targetdimension_},
      decltype(_impl_.targetperbase_){from._impl_.targetperbase_},
      decltype(_impl_.basedimension_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.basedimension_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.basedimension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.basedimension_.Set(from._internal_basedimension(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.ProductGroup.ProductSpecification)
}
inline void ProductGroup_ProductSpecification::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.targetdimension_){arena},
      decltype(_impl_.targetperbase_){arena},
      decltype(_impl_.basedimension_){},
  };
  _impl_.basedimension_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.basedimension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
ProductGroup_ProductSpecification::~ProductGroup_ProductSpecification() {
  // @@protoc_insertion_point(destructor:NS3.ProductGroup.ProductSpecification)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ProductGroup_ProductSpecification::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_targetdimension()->~RepeatedPtrField();
  _impl_.targetperbase_.~RepeatedField();
  _impl_.basedimension_.Destroy();
}
void ProductGroup_ProductSpecification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void ProductGroup_ProductSpecification::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.ProductGroup.ProductSpecification)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_targetdimension()->Clear();
  _internal_mutable_targetperbase()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.basedimension_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ProductGroup_ProductSpecification::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 74, 2> ProductGroup_ProductSpecification::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ProductGroup_ProductSpecification_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string baseDimension = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_.basedimension_)}},
    // repeated string targetDimension = 2;
    {::_pbi::TcParser::FastSR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_.targetdimension_)}},
    // repeated float targetPerBase = 3;
    {::_pbi::TcParser::FastF32R1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_.targetperbase_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string baseDimension = 1;
    {PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_.basedimension_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated string targetDimension = 2;
    {PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_.targetdimension_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated float targetPerBase = 3;
    {PROTOBUF_FIELD_OFFSET(ProductGroup_ProductSpecification, _impl_.targetperbase_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\45\15\17\0\0\0\0\0"
    "NS3.ProductGroup.ProductSpecification"
    "baseDimension"
    "targetDimension"
  }},
};

::uint8_t* ProductGroup_ProductSpecification::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.ProductGroup.ProductSpecification)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string baseDimension = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_basedimension();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.ProductGroup.ProductSpecification.baseDimension");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated string targetDimension = 2;
  for (int i = 0, n = this->_internal_targetdimension_size(); i < n; ++i) {
    const auto& s = this->_internal_targetdimension().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.ProductGroup.ProductSpecification.targetDimension");
    target = stream->WriteString(2, s, target);
  }

  // repeated float targetPerBase = 3;
  for (int i = 0, n = this->_internal_targetperbase_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_targetperbase().Get(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.ProductGroup.ProductSpecification)
  return target;
}

::size_t ProductGroup_ProductSpecification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.ProductGroup.ProductSpecification)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string targetDimension = 2;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_targetdimension().size());
  for (int i = 0, n = _internal_targetdimension().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_targetdimension().Get(i));
  }
  // repeated float targetPerBase = 3;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_targetperbase_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_targetperbase_size());
    ;
    total_size += tag_size + data_size;
  }
  // required string baseDimension = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_basedimension());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ProductGroup_ProductSpecification::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ProductGroup_ProductSpecification::MergeImpl
};
const ::google::protobuf::Message::ClassData*ProductGroup_ProductSpecification::GetClassData() const { return &_class_data_; }


void ProductGroup_ProductSpecification::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ProductGroup_ProductSpecification*>(&to_msg);
  auto& from = static_cast<const ProductGroup_ProductSpecification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.ProductGroup.ProductSpecification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_targetdimension()->MergeFrom(from._internal_targetdimension());
  _this->_internal_mutable_targetperbase()->MergeFrom(from._internal_targetperbase());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_basedimension(from._internal_basedimension());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ProductGroup_ProductSpecification::CopyFrom(const ProductGroup_ProductSpecification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.ProductGroup.ProductSpecification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ProductGroup_ProductSpecification::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ProductGroup_ProductSpecification::InternalSwap(ProductGroup_ProductSpecification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.targetdimension_.InternalSwap(&other->_impl_.targetdimension_);
  _impl_.targetperbase_.InternalSwap(&other->_impl_.targetperbase_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.basedimension_, lhs_arena,
                                       &other->_impl_.basedimension_, rhs_arena);
}

::google::protobuf::Metadata ProductGroup_ProductSpecification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[13]);
}
// ===================================================================

class ProductGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<ProductGroup>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_._has_bits_);
  static void set_has_productid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_productgroupid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ProductGroup::ProductGroup(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.ProductGroup)
}
ProductGroup::ProductGroup(const ProductGroup& from) : ::google::protobuf::Message() {
  ProductGroup* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productspecification_){from._impl_.productspecification_},
      decltype(_impl_.productid_){},
      decltype(_impl_.productgroupid_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.productid_.Set(from._internal_productid(), _this->GetArenaForAllocation());
  }
  _impl_.productgroupid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productgroupid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.productgroupid_.Set(from._internal_productgroupid(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.ProductGroup)
}
inline void ProductGroup::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productspecification_){arena},
      decltype(_impl_.productid_){},
      decltype(_impl_.productgroupid_){},
  };
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productgroupid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productgroupid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
ProductGroup::~ProductGroup() {
  // @@protoc_insertion_point(destructor:NS3.ProductGroup)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ProductGroup::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productspecification_.~RepeatedPtrField();
  _impl_.productid_.Destroy();
  _impl_.productgroupid_.Destroy();
}
void ProductGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void ProductGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.ProductGroup)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_productspecification()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.productid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.productgroupid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ProductGroup::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 48, 2> ProductGroup::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_ProductGroup_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string productId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_.productid_)}},
    // required string productGroupId = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_.productgroupid_)}},
    // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_.productspecification_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string productId = 1;
    {PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_.productid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string productGroupId = 2;
    {PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_.productgroupid_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
    {PROTOBUF_FIELD_OFFSET(ProductGroup, _impl_.productspecification_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::ProductGroup_ProductSpecification>()},
  }}, {{
    "\20\11\16\0\0\0\0\0"
    "NS3.ProductGroup"
    "productId"
    "productGroupId"
  }},
};

::uint8_t* ProductGroup::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.ProductGroup)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string productId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_productid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.ProductGroup.productId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string productGroupId = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_productgroupid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.ProductGroup.productGroupId");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_productspecification_size()); i < n; i++) {
    const auto& repfield = this->_internal_productspecification().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.ProductGroup)
  return target;
}

::size_t ProductGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.ProductGroup)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
  total_size += 1UL * this->_internal_productspecification_size();
  for (const auto& msg : this->_internal_productspecification()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string productId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_productid());
    }

    // required string productGroupId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_productgroupid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ProductGroup::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    ProductGroup::MergeImpl
};
const ::google::protobuf::Message::ClassData*ProductGroup::GetClassData() const { return &_class_data_; }


void ProductGroup::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ProductGroup*>(&to_msg);
  auto& from = static_cast<const ProductGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.ProductGroup)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_productspecification()->MergeFrom(from._internal_productspecification());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_productid(from._internal_productid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_productgroupid(from._internal_productgroupid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ProductGroup::CopyFrom(const ProductGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.ProductGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ProductGroup::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_productspecification()))
    return false;
  return true;
}

void ProductGroup::InternalSwap(ProductGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.productspecification_.InternalSwap(&other->_impl_.productspecification_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productid_, lhs_arena,
                                       &other->_impl_.productid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productgroupid_, lhs_arena,
                                       &other->_impl_.productgroupid_, rhs_arena);
}

::google::protobuf::Metadata ProductGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[14]);
}
// ===================================================================

class LaneRate::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneRate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LaneRate, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_destination(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LaneRate::LaneRate(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.LaneRate)
}
LaneRate::LaneRate(const LaneRate& from) : ::google::protobuf::Message() {
  LaneRate* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productids_){from._impl_.productids_},
      decltype(_impl_.productgroupids_){from._impl_.productgroupids_},
      decltype(_impl_.unitdimensioncosts_){from._impl_.unitdimensioncosts_},
      decltype(_impl_.flowconstraints_){from._impl_.flowconstraints_},
      decltype(_impl_.id_){},
      decltype(_impl_.source_){},
      decltype(_impl_.destination_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.source_.Set(from._internal_source(), _this->GetArenaForAllocation());
  }
  _impl_.destination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.destination_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.destination_.Set(from._internal_destination(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.LaneRate)
}
inline void LaneRate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productids_){arena},
      decltype(_impl_.productgroupids_){arena},
      decltype(_impl_.unitdimensioncosts_){arena},
      decltype(_impl_.flowconstraints_){arena},
      decltype(_impl_.id_){},
      decltype(_impl_.source_){},
      decltype(_impl_.destination_){},
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.destination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.destination_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
LaneRate::~LaneRate() {
  // @@protoc_insertion_point(destructor:NS3.LaneRate)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LaneRate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_productids()->~RepeatedPtrField();
  _internal_mutable_productgroupids()->~RepeatedPtrField();
  _impl_.unitdimensioncosts_.~RepeatedPtrField();
  _impl_.flowconstraints_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  _impl_.source_.Destroy();
  _impl_.destination_.Destroy();
}
void LaneRate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void LaneRate::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.LaneRate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_productids()->Clear();
  _internal_mutable_productgroupids()->Clear();
  _internal_mutable_unitdimensioncosts()->Clear();
  _internal_mutable_flowconstraints()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.destination_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LaneRate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 2, 65, 2> LaneRate::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LaneRate, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967042,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_LaneRate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
    {::_pbi::TcParser::FastMtR1,
     {66, 63, 1, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.flowconstraints_)}},
    // required string id = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // required string source = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.source_)}},
    // required string destination = 4;
    {::_pbi::TcParser::FastSS1,
     {34, 2, 0, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.destination_)}},
    // repeated string productIds = 5;
    {::_pbi::TcParser::FastSR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.productids_)}},
    // repeated string productGroupIds = 6;
    {::_pbi::TcParser::FastSR1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.productgroupids_)}},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.unitdimensioncosts_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string id = 1;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string source = 3;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.source_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string destination = 4;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.destination_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated string productIds = 5;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.productids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated string productGroupIds = 6;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.productgroupids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.unitdimensioncosts_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
    {PROTOBUF_FIELD_OFFSET(LaneRate, _impl_.flowconstraints_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::UnitDimensionCost>()},
    {::_pbi::TcParser::GetTable<::NS3::FlowDimensionalConstraint>()},
  }}, {{
    "\14\2\6\13\12\17\0\0"
    "NS3.LaneRate"
    "id"
    "source"
    "destination"
    "productIds"
    "productGroupIds"
  }},
};

::uint8_t* LaneRate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.LaneRate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.LaneRate.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string source = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_source();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.LaneRate.source");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // required string destination = 4;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_destination();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.LaneRate.destination");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // repeated string productIds = 5;
  for (int i = 0, n = this->_internal_productids_size(); i < n; ++i) {
    const auto& s = this->_internal_productids().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.LaneRate.productIds");
    target = stream->WriteString(5, s, target);
  }

  // repeated string productGroupIds = 6;
  for (int i = 0, n = this->_internal_productgroupids_size(); i < n; ++i) {
    const auto& s = this->_internal_productgroupids().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.LaneRate.productGroupIds");
    target = stream->WriteString(6, s, target);
  }

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unitdimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_unitdimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_flowconstraints_size()); i < n; i++) {
    const auto& repfield = this->_internal_flowconstraints().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.LaneRate)
  return target;
}

::size_t LaneRate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.LaneRate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string productIds = 5;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_productids().size());
  for (int i = 0, n = _internal_productids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_productids().Get(i));
  }
  // repeated string productGroupIds = 6;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_productgroupids().size());
  for (int i = 0, n = _internal_productgroupids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_productgroupids().Get(i));
  }
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
  total_size += 1UL * this->_internal_unitdimensioncosts_size();
  for (const auto& msg : this->_internal_unitdimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
  total_size += 1UL * this->_internal_flowconstraints_size();
  for (const auto& msg : this->_internal_flowconstraints()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // required string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // required string source = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_source());
    }

    // required string destination = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_destination());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LaneRate::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    LaneRate::MergeImpl
};
const ::google::protobuf::Message::ClassData*LaneRate::GetClassData() const { return &_class_data_; }


void LaneRate::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LaneRate*>(&to_msg);
  auto& from = static_cast<const LaneRate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.LaneRate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_productids()->MergeFrom(from._internal_productids());
  _this->_internal_mutable_productgroupids()->MergeFrom(from._internal_productgroupids());
  _this->_internal_mutable_unitdimensioncosts()->MergeFrom(from._internal_unitdimensioncosts());
  _this->_internal_mutable_flowconstraints()->MergeFrom(from._internal_flowconstraints());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_source(from._internal_source());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_destination(from._internal_destination());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LaneRate::CopyFrom(const LaneRate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.LaneRate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LaneRate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_unitdimensioncosts()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_flowconstraints()))
    return false;
  return true;
}

void LaneRate::InternalSwap(LaneRate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.productids_.InternalSwap(&other->_impl_.productids_);
  _impl_.productgroupids_.InternalSwap(&other->_impl_.productgroupids_);
  _impl_.unitdimensioncosts_.InternalSwap(&other->_impl_.unitdimensioncosts_);
  _impl_.flowconstraints_.InternalSwap(&other->_impl_.flowconstraints_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.source_, lhs_arena,
                                       &other->_impl_.source_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.destination_, lhs_arena,
                                       &other->_impl_.destination_, rhs_arena);
}

::google::protobuf::Metadata LaneRate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[15]);
}
// ===================================================================

class CostModel::_Internal {
 public:
  using HasBits = decltype(std::declval<CostModel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CostModel, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CostModel::CostModel(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.CostModel)
}
CostModel::CostModel(const CostModel& from) : ::google::protobuf::Message() {
  CostModel* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productgroupids_){from._impl_.productgroupids_},
      decltype(_impl_.unitdimensioncosts_){from._impl_.unitdimensioncosts_},
      decltype(_impl_.flowconstraints_){from._impl_.flowconstraints_},
      decltype(_impl_.id_){},
      decltype(_impl_.source_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.source_.Set(from._internal_source(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.CostModel)
}
inline void CostModel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productgroupids_){arena},
      decltype(_impl_.unitdimensioncosts_){arena},
      decltype(_impl_.flowconstraints_){arena},
      decltype(_impl_.id_){},
      decltype(_impl_.source_){},
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
CostModel::~CostModel() {
  // @@protoc_insertion_point(destructor:NS3.CostModel)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CostModel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_productgroupids()->~RepeatedPtrField();
  _impl_.unitdimensioncosts_.~RepeatedPtrField();
  _impl_.flowconstraints_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  _impl_.source_.Destroy();
}
void CostModel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CostModel::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.CostModel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_productgroupids()->Clear();
  _internal_mutable_unitdimensioncosts()->Clear();
  _internal_mutable_flowconstraints()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CostModel::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 45, 2> CostModel::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CostModel, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CostModel_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string id = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CostModel, _impl_.id_)}},
    // required string source = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(CostModel, _impl_.source_)}},
    // repeated string productGroupIds = 3;
    {::_pbi::TcParser::FastSR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(CostModel, _impl_.productgroupids_)}},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(CostModel, _impl_.unitdimensioncosts_)}},
    // repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 1, PROTOBUF_FIELD_OFFSET(CostModel, _impl_.flowconstraints_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string id = 1;
    {PROTOBUF_FIELD_OFFSET(CostModel, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string source = 2;
    {PROTOBUF_FIELD_OFFSET(CostModel, _impl_.source_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated string productGroupIds = 3;
    {PROTOBUF_FIELD_OFFSET(CostModel, _impl_.productgroupids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
    {PROTOBUF_FIELD_OFFSET(CostModel, _impl_.unitdimensioncosts_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
    {PROTOBUF_FIELD_OFFSET(CostModel, _impl_.flowconstraints_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::UnitDimensionCost>()},
    {::_pbi::TcParser::GetTable<::NS3::FlowDimensionalConstraint>()},
  }}, {{
    "\15\2\6\17\0\0\0\0"
    "NS3.CostModel"
    "id"
    "source"
    "productGroupIds"
  }},
};

::uint8_t* CostModel::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.CostModel)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.CostModel.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string source = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_source();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.CostModel.source");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string productGroupIds = 3;
  for (int i = 0, n = this->_internal_productgroupids_size(); i < n; ++i) {
    const auto& s = this->_internal_productgroupids().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.CostModel.productGroupIds");
    target = stream->WriteString(3, s, target);
  }

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unitdimensioncosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_unitdimensioncosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_flowconstraints_size()); i < n; i++) {
    const auto& repfield = this->_internal_flowconstraints().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.CostModel)
  return target;
}

::size_t CostModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.CostModel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string productGroupIds = 3;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_productgroupids().size());
  for (int i = 0, n = _internal_productgroupids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_productgroupids().Get(i));
  }
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  total_size += 1UL * this->_internal_unitdimensioncosts_size();
  for (const auto& msg : this->_internal_unitdimensioncosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
  total_size += 1UL * this->_internal_flowconstraints_size();
  for (const auto& msg : this->_internal_flowconstraints()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // required string source = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_source());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CostModel::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CostModel::MergeImpl
};
const ::google::protobuf::Message::ClassData*CostModel::GetClassData() const { return &_class_data_; }


void CostModel::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CostModel*>(&to_msg);
  auto& from = static_cast<const CostModel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.CostModel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_productgroupids()->MergeFrom(from._internal_productgroupids());
  _this->_internal_mutable_unitdimensioncosts()->MergeFrom(from._internal_unitdimensioncosts());
  _this->_internal_mutable_flowconstraints()->MergeFrom(from._internal_flowconstraints());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_source(from._internal_source());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CostModel::CopyFrom(const CostModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.CostModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CostModel::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_unitdimensioncosts()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_flowconstraints()))
    return false;
  return true;
}

void CostModel::InternalSwap(CostModel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.productgroupids_.InternalSwap(&other->_impl_.productgroupids_);
  _impl_.unitdimensioncosts_.InternalSwap(&other->_impl_.unitdimensioncosts_);
  _impl_.flowconstraints_.InternalSwap(&other->_impl_.flowconstraints_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.source_, lhs_arena,
                                       &other->_impl_.source_, rhs_arena);
}

::google::protobuf::Metadata CostModel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[16]);
}
// ===================================================================

class Model::_Internal {
 public:
  using HasBits = decltype(std::declval<Model>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Model, _impl_._has_bits_);
  static const ::NS3::DimensionConfiguration& dimensions(const Model* msg);
  static void set_has_dimensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::NS3::DimensionConfiguration& Model::_Internal::dimensions(const Model* msg) {
  return *msg->_impl_.dimensions_;
}
Model::Model(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.Model)
}
Model::Model(const Model& from) : ::google::protobuf::Message() {
  Model* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.nodes_){from._impl_.nodes_},
      decltype(_impl_.lanerates_){from._impl_.lanerates_},
      decltype(_impl_.costmodels_){from._impl_.costmodels_},
      decltype(_impl_.productgroups_){from._impl_.productgroups_},
      decltype(_impl_.dimensions_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.dimensions_ = new ::NS3::DimensionConfiguration(*from._impl_.dimensions_);
  }

  // @@protoc_insertion_point(copy_constructor:NS3.Model)
}
inline void Model::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.nodes_){arena},
      decltype(_impl_.lanerates_){arena},
      decltype(_impl_.costmodels_){arena},
      decltype(_impl_.productgroups_){arena},
      decltype(_impl_.dimensions_){nullptr},
  };
}
Model::~Model() {
  // @@protoc_insertion_point(destructor:NS3.Model)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Model::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
  _impl_.lanerates_.~RepeatedPtrField();
  _impl_.costmodels_.~RepeatedPtrField();
  _impl_.productgroups_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.dimensions_;
}
void Model::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Model::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.Model)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_nodes()->Clear();
  _internal_mutable_lanerates()->Clear();
  _internal_mutable_costmodels()->Clear();
  _internal_mutable_productgroups()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.dimensions_ != nullptr);
    _impl_.dimensions_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Model::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> Model::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Model, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Model_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required .NS3.DimensionConfiguration dimensions = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Model, _impl_.dimensions_)}},
    // repeated .NS3.Node nodes = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(Model, _impl_.nodes_)}},
    // repeated .NS3.LaneRate laneRates = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(Model, _impl_.lanerates_)}},
    // repeated .NS3.CostModel costModels = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(Model, _impl_.costmodels_)}},
    // repeated .NS3.ProductGroup productGroups = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 4, PROTOBUF_FIELD_OFFSET(Model, _impl_.productgroups_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required .NS3.DimensionConfiguration dimensions = 1;
    {PROTOBUF_FIELD_OFFSET(Model, _impl_.dimensions_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.Node nodes = 2;
    {PROTOBUF_FIELD_OFFSET(Model, _impl_.nodes_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.LaneRate laneRates = 3;
    {PROTOBUF_FIELD_OFFSET(Model, _impl_.lanerates_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.CostModel costModels = 4;
    {PROTOBUF_FIELD_OFFSET(Model, _impl_.costmodels_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.ProductGroup productGroups = 5;
    {PROTOBUF_FIELD_OFFSET(Model, _impl_.productgroups_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::DimensionConfiguration>()},
    {::_pbi::TcParser::GetTable<::NS3::Node>()},
    {::_pbi::TcParser::GetTable<::NS3::LaneRate>()},
    {::_pbi::TcParser::GetTable<::NS3::CostModel>()},
    {::_pbi::TcParser::GetTable<::NS3::ProductGroup>()},
  }}, {{
  }},
};

::uint8_t* Model::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.Model)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .NS3.DimensionConfiguration dimensions = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::dimensions(this),
        _Internal::dimensions(this).GetCachedSize(), target, stream);
  }

  // repeated .NS3.Node nodes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.LaneRate laneRates = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lanerates_size()); i < n; i++) {
    const auto& repfield = this->_internal_lanerates().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.CostModel costModels = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_costmodels_size()); i < n; i++) {
    const auto& repfield = this->_internal_costmodels().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.ProductGroup productGroups = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_productgroups_size()); i < n; i++) {
    const auto& repfield = this->_internal_productgroups().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.Model)
  return target;
}

::size_t Model::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.Model)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.Node nodes = 2;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_internal_nodes()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.LaneRate laneRates = 3;
  total_size += 1UL * this->_internal_lanerates_size();
  for (const auto& msg : this->_internal_lanerates()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.CostModel costModels = 4;
  total_size += 1UL * this->_internal_costmodels_size();
  for (const auto& msg : this->_internal_costmodels()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.ProductGroup productGroups = 5;
  total_size += 1UL * this->_internal_productgroups_size();
  for (const auto& msg : this->_internal_productgroups()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required .NS3.DimensionConfiguration dimensions = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.dimensions_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Model::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Model::MergeImpl
};
const ::google::protobuf::Message::ClassData*Model::GetClassData() const { return &_class_data_; }


void Model::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Model*>(&to_msg);
  auto& from = static_cast<const Model&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.Model)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_nodes()->MergeFrom(from._internal_nodes());
  _this->_internal_mutable_lanerates()->MergeFrom(from._internal_lanerates());
  _this->_internal_mutable_costmodels()->MergeFrom(from._internal_costmodels());
  _this->_internal_mutable_productgroups()->MergeFrom(from._internal_productgroups());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_dimensions()->::NS3::DimensionConfiguration::MergeFrom(
        from._internal_dimensions());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Model::CopyFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Model::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_nodes()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_lanerates()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_costmodels()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_productgroups()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.dimensions_->IsInitialized()) return false;
  }
  return true;
}

void Model::InternalSwap(Model* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  _impl_.lanerates_.InternalSwap(&other->_impl_.lanerates_);
  _impl_.costmodels_.InternalSwap(&other->_impl_.costmodels_);
  _impl_.productgroups_.InternalSwap(&other->_impl_.productgroups_);
  swap(_impl_.dimensions_, other->_impl_.dimensions_);
}

::google::protobuf::Metadata Model::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[17]);
}
// ===================================================================

class SolveRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SolveRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_._has_bits_);
  static const ::NS3::Model& model(const SolveRequest* msg);
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_modelid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_solvetype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_geometryoutput(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::NS3::Model& SolveRequest::_Internal::model(const SolveRequest* msg) {
  return *msg->_impl_.model_;
}
SolveRequest::SolveRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolveRequest)
}
SolveRequest::SolveRequest(const SolveRequest& from) : ::google::protobuf::Message() {
  SolveRequest* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.modelid_){},
      decltype(_impl_.model_){nullptr},
      decltype(_impl_.solvetype_){},
      decltype(_impl_.geometryoutput_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.modelid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.modelid_.Set(from._internal_modelid(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.model_ = new ::NS3::Model(*from._impl_.model_);
  }
  ::memcpy(&_impl_.solvetype_, &from._impl_.solvetype_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.geometryoutput_) -
    reinterpret_cast<char*>(&_impl_.solvetype_)) + sizeof(_impl_.geometryoutput_));

  // @@protoc_insertion_point(copy_constructor:NS3.SolveRequest)
}
inline void SolveRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.modelid_){},
      decltype(_impl_.model_){nullptr},
      decltype(_impl_.solvetype_){0},
      decltype(_impl_.geometryoutput_){0},
  };
  _impl_.modelid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolveRequest::~SolveRequest() {
  // @@protoc_insertion_point(destructor:NS3.SolveRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolveRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.modelid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.model_;
}
void SolveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolveRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.modelid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.model_ != nullptr);
      _impl_.model_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.solvetype_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.geometryoutput_) -
        reinterpret_cast<char*>(&_impl_.solvetype_)) + sizeof(_impl_.geometryoutput_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolveRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 3, 32, 2> SolveRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967268,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SolveRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .NS3.Model model = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 1, 0, PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.model_)}},
    // optional string modelID = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.modelid_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
    {::_pbi::TcParser::FastEr0S1,
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.solvetype_)}},
    // optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
    {::_pbi::TcParser::FastEr0S1,
     {40, 3, 1, PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.geometryoutput_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .NS3.Model model = 1;
    {PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.model_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional string modelID = 2;
    {PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.modelid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
    {PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.solvetype_), _Internal::kHasBitsOffset + 2, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
    {PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.geometryoutput_), _Internal::kHasBitsOffset + 3, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::Model>()},
    {0, 1},
    {0, 2},
  }}, {{
    "\20\0\7\0\0\0\0\0"
    "NS3.SolveRequest"
    "modelID"
  }},
};

::uint8_t* SolveRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolveRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .NS3.Model model = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::model(this),
        _Internal::model(this).GetCachedSize(), target, stream);
  }

  // optional string modelID = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_modelid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolveRequest.modelID");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_solvetype(), target);
  }

  // optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_geometryoutput(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolveRequest)
  return target;
}

::size_t SolveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolveRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string modelID = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_modelid());
    }

    // optional .NS3.Model model = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.model_);
    }

    // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_solvetype());
    }

    // optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_geometryoutput());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolveRequest::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolveRequest::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolveRequest::GetClassData() const { return &_class_data_; }


void SolveRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolveRequest*>(&to_msg);
  auto& from = static_cast<const SolveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolveRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_modelid(from._internal_modelid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_model()->::NS3::Model::MergeFrom(
          from._internal_model());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.solvetype_ = from._impl_.solvetype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.geometryoutput_ = from._impl_.geometryoutput_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolveRequest::CopyFrom(const SolveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolveRequest::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.model_->IsInitialized()) return false;
  }
  return true;
}

void SolveRequest::InternalSwap(SolveRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.modelid_, lhs_arena,
                                       &other->_impl_.modelid_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.geometryoutput_)
      + sizeof(SolveRequest::_impl_.geometryoutput_)
      - PROTOBUF_FIELD_OFFSET(SolveRequest, _impl_.model_)>(
          reinterpret_cast<char*>(&_impl_.model_),
          reinterpret_cast<char*>(&other->_impl_.model_));
}

::google::protobuf::Metadata SolveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[18]);
}
// ===================================================================

class SolutionResponse_Assignment::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse_Assignment>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_._has_bits_);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_destination(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_productid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_lanerateid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_costmodelid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000001e7) ^ 0x000001e7) != 0;
  }
};

SolutionResponse_Assignment::SolutionResponse_Assignment(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.Assignment)
}
SolutionResponse_Assignment::SolutionResponse_Assignment(const SolutionResponse_Assignment& from) : ::google::protobuf::Message() {
  SolutionResponse_Assignment* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.source_){},
      decltype(_impl_.destination_){},
      decltype(_impl_.productid_){},
      decltype(_impl_.lanerateid_){},
      decltype(_impl_.costmodelid_){},
      decltype(_impl_.amount_){},
      decltype(_impl_.cost_){},
      decltype(_impl_.distance_){},
      decltype(_impl_.duration_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.source_.Set(from._internal_source(), _this->GetArenaForAllocation());
  }
  _impl_.destination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.destination_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.destination_.Set(from._internal_destination(), _this->GetArenaForAllocation());
  }
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.productid_.Set(from._internal_productid(), _this->GetArenaForAllocation());
  }
  _impl_.lanerateid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.lanerateid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.lanerateid_.Set(from._internal_lanerateid(), _this->GetArenaForAllocation());
  }
  _impl_.costmodelid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.costmodelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.costmodelid_.Set(from._internal_costmodelid(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.duration_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.duration_));

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.Assignment)
}
inline void SolutionResponse_Assignment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.source_){},
      decltype(_impl_.destination_){},
      decltype(_impl_.productid_){},
      decltype(_impl_.lanerateid_){},
      decltype(_impl_.costmodelid_){},
      decltype(_impl_.amount_){0},
      decltype(_impl_.cost_){0},
      decltype(_impl_.distance_){0},
      decltype(_impl_.duration_){0},
  };
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.destination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.destination_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lanerateid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.lanerateid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.costmodelid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.costmodelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolutionResponse_Assignment::~SolutionResponse_Assignment() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.Assignment)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_Assignment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_.Destroy();
  _impl_.destination_.Destroy();
  _impl_.productid_.Destroy();
  _impl_.lanerateid_.Destroy();
  _impl_.costmodelid_.Destroy();
}
void SolutionResponse_Assignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_Assignment::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.Assignment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.destination_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.productid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.lanerateid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.costmodelid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.amount_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.distance_) -
        reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.distance_));
  }
  _impl_.duration_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_Assignment::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 95, 2> SolutionResponse_Assignment::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SolutionResponse_Assignment_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string source = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.source_)}},
    // required string destination = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.destination_)}},
    // required string productId = 3;
    {::_pbi::TcParser::FastSS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.productid_)}},
    // required float amount = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 5, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.amount_)}},
    // required float cost = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 6, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.cost_)}},
    // optional string laneRateId = 6;
    {::_pbi::TcParser::FastSS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.lanerateid_)}},
    // optional string costModelId = 7;
    {::_pbi::TcParser::FastSS1,
     {58, 4, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.costmodelid_)}},
    // required float distance = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.distance_)}},
    // required float duration = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.duration_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string source = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.source_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string destination = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.destination_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string productId = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.productid_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required float amount = 4;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.amount_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float cost = 5;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.cost_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional string laneRateId = 6;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.lanerateid_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string costModelId = 7;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.costmodelid_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required float distance = 8;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.distance_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float duration = 9;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.duration_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\37\6\13\11\0\0\12\13\0\0\0\0\0\0\0\0"
    "NS3.SolutionResponse.Assignment"
    "source"
    "destination"
    "productId"
    "laneRateId"
    "costModelId"
  }},
};

::uint8_t* SolutionResponse_Assignment::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.Assignment)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string source = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_source();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Assignment.source");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string destination = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_destination();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Assignment.destination");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // required string productId = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_productid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Assignment.productId");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // required float amount = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_amount(), target);
  }

  // required float cost = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_cost(), target);
  }

  // optional string laneRateId = 6;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_lanerateid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Assignment.laneRateId");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional string costModelId = 7;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_costmodelid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Assignment.costModelId");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // required float distance = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_distance(), target);
  }

  // required float duration = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.Assignment)
  return target;
}

::size_t SolutionResponse_Assignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.Assignment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // required string source = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_source());
    }

    // required string destination = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_destination());
    }

    // required string productId = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_productid());
    }

  }
  if (cached_has_bits & 0x00000018u) {
    // optional string laneRateId = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_lanerateid());
    }

    // optional string costModelId = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_costmodelid());
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // required float amount = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // required float cost = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }

    // required float distance = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 5;
    }

  }
  // required float duration = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_Assignment::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_Assignment::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_Assignment::GetClassData() const { return &_class_data_; }


void SolutionResponse_Assignment::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_Assignment*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_Assignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.Assignment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_source(from._internal_source());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_destination(from._internal_destination());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_productid(from._internal_productid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_lanerateid(from._internal_lanerateid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_costmodelid(from._internal_costmodelid());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cost_ = from._impl_.cost_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_duration(from._internal_duration());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_Assignment::CopyFrom(const SolutionResponse_Assignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.Assignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_Assignment::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void SolutionResponse_Assignment::InternalSwap(SolutionResponse_Assignment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.source_, lhs_arena,
                                       &other->_impl_.source_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.destination_, lhs_arena,
                                       &other->_impl_.destination_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productid_, lhs_arena,
                                       &other->_impl_.productid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lanerateid_, lhs_arena,
                                       &other->_impl_.lanerateid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.costmodelid_, lhs_arena,
                                       &other->_impl_.costmodelid_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.duration_)
      + sizeof(SolutionResponse_Assignment::_impl_.duration_)
      - PROTOBUF_FIELD_OFFSET(SolutionResponse_Assignment, _impl_.amount_)>(
          reinterpret_cast<char*>(&_impl_.amount_),
          reinterpret_cast<char*>(&other->_impl_.amount_));
}

::google::protobuf::Metadata SolutionResponse_Assignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[19]);
}
// ===================================================================

class SolutionResponse_NodeProductFlow::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse_NodeProductFlow>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_._has_bits_);
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_productid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_inflow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_outflow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flowcost(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fixedcost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_productionamount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_productionpenalty(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_productioncost(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_consumptionamount(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_consumptionpenalty(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_consumptioncost(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000fff) ^ 0x00000fff) != 0;
  }
};

SolutionResponse_NodeProductFlow::SolutionResponse_NodeProductFlow(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.NodeProductFlow)
}
SolutionResponse_NodeProductFlow::SolutionResponse_NodeProductFlow(const SolutionResponse_NodeProductFlow& from) : ::google::protobuf::Message() {
  SolutionResponse_NodeProductFlow* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.nodeid_){},
      decltype(_impl_.productid_){},
      decltype(_impl_.inflow_){},
      decltype(_impl_.outflow_){},
      decltype(_impl_.flowcost_){},
      decltype(_impl_.fixedcost_){},
      decltype(_impl_.productionamount_){},
      decltype(_impl_.productionpenalty_){},
      decltype(_impl_.productioncost_){},
      decltype(_impl_.consumptionamount_){},
      decltype(_impl_.consumptionpenalty_){},
      decltype(_impl_.consumptioncost_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.nodeid_.Set(from._internal_nodeid(), _this->GetArenaForAllocation());
  }
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.productid_.Set(from._internal_productid(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.inflow_, &from._impl_.inflow_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.consumptioncost_) -
    reinterpret_cast<char*>(&_impl_.inflow_)) + sizeof(_impl_.consumptioncost_));

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.NodeProductFlow)
}
inline void SolutionResponse_NodeProductFlow::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.nodeid_){},
      decltype(_impl_.productid_){},
      decltype(_impl_.inflow_){0},
      decltype(_impl_.outflow_){0},
      decltype(_impl_.flowcost_){0},
      decltype(_impl_.fixedcost_){0},
      decltype(_impl_.productionamount_){0},
      decltype(_impl_.productionpenalty_){0},
      decltype(_impl_.productioncost_){0},
      decltype(_impl_.consumptionamount_){0},
      decltype(_impl_.consumptionpenalty_){0},
      decltype(_impl_.consumptioncost_){0},
  };
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolutionResponse_NodeProductFlow::~SolutionResponse_NodeProductFlow() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.NodeProductFlow)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_NodeProductFlow::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodeid_.Destroy();
  _impl_.productid_.Destroy();
}
void SolutionResponse_NodeProductFlow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_NodeProductFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.NodeProductFlow)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.nodeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.productid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.inflow_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.productionpenalty_) -
        reinterpret_cast<char*>(&_impl_.inflow_)) + sizeof(_impl_.productionpenalty_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.productioncost_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.consumptioncost_) -
        reinterpret_cast<char*>(&_impl_.productioncost_)) + sizeof(_impl_.consumptioncost_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_NodeProductFlow::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 0, 68, 2> SolutionResponse_NodeProductFlow::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SolutionResponse_NodeProductFlow_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string nodeId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.nodeid_)}},
    // required string productId = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productid_)}},
    // required float inFlow = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.inflow_)}},
    // required float outFlow = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.outflow_)}},
    // required float flowCost = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.flowcost_)}},
    // required float fixedCost = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.fixedcost_)}},
    // required float productionAmount = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productionamount_)}},
    // required float productionPenalty = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productionpenalty_)}},
    // required float productionCost = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productioncost_)}},
    // required float consumptionAmount = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 9, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptionamount_)}},
    // required float consumptionPenalty = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 10, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptionpenalty_)}},
    // required float consumptionCost = 12;
    {::_pbi::TcParser::FastF32S1,
     {101, 11, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptioncost_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string nodeId = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.nodeid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string productId = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productid_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required float inFlow = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.inflow_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float outFlow = 4;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.outflow_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float flowCost = 5;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.flowcost_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float fixedCost = 6;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.fixedcost_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productionAmount = 7;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productionamount_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productionPenalty = 8;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productionpenalty_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productionCost = 9;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.productioncost_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float consumptionAmount = 10;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptionamount_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float consumptionPenalty = 11;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptionpenalty_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float consumptionCost = 12;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptioncost_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\44\6\11\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "NS3.SolutionResponse.NodeProductFlow"
    "nodeId"
    "productId"
  }},
};

::uint8_t* SolutionResponse_NodeProductFlow::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.NodeProductFlow)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string nodeId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_nodeid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.NodeProductFlow.nodeId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string productId = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_productid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.NodeProductFlow.productId");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // required float inFlow = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_inflow(), target);
  }

  // required float outFlow = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_outflow(), target);
  }

  // required float flowCost = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_flowcost(), target);
  }

  // required float fixedCost = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_fixedcost(), target);
  }

  // required float productionAmount = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_productionamount(), target);
  }

  // required float productionPenalty = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_productionpenalty(), target);
  }

  // required float productionCost = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_productioncost(), target);
  }

  // required float consumptionAmount = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_consumptionamount(), target);
  }

  // required float consumptionPenalty = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_consumptionpenalty(), target);
  }

  // required float consumptionCost = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_consumptioncost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.NodeProductFlow)
  return target;
}

::size_t SolutionResponse_NodeProductFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.NodeProductFlow)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // required string nodeId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_nodeid());
    }

    // required string productId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_productid());
    }

    // required float inFlow = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // required float outFlow = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

    // required float flowCost = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // required float fixedCost = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // required float productionAmount = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }

    // required float productionPenalty = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 5;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // required float productionCost = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // required float consumptionAmount = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }

    // required float consumptionPenalty = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 5;
    }

    // required float consumptionCost = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_NodeProductFlow::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_NodeProductFlow::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_NodeProductFlow::GetClassData() const { return &_class_data_; }


void SolutionResponse_NodeProductFlow::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_NodeProductFlow*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_NodeProductFlow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.NodeProductFlow)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nodeid(from._internal_nodeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_productid(from._internal_productid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.inflow_ = from._impl_.inflow_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.outflow_ = from._impl_.outflow_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flowcost_ = from._impl_.flowcost_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.fixedcost_ = from._impl_.fixedcost_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.productionamount_ = from._impl_.productionamount_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.productionpenalty_ = from._impl_.productionpenalty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.productioncost_ = from._impl_.productioncost_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.consumptionamount_ = from._impl_.consumptionamount_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.consumptionpenalty_ = from._impl_.consumptionpenalty_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.consumptioncost_ = from._impl_.consumptioncost_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_NodeProductFlow::CopyFrom(const SolutionResponse_NodeProductFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.NodeProductFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_NodeProductFlow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void SolutionResponse_NodeProductFlow::InternalSwap(SolutionResponse_NodeProductFlow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.nodeid_, lhs_arena,
                                       &other->_impl_.nodeid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productid_, lhs_arena,
                                       &other->_impl_.productid_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.consumptioncost_)
      + sizeof(SolutionResponse_NodeProductFlow::_impl_.consumptioncost_)
      - PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductFlow, _impl_.inflow_)>(
          reinterpret_cast<char*>(&_impl_.inflow_),
          reinterpret_cast<char*>(&other->_impl_.inflow_));
}

::google::protobuf::Metadata SolutionResponse_NodeProductFlow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[20]);
}
// ===================================================================

class SolutionResponse_NodeFlow::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse_NodeFlow>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_._has_bits_);
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_inflow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_outflow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flowcost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_fixedcost(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_productflowcost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_productfixedcost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_productionamount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_productionpenalty(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_productioncost(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_consumptionamount(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_consumptionpenalty(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_consumptioncost(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00001fff) ^ 0x00001fff) != 0;
  }
};

SolutionResponse_NodeFlow::SolutionResponse_NodeFlow(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.NodeFlow)
}
SolutionResponse_NodeFlow::SolutionResponse_NodeFlow(const SolutionResponse_NodeFlow& from) : ::google::protobuf::Message() {
  SolutionResponse_NodeFlow* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.nodeid_){},
      decltype(_impl_.inflow_){},
      decltype(_impl_.outflow_){},
      decltype(_impl_.flowcost_){},
      decltype(_impl_.fixedcost_){},
      decltype(_impl_.productflowcost_){},
      decltype(_impl_.productfixedcost_){},
      decltype(_impl_.productionamount_){},
      decltype(_impl_.productionpenalty_){},
      decltype(_impl_.productioncost_){},
      decltype(_impl_.consumptionamount_){},
      decltype(_impl_.consumptionpenalty_){},
      decltype(_impl_.consumptioncost_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.nodeid_.Set(from._internal_nodeid(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.inflow_, &from._impl_.inflow_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.consumptioncost_) -
    reinterpret_cast<char*>(&_impl_.inflow_)) + sizeof(_impl_.consumptioncost_));

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.NodeFlow)
}
inline void SolutionResponse_NodeFlow::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.nodeid_){},
      decltype(_impl_.inflow_){0},
      decltype(_impl_.outflow_){0},
      decltype(_impl_.flowcost_){0},
      decltype(_impl_.fixedcost_){0},
      decltype(_impl_.productflowcost_){0},
      decltype(_impl_.productfixedcost_){0},
      decltype(_impl_.productionamount_){0},
      decltype(_impl_.productionpenalty_){0},
      decltype(_impl_.productioncost_){0},
      decltype(_impl_.consumptionamount_){0},
      decltype(_impl_.consumptionpenalty_){0},
      decltype(_impl_.consumptioncost_){0},
  };
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolutionResponse_NodeFlow::~SolutionResponse_NodeFlow() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.NodeFlow)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_NodeFlow::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodeid_.Destroy();
}
void SolutionResponse_NodeFlow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_NodeFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.NodeFlow)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.nodeid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.inflow_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.productionamount_) -
        reinterpret_cast<char*>(&_impl_.inflow_)) + sizeof(_impl_.productionamount_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.productionpenalty_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.consumptioncost_) -
        reinterpret_cast<char*>(&_impl_.productionpenalty_)) + sizeof(_impl_.consumptioncost_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_NodeFlow::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 0, 52, 2> SolutionResponse_NodeFlow::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SolutionResponse_NodeFlow_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string nodeId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.nodeid_)}},
    // required float inFlow = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.inflow_)}},
    // required float outFlow = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.outflow_)}},
    // required float flowCost = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.flowcost_)}},
    // required float fixedCost = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.fixedcost_)}},
    // required float productFlowCost = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productflowcost_)}},
    // required float productFixedCost = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productfixedcost_)}},
    // required float productionAmount = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productionamount_)}},
    // required float productionPenalty = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productionpenalty_)}},
    // required float productionCost = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 9, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productioncost_)}},
    // required float consumptionAmount = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 10, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptionamount_)}},
    // required float consumptionPenalty = 12;
    {::_pbi::TcParser::FastF32S1,
     {101, 11, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptionpenalty_)}},
    // required float consumptionCost = 13;
    {::_pbi::TcParser::FastF32S1,
     {109, 12, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptioncost_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string nodeId = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.nodeid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required float inFlow = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.inflow_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float outFlow = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.outflow_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float flowCost = 4;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.flowcost_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float fixedCost = 5;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.fixedcost_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productFlowCost = 6;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productflowcost_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productFixedCost = 7;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productfixedcost_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productionAmount = 8;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productionamount_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productionPenalty = 9;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productionpenalty_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float productionCost = 10;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.productioncost_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float consumptionAmount = 11;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptionamount_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float consumptionPenalty = 12;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptionpenalty_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float consumptionCost = 13;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptioncost_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\35\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "NS3.SolutionResponse.NodeFlow"
    "nodeId"
  }},
};

::uint8_t* SolutionResponse_NodeFlow::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.NodeFlow)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string nodeId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_nodeid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.NodeFlow.nodeId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required float inFlow = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_inflow(), target);
  }

  // required float outFlow = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_outflow(), target);
  }

  // required float flowCost = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_flowcost(), target);
  }

  // required float fixedCost = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_fixedcost(), target);
  }

  // required float productFlowCost = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_productflowcost(), target);
  }

  // required float productFixedCost = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_productfixedcost(), target);
  }

  // required float productionAmount = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_productionamount(), target);
  }

  // required float productionPenalty = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_productionpenalty(), target);
  }

  // required float productionCost = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_productioncost(), target);
  }

  // required float consumptionAmount = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_consumptionamount(), target);
  }

  // required float consumptionPenalty = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_consumptionpenalty(), target);
  }

  // required float consumptionCost = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_consumptioncost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.NodeFlow)
  return target;
}

::size_t SolutionResponse_NodeFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.NodeFlow)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // required string nodeId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_nodeid());
    }

    // required float inFlow = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // required float outFlow = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // required float flowCost = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

    // required float fixedCost = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // required float productFlowCost = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // required float productFixedCost = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }

    // required float productionAmount = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 5;
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // required float productionPenalty = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // required float productionCost = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }

    // required float consumptionAmount = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 5;
    }

    // required float consumptionPenalty = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 5;
    }

    // required float consumptionCost = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_NodeFlow::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_NodeFlow::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_NodeFlow::GetClassData() const { return &_class_data_; }


void SolutionResponse_NodeFlow::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_NodeFlow*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_NodeFlow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.NodeFlow)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nodeid(from._internal_nodeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.inflow_ = from._impl_.inflow_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.outflow_ = from._impl_.outflow_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flowcost_ = from._impl_.flowcost_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.fixedcost_ = from._impl_.fixedcost_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.productflowcost_ = from._impl_.productflowcost_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.productfixedcost_ = from._impl_.productfixedcost_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.productionamount_ = from._impl_.productionamount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.productionpenalty_ = from._impl_.productionpenalty_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.productioncost_ = from._impl_.productioncost_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.consumptionamount_ = from._impl_.consumptionamount_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.consumptionpenalty_ = from._impl_.consumptionpenalty_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.consumptioncost_ = from._impl_.consumptioncost_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_NodeFlow::CopyFrom(const SolutionResponse_NodeFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.NodeFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_NodeFlow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void SolutionResponse_NodeFlow::InternalSwap(SolutionResponse_NodeFlow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.nodeid_, lhs_arena,
                                       &other->_impl_.nodeid_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.consumptioncost_)
      + sizeof(SolutionResponse_NodeFlow::_impl_.consumptioncost_)
      - PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeFlow, _impl_.inflow_)>(
          reinterpret_cast<char*>(&_impl_.inflow_),
          reinterpret_cast<char*>(&other->_impl_.inflow_));
}

::google::protobuf::Metadata SolutionResponse_NodeFlow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[21]);
}
// ===================================================================

class SolutionResponse_GeometrySequence::_Internal {
 public:
};

SolutionResponse_GeometrySequence::SolutionResponse_GeometrySequence(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.GeometrySequence)
}
SolutionResponse_GeometrySequence::SolutionResponse_GeometrySequence(const SolutionResponse_GeometrySequence& from) : ::google::protobuf::Message() {
  SolutionResponse_GeometrySequence* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){from._impl_.x_},
      decltype(_impl_.y_){from._impl_.y_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.GeometrySequence)
}
inline void SolutionResponse_GeometrySequence::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){arena},
      decltype(_impl_.y_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
SolutionResponse_GeometrySequence::~SolutionResponse_GeometrySequence() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.GeometrySequence)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_GeometrySequence::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.x_.~RepeatedField();
  _impl_.y_.~RepeatedField();
}
void SolutionResponse_GeometrySequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_GeometrySequence::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.GeometrySequence)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_x()->Clear();
  _internal_mutable_y()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_GeometrySequence::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> SolutionResponse_GeometrySequence::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SolutionResponse_GeometrySequence_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated float y = 2;
    {::_pbi::TcParser::FastF32R1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_GeometrySequence, _impl_.y_)}},
    // repeated float x = 1;
    {::_pbi::TcParser::FastF32R1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_GeometrySequence, _impl_.x_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated float x = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_GeometrySequence, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // repeated float y = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_GeometrySequence, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SolutionResponse_GeometrySequence::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.GeometrySequence)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated float x = 1;
  for (int i = 0, n = this->_internal_x_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x().Get(i), target);
  }

  // repeated float y = 2;
  for (int i = 0, n = this->_internal_y_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y().Get(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.GeometrySequence)
  return target;
}

::size_t SolutionResponse_GeometrySequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.GeometrySequence)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float x = 1;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_x_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_x_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated float y = 2;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_y_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_y_size());
    ;
    total_size += tag_size + data_size;
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_GeometrySequence::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_GeometrySequence::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_GeometrySequence::GetClassData() const { return &_class_data_; }


void SolutionResponse_GeometrySequence::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_GeometrySequence*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_GeometrySequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.GeometrySequence)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_x()->MergeFrom(from._internal_x());
  _this->_internal_mutable_y()->MergeFrom(from._internal_y());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_GeometrySequence::CopyFrom(const SolutionResponse_GeometrySequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.GeometrySequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_GeometrySequence::IsInitialized() const {
  return true;
}

void SolutionResponse_GeometrySequence::InternalSwap(SolutionResponse_GeometrySequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.x_.InternalSwap(&other->_impl_.x_);
  _impl_.y_.InternalSwap(&other->_impl_.y_);
}

::google::protobuf::Metadata SolutionResponse_GeometrySequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[22]);
}
// ===================================================================

class SolutionResponse_Route::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse_Route>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_._has_bits_);
  static void set_has_fromid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_toid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SolutionResponse_Route::SolutionResponse_Route(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.Route)
}
SolutionResponse_Route::SolutionResponse_Route(const SolutionResponse_Route& from) : ::google::protobuf::Message() {
  SolutionResponse_Route* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.geometrysequence_){from._impl_.geometrysequence_},
      decltype(_impl_.fromid_){},
      decltype(_impl_.toid_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.fromid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fromid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.fromid_.Set(from._internal_fromid(), _this->GetArenaForAllocation());
  }
  _impl_.toid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.toid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.toid_.Set(from._internal_toid(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.Route)
}
inline void SolutionResponse_Route::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.geometrysequence_){arena},
      decltype(_impl_.fromid_){},
      decltype(_impl_.toid_){},
  };
  _impl_.fromid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fromid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.toid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.toid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolutionResponse_Route::~SolutionResponse_Route() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.Route)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_Route::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.geometrysequence_.~RepeatedField();
  _impl_.fromid_.Destroy();
  _impl_.toid_.Destroy();
}
void SolutionResponse_Route::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_Route::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.Route)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_geometrysequence()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.fromid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.toid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_Route::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 45, 2> SolutionResponse_Route::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SolutionResponse_Route_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string fromId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_.fromid_)}},
    // required string toId = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_.toid_)}},
    // repeated int32 geometrySequence = 3;
    {::_pbi::TcParser::FastV32R1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_.geometrysequence_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string fromId = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_.fromid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string toId = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_.toid_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated int32 geometrySequence = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_Route, _impl_.geometrysequence_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\32\6\4\0\0\0\0\0"
    "NS3.SolutionResponse.Route"
    "fromId"
    "toId"
  }},
};

::uint8_t* SolutionResponse_Route::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.Route)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string fromId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_fromid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Route.fromId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string toId = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_toid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.Route.toId");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated int32 geometrySequence = 3;
  for (int i = 0, n = this->_internal_geometrysequence_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_geometrysequence().Get(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.Route)
  return target;
}

::size_t SolutionResponse_Route::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.Route)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 geometrySequence = 3;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_geometrysequence())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_geometrysequence_size());
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string fromId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_fromid());
    }

    // required string toId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_toid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_Route::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_Route::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_Route::GetClassData() const { return &_class_data_; }


void SolutionResponse_Route::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_Route*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_Route&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.Route)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_geometrysequence()->MergeFrom(from._internal_geometrysequence());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_fromid(from._internal_fromid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_toid(from._internal_toid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_Route::CopyFrom(const SolutionResponse_Route& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.Route)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_Route::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void SolutionResponse_Route::InternalSwap(SolutionResponse_Route* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.geometrysequence_.InternalSwap(&other->_impl_.geometrysequence_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fromid_, lhs_arena,
                                       &other->_impl_.fromid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.toid_, lhs_arena,
                                       &other->_impl_.toid_, rhs_arena);
}

::google::protobuf::Metadata SolutionResponse_Route::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[23]);
}
// ===================================================================

class SolutionResponse_NodeProductTransformAssignment_Item::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse_NodeProductTransformAssignment_Item>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_._has_bits_);
  static void set_has_productid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fixedcost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_penaltyamount(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_penaltycost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

SolutionResponse_NodeProductTransformAssignment_Item::SolutionResponse_NodeProductTransformAssignment_Item(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
}
SolutionResponse_NodeProductTransformAssignment_Item::SolutionResponse_NodeProductTransformAssignment_Item(const SolutionResponse_NodeProductTransformAssignment_Item& from) : ::google::protobuf::Message() {
  SolutionResponse_NodeProductTransformAssignment_Item* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productid_){},
      decltype(_impl_.amount_){},
      decltype(_impl_.cost_){},
      decltype(_impl_.fixedcost_){},
      decltype(_impl_.penaltyamount_){},
      decltype(_impl_.penaltycost_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.productid_.Set(from._internal_productid(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.penaltycost_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.penaltycost_));

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.productid_){},
      decltype(_impl_.amount_){0},
      decltype(_impl_.cost_){0},
      decltype(_impl_.fixedcost_){0},
      decltype(_impl_.penaltyamount_){0},
      decltype(_impl_.penaltycost_){0},
  };
  _impl_.productid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolutionResponse_NodeProductTransformAssignment_Item::~SolutionResponse_NodeProductTransformAssignment_Item() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productid_.Destroy();
}
void SolutionResponse_NodeProductTransformAssignment_Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_NodeProductTransformAssignment_Item::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.productid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.amount_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.penaltycost_) -
        reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.penaltycost_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_NodeProductTransformAssignment_Item::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 74, 2> SolutionResponse_NodeProductTransformAssignment_Item::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SolutionResponse_NodeProductTransformAssignment_Item_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string productId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.productid_)}},
    // required float amount = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.amount_)}},
    // required float cost = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.cost_)}},
    // required float fixedCost = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.fixedcost_)}},
    // required float penaltyAmount = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltyamount_)}},
    // required float penaltyCost = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltycost_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string productId = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.productid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required float amount = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.amount_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float cost = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.cost_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float fixedCost = 4;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.fixedcost_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float penaltyAmount = 5;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltyamount_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // required float penaltyCost = 6;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltycost_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\70\11\0\0\0\0\0\0"
    "NS3.SolutionResponse.NodeProductTransformAssignment.Item"
    "productId"
  }},
};

::uint8_t* SolutionResponse_NodeProductTransformAssignment_Item::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string productId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_productid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required float amount = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_amount(), target);
  }

  // required float cost = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_cost(), target);
  }

  // required float fixedCost = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_fixedcost(), target);
  }

  // required float penaltyAmount = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_penaltyamount(), target);
  }

  // required float penaltyCost = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_penaltycost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  return target;
}

::size_t SolutionResponse_NodeProductTransformAssignment_Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // required string productId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_productid());
    }

    // required float amount = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // required float cost = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // required float fixedCost = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

    // required float penaltyAmount = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // required float penaltyCost = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_NodeProductTransformAssignment_Item::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_NodeProductTransformAssignment_Item::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_NodeProductTransformAssignment_Item::GetClassData() const { return &_class_data_; }


void SolutionResponse_NodeProductTransformAssignment_Item::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_NodeProductTransformAssignment_Item*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_NodeProductTransformAssignment_Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_productid(from._internal_productid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cost_ = from._impl_.cost_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.fixedcost_ = from._impl_.fixedcost_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.penaltyamount_ = from._impl_.penaltyamount_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.penaltycost_ = from._impl_.penaltycost_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_NodeProductTransformAssignment_Item::CopyFrom(const SolutionResponse_NodeProductTransformAssignment_Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_NodeProductTransformAssignment_Item::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

void SolutionResponse_NodeProductTransformAssignment_Item::InternalSwap(SolutionResponse_NodeProductTransformAssignment_Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productid_, lhs_arena,
                                       &other->_impl_.productid_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.penaltycost_)
      + sizeof(SolutionResponse_NodeProductTransformAssignment_Item::_impl_.penaltycost_)
      - PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment_Item, _impl_.amount_)>(
          reinterpret_cast<char*>(&_impl_.amount_),
          reinterpret_cast<char*>(&other->_impl_.amount_));
}

::google::protobuf::Metadata SolutionResponse_NodeProductTransformAssignment_Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[24]);
}
// ===================================================================

class SolutionResponse_NodeProductTransformAssignment::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse_NodeProductTransformAssignment>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_._has_bits_);
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_producttransformid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SolutionResponse_NodeProductTransformAssignment::SolutionResponse_NodeProductTransformAssignment(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse.NodeProductTransformAssignment)
}
SolutionResponse_NodeProductTransformAssignment::SolutionResponse_NodeProductTransformAssignment(const SolutionResponse_NodeProductTransformAssignment& from) : ::google::protobuf::Message() {
  SolutionResponse_NodeProductTransformAssignment* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.inputitems_){from._impl_.inputitems_},
      decltype(_impl_.outputitems_){from._impl_.outputitems_},
      decltype(_impl_.nodeid_){},
      decltype(_impl_.producttransformid_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.nodeid_.Set(from._internal_nodeid(), _this->GetArenaForAllocation());
  }
  _impl_.producttransformid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.producttransformid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.producttransformid_.Set(from._internal_producttransformid(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse.NodeProductTransformAssignment)
}
inline void SolutionResponse_NodeProductTransformAssignment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.inputitems_){arena},
      decltype(_impl_.outputitems_){arena},
      decltype(_impl_.nodeid_){},
      decltype(_impl_.producttransformid_){},
  };
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producttransformid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.producttransformid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
SolutionResponse_NodeProductTransformAssignment::~SolutionResponse_NodeProductTransformAssignment() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse.NodeProductTransformAssignment)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse_NodeProductTransformAssignment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.inputitems_.~RepeatedPtrField();
  _impl_.outputitems_.~RepeatedPtrField();
  _impl_.nodeid_.Destroy();
  _impl_.producttransformid_.Destroy();
}
void SolutionResponse_NodeProductTransformAssignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse_NodeProductTransformAssignment::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse.NodeProductTransformAssignment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_inputitems()->Clear();
  _internal_mutable_outputitems()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.nodeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.producttransformid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse_NodeProductTransformAssignment::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 84, 2> SolutionResponse_NodeProductTransformAssignment::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SolutionResponse_NodeProductTransformAssignment_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 1, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.outputitems_)}},
    // required string nodeId = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.nodeid_)}},
    // required string productTransformId = 2;
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.producttransformid_)}},
    // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.inputitems_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string nodeId = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.nodeid_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // required string productTransformId = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.producttransformid_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.inputitems_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse_NodeProductTransformAssignment, _impl_.outputitems_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>()},
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>()},
  }}, {{
    "\63\6\22\0\0\0\0\0"
    "NS3.SolutionResponse.NodeProductTransformAssignment"
    "nodeId"
    "productTransformId"
  }},
};

::uint8_t* SolutionResponse_NodeProductTransformAssignment::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse.NodeProductTransformAssignment)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string nodeId = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_nodeid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.NodeProductTransformAssignment.nodeId");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string productTransformId = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_producttransformid();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inputitems_size()); i < n; i++) {
    const auto& repfield = this->_internal_inputitems().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outputitems_size()); i < n; i++) {
    const auto& repfield = this->_internal_outputitems().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse.NodeProductTransformAssignment)
  return target;
}

::size_t SolutionResponse_NodeProductTransformAssignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse.NodeProductTransformAssignment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
  total_size += 1UL * this->_internal_inputitems_size();
  for (const auto& msg : this->_internal_inputitems()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
  total_size += 1UL * this->_internal_outputitems_size();
  for (const auto& msg : this->_internal_outputitems()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string nodeId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_nodeid());
    }

    // required string productTransformId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_producttransformid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse_NodeProductTransformAssignment::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse_NodeProductTransformAssignment::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse_NodeProductTransformAssignment::GetClassData() const { return &_class_data_; }


void SolutionResponse_NodeProductTransformAssignment::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse_NodeProductTransformAssignment*>(&to_msg);
  auto& from = static_cast<const SolutionResponse_NodeProductTransformAssignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse.NodeProductTransformAssignment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_inputitems()->MergeFrom(from._internal_inputitems());
  _this->_internal_mutable_outputitems()->MergeFrom(from._internal_outputitems());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nodeid(from._internal_nodeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_producttransformid(from._internal_producttransformid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse_NodeProductTransformAssignment::CopyFrom(const SolutionResponse_NodeProductTransformAssignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse.NodeProductTransformAssignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse_NodeProductTransformAssignment::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_inputitems()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_outputitems()))
    return false;
  return true;
}

void SolutionResponse_NodeProductTransformAssignment::InternalSwap(SolutionResponse_NodeProductTransformAssignment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.inputitems_.InternalSwap(&other->_impl_.inputitems_);
  _impl_.outputitems_.InternalSwap(&other->_impl_.outputitems_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.nodeid_, lhs_arena,
                                       &other->_impl_.nodeid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.producttransformid_, lhs_arena,
                                       &other->_impl_.producttransformid_, rhs_arena);
}

::google::protobuf::Metadata SolutionResponse_NodeProductTransformAssignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[25]);
}
// ===================================================================

class SolutionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SolutionResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_._has_bits_);
  static void set_has_objective(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lowerbound(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_optimalitygap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SolutionResponse::SolutionResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:NS3.SolutionResponse)
}
SolutionResponse::SolutionResponse(const SolutionResponse& from) : ::google::protobuf::Message() {
  SolutionResponse* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.assignments_){from._impl_.assignments_},
      decltype(_impl_.nodeflows_){from._impl_.nodeflows_},
      decltype(_impl_.nodeproductflows_){from._impl_.nodeproductflows_},
      decltype(_impl_.geometrysequence_){from._impl_.geometrysequence_},
      decltype(_impl_.routes_){from._impl_.routes_},
      decltype(_impl_.nodeproducttransformassignments_){from._impl_.nodeproducttransformassignments_},
      decltype(_impl_.objective_){},
      decltype(_impl_.lowerbound_){},
      decltype(_impl_.optimalitygap_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.objective_, &from._impl_.objective_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.optimalitygap_) -
    reinterpret_cast<char*>(&_impl_.objective_)) + sizeof(_impl_.optimalitygap_));

  // @@protoc_insertion_point(copy_constructor:NS3.SolutionResponse)
}
inline void SolutionResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.assignments_){arena},
      decltype(_impl_.nodeflows_){arena},
      decltype(_impl_.nodeproductflows_){arena},
      decltype(_impl_.geometrysequence_){arena},
      decltype(_impl_.routes_){arena},
      decltype(_impl_.nodeproducttransformassignments_){arena},
      decltype(_impl_.objective_){0},
      decltype(_impl_.lowerbound_){0},
      decltype(_impl_.optimalitygap_){0},
  };
}
SolutionResponse::~SolutionResponse() {
  // @@protoc_insertion_point(destructor:NS3.SolutionResponse)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SolutionResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assignments_.~RepeatedPtrField();
  _impl_.nodeflows_.~RepeatedPtrField();
  _impl_.nodeproductflows_.~RepeatedPtrField();
  _impl_.geometrysequence_.~RepeatedPtrField();
  _impl_.routes_.~RepeatedPtrField();
  _impl_.nodeproducttransformassignments_.~RepeatedPtrField();
}
void SolutionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SolutionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:NS3.SolutionResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_assignments()->Clear();
  _internal_mutable_nodeflows()->Clear();
  _internal_mutable_nodeproductflows()->Clear();
  _internal_mutable_geometrysequence()->Clear();
  _internal_mutable_routes()->Clear();
  _internal_mutable_nodeproducttransformassignments()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.objective_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.optimalitygap_) -
        reinterpret_cast<char*>(&_impl_.objective_)) + sizeof(_impl_.optimalitygap_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SolutionResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 6, 0, 2> SolutionResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SolutionResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required float objective = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.objective_)}},
    // optional float lowerBound = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.lowerbound_)}},
    // optional float optimalityGap = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.optimalitygap_)}},
    // repeated .NS3.SolutionResponse.Assignment assignments = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.assignments_)}},
    // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 1, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.nodeflows_)}},
    // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 2, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.nodeproductflows_)}},
    // repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 3, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.geometrysequence_)}},
    // repeated .NS3.SolutionResponse.Route routes = 8;
    {::_pbi::TcParser::FastMtR1,
     {66, 63, 4, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.routes_)}},
    // repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
    {::_pbi::TcParser::FastMtR1,
     {74, 63, 5, PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.nodeproducttransformassignments_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required float objective = 1;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.objective_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float lowerBound = 2;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.lowerbound_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float optimalityGap = 3;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.optimalitygap_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // repeated .NS3.SolutionResponse.Assignment assignments = 4;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.assignments_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.nodeflows_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.nodeproductflows_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.geometrysequence_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.SolutionResponse.Route routes = 8;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.routes_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
    {PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.nodeproducttransformassignments_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_Assignment>()},
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_NodeFlow>()},
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_NodeProductFlow>()},
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_GeometrySequence>()},
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_Route>()},
    {::_pbi::TcParser::GetTable<::NS3::SolutionResponse_NodeProductTransformAssignment>()},
  }}, {{
  }},
};

::uint8_t* SolutionResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NS3.SolutionResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float objective = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_objective(), target);
  }

  // optional float lowerBound = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_lowerbound(), target);
  }

  // optional float optimalityGap = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_optimalitygap(), target);
  }

  // repeated .NS3.SolutionResponse.Assignment assignments = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assignments_size()); i < n; i++) {
    const auto& repfield = this->_internal_assignments().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodeflows_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodeflows().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodeproductflows_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodeproductflows().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_geometrysequence_size()); i < n; i++) {
    const auto& repfield = this->_internal_geometrysequence().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.SolutionResponse.Route routes = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_routes_size()); i < n; i++) {
    const auto& repfield = this->_internal_routes().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodeproducttransformassignments_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodeproducttransformassignments().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NS3.SolutionResponse)
  return target;
}

::size_t SolutionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NS3.SolutionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NS3.SolutionResponse.Assignment assignments = 4;
  total_size += 1UL * this->_internal_assignments_size();
  for (const auto& msg : this->_internal_assignments()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
  total_size += 1UL * this->_internal_nodeflows_size();
  for (const auto& msg : this->_internal_nodeflows()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
  total_size += 1UL * this->_internal_nodeproductflows_size();
  for (const auto& msg : this->_internal_nodeproductflows()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
  total_size += 1UL * this->_internal_geometrysequence_size();
  for (const auto& msg : this->_internal_geometrysequence()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.SolutionResponse.Route routes = 8;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->_internal_routes()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
  total_size += 1UL * this->_internal_nodeproducttransformassignments_size();
  for (const auto& msg : this->_internal_nodeproducttransformassignments()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required float objective = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  if (cached_has_bits & 0x00000006u) {
    // optional float lowerBound = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // optional float optimalityGap = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SolutionResponse::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SolutionResponse::MergeImpl
};
const ::google::protobuf::Message::ClassData*SolutionResponse::GetClassData() const { return &_class_data_; }


void SolutionResponse::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SolutionResponse*>(&to_msg);
  auto& from = static_cast<const SolutionResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NS3.SolutionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_assignments()->MergeFrom(from._internal_assignments());
  _this->_internal_mutable_nodeflows()->MergeFrom(from._internal_nodeflows());
  _this->_internal_mutable_nodeproductflows()->MergeFrom(from._internal_nodeproductflows());
  _this->_internal_mutable_geometrysequence()->MergeFrom(from._internal_geometrysequence());
  _this->_internal_mutable_routes()->MergeFrom(from._internal_routes());
  _this->_internal_mutable_nodeproducttransformassignments()->MergeFrom(from._internal_nodeproducttransformassignments());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.objective_ = from._impl_.objective_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lowerbound_ = from._impl_.lowerbound_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.optimalitygap_ = from._impl_.optimalitygap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SolutionResponse::CopyFrom(const SolutionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NS3.SolutionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SolutionResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_assignments()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_nodeflows()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_nodeproductflows()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_routes()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_nodeproducttransformassignments()))
    return false;
  return true;
}

void SolutionResponse::InternalSwap(SolutionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.assignments_.InternalSwap(&other->_impl_.assignments_);
  _impl_.nodeflows_.InternalSwap(&other->_impl_.nodeflows_);
  _impl_.nodeproductflows_.InternalSwap(&other->_impl_.nodeproductflows_);
  _impl_.geometrysequence_.InternalSwap(&other->_impl_.geometrysequence_);
  _impl_.routes_.InternalSwap(&other->_impl_.routes_);
  _impl_.nodeproducttransformassignments_.InternalSwap(&other->_impl_.nodeproducttransformassignments_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.optimalitygap_)
      + sizeof(SolutionResponse::_impl_.optimalitygap_)
      - PROTOBUF_FIELD_OFFSET(SolutionResponse, _impl_.objective_)>(
          reinterpret_cast<char*>(&_impl_.objective_),
          reinterpret_cast<char*>(&other->_impl_.objective_));
}

::google::protobuf::Metadata SolutionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_getter, &descriptor_table_ns3_2dtbfvuwtge2iq_2eproto_once,
      file_level_metadata_ns3_2dtbfvuwtge2iq_2eproto[26]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace NS3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
