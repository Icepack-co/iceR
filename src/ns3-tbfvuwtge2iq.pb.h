// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ns3-tbfvuwtge2iq.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ns3_2dtbfvuwtge2iq_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ns3_2dtbfvuwtge2iq_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ns3_2dtbfvuwtge2iq_2eproto;
namespace NS3 {
class CostModel;
struct CostModelDefaultTypeInternal;
extern CostModelDefaultTypeInternal _CostModel_default_instance_;
class DimensionConfiguration;
struct DimensionConfigurationDefaultTypeInternal;
extern DimensionConfigurationDefaultTypeInternal _DimensionConfiguration_default_instance_;
class DimensionRange;
struct DimensionRangeDefaultTypeInternal;
extern DimensionRangeDefaultTypeInternal _DimensionRange_default_instance_;
class FixedDimensionCost;
struct FixedDimensionCostDefaultTypeInternal;
extern FixedDimensionCostDefaultTypeInternal _FixedDimensionCost_default_instance_;
class FlowDimensionalConstraint;
struct FlowDimensionalConstraintDefaultTypeInternal;
extern FlowDimensionalConstraintDefaultTypeInternal _FlowDimensionalConstraint_default_instance_;
class Geocode;
struct GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class InternalDimension;
struct InternalDimensionDefaultTypeInternal;
extern InternalDimensionDefaultTypeInternal _InternalDimension_default_instance_;
class LaneRate;
struct LaneRateDefaultTypeInternal;
extern LaneRateDefaultTypeInternal _LaneRate_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Node_Flow;
struct Node_FlowDefaultTypeInternal;
extern Node_FlowDefaultTypeInternal _Node_Flow_default_instance_;
class Node_ProductFlow;
struct Node_ProductFlowDefaultTypeInternal;
extern Node_ProductFlowDefaultTypeInternal _Node_ProductFlow_default_instance_;
class Node_ProductTransform;
struct Node_ProductTransformDefaultTypeInternal;
extern Node_ProductTransformDefaultTypeInternal _Node_ProductTransform_default_instance_;
class Node_ProductTransform_Item;
struct Node_ProductTransform_ItemDefaultTypeInternal;
extern Node_ProductTransform_ItemDefaultTypeInternal _Node_ProductTransform_Item_default_instance_;
class ProductGroup;
struct ProductGroupDefaultTypeInternal;
extern ProductGroupDefaultTypeInternal _ProductGroup_default_instance_;
class ProductGroup_ProductSpecification;
struct ProductGroup_ProductSpecificationDefaultTypeInternal;
extern ProductGroup_ProductSpecificationDefaultTypeInternal _ProductGroup_ProductSpecification_default_instance_;
class SolutionResponse;
struct SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Assignment;
struct SolutionResponse_AssignmentDefaultTypeInternal;
extern SolutionResponse_AssignmentDefaultTypeInternal _SolutionResponse_Assignment_default_instance_;
class SolutionResponse_GeometrySequence;
struct SolutionResponse_GeometrySequenceDefaultTypeInternal;
extern SolutionResponse_GeometrySequenceDefaultTypeInternal _SolutionResponse_GeometrySequence_default_instance_;
class SolutionResponse_NodeFlow;
struct SolutionResponse_NodeFlowDefaultTypeInternal;
extern SolutionResponse_NodeFlowDefaultTypeInternal _SolutionResponse_NodeFlow_default_instance_;
class SolutionResponse_NodeProductFlow;
struct SolutionResponse_NodeProductFlowDefaultTypeInternal;
extern SolutionResponse_NodeProductFlowDefaultTypeInternal _SolutionResponse_NodeProductFlow_default_instance_;
class SolutionResponse_NodeProductTransformAssignment;
struct SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal;
extern SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal _SolutionResponse_NodeProductTransformAssignment_default_instance_;
class SolutionResponse_NodeProductTransformAssignment_Item;
struct SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal;
extern SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal _SolutionResponse_NodeProductTransformAssignment_Item_default_instance_;
class SolutionResponse_Route;
struct SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolveRequest;
struct SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class UnitDimensionCost;
struct UnitDimensionCostDefaultTypeInternal;
extern UnitDimensionCostDefaultTypeInternal _UnitDimensionCost_default_instance_;
class UserDimension;
struct UserDimensionDefaultTypeInternal;
extern UserDimensionDefaultTypeInternal _UserDimension_default_instance_;
}  // namespace NS3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace NS3 {
enum InternalDimension_eMeasurementUnit : int {
  InternalDimension_eMeasurementUnit_SECONDS = 0,
  InternalDimension_eMeasurementUnit_MINUTES = 1,
  InternalDimension_eMeasurementUnit_HOURS = 2,
  InternalDimension_eMeasurementUnit_DAYS = 3,
  InternalDimension_eMeasurementUnit_KILOMETRES = 4,
  InternalDimension_eMeasurementUnit_MILES = 5,
};

bool InternalDimension_eMeasurementUnit_IsValid(int value);
constexpr InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN = static_cast<InternalDimension_eMeasurementUnit>(0);
constexpr InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX = static_cast<InternalDimension_eMeasurementUnit>(5);
constexpr int InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
InternalDimension_eMeasurementUnit_descriptor();
template <typename T>
const std::string& InternalDimension_eMeasurementUnit_Name(T value) {
  static_assert(std::is_same<T, InternalDimension_eMeasurementUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to eMeasurementUnit_Name().");
  return InternalDimension_eMeasurementUnit_Name(static_cast<InternalDimension_eMeasurementUnit>(value));
}
template <>
inline const std::string& InternalDimension_eMeasurementUnit_Name(InternalDimension_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InternalDimension_eMeasurementUnit_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool InternalDimension_eMeasurementUnit_Parse(absl::string_view name, InternalDimension_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalDimension_eMeasurementUnit>(
      InternalDimension_eMeasurementUnit_descriptor(), name, value);
}
enum SolveRequest_SolveType : int {
  SolveRequest_SolveType_Optimise = 0,
};

bool SolveRequest_SolveType_IsValid(int value);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = static_cast<SolveRequest_SolveType>(0);
constexpr SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = static_cast<SolveRequest_SolveType>(0);
constexpr int SolveRequest_SolveType_SolveType_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_SolveType_descriptor();
template <typename T>
const std::string& SolveRequest_SolveType_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_SolveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SolveType_Name().");
  return SolveRequest_SolveType_Name(static_cast<SolveRequest_SolveType>(value));
}
template <>
inline const std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_SolveType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool SolveRequest_SolveType_Parse(absl::string_view name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
      SolveRequest_SolveType_descriptor(), name, value);
}
enum SolveRequest_GeometryOutput : int {
  SolveRequest_GeometryOutput_None = 0,
  SolveRequest_GeometryOutput_Aggregate = 1,
};

bool SolveRequest_GeometryOutput_IsValid(int value);
constexpr SolveRequest_GeometryOutput SolveRequest_GeometryOutput_GeometryOutput_MIN = static_cast<SolveRequest_GeometryOutput>(0);
constexpr SolveRequest_GeometryOutput SolveRequest_GeometryOutput_GeometryOutput_MAX = static_cast<SolveRequest_GeometryOutput>(1);
constexpr int SolveRequest_GeometryOutput_GeometryOutput_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SolveRequest_GeometryOutput_descriptor();
template <typename T>
const std::string& SolveRequest_GeometryOutput_Name(T value) {
  static_assert(std::is_same<T, SolveRequest_GeometryOutput>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GeometryOutput_Name().");
  return SolveRequest_GeometryOutput_Name(static_cast<SolveRequest_GeometryOutput>(value));
}
template <>
inline const std::string& SolveRequest_GeometryOutput_Name(SolveRequest_GeometryOutput value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SolveRequest_GeometryOutput_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SolveRequest_GeometryOutput_Parse(absl::string_view name, SolveRequest_GeometryOutput* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_GeometryOutput>(
      SolveRequest_GeometryOutput_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class InternalDimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.InternalDimension) */ {
 public:
  inline InternalDimension() : InternalDimension(nullptr) {}
  ~InternalDimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InternalDimension(::google::protobuf::internal::ConstantInitialized);

  InternalDimension(const InternalDimension& from);
  InternalDimension(InternalDimension&& from) noexcept
    : InternalDimension() {
    *this = ::std::move(from);
  }

  inline InternalDimension& operator=(const InternalDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalDimension& operator=(InternalDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalDimension* internal_default_instance() {
    return reinterpret_cast<const InternalDimension*>(
               &_InternalDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InternalDimension& a, InternalDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalDimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InternalDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InternalDimension& from) {
    InternalDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalDimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.InternalDimension";
  }
  protected:
  explicit InternalDimension(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using eMeasurementUnit = InternalDimension_eMeasurementUnit;
  static constexpr eMeasurementUnit SECONDS = InternalDimension_eMeasurementUnit_SECONDS;
  static constexpr eMeasurementUnit MINUTES = InternalDimension_eMeasurementUnit_MINUTES;
  static constexpr eMeasurementUnit HOURS = InternalDimension_eMeasurementUnit_HOURS;
  static constexpr eMeasurementUnit DAYS = InternalDimension_eMeasurementUnit_DAYS;
  static constexpr eMeasurementUnit KILOMETRES = InternalDimension_eMeasurementUnit_KILOMETRES;
  static constexpr eMeasurementUnit MILES = InternalDimension_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return InternalDimension_eMeasurementUnit_IsValid(value);
  }
  static constexpr eMeasurementUnit eMeasurementUnit_MIN = InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN;
  static constexpr eMeasurementUnit eMeasurementUnit_MAX = InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX;
  static constexpr int eMeasurementUnit_ARRAYSIZE = InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* eMeasurementUnit_descriptor() {
    return InternalDimension_eMeasurementUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& eMeasurementUnit_Name(T value) {
    return InternalDimension_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(absl::string_view name, eMeasurementUnit* value) {
    return InternalDimension_eMeasurementUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMeasurementUnitFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
  bool has_measurementunit() const;
  void clear_measurementunit() ;
  ::NS3::InternalDimension_eMeasurementUnit measurementunit() const;
  void set_measurementunit(::NS3::InternalDimension_eMeasurementUnit value);

  private:
  ::NS3::InternalDimension_eMeasurementUnit _internal_measurementunit() const;
  void _internal_set_measurementunit(::NS3::InternalDimension_eMeasurementUnit value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.InternalDimension)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    int measurementunit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class UserDimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.UserDimension) */ {
 public:
  inline UserDimension() : UserDimension(nullptr) {}
  ~UserDimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserDimension(::google::protobuf::internal::ConstantInitialized);

  UserDimension(const UserDimension& from);
  UserDimension(UserDimension&& from) noexcept
    : UserDimension() {
    *this = ::std::move(from);
  }

  inline UserDimension& operator=(const UserDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDimension& operator=(UserDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDimension* internal_default_instance() {
    return reinterpret_cast<const UserDimension*>(
               &_UserDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserDimension& a, UserDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserDimension& from) {
    UserDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.UserDimension";
  }
  protected:
  explicit UserDimension(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUnitsFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string units = 2;
  bool has_units() const;
  void clear_units() ;
  const std::string& units() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_units(Arg_&& arg, Args_... args);
  std::string* mutable_units();
  PROTOBUF_NODISCARD std::string* release_units();
  void set_allocated_units(std::string* ptr);

  private:
  const std::string& _internal_units() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_units(
      const std::string& value);
  std::string* _internal_mutable_units();

  public:
  // @@protoc_insertion_point(class_scope:NS3.UserDimension)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 33, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr units_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class DimensionConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.DimensionConfiguration) */ {
 public:
  inline DimensionConfiguration() : DimensionConfiguration(nullptr) {}
  ~DimensionConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DimensionConfiguration(::google::protobuf::internal::ConstantInitialized);

  DimensionConfiguration(const DimensionConfiguration& from);
  DimensionConfiguration(DimensionConfiguration&& from) noexcept
    : DimensionConfiguration() {
    *this = ::std::move(from);
  }

  inline DimensionConfiguration& operator=(const DimensionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DimensionConfiguration& operator=(DimensionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DimensionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DimensionConfiguration* internal_default_instance() {
    return reinterpret_cast<const DimensionConfiguration*>(
               &_DimensionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DimensionConfiguration& a, DimensionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(DimensionConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DimensionConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DimensionConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DimensionConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DimensionConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DimensionConfiguration& from) {
    DimensionConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.DimensionConfiguration";
  }
  protected:
  explicit DimensionConfiguration(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDimensionsFieldNumber = 3,
    kTimeConfigFieldNumber = 1,
    kDistanceConfigFieldNumber = 2,
  };
  // repeated .NS3.UserDimension userDimensions = 3;
  int userdimensions_size() const;
  private:
  int _internal_userdimensions_size() const;

  public:
  void clear_userdimensions() ;
  ::NS3::UserDimension* mutable_userdimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >*
      mutable_userdimensions();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::UserDimension>& _internal_userdimensions() const;
  ::google::protobuf::RepeatedPtrField<::NS3::UserDimension>* _internal_mutable_userdimensions();
  public:
  const ::NS3::UserDimension& userdimensions(int index) const;
  ::NS3::UserDimension* add_userdimensions();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >&
      userdimensions() const;
  // optional .NS3.InternalDimension timeConfig = 1;
  bool has_timeconfig() const;
  void clear_timeconfig() ;
  const ::NS3::InternalDimension& timeconfig() const;
  PROTOBUF_NODISCARD ::NS3::InternalDimension* release_timeconfig();
  ::NS3::InternalDimension* mutable_timeconfig();
  void set_allocated_timeconfig(::NS3::InternalDimension* value);
  void unsafe_arena_set_allocated_timeconfig(::NS3::InternalDimension* value);
  ::NS3::InternalDimension* unsafe_arena_release_timeconfig();

  private:
  const ::NS3::InternalDimension& _internal_timeconfig() const;
  ::NS3::InternalDimension* _internal_mutable_timeconfig();

  public:
  // optional .NS3.InternalDimension distanceConfig = 2;
  bool has_distanceconfig() const;
  void clear_distanceconfig() ;
  const ::NS3::InternalDimension& distanceconfig() const;
  PROTOBUF_NODISCARD ::NS3::InternalDimension* release_distanceconfig();
  ::NS3::InternalDimension* mutable_distanceconfig();
  void set_allocated_distanceconfig(::NS3::InternalDimension* value);
  void unsafe_arena_set_allocated_distanceconfig(::NS3::InternalDimension* value);
  ::NS3::InternalDimension* unsafe_arena_release_distanceconfig();

  private:
  const ::NS3::InternalDimension& _internal_distanceconfig() const;
  ::NS3::InternalDimension* _internal_mutable_distanceconfig();

  public:
  // @@protoc_insertion_point(class_scope:NS3.DimensionConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension > userdimensions_;
    ::NS3::InternalDimension* timeconfig_;
    ::NS3::InternalDimension* distanceconfig_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Geocode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Geocode) */ {
 public:
  inline Geocode() : Geocode(nullptr) {}
  ~Geocode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Geocode(::google::protobuf::internal::ConstantInitialized);

  Geocode(const Geocode& from);
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geocode& operator=(Geocode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geocode& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }
  inline void Swap(Geocode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geocode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geocode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geocode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Geocode& from) {
    Geocode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Geocode";
  }
  protected:
  explicit Geocode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.Geocode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float longitude_;
    float latitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class UnitDimensionCost final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.UnitDimensionCost) */ {
 public:
  inline UnitDimensionCost() : UnitDimensionCost(nullptr) {}
  ~UnitDimensionCost() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnitDimensionCost(::google::protobuf::internal::ConstantInitialized);

  UnitDimensionCost(const UnitDimensionCost& from);
  UnitDimensionCost(UnitDimensionCost&& from) noexcept
    : UnitDimensionCost() {
    *this = ::std::move(from);
  }

  inline UnitDimensionCost& operator=(const UnitDimensionCost& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitDimensionCost& operator=(UnitDimensionCost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnitDimensionCost& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnitDimensionCost* internal_default_instance() {
    return reinterpret_cast<const UnitDimensionCost*>(
               &_UnitDimensionCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UnitDimensionCost& a, UnitDimensionCost& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitDimensionCost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitDimensionCost* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnitDimensionCost* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnitDimensionCost>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnitDimensionCost& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UnitDimensionCost& from) {
    UnitDimensionCost::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitDimensionCost* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.UnitDimensionCost";
  }
  protected:
  explicit UnitDimensionCost(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdsFieldNumber = 1,
    kDimensionCoefficientsFieldNumber = 2,
    kCostPerUnitFieldNumber = 3,
  };
  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  private:
  int _internal_dimensionids_size() const;

  public:
  void clear_dimensionids() ;
  const std::string& dimensionids(int index) const;
  std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const std::string& value);
  void set_dimensionids(int index, std::string&& value);
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, std::size_t size);
  void set_dimensionids(int index, absl::string_view value);
  std::string* add_dimensionids();
  void add_dimensionids(const std::string& value);
  void add_dimensionids(std::string&& value);
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, std::size_t size);
  void add_dimensionids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dimensionids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dimensionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dimensionids();

  public:
  // repeated float dimensionCoefficients = 2;
  int dimensioncoefficients_size() const;
  private:
  int _internal_dimensioncoefficients_size() const;

  public:
  void clear_dimensioncoefficients() ;
  float dimensioncoefficients(int index) const;
  void set_dimensioncoefficients(int index, float value);
  void add_dimensioncoefficients(float value);
  const ::google::protobuf::RepeatedField<float>& dimensioncoefficients() const;
  ::google::protobuf::RepeatedField<float>* mutable_dimensioncoefficients();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_dimensioncoefficients() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_dimensioncoefficients();

  public:
  // required float costPerUnit = 3;
  bool has_costperunit() const;
  void clear_costperunit() ;
  float costperunit() const;
  void set_costperunit(float value);

  private:
  float _internal_costperunit() const;
  void _internal_set_costperunit(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.UnitDimensionCost)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 42, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> dimensionids_;
    ::google::protobuf::RepeatedField<float> dimensioncoefficients_;
    float costperunit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class FixedDimensionCost final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.FixedDimensionCost) */ {
 public:
  inline FixedDimensionCost() : FixedDimensionCost(nullptr) {}
  ~FixedDimensionCost() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FixedDimensionCost(::google::protobuf::internal::ConstantInitialized);

  FixedDimensionCost(const FixedDimensionCost& from);
  FixedDimensionCost(FixedDimensionCost&& from) noexcept
    : FixedDimensionCost() {
    *this = ::std::move(from);
  }

  inline FixedDimensionCost& operator=(const FixedDimensionCost& from) {
    CopyFrom(from);
    return *this;
  }
  inline FixedDimensionCost& operator=(FixedDimensionCost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FixedDimensionCost& default_instance() {
    return *internal_default_instance();
  }
  static inline const FixedDimensionCost* internal_default_instance() {
    return reinterpret_cast<const FixedDimensionCost*>(
               &_FixedDimensionCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FixedDimensionCost& a, FixedDimensionCost& b) {
    a.Swap(&b);
  }
  inline void Swap(FixedDimensionCost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FixedDimensionCost* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FixedDimensionCost* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FixedDimensionCost>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FixedDimensionCost& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FixedDimensionCost& from) {
    FixedDimensionCost::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixedDimensionCost* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.FixedDimensionCost";
  }
  protected:
  explicit FixedDimensionCost(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdsFieldNumber = 1,
    kFixedCostFieldNumber = 2,
  };
  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  private:
  int _internal_dimensionids_size() const;

  public:
  void clear_dimensionids() ;
  const std::string& dimensionids(int index) const;
  std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const std::string& value);
  void set_dimensionids(int index, std::string&& value);
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, std::size_t size);
  void set_dimensionids(int index, absl::string_view value);
  std::string* add_dimensionids();
  void add_dimensionids(const std::string& value);
  void add_dimensionids(std::string&& value);
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, std::size_t size);
  void add_dimensionids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dimensionids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dimensionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dimensionids();

  public:
  // required float fixedCost = 2;
  bool has_fixedcost() const;
  void clear_fixedcost() ;
  float fixedcost() const;
  void set_fixedcost(float value);

  private:
  float _internal_fixedcost() const;
  void _internal_set_fixedcost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.FixedDimensionCost)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 43, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> dimensionids_;
    float fixedcost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class FlowDimensionalConstraint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.FlowDimensionalConstraint) */ {
 public:
  inline FlowDimensionalConstraint() : FlowDimensionalConstraint(nullptr) {}
  ~FlowDimensionalConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowDimensionalConstraint(::google::protobuf::internal::ConstantInitialized);

  FlowDimensionalConstraint(const FlowDimensionalConstraint& from);
  FlowDimensionalConstraint(FlowDimensionalConstraint&& from) noexcept
    : FlowDimensionalConstraint() {
    *this = ::std::move(from);
  }

  inline FlowDimensionalConstraint& operator=(const FlowDimensionalConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowDimensionalConstraint& operator=(FlowDimensionalConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowDimensionalConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowDimensionalConstraint* internal_default_instance() {
    return reinterpret_cast<const FlowDimensionalConstraint*>(
               &_FlowDimensionalConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlowDimensionalConstraint& a, FlowDimensionalConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowDimensionalConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowDimensionalConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowDimensionalConstraint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowDimensionalConstraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowDimensionalConstraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FlowDimensionalConstraint& from) {
    FlowDimensionalConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowDimensionalConstraint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.FlowDimensionalConstraint";
  }
  protected:
  explicit FlowDimensionalConstraint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdsFieldNumber = 1,
    kDimensionCoefficientsFieldNumber = 2,
    kFlowMinFieldNumber = 3,
    kFlowMaxFieldNumber = 4,
  };
  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  private:
  int _internal_dimensionids_size() const;

  public:
  void clear_dimensionids() ;
  const std::string& dimensionids(int index) const;
  std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const std::string& value);
  void set_dimensionids(int index, std::string&& value);
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, std::size_t size);
  void set_dimensionids(int index, absl::string_view value);
  std::string* add_dimensionids();
  void add_dimensionids(const std::string& value);
  void add_dimensionids(std::string&& value);
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, std::size_t size);
  void add_dimensionids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dimensionids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dimensionids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dimensionids();

  public:
  // repeated float dimensionCoefficients = 2;
  int dimensioncoefficients_size() const;
  private:
  int _internal_dimensioncoefficients_size() const;

  public:
  void clear_dimensioncoefficients() ;
  float dimensioncoefficients(int index) const;
  void set_dimensioncoefficients(int index, float value);
  void add_dimensioncoefficients(float value);
  const ::google::protobuf::RepeatedField<float>& dimensioncoefficients() const;
  ::google::protobuf::RepeatedField<float>* mutable_dimensioncoefficients();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_dimensioncoefficients() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_dimensioncoefficients();

  public:
  // required float flowMin = 3;
  bool has_flowmin() const;
  void clear_flowmin() ;
  float flowmin() const;
  void set_flowmin(float value);

  private:
  float _internal_flowmin() const;
  void _internal_set_flowmin(float value);

  public:
  // required float flowMax = 4;
  bool has_flowmax() const;
  void clear_flowmax() ;
  float flowmax() const;
  void set_flowmax(float value);

  private:
  float _internal_flowmax() const;
  void _internal_set_flowmax(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.FlowDimensionalConstraint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> dimensionids_;
    ::google::protobuf::RepeatedField<float> dimensioncoefficients_;
    float flowmin_;
    float flowmax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class DimensionRange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.DimensionRange) */ {
 public:
  inline DimensionRange() : DimensionRange(nullptr) {}
  ~DimensionRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DimensionRange(::google::protobuf::internal::ConstantInitialized);

  DimensionRange(const DimensionRange& from);
  DimensionRange(DimensionRange&& from) noexcept
    : DimensionRange() {
    *this = ::std::move(from);
  }

  inline DimensionRange& operator=(const DimensionRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DimensionRange& operator=(DimensionRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DimensionRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const DimensionRange* internal_default_instance() {
    return reinterpret_cast<const DimensionRange*>(
               &_DimensionRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DimensionRange& a, DimensionRange& b) {
    a.Swap(&b);
  }
  inline void Swap(DimensionRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DimensionRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DimensionRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DimensionRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DimensionRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DimensionRange& from) {
    DimensionRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.DimensionRange";
  }
  protected:
  explicit DimensionRange(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionIdFieldNumber = 1,
    kMinRangeFieldNumber = 2,
    kMaxRangeFieldNumber = 3,
    kFlowPenaltyFieldNumber = 4,
  };
  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid() ;
  const std::string& dimensionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensionid(Arg_&& arg, Args_... args);
  std::string* mutable_dimensionid();
  PROTOBUF_NODISCARD std::string* release_dimensionid();
  void set_allocated_dimensionid(std::string* ptr);

  private:
  const std::string& _internal_dimensionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensionid(
      const std::string& value);
  std::string* _internal_mutable_dimensionid();

  public:
  // required float minRange = 2 [default = 0];
  bool has_minrange() const;
  void clear_minrange() ;
  float minrange() const;
  void set_minrange(float value);

  private:
  float _internal_minrange() const;
  void _internal_set_minrange(float value);

  public:
  // required float maxRange = 3;
  bool has_maxrange() const;
  void clear_maxrange() ;
  float maxrange() const;
  void set_maxrange(float value);

  private:
  float _internal_maxrange() const;
  void _internal_set_maxrange(float value);

  public:
  // required float flowPenalty = 4 [default = 0];
  bool has_flowpenalty() const;
  void clear_flowpenalty() ;
  float flowpenalty() const;
  void set_flowpenalty(float value);

  private:
  float _internal_flowpenalty() const;
  void _internal_set_flowpenalty(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.DimensionRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dimensionid_;
    float minrange_;
    float maxrange_;
    float flowpenalty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Node_ProductFlow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductFlow) */ {
 public:
  inline Node_ProductFlow() : Node_ProductFlow(nullptr) {}
  ~Node_ProductFlow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node_ProductFlow(::google::protobuf::internal::ConstantInitialized);

  Node_ProductFlow(const Node_ProductFlow& from);
  Node_ProductFlow(Node_ProductFlow&& from) noexcept
    : Node_ProductFlow() {
    *this = ::std::move(from);
  }

  inline Node_ProductFlow& operator=(const Node_ProductFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node_ProductFlow& operator=(Node_ProductFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node_ProductFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node_ProductFlow* internal_default_instance() {
    return reinterpret_cast<const Node_ProductFlow*>(
               &_Node_ProductFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Node_ProductFlow& a, Node_ProductFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(Node_ProductFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node_ProductFlow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node_ProductFlow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node_ProductFlow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node_ProductFlow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node_ProductFlow& from) {
    Node_ProductFlow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductFlow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Node.ProductFlow";
  }
  protected:
  explicit Node_ProductFlow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionRangesFieldNumber = 2,
    kFixedDimensionCostsFieldNumber = 3,
    kUnitDimensionCostsFieldNumber = 4,
    kProductIdFieldNumber = 1,
  };
  // repeated .NS3.DimensionRange dimensionRanges = 2;
  int dimensionranges_size() const;
  private:
  int _internal_dimensionranges_size() const;

  public:
  void clear_dimensionranges() ;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>& _internal_dimensionranges() const;
  ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>* _internal_mutable_dimensionranges();
  public:
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;
  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
  int fixeddimensioncosts_size() const;
  private:
  int _internal_fixeddimensioncosts_size() const;

  public:
  void clear_fixeddimensioncosts() ;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>& _internal_fixeddimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>* _internal_mutable_fixeddimensioncosts();
  public:
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  int unitdimensioncosts_size() const;
  private:
  int _internal_unitdimensioncosts_size() const;

  public:
  void clear_unitdimensioncosts() ;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>& _internal_unitdimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>* _internal_mutable_unitdimensioncosts();
  public:
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;
  // required string productId = 1;
  bool has_productid() const;
  void clear_productid() ;
  const std::string& productid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productid(Arg_&& arg, Args_... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* ptr);

  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(
      const std::string& value);
  std::string* _internal_mutable_productid();

  public:
  // @@protoc_insertion_point(class_scope:NS3.Node.ProductFlow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 3, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
    ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
    ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
    ::google::protobuf::internal::ArenaStringPtr productid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Node_Flow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.Flow) */ {
 public:
  inline Node_Flow() : Node_Flow(nullptr) {}
  ~Node_Flow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node_Flow(::google::protobuf::internal::ConstantInitialized);

  Node_Flow(const Node_Flow& from);
  Node_Flow(Node_Flow&& from) noexcept
    : Node_Flow() {
    *this = ::std::move(from);
  }

  inline Node_Flow& operator=(const Node_Flow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node_Flow& operator=(Node_Flow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node_Flow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node_Flow* internal_default_instance() {
    return reinterpret_cast<const Node_Flow*>(
               &_Node_Flow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Node_Flow& a, Node_Flow& b) {
    a.Swap(&b);
  }
  inline void Swap(Node_Flow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node_Flow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node_Flow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node_Flow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node_Flow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node_Flow& from) {
    Node_Flow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_Flow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Node.Flow";
  }
  protected:
  explicit Node_Flow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionRangesFieldNumber = 1,
    kFixedDimensionCostsFieldNumber = 2,
    kUnitDimensionCostsFieldNumber = 3,
  };
  // repeated .NS3.DimensionRange dimensionRanges = 1;
  int dimensionranges_size() const;
  private:
  int _internal_dimensionranges_size() const;

  public:
  void clear_dimensionranges() ;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>& _internal_dimensionranges() const;
  ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>* _internal_mutable_dimensionranges();
  public:
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;
  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
  int fixeddimensioncosts_size() const;
  private:
  int _internal_fixeddimensioncosts_size() const;

  public:
  void clear_fixeddimensioncosts() ;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>& _internal_fixeddimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>* _internal_mutable_fixeddimensioncosts();
  public:
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
  int unitdimensioncosts_size() const;
  private:
  int _internal_unitdimensioncosts_size() const;

  public:
  void clear_unitdimensioncosts() ;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>& _internal_unitdimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>* _internal_mutable_unitdimensioncosts();
  public:
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;
  // @@protoc_insertion_point(class_scope:NS3.Node.Flow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
    ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
    ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Node_ProductTransform_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductTransform.Item) */ {
 public:
  inline Node_ProductTransform_Item() : Node_ProductTransform_Item(nullptr) {}
  ~Node_ProductTransform_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node_ProductTransform_Item(::google::protobuf::internal::ConstantInitialized);

  Node_ProductTransform_Item(const Node_ProductTransform_Item& from);
  Node_ProductTransform_Item(Node_ProductTransform_Item&& from) noexcept
    : Node_ProductTransform_Item() {
    *this = ::std::move(from);
  }

  inline Node_ProductTransform_Item& operator=(const Node_ProductTransform_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node_ProductTransform_Item& operator=(Node_ProductTransform_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node_ProductTransform_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node_ProductTransform_Item* internal_default_instance() {
    return reinterpret_cast<const Node_ProductTransform_Item*>(
               &_Node_ProductTransform_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Node_ProductTransform_Item& a, Node_ProductTransform_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Node_ProductTransform_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node_ProductTransform_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node_ProductTransform_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node_ProductTransform_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node_ProductTransform_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node_ProductTransform_Item& from) {
    Node_ProductTransform_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductTransform_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Node.ProductTransform.Item";
  }
  protected:
  explicit Node_ProductTransform_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionRangesFieldNumber = 3,
    kFixedDimensionCostsFieldNumber = 4,
    kUnitDimensionCostsFieldNumber = 5,
    kProductIdFieldNumber = 1,
    kProductRatioFieldNumber = 2,
  };
  // repeated .NS3.DimensionRange dimensionRanges = 3;
  int dimensionranges_size() const;
  private:
  int _internal_dimensionranges_size() const;

  public:
  void clear_dimensionranges() ;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>& _internal_dimensionranges() const;
  ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>* _internal_mutable_dimensionranges();
  public:
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;
  // repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
  int fixeddimensioncosts_size() const;
  private:
  int _internal_fixeddimensioncosts_size() const;

  public:
  void clear_fixeddimensioncosts() ;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>& _internal_fixeddimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>* _internal_mutable_fixeddimensioncosts();
  public:
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
  int unitdimensioncosts_size() const;
  private:
  int _internal_unitdimensioncosts_size() const;

  public:
  void clear_unitdimensioncosts() ;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>& _internal_unitdimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>* _internal_mutable_unitdimensioncosts();
  public:
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;
  // required string productId = 1;
  bool has_productid() const;
  void clear_productid() ;
  const std::string& productid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productid(Arg_&& arg, Args_... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* ptr);

  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(
      const std::string& value);
  std::string* _internal_mutable_productid();

  public:
  // required int32 productRatio = 2;
  bool has_productratio() const;
  void clear_productratio() ;
  ::int32_t productratio() const;
  void set_productratio(::int32_t value);

  private:
  ::int32_t _internal_productratio() const;
  void _internal_set_productratio(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.Node.ProductTransform.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
    ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
    ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
    ::google::protobuf::internal::ArenaStringPtr productid_;
    ::int32_t productratio_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Node_ProductTransform final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductTransform) */ {
 public:
  inline Node_ProductTransform() : Node_ProductTransform(nullptr) {}
  ~Node_ProductTransform() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node_ProductTransform(::google::protobuf::internal::ConstantInitialized);

  Node_ProductTransform(const Node_ProductTransform& from);
  Node_ProductTransform(Node_ProductTransform&& from) noexcept
    : Node_ProductTransform() {
    *this = ::std::move(from);
  }

  inline Node_ProductTransform& operator=(const Node_ProductTransform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node_ProductTransform& operator=(Node_ProductTransform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node_ProductTransform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node_ProductTransform* internal_default_instance() {
    return reinterpret_cast<const Node_ProductTransform*>(
               &_Node_ProductTransform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Node_ProductTransform& a, Node_ProductTransform& b) {
    a.Swap(&b);
  }
  inline void Swap(Node_ProductTransform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node_ProductTransform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node_ProductTransform* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node_ProductTransform>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node_ProductTransform& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node_ProductTransform& from) {
    Node_ProductTransform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductTransform* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Node.ProductTransform";
  }
  protected:
  explicit Node_ProductTransform(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Node_ProductTransform_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kInputItemsFieldNumber = 2,
    kOutputItemsFieldNumber = 3,
    kProductTransformIdFieldNumber = 1,
  };
  // repeated .NS3.Node.ProductTransform.Item inputItems = 2;
  int inputitems_size() const;
  private:
  int _internal_inputitems_size() const;

  public:
  void clear_inputitems() ;
  ::NS3::Node_ProductTransform_Item* mutable_inputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
      mutable_inputitems();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>& _internal_inputitems() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>* _internal_mutable_inputitems();
  public:
  const ::NS3::Node_ProductTransform_Item& inputitems(int index) const;
  ::NS3::Node_ProductTransform_Item* add_inputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
      inputitems() const;
  // repeated .NS3.Node.ProductTransform.Item outputItems = 3;
  int outputitems_size() const;
  private:
  int _internal_outputitems_size() const;

  public:
  void clear_outputitems() ;
  ::NS3::Node_ProductTransform_Item* mutable_outputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
      mutable_outputitems();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>& _internal_outputitems() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>* _internal_mutable_outputitems();
  public:
  const ::NS3::Node_ProductTransform_Item& outputitems(int index) const;
  ::NS3::Node_ProductTransform_Item* add_outputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
      outputitems() const;
  // required string productTransformId = 1;
  bool has_producttransformid() const;
  void clear_producttransformid() ;
  const std::string& producttransformid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producttransformid(Arg_&& arg, Args_... args);
  std::string* mutable_producttransformid();
  PROTOBUF_NODISCARD std::string* release_producttransformid();
  void set_allocated_producttransformid(std::string* ptr);

  private:
  const std::string& _internal_producttransformid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producttransformid(
      const std::string& value);
  std::string* _internal_mutable_producttransformid();

  public:
  // @@protoc_insertion_point(class_scope:NS3.Node.ProductTransform)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item > inputitems_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item > outputitems_;
    ::google::protobuf::internal::ArenaStringPtr producttransformid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Node final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node(::google::protobuf::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Node";
  }
  protected:
  explicit Node(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Node_ProductFlow ProductFlow;
  typedef Node_Flow Flow;
  typedef Node_ProductTransform ProductTransform;

  // accessors -------------------------------------------------------

  enum : int {
    kProductionFieldNumber = 3,
    kConsumptionFieldNumber = 4,
    kProductFlowsFieldNumber = 6,
    kAllowableSourcesFieldNumber = 7,
    kFlowConstraintsFieldNumber = 9,
    kProductTransformsFieldNumber = 10,
    kIdFieldNumber = 1,
    kGeocodeFieldNumber = 2,
    kFlowFieldNumber = 5,
    kMaximumSourcesFieldNumber = 8,
  };
  // repeated .NS3.Node.ProductFlow production = 3;
  int production_size() const;
  private:
  int _internal_production_size() const;

  public:
  void clear_production() ;
  ::NS3::Node_ProductFlow* mutable_production(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_production();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>& _internal_production() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>* _internal_mutable_production();
  public:
  const ::NS3::Node_ProductFlow& production(int index) const;
  ::NS3::Node_ProductFlow* add_production();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      production() const;
  // repeated .NS3.Node.ProductFlow consumption = 4;
  int consumption_size() const;
  private:
  int _internal_consumption_size() const;

  public:
  void clear_consumption() ;
  ::NS3::Node_ProductFlow* mutable_consumption(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_consumption();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>& _internal_consumption() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>* _internal_mutable_consumption();
  public:
  const ::NS3::Node_ProductFlow& consumption(int index) const;
  ::NS3::Node_ProductFlow* add_consumption();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      consumption() const;
  // repeated .NS3.Node.ProductFlow productFlows = 6;
  int productflows_size() const;
  private:
  int _internal_productflows_size() const;

  public:
  void clear_productflows() ;
  ::NS3::Node_ProductFlow* mutable_productflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_productflows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>& _internal_productflows() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>* _internal_mutable_productflows();
  public:
  const ::NS3::Node_ProductFlow& productflows(int index) const;
  ::NS3::Node_ProductFlow* add_productflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      productflows() const;
  // repeated string allowableSources = 7;
  int allowablesources_size() const;
  private:
  int _internal_allowablesources_size() const;

  public:
  void clear_allowablesources() ;
  const std::string& allowablesources(int index) const;
  std::string* mutable_allowablesources(int index);
  void set_allowablesources(int index, const std::string& value);
  void set_allowablesources(int index, std::string&& value);
  void set_allowablesources(int index, const char* value);
  void set_allowablesources(int index, const char* value, std::size_t size);
  void set_allowablesources(int index, absl::string_view value);
  std::string* add_allowablesources();
  void add_allowablesources(const std::string& value);
  void add_allowablesources(std::string&& value);
  void add_allowablesources(const char* value);
  void add_allowablesources(const char* value, std::size_t size);
  void add_allowablesources(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& allowablesources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_allowablesources();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_allowablesources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_allowablesources();

  public:
  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
  int flowconstraints_size() const;
  private:
  int _internal_flowconstraints_size() const;

  public:
  void clear_flowconstraints() ;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>& _internal_flowconstraints() const;
  ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>* _internal_mutable_flowconstraints();
  public:
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;
  // repeated .NS3.Node.ProductTransform productTransforms = 10;
  int producttransforms_size() const;
  private:
  int _internal_producttransforms_size() const;

  public:
  void clear_producttransforms() ;
  ::NS3::Node_ProductTransform* mutable_producttransforms(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >*
      mutable_producttransforms();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform>& _internal_producttransforms() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform>* _internal_mutable_producttransforms();
  public:
  const ::NS3::Node_ProductTransform& producttransforms(int index) const;
  ::NS3::Node_ProductTransform* add_producttransforms();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >&
      producttransforms() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .NS3.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode() ;
  const ::NS3::Geocode& geocode() const;
  PROTOBUF_NODISCARD ::NS3::Geocode* release_geocode();
  ::NS3::Geocode* mutable_geocode();
  void set_allocated_geocode(::NS3::Geocode* value);
  void unsafe_arena_set_allocated_geocode(::NS3::Geocode* value);
  ::NS3::Geocode* unsafe_arena_release_geocode();

  private:
  const ::NS3::Geocode& _internal_geocode() const;
  ::NS3::Geocode* _internal_mutable_geocode();

  public:
  // optional .NS3.Node.Flow flow = 5;
  bool has_flow() const;
  void clear_flow() ;
  const ::NS3::Node_Flow& flow() const;
  PROTOBUF_NODISCARD ::NS3::Node_Flow* release_flow();
  ::NS3::Node_Flow* mutable_flow();
  void set_allocated_flow(::NS3::Node_Flow* value);
  void unsafe_arena_set_allocated_flow(::NS3::Node_Flow* value);
  ::NS3::Node_Flow* unsafe_arena_release_flow();

  private:
  const ::NS3::Node_Flow& _internal_flow() const;
  ::NS3::Node_Flow* _internal_mutable_flow();

  public:
  // optional int32 maximumSources = 8 [default = -1];
  bool has_maximumsources() const;
  void clear_maximumsources() ;
  ::int32_t maximumsources() const;
  void set_maximumsources(::int32_t value);

  private:
  ::int32_t _internal_maximumsources() const;
  void _internal_set_maximumsources(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.Node)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10, 7, 43, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > production_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > consumption_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > productflows_;
    ::google::protobuf::RepeatedPtrField<std::string> allowablesources_;
    ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform > producttransforms_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::NS3::Geocode* geocode_;
    ::NS3::Node_Flow* flow_;
    ::int32_t maximumsources_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class ProductGroup_ProductSpecification final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.ProductGroup.ProductSpecification) */ {
 public:
  inline ProductGroup_ProductSpecification() : ProductGroup_ProductSpecification(nullptr) {}
  ~ProductGroup_ProductSpecification() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProductGroup_ProductSpecification(::google::protobuf::internal::ConstantInitialized);

  ProductGroup_ProductSpecification(const ProductGroup_ProductSpecification& from);
  ProductGroup_ProductSpecification(ProductGroup_ProductSpecification&& from) noexcept
    : ProductGroup_ProductSpecification() {
    *this = ::std::move(from);
  }

  inline ProductGroup_ProductSpecification& operator=(const ProductGroup_ProductSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductGroup_ProductSpecification& operator=(ProductGroup_ProductSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductGroup_ProductSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductGroup_ProductSpecification* internal_default_instance() {
    return reinterpret_cast<const ProductGroup_ProductSpecification*>(
               &_ProductGroup_ProductSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProductGroup_ProductSpecification& a, ProductGroup_ProductSpecification& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductGroup_ProductSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductGroup_ProductSpecification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductGroup_ProductSpecification* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductGroup_ProductSpecification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProductGroup_ProductSpecification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProductGroup_ProductSpecification& from) {
    ProductGroup_ProductSpecification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductGroup_ProductSpecification* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.ProductGroup.ProductSpecification";
  }
  protected:
  explicit ProductGroup_ProductSpecification(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetDimensionFieldNumber = 2,
    kTargetPerBaseFieldNumber = 3,
    kBaseDimensionFieldNumber = 1,
  };
  // repeated string targetDimension = 2;
  int targetdimension_size() const;
  private:
  int _internal_targetdimension_size() const;

  public:
  void clear_targetdimension() ;
  const std::string& targetdimension(int index) const;
  std::string* mutable_targetdimension(int index);
  void set_targetdimension(int index, const std::string& value);
  void set_targetdimension(int index, std::string&& value);
  void set_targetdimension(int index, const char* value);
  void set_targetdimension(int index, const char* value, std::size_t size);
  void set_targetdimension(int index, absl::string_view value);
  std::string* add_targetdimension();
  void add_targetdimension(const std::string& value);
  void add_targetdimension(std::string&& value);
  void add_targetdimension(const char* value);
  void add_targetdimension(const char* value, std::size_t size);
  void add_targetdimension(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& targetdimension() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_targetdimension();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_targetdimension() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_targetdimension();

  public:
  // repeated float targetPerBase = 3;
  int targetperbase_size() const;
  private:
  int _internal_targetperbase_size() const;

  public:
  void clear_targetperbase() ;
  float targetperbase(int index) const;
  void set_targetperbase(int index, float value);
  void add_targetperbase(float value);
  const ::google::protobuf::RepeatedField<float>& targetperbase() const;
  ::google::protobuf::RepeatedField<float>* mutable_targetperbase();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_targetperbase() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_targetperbase();

  public:
  // required string baseDimension = 1;
  bool has_basedimension() const;
  void clear_basedimension() ;
  const std::string& basedimension() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_basedimension(Arg_&& arg, Args_... args);
  std::string* mutable_basedimension();
  PROTOBUF_NODISCARD std::string* release_basedimension();
  void set_allocated_basedimension(std::string* ptr);

  private:
  const std::string& _internal_basedimension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_basedimension(
      const std::string& value);
  std::string* _internal_mutable_basedimension();

  public:
  // @@protoc_insertion_point(class_scope:NS3.ProductGroup.ProductSpecification)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 74, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> targetdimension_;
    ::google::protobuf::RepeatedField<float> targetperbase_;
    ::google::protobuf::internal::ArenaStringPtr basedimension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class ProductGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.ProductGroup) */ {
 public:
  inline ProductGroup() : ProductGroup(nullptr) {}
  ~ProductGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProductGroup(::google::protobuf::internal::ConstantInitialized);

  ProductGroup(const ProductGroup& from);
  ProductGroup(ProductGroup&& from) noexcept
    : ProductGroup() {
    *this = ::std::move(from);
  }

  inline ProductGroup& operator=(const ProductGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductGroup& operator=(ProductGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductGroup* internal_default_instance() {
    return reinterpret_cast<const ProductGroup*>(
               &_ProductGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProductGroup& a, ProductGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProductGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProductGroup& from) {
    ProductGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductGroup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.ProductGroup";
  }
  protected:
  explicit ProductGroup(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProductGroup_ProductSpecification ProductSpecification;

  // accessors -------------------------------------------------------

  enum : int {
    kProductSpecificationFieldNumber = 3,
    kProductIdFieldNumber = 1,
    kProductGroupIdFieldNumber = 2,
  };
  // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
  int productspecification_size() const;
  private:
  int _internal_productspecification_size() const;

  public:
  void clear_productspecification() ;
  ::NS3::ProductGroup_ProductSpecification* mutable_productspecification(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >*
      mutable_productspecification();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup_ProductSpecification>& _internal_productspecification() const;
  ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup_ProductSpecification>* _internal_mutable_productspecification();
  public:
  const ::NS3::ProductGroup_ProductSpecification& productspecification(int index) const;
  ::NS3::ProductGroup_ProductSpecification* add_productspecification();
  const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >&
      productspecification() const;
  // required string productId = 1;
  bool has_productid() const;
  void clear_productid() ;
  const std::string& productid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productid(Arg_&& arg, Args_... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* ptr);

  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(
      const std::string& value);
  std::string* _internal_mutable_productid();

  public:
  // required string productGroupId = 2;
  bool has_productgroupid() const;
  void clear_productgroupid() ;
  const std::string& productgroupid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productgroupid(Arg_&& arg, Args_... args);
  std::string* mutable_productgroupid();
  PROTOBUF_NODISCARD std::string* release_productgroupid();
  void set_allocated_productgroupid(std::string* ptr);

  private:
  const std::string& _internal_productgroupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productgroupid(
      const std::string& value);
  std::string* _internal_mutable_productgroupid();

  public:
  // @@protoc_insertion_point(class_scope:NS3.ProductGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification > productspecification_;
    ::google::protobuf::internal::ArenaStringPtr productid_;
    ::google::protobuf::internal::ArenaStringPtr productgroupid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class LaneRate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.LaneRate) */ {
 public:
  inline LaneRate() : LaneRate(nullptr) {}
  ~LaneRate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneRate(::google::protobuf::internal::ConstantInitialized);

  LaneRate(const LaneRate& from);
  LaneRate(LaneRate&& from) noexcept
    : LaneRate() {
    *this = ::std::move(from);
  }

  inline LaneRate& operator=(const LaneRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneRate& operator=(LaneRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneRate* internal_default_instance() {
    return reinterpret_cast<const LaneRate*>(
               &_LaneRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LaneRate& a, LaneRate& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneRate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneRate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneRate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneRate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneRate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneRate& from) {
    LaneRate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneRate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.LaneRate";
  }
  protected:
  explicit LaneRate(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdsFieldNumber = 5,
    kProductGroupIdsFieldNumber = 6,
    kUnitDimensionCostsFieldNumber = 7,
    kFlowConstraintsFieldNumber = 8,
    kIdFieldNumber = 1,
    kSourceFieldNumber = 3,
    kDestinationFieldNumber = 4,
  };
  // repeated string productIds = 5;
  int productids_size() const;
  private:
  int _internal_productids_size() const;

  public:
  void clear_productids() ;
  const std::string& productids(int index) const;
  std::string* mutable_productids(int index);
  void set_productids(int index, const std::string& value);
  void set_productids(int index, std::string&& value);
  void set_productids(int index, const char* value);
  void set_productids(int index, const char* value, std::size_t size);
  void set_productids(int index, absl::string_view value);
  std::string* add_productids();
  void add_productids(const std::string& value);
  void add_productids(std::string&& value);
  void add_productids(const char* value);
  void add_productids(const char* value, std::size_t size);
  void add_productids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& productids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_productids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_productids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_productids();

  public:
  // repeated string productGroupIds = 6;
  int productgroupids_size() const;
  private:
  int _internal_productgroupids_size() const;

  public:
  void clear_productgroupids() ;
  const std::string& productgroupids(int index) const;
  std::string* mutable_productgroupids(int index);
  void set_productgroupids(int index, const std::string& value);
  void set_productgroupids(int index, std::string&& value);
  void set_productgroupids(int index, const char* value);
  void set_productgroupids(int index, const char* value, std::size_t size);
  void set_productgroupids(int index, absl::string_view value);
  std::string* add_productgroupids();
  void add_productgroupids(const std::string& value);
  void add_productgroupids(std::string&& value);
  void add_productgroupids(const char* value);
  void add_productgroupids(const char* value, std::size_t size);
  void add_productgroupids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& productgroupids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_productgroupids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_productgroupids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_productgroupids();

  public:
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
  int unitdimensioncosts_size() const;
  private:
  int _internal_unitdimensioncosts_size() const;

  public:
  void clear_unitdimensioncosts() ;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>& _internal_unitdimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>* _internal_mutable_unitdimensioncosts();
  public:
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;
  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
  int flowconstraints_size() const;
  private:
  int _internal_flowconstraints_size() const;

  public:
  void clear_flowconstraints() ;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>& _internal_flowconstraints() const;
  ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>* _internal_mutable_flowconstraints();
  public:
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string source = 3;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // required string destination = 4;
  bool has_destination() const;
  void clear_destination() ;
  const std::string& destination() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // @@protoc_insertion_point(class_scope:NS3.LaneRate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 2, 65, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> productids_;
    ::google::protobuf::RepeatedPtrField<std::string> productgroupids_;
    ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
    ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr destination_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class CostModel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.CostModel) */ {
 public:
  inline CostModel() : CostModel(nullptr) {}
  ~CostModel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CostModel(::google::protobuf::internal::ConstantInitialized);

  CostModel(const CostModel& from);
  CostModel(CostModel&& from) noexcept
    : CostModel() {
    *this = ::std::move(from);
  }

  inline CostModel& operator=(const CostModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostModel& operator=(CostModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CostModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostModel* internal_default_instance() {
    return reinterpret_cast<const CostModel*>(
               &_CostModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CostModel& a, CostModel& b) {
    a.Swap(&b);
  }
  inline void Swap(CostModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostModel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CostModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CostModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CostModel& from) {
    CostModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostModel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.CostModel";
  }
  protected:
  explicit CostModel(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductGroupIdsFieldNumber = 3,
    kUnitDimensionCostsFieldNumber = 4,
    kFlowConstraintsFieldNumber = 5,
    kIdFieldNumber = 1,
    kSourceFieldNumber = 2,
  };
  // repeated string productGroupIds = 3;
  int productgroupids_size() const;
  private:
  int _internal_productgroupids_size() const;

  public:
  void clear_productgroupids() ;
  const std::string& productgroupids(int index) const;
  std::string* mutable_productgroupids(int index);
  void set_productgroupids(int index, const std::string& value);
  void set_productgroupids(int index, std::string&& value);
  void set_productgroupids(int index, const char* value);
  void set_productgroupids(int index, const char* value, std::size_t size);
  void set_productgroupids(int index, absl::string_view value);
  std::string* add_productgroupids();
  void add_productgroupids(const std::string& value);
  void add_productgroupids(std::string&& value);
  void add_productgroupids(const char* value);
  void add_productgroupids(const char* value, std::size_t size);
  void add_productgroupids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& productgroupids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_productgroupids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_productgroupids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_productgroupids();

  public:
  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  int unitdimensioncosts_size() const;
  private:
  int _internal_unitdimensioncosts_size() const;

  public:
  void clear_unitdimensioncosts() ;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>& _internal_unitdimensioncosts() const;
  ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>* _internal_mutable_unitdimensioncosts();
  public:
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;
  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
  int flowconstraints_size() const;
  private:
  int _internal_flowconstraints_size() const;

  public:
  void clear_flowconstraints() ;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>& _internal_flowconstraints() const;
  ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>* _internal_mutable_flowconstraints();
  public:
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string source = 2;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // @@protoc_insertion_point(class_scope:NS3.CostModel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 2, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> productgroupids_;
    ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
    ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::google::protobuf::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.Model";
  }
  protected:
  explicit Model(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kLaneRatesFieldNumber = 3,
    kCostModelsFieldNumber = 4,
    kProductGroupsFieldNumber = 5,
    kDimensionsFieldNumber = 1,
  };
  // repeated .NS3.Node nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::NS3::Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node >*
      mutable_nodes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::Node>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::NS3::Node>* _internal_mutable_nodes();
  public:
  const ::NS3::Node& nodes(int index) const;
  ::NS3::Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node >&
      nodes() const;
  // repeated .NS3.LaneRate laneRates = 3;
  int lanerates_size() const;
  private:
  int _internal_lanerates_size() const;

  public:
  void clear_lanerates() ;
  ::NS3::LaneRate* mutable_lanerates(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >*
      mutable_lanerates();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::LaneRate>& _internal_lanerates() const;
  ::google::protobuf::RepeatedPtrField<::NS3::LaneRate>* _internal_mutable_lanerates();
  public:
  const ::NS3::LaneRate& lanerates(int index) const;
  ::NS3::LaneRate* add_lanerates();
  const ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >&
      lanerates() const;
  // repeated .NS3.CostModel costModels = 4;
  int costmodels_size() const;
  private:
  int _internal_costmodels_size() const;

  public:
  void clear_costmodels() ;
  ::NS3::CostModel* mutable_costmodels(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >*
      mutable_costmodels();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::CostModel>& _internal_costmodels() const;
  ::google::protobuf::RepeatedPtrField<::NS3::CostModel>* _internal_mutable_costmodels();
  public:
  const ::NS3::CostModel& costmodels(int index) const;
  ::NS3::CostModel* add_costmodels();
  const ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >&
      costmodels() const;
  // repeated .NS3.ProductGroup productGroups = 5;
  int productgroups_size() const;
  private:
  int _internal_productgroups_size() const;

  public:
  void clear_productgroups() ;
  ::NS3::ProductGroup* mutable_productgroups(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >*
      mutable_productgroups();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup>& _internal_productgroups() const;
  ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup>* _internal_mutable_productgroups();
  public:
  const ::NS3::ProductGroup& productgroups(int index) const;
  ::NS3::ProductGroup* add_productgroups();
  const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >&
      productgroups() const;
  // required .NS3.DimensionConfiguration dimensions = 1;
  bool has_dimensions() const;
  void clear_dimensions() ;
  const ::NS3::DimensionConfiguration& dimensions() const;
  PROTOBUF_NODISCARD ::NS3::DimensionConfiguration* release_dimensions();
  ::NS3::DimensionConfiguration* mutable_dimensions();
  void set_allocated_dimensions(::NS3::DimensionConfiguration* value);
  void unsafe_arena_set_allocated_dimensions(::NS3::DimensionConfiguration* value);
  ::NS3::DimensionConfiguration* unsafe_arena_release_dimensions();

  private:
  const ::NS3::DimensionConfiguration& _internal_dimensions() const;
  ::NS3::DimensionConfiguration* _internal_mutable_dimensions();

  public:
  // @@protoc_insertion_point(class_scope:NS3.Model)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 5, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::Node > nodes_;
    ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate > lanerates_;
    ::google::protobuf::RepeatedPtrField< ::NS3::CostModel > costmodels_;
    ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup > productgroups_;
    ::NS3::DimensionConfiguration* dimensions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolveRequest) */ {
 public:
  inline SolveRequest() : SolveRequest(nullptr) {}
  ~SolveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolveRequest(::google::protobuf::internal::ConstantInitialized);

  SolveRequest(const SolveRequest& from);
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SolveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolveRequest& from) {
    SolveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolveRequest";
  }
  protected:
  explicit SolveRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SolveType = SolveRequest_SolveType;
  static constexpr SolveType Optimise = SolveRequest_SolveType_Optimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static constexpr SolveType SolveType_MIN = SolveRequest_SolveType_SolveType_MIN;
  static constexpr SolveType SolveType_MAX = SolveRequest_SolveType_SolveType_MAX;
  static constexpr int SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  template <typename T>
  static inline const std::string& SolveType_Name(T value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(absl::string_view name, SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  using GeometryOutput = SolveRequest_GeometryOutput;
  static constexpr GeometryOutput None = SolveRequest_GeometryOutput_None;
  static constexpr GeometryOutput Aggregate = SolveRequest_GeometryOutput_Aggregate;
  static inline bool GeometryOutput_IsValid(int value) {
    return SolveRequest_GeometryOutput_IsValid(value);
  }
  static constexpr GeometryOutput GeometryOutput_MIN = SolveRequest_GeometryOutput_GeometryOutput_MIN;
  static constexpr GeometryOutput GeometryOutput_MAX = SolveRequest_GeometryOutput_GeometryOutput_MAX;
  static constexpr int GeometryOutput_ARRAYSIZE = SolveRequest_GeometryOutput_GeometryOutput_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GeometryOutput_descriptor() {
    return SolveRequest_GeometryOutput_descriptor();
  }
  template <typename T>
  static inline const std::string& GeometryOutput_Name(T value) {
    return SolveRequest_GeometryOutput_Name(value);
  }
  static inline bool GeometryOutput_Parse(absl::string_view name, GeometryOutput* value) {
    return SolveRequest_GeometryOutput_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModelIDFieldNumber = 2,
    kModelFieldNumber = 1,
    kSolveTypeFieldNumber = 4,
    kGeometryOutputFieldNumber = 5,
  };
  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid() ;
  const std::string& modelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modelid(Arg_&& arg, Args_... args);
  std::string* mutable_modelid();
  PROTOBUF_NODISCARD std::string* release_modelid();
  void set_allocated_modelid(std::string* ptr);

  private:
  const std::string& _internal_modelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelid(
      const std::string& value);
  std::string* _internal_mutable_modelid();

  public:
  // optional .NS3.Model model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::NS3::Model& model() const;
  PROTOBUF_NODISCARD ::NS3::Model* release_model();
  ::NS3::Model* mutable_model();
  void set_allocated_model(::NS3::Model* value);
  void unsafe_arena_set_allocated_model(::NS3::Model* value);
  ::NS3::Model* unsafe_arena_release_model();

  private:
  const ::NS3::Model& _internal_model() const;
  ::NS3::Model* _internal_mutable_model();

  public:
  // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype() ;
  ::NS3::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::NS3::SolveRequest_SolveType value);

  private:
  ::NS3::SolveRequest_SolveType _internal_solvetype() const;
  void _internal_set_solvetype(::NS3::SolveRequest_SolveType value);

  public:
  // optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
  bool has_geometryoutput() const;
  void clear_geometryoutput() ;
  ::NS3::SolveRequest_GeometryOutput geometryoutput() const;
  void set_geometryoutput(::NS3::SolveRequest_GeometryOutput value);

  private:
  ::NS3::SolveRequest_GeometryOutput _internal_geometryoutput() const;
  void _internal_set_geometryoutput(::NS3::SolveRequest_GeometryOutput value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4, 3, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr modelid_;
    ::NS3::Model* model_;
    int solvetype_;
    int geometryoutput_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Assignment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.Assignment) */ {
 public:
  inline SolutionResponse_Assignment() : SolutionResponse_Assignment(nullptr) {}
  ~SolutionResponse_Assignment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Assignment(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Assignment(const SolutionResponse_Assignment& from);
  SolutionResponse_Assignment(SolutionResponse_Assignment&& from) noexcept
    : SolutionResponse_Assignment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Assignment& operator=(const SolutionResponse_Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Assignment& operator=(SolutionResponse_Assignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Assignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Assignment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Assignment*>(
               &_SolutionResponse_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SolutionResponse_Assignment& a, SolutionResponse_Assignment& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Assignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Assignment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Assignment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Assignment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Assignment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Assignment& from) {
    SolutionResponse_Assignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Assignment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.Assignment";
  }
  protected:
  explicit SolutionResponse_Assignment(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kProductIdFieldNumber = 3,
    kLaneRateIdFieldNumber = 6,
    kCostModelIdFieldNumber = 7,
    kAmountFieldNumber = 4,
    kCostFieldNumber = 5,
    kDistanceFieldNumber = 8,
    kDurationFieldNumber = 9,
  };
  // required string source = 1;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // required string destination = 2;
  bool has_destination() const;
  void clear_destination() ;
  const std::string& destination() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // required string productId = 3;
  bool has_productid() const;
  void clear_productid() ;
  const std::string& productid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productid(Arg_&& arg, Args_... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* ptr);

  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(
      const std::string& value);
  std::string* _internal_mutable_productid();

  public:
  // optional string laneRateId = 6;
  bool has_lanerateid() const;
  void clear_lanerateid() ;
  const std::string& lanerateid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lanerateid(Arg_&& arg, Args_... args);
  std::string* mutable_lanerateid();
  PROTOBUF_NODISCARD std::string* release_lanerateid();
  void set_allocated_lanerateid(std::string* ptr);

  private:
  const std::string& _internal_lanerateid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lanerateid(
      const std::string& value);
  std::string* _internal_mutable_lanerateid();

  public:
  // optional string costModelId = 7;
  bool has_costmodelid() const;
  void clear_costmodelid() ;
  const std::string& costmodelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_costmodelid(Arg_&& arg, Args_... args);
  std::string* mutable_costmodelid();
  PROTOBUF_NODISCARD std::string* release_costmodelid();
  void set_allocated_costmodelid(std::string* ptr);

  private:
  const std::string& _internal_costmodelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_costmodelid(
      const std::string& value);
  std::string* _internal_mutable_costmodelid();

  public:
  // required float amount = 4;
  bool has_amount() const;
  void clear_amount() ;
  float amount() const;
  void set_amount(float value);

  private:
  float _internal_amount() const;
  void _internal_set_amount(float value);

  public:
  // required float cost = 5;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // required float distance = 8;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  // required float duration = 9;
  bool has_duration() const;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.Assignment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 0, 95, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr destination_;
    ::google::protobuf::internal::ArenaStringPtr productid_;
    ::google::protobuf::internal::ArenaStringPtr lanerateid_;
    ::google::protobuf::internal::ArenaStringPtr costmodelid_;
    float amount_;
    float cost_;
    float distance_;
    float duration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_NodeProductFlow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductFlow) */ {
 public:
  inline SolutionResponse_NodeProductFlow() : SolutionResponse_NodeProductFlow(nullptr) {}
  ~SolutionResponse_NodeProductFlow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_NodeProductFlow(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_NodeProductFlow(const SolutionResponse_NodeProductFlow& from);
  SolutionResponse_NodeProductFlow(SolutionResponse_NodeProductFlow&& from) noexcept
    : SolutionResponse_NodeProductFlow() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductFlow& operator=(const SolutionResponse_NodeProductFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_NodeProductFlow& operator=(SolutionResponse_NodeProductFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_NodeProductFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_NodeProductFlow* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductFlow*>(
               &_SolutionResponse_NodeProductFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SolutionResponse_NodeProductFlow& a, SolutionResponse_NodeProductFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_NodeProductFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_NodeProductFlow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_NodeProductFlow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductFlow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_NodeProductFlow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_NodeProductFlow& from) {
    SolutionResponse_NodeProductFlow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductFlow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.NodeProductFlow";
  }
  protected:
  explicit SolutionResponse_NodeProductFlow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kProductIdFieldNumber = 2,
    kInFlowFieldNumber = 3,
    kOutFlowFieldNumber = 4,
    kFlowCostFieldNumber = 5,
    kFixedCostFieldNumber = 6,
    kProductionAmountFieldNumber = 7,
    kProductionPenaltyFieldNumber = 8,
    kProductionCostFieldNumber = 9,
    kConsumptionAmountFieldNumber = 10,
    kConsumptionPenaltyFieldNumber = 11,
    kConsumptionCostFieldNumber = 12,
  };
  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid() ;
  const std::string& nodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodeid(Arg_&& arg, Args_... args);
  std::string* mutable_nodeid();
  PROTOBUF_NODISCARD std::string* release_nodeid();
  void set_allocated_nodeid(std::string* ptr);

  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(
      const std::string& value);
  std::string* _internal_mutable_nodeid();

  public:
  // required string productId = 2;
  bool has_productid() const;
  void clear_productid() ;
  const std::string& productid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productid(Arg_&& arg, Args_... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* ptr);

  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(
      const std::string& value);
  std::string* _internal_mutable_productid();

  public:
  // required float inFlow = 3;
  bool has_inflow() const;
  void clear_inflow() ;
  float inflow() const;
  void set_inflow(float value);

  private:
  float _internal_inflow() const;
  void _internal_set_inflow(float value);

  public:
  // required float outFlow = 4;
  bool has_outflow() const;
  void clear_outflow() ;
  float outflow() const;
  void set_outflow(float value);

  private:
  float _internal_outflow() const;
  void _internal_set_outflow(float value);

  public:
  // required float flowCost = 5;
  bool has_flowcost() const;
  void clear_flowcost() ;
  float flowcost() const;
  void set_flowcost(float value);

  private:
  float _internal_flowcost() const;
  void _internal_set_flowcost(float value);

  public:
  // required float fixedCost = 6;
  bool has_fixedcost() const;
  void clear_fixedcost() ;
  float fixedcost() const;
  void set_fixedcost(float value);

  private:
  float _internal_fixedcost() const;
  void _internal_set_fixedcost(float value);

  public:
  // required float productionAmount = 7;
  bool has_productionamount() const;
  void clear_productionamount() ;
  float productionamount() const;
  void set_productionamount(float value);

  private:
  float _internal_productionamount() const;
  void _internal_set_productionamount(float value);

  public:
  // required float productionPenalty = 8;
  bool has_productionpenalty() const;
  void clear_productionpenalty() ;
  float productionpenalty() const;
  void set_productionpenalty(float value);

  private:
  float _internal_productionpenalty() const;
  void _internal_set_productionpenalty(float value);

  public:
  // required float productionCost = 9;
  bool has_productioncost() const;
  void clear_productioncost() ;
  float productioncost() const;
  void set_productioncost(float value);

  private:
  float _internal_productioncost() const;
  void _internal_set_productioncost(float value);

  public:
  // required float consumptionAmount = 10;
  bool has_consumptionamount() const;
  void clear_consumptionamount() ;
  float consumptionamount() const;
  void set_consumptionamount(float value);

  private:
  float _internal_consumptionamount() const;
  void _internal_set_consumptionamount(float value);

  public:
  // required float consumptionPenalty = 11;
  bool has_consumptionpenalty() const;
  void clear_consumptionpenalty() ;
  float consumptionpenalty() const;
  void set_consumptionpenalty(float value);

  private:
  float _internal_consumptionpenalty() const;
  void _internal_set_consumptionpenalty(float value);

  public:
  // required float consumptionCost = 12;
  bool has_consumptioncost() const;
  void clear_consumptioncost() ;
  float consumptioncost() const;
  void set_consumptioncost(float value);

  private:
  float _internal_consumptioncost() const;
  void _internal_set_consumptioncost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductFlow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12, 0, 68, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nodeid_;
    ::google::protobuf::internal::ArenaStringPtr productid_;
    float inflow_;
    float outflow_;
    float flowcost_;
    float fixedcost_;
    float productionamount_;
    float productionpenalty_;
    float productioncost_;
    float consumptionamount_;
    float consumptionpenalty_;
    float consumptioncost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_NodeFlow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeFlow) */ {
 public:
  inline SolutionResponse_NodeFlow() : SolutionResponse_NodeFlow(nullptr) {}
  ~SolutionResponse_NodeFlow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_NodeFlow(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_NodeFlow(const SolutionResponse_NodeFlow& from);
  SolutionResponse_NodeFlow(SolutionResponse_NodeFlow&& from) noexcept
    : SolutionResponse_NodeFlow() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeFlow& operator=(const SolutionResponse_NodeFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_NodeFlow& operator=(SolutionResponse_NodeFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_NodeFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_NodeFlow* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeFlow*>(
               &_SolutionResponse_NodeFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SolutionResponse_NodeFlow& a, SolutionResponse_NodeFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_NodeFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_NodeFlow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_NodeFlow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_NodeFlow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_NodeFlow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_NodeFlow& from) {
    SolutionResponse_NodeFlow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeFlow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.NodeFlow";
  }
  protected:
  explicit SolutionResponse_NodeFlow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kInFlowFieldNumber = 2,
    kOutFlowFieldNumber = 3,
    kFlowCostFieldNumber = 4,
    kFixedCostFieldNumber = 5,
    kProductFlowCostFieldNumber = 6,
    kProductFixedCostFieldNumber = 7,
    kProductionAmountFieldNumber = 8,
    kProductionPenaltyFieldNumber = 9,
    kProductionCostFieldNumber = 10,
    kConsumptionAmountFieldNumber = 11,
    kConsumptionPenaltyFieldNumber = 12,
    kConsumptionCostFieldNumber = 13,
  };
  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid() ;
  const std::string& nodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodeid(Arg_&& arg, Args_... args);
  std::string* mutable_nodeid();
  PROTOBUF_NODISCARD std::string* release_nodeid();
  void set_allocated_nodeid(std::string* ptr);

  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(
      const std::string& value);
  std::string* _internal_mutable_nodeid();

  public:
  // required float inFlow = 2;
  bool has_inflow() const;
  void clear_inflow() ;
  float inflow() const;
  void set_inflow(float value);

  private:
  float _internal_inflow() const;
  void _internal_set_inflow(float value);

  public:
  // required float outFlow = 3;
  bool has_outflow() const;
  void clear_outflow() ;
  float outflow() const;
  void set_outflow(float value);

  private:
  float _internal_outflow() const;
  void _internal_set_outflow(float value);

  public:
  // required float flowCost = 4;
  bool has_flowcost() const;
  void clear_flowcost() ;
  float flowcost() const;
  void set_flowcost(float value);

  private:
  float _internal_flowcost() const;
  void _internal_set_flowcost(float value);

  public:
  // required float fixedCost = 5;
  bool has_fixedcost() const;
  void clear_fixedcost() ;
  float fixedcost() const;
  void set_fixedcost(float value);

  private:
  float _internal_fixedcost() const;
  void _internal_set_fixedcost(float value);

  public:
  // required float productFlowCost = 6;
  bool has_productflowcost() const;
  void clear_productflowcost() ;
  float productflowcost() const;
  void set_productflowcost(float value);

  private:
  float _internal_productflowcost() const;
  void _internal_set_productflowcost(float value);

  public:
  // required float productFixedCost = 7;
  bool has_productfixedcost() const;
  void clear_productfixedcost() ;
  float productfixedcost() const;
  void set_productfixedcost(float value);

  private:
  float _internal_productfixedcost() const;
  void _internal_set_productfixedcost(float value);

  public:
  // required float productionAmount = 8;
  bool has_productionamount() const;
  void clear_productionamount() ;
  float productionamount() const;
  void set_productionamount(float value);

  private:
  float _internal_productionamount() const;
  void _internal_set_productionamount(float value);

  public:
  // required float productionPenalty = 9;
  bool has_productionpenalty() const;
  void clear_productionpenalty() ;
  float productionpenalty() const;
  void set_productionpenalty(float value);

  private:
  float _internal_productionpenalty() const;
  void _internal_set_productionpenalty(float value);

  public:
  // required float productionCost = 10;
  bool has_productioncost() const;
  void clear_productioncost() ;
  float productioncost() const;
  void set_productioncost(float value);

  private:
  float _internal_productioncost() const;
  void _internal_set_productioncost(float value);

  public:
  // required float consumptionAmount = 11;
  bool has_consumptionamount() const;
  void clear_consumptionamount() ;
  float consumptionamount() const;
  void set_consumptionamount(float value);

  private:
  float _internal_consumptionamount() const;
  void _internal_set_consumptionamount(float value);

  public:
  // required float consumptionPenalty = 12;
  bool has_consumptionpenalty() const;
  void clear_consumptionpenalty() ;
  float consumptionpenalty() const;
  void set_consumptionpenalty(float value);

  private:
  float _internal_consumptionpenalty() const;
  void _internal_set_consumptionpenalty(float value);

  public:
  // required float consumptionCost = 13;
  bool has_consumptioncost() const;
  void clear_consumptioncost() ;
  float consumptioncost() const;
  void set_consumptioncost(float value);

  private:
  float _internal_consumptioncost() const;
  void _internal_set_consumptioncost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeFlow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nodeid_;
    float inflow_;
    float outflow_;
    float flowcost_;
    float fixedcost_;
    float productflowcost_;
    float productfixedcost_;
    float productionamount_;
    float productionpenalty_;
    float productioncost_;
    float consumptionamount_;
    float consumptionpenalty_;
    float consumptioncost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_GeometrySequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.GeometrySequence) */ {
 public:
  inline SolutionResponse_GeometrySequence() : SolutionResponse_GeometrySequence(nullptr) {}
  ~SolutionResponse_GeometrySequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_GeometrySequence(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_GeometrySequence(const SolutionResponse_GeometrySequence& from);
  SolutionResponse_GeometrySequence(SolutionResponse_GeometrySequence&& from) noexcept
    : SolutionResponse_GeometrySequence() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_GeometrySequence& operator=(const SolutionResponse_GeometrySequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_GeometrySequence& operator=(SolutionResponse_GeometrySequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_GeometrySequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_GeometrySequence* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_GeometrySequence*>(
               &_SolutionResponse_GeometrySequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SolutionResponse_GeometrySequence& a, SolutionResponse_GeometrySequence& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_GeometrySequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_GeometrySequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_GeometrySequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_GeometrySequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_GeometrySequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_GeometrySequence& from) {
    SolutionResponse_GeometrySequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_GeometrySequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.GeometrySequence";
  }
  protected:
  explicit SolutionResponse_GeometrySequence(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // repeated float x = 1;
  int x_size() const;
  private:
  int _internal_x_size() const;

  public:
  void clear_x() ;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField<float>& x() const;
  ::google::protobuf::RepeatedField<float>* mutable_x();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_x() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_x();

  public:
  // repeated float y = 2;
  int y_size() const;
  private:
  int _internal_y_size() const;

  public:
  void clear_y() ;
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::google::protobuf::RepeatedField<float>& y() const;
  ::google::protobuf::RepeatedField<float>* mutable_y();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_y() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_y();

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.GeometrySequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> x_;
    ::google::protobuf::RepeatedField<float> y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_Route final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.Route) */ {
 public:
  inline SolutionResponse_Route() : SolutionResponse_Route(nullptr) {}
  ~SolutionResponse_Route() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_Route(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_Route(const SolutionResponse_Route& from);
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_Route* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_Route* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_Route& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_Route& from) {
    SolutionResponse_Route::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.Route";
  }
  protected:
  explicit SolutionResponse_Route(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeometrySequenceFieldNumber = 3,
    kFromIdFieldNumber = 1,
    kToIdFieldNumber = 2,
  };
  // repeated int32 geometrySequence = 3;
  int geometrysequence_size() const;
  private:
  int _internal_geometrysequence_size() const;

  public:
  void clear_geometrysequence() ;
  ::int32_t geometrysequence(int index) const;
  void set_geometrysequence(int index, ::int32_t value);
  void add_geometrysequence(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& geometrysequence() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_geometrysequence();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_geometrysequence() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_geometrysequence();

  public:
  // required string fromId = 1;
  bool has_fromid() const;
  void clear_fromid() ;
  const std::string& fromid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fromid(Arg_&& arg, Args_... args);
  std::string* mutable_fromid();
  PROTOBUF_NODISCARD std::string* release_fromid();
  void set_allocated_fromid(std::string* ptr);

  private:
  const std::string& _internal_fromid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromid(
      const std::string& value);
  std::string* _internal_mutable_fromid();

  public:
  // required string toId = 2;
  bool has_toid() const;
  void clear_toid() ;
  const std::string& toid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_toid(Arg_&& arg, Args_... args);
  std::string* mutable_toid();
  PROTOBUF_NODISCARD std::string* release_toid();
  void set_allocated_toid(std::string* ptr);

  private:
  const std::string& _internal_toid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toid(
      const std::string& value);
  std::string* _internal_mutable_toid();

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.Route)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> geometrysequence_;
    ::google::protobuf::internal::ArenaStringPtr fromid_;
    ::google::protobuf::internal::ArenaStringPtr toid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_NodeProductTransformAssignment_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductTransformAssignment.Item) */ {
 public:
  inline SolutionResponse_NodeProductTransformAssignment_Item() : SolutionResponse_NodeProductTransformAssignment_Item(nullptr) {}
  ~SolutionResponse_NodeProductTransformAssignment_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_NodeProductTransformAssignment_Item(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_NodeProductTransformAssignment_Item(const SolutionResponse_NodeProductTransformAssignment_Item& from);
  SolutionResponse_NodeProductTransformAssignment_Item(SolutionResponse_NodeProductTransformAssignment_Item&& from) noexcept
    : SolutionResponse_NodeProductTransformAssignment_Item() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductTransformAssignment_Item& operator=(const SolutionResponse_NodeProductTransformAssignment_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_NodeProductTransformAssignment_Item& operator=(SolutionResponse_NodeProductTransformAssignment_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_NodeProductTransformAssignment_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_NodeProductTransformAssignment_Item* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductTransformAssignment_Item*>(
               &_SolutionResponse_NodeProductTransformAssignment_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SolutionResponse_NodeProductTransformAssignment_Item& a, SolutionResponse_NodeProductTransformAssignment_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_NodeProductTransformAssignment_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_NodeProductTransformAssignment_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_NodeProductTransformAssignment_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductTransformAssignment_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_NodeProductTransformAssignment_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_NodeProductTransformAssignment_Item& from) {
    SolutionResponse_NodeProductTransformAssignment_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductTransformAssignment_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.NodeProductTransformAssignment.Item";
  }
  protected:
  explicit SolutionResponse_NodeProductTransformAssignment_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
    kAmountFieldNumber = 2,
    kCostFieldNumber = 3,
    kFixedCostFieldNumber = 4,
    kPenaltyAmountFieldNumber = 5,
    kPenaltyCostFieldNumber = 6,
  };
  // required string productId = 1;
  bool has_productid() const;
  void clear_productid() ;
  const std::string& productid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productid(Arg_&& arg, Args_... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* ptr);

  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(
      const std::string& value);
  std::string* _internal_mutable_productid();

  public:
  // required float amount = 2;
  bool has_amount() const;
  void clear_amount() ;
  float amount() const;
  void set_amount(float value);

  private:
  float _internal_amount() const;
  void _internal_set_amount(float value);

  public:
  // required float cost = 3;
  bool has_cost() const;
  void clear_cost() ;
  float cost() const;
  void set_cost(float value);

  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);

  public:
  // required float fixedCost = 4;
  bool has_fixedcost() const;
  void clear_fixedcost() ;
  float fixedcost() const;
  void set_fixedcost(float value);

  private:
  float _internal_fixedcost() const;
  void _internal_set_fixedcost(float value);

  public:
  // required float penaltyAmount = 5;
  bool has_penaltyamount() const;
  void clear_penaltyamount() ;
  float penaltyamount() const;
  void set_penaltyamount(float value);

  private:
  float _internal_penaltyamount() const;
  void _internal_set_penaltyamount(float value);

  public:
  // required float penaltyCost = 6;
  bool has_penaltycost() const;
  void clear_penaltycost() ;
  float penaltycost() const;
  void set_penaltycost(float value);

  private:
  float _internal_penaltycost() const;
  void _internal_set_penaltycost(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 74, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr productid_;
    float amount_;
    float cost_;
    float fixedcost_;
    float penaltyamount_;
    float penaltycost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse_NodeProductTransformAssignment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductTransformAssignment) */ {
 public:
  inline SolutionResponse_NodeProductTransformAssignment() : SolutionResponse_NodeProductTransformAssignment(nullptr) {}
  ~SolutionResponse_NodeProductTransformAssignment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse_NodeProductTransformAssignment(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse_NodeProductTransformAssignment(const SolutionResponse_NodeProductTransformAssignment& from);
  SolutionResponse_NodeProductTransformAssignment(SolutionResponse_NodeProductTransformAssignment&& from) noexcept
    : SolutionResponse_NodeProductTransformAssignment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductTransformAssignment& operator=(const SolutionResponse_NodeProductTransformAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse_NodeProductTransformAssignment& operator=(SolutionResponse_NodeProductTransformAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse_NodeProductTransformAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse_NodeProductTransformAssignment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductTransformAssignment*>(
               &_SolutionResponse_NodeProductTransformAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SolutionResponse_NodeProductTransformAssignment& a, SolutionResponse_NodeProductTransformAssignment& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse_NodeProductTransformAssignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse_NodeProductTransformAssignment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse_NodeProductTransformAssignment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductTransformAssignment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse_NodeProductTransformAssignment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse_NodeProductTransformAssignment& from) {
    SolutionResponse_NodeProductTransformAssignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductTransformAssignment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse.NodeProductTransformAssignment";
  }
  protected:
  explicit SolutionResponse_NodeProductTransformAssignment(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_NodeProductTransformAssignment_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kInputItemsFieldNumber = 3,
    kOutputItemsFieldNumber = 4,
    kNodeIdFieldNumber = 1,
    kProductTransformIdFieldNumber = 2,
  };
  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
  int inputitems_size() const;
  private:
  int _internal_inputitems_size() const;

  public:
  void clear_inputitems() ;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* mutable_inputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
      mutable_inputitems();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>& _internal_inputitems() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>* _internal_mutable_inputitems();
  public:
  const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& inputitems(int index) const;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* add_inputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
      inputitems() const;
  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
  int outputitems_size() const;
  private:
  int _internal_outputitems_size() const;

  public:
  void clear_outputitems() ;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* mutable_outputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
      mutable_outputitems();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>& _internal_outputitems() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>* _internal_mutable_outputitems();
  public:
  const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& outputitems(int index) const;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* add_outputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
      outputitems() const;
  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid() ;
  const std::string& nodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodeid(Arg_&& arg, Args_... args);
  std::string* mutable_nodeid();
  PROTOBUF_NODISCARD std::string* release_nodeid();
  void set_allocated_nodeid(std::string* ptr);

  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(
      const std::string& value);
  std::string* _internal_mutable_nodeid();

  public:
  // required string productTransformId = 2;
  bool has_producttransformid() const;
  void clear_producttransformid() ;
  const std::string& producttransformid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producttransformid(Arg_&& arg, Args_... args);
  std::string* mutable_producttransformid();
  PROTOBUF_NODISCARD std::string* release_producttransformid();
  void set_allocated_producttransformid(std::string* ptr);

  private:
  const std::string& _internal_producttransformid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producttransformid(
      const std::string& value);
  std::string* _internal_mutable_producttransformid();

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductTransformAssignment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 84, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item > inputitems_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item > outputitems_;
    ::google::protobuf::internal::ArenaStringPtr nodeid_;
    ::google::protobuf::internal::ArenaStringPtr producttransformid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};// -------------------------------------------------------------------

class SolutionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse) */ {
 public:
  inline SolutionResponse() : SolutionResponse(nullptr) {}
  ~SolutionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SolutionResponse(::google::protobuf::internal::ConstantInitialized);

  SolutionResponse(const SolutionResponse& from);
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolutionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SolutionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolutionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolutionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SolutionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SolutionResponse& from) {
    SolutionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NS3.SolutionResponse";
  }
  protected:
  explicit SolutionResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Assignment Assignment;
  typedef SolutionResponse_NodeProductFlow NodeProductFlow;
  typedef SolutionResponse_NodeFlow NodeFlow;
  typedef SolutionResponse_GeometrySequence GeometrySequence;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_NodeProductTransformAssignment NodeProductTransformAssignment;

  // accessors -------------------------------------------------------

  enum : int {
    kAssignmentsFieldNumber = 4,
    kNodeFlowsFieldNumber = 5,
    kNodeProductFlowsFieldNumber = 6,
    kGeometrySequenceFieldNumber = 7,
    kRoutesFieldNumber = 8,
    kNodeProductTransformAssignmentsFieldNumber = 9,
    kObjectiveFieldNumber = 1,
    kLowerBoundFieldNumber = 2,
    kOptimalityGapFieldNumber = 3,
  };
  // repeated .NS3.SolutionResponse.Assignment assignments = 4;
  int assignments_size() const;
  private:
  int _internal_assignments_size() const;

  public:
  void clear_assignments() ;
  ::NS3::SolutionResponse_Assignment* mutable_assignments(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >*
      mutable_assignments();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Assignment>& _internal_assignments() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Assignment>* _internal_mutable_assignments();
  public:
  const ::NS3::SolutionResponse_Assignment& assignments(int index) const;
  ::NS3::SolutionResponse_Assignment* add_assignments();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >&
      assignments() const;
  // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
  int nodeflows_size() const;
  private:
  int _internal_nodeflows_size() const;

  public:
  void clear_nodeflows() ;
  ::NS3::SolutionResponse_NodeFlow* mutable_nodeflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >*
      mutable_nodeflows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeFlow>& _internal_nodeflows() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeFlow>* _internal_mutable_nodeflows();
  public:
  const ::NS3::SolutionResponse_NodeFlow& nodeflows(int index) const;
  ::NS3::SolutionResponse_NodeFlow* add_nodeflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >&
      nodeflows() const;
  // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
  int nodeproductflows_size() const;
  private:
  int _internal_nodeproductflows_size() const;

  public:
  void clear_nodeproductflows() ;
  ::NS3::SolutionResponse_NodeProductFlow* mutable_nodeproductflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >*
      mutable_nodeproductflows();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductFlow>& _internal_nodeproductflows() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductFlow>* _internal_mutable_nodeproductflows();
  public:
  const ::NS3::SolutionResponse_NodeProductFlow& nodeproductflows(int index) const;
  ::NS3::SolutionResponse_NodeProductFlow* add_nodeproductflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >&
      nodeproductflows() const;
  // repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
  int geometrysequence_size() const;
  private:
  int _internal_geometrysequence_size() const;

  public:
  void clear_geometrysequence() ;
  ::NS3::SolutionResponse_GeometrySequence* mutable_geometrysequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >*
      mutable_geometrysequence();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_GeometrySequence>& _internal_geometrysequence() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_GeometrySequence>* _internal_mutable_geometrysequence();
  public:
  const ::NS3::SolutionResponse_GeometrySequence& geometrysequence(int index) const;
  ::NS3::SolutionResponse_GeometrySequence* add_geometrysequence();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >&
      geometrysequence() const;
  // repeated .NS3.SolutionResponse.Route routes = 8;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::NS3::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Route>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Route>* _internal_mutable_routes();
  public:
  const ::NS3::SolutionResponse_Route& routes(int index) const;
  ::NS3::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >&
      routes() const;
  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
  int nodeproducttransformassignments_size() const;
  private:
  int _internal_nodeproducttransformassignments_size() const;

  public:
  void clear_nodeproducttransformassignments() ;
  ::NS3::SolutionResponse_NodeProductTransformAssignment* mutable_nodeproducttransformassignments(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >*
      mutable_nodeproducttransformassignments();
  private:
  const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment>& _internal_nodeproducttransformassignments() const;
  ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment>* _internal_mutable_nodeproducttransformassignments();
  public:
  const ::NS3::SolutionResponse_NodeProductTransformAssignment& nodeproducttransformassignments(int index) const;
  ::NS3::SolutionResponse_NodeProductTransformAssignment* add_nodeproducttransformassignments();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >&
      nodeproducttransformassignments() const;
  // required float objective = 1;
  bool has_objective() const;
  void clear_objective() ;
  float objective() const;
  void set_objective(float value);

  private:
  float _internal_objective() const;
  void _internal_set_objective(float value);

  public:
  // optional float lowerBound = 2;
  bool has_lowerbound() const;
  void clear_lowerbound() ;
  float lowerbound() const;
  void set_lowerbound(float value);

  private:
  float _internal_lowerbound() const;
  void _internal_set_lowerbound(float value);

  public:
  // optional float optimalityGap = 3;
  bool has_optimalitygap() const;
  void clear_optimalitygap() ;
  float optimalitygap() const;
  void set_optimalitygap(float value);

  private:
  float _internal_optimalitygap() const;
  void _internal_set_optimalitygap(float value);

  public:
  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 6, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment > assignments_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow > nodeflows_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow > nodeproductflows_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence > geometrysequence_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route > routes_;
    ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment > nodeproducttransformassignments_;
    float objective_;
    float lowerbound_;
    float optimalitygap_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ns3_2dtbfvuwtge2iq_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InternalDimension

// required string id = 1;
inline bool InternalDimension::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InternalDimension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InternalDimension::id() const {
  // @@protoc_insertion_point(field_get:NS3.InternalDimension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InternalDimension::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.InternalDimension.id)
}
inline std::string* InternalDimension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NS3.InternalDimension.id)
  return _s;
}
inline const std::string& InternalDimension::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void InternalDimension::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalDimension::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* InternalDimension::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.InternalDimension.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InternalDimension::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.InternalDimension.id)
}

// required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
inline bool InternalDimension::has_measurementunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InternalDimension::clear_measurementunit() {
  _impl_.measurementunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::NS3::InternalDimension_eMeasurementUnit InternalDimension::measurementunit() const {
  // @@protoc_insertion_point(field_get:NS3.InternalDimension.measurementUnit)
  return _internal_measurementunit();
}
inline void InternalDimension::set_measurementunit(::NS3::InternalDimension_eMeasurementUnit value) {
  _internal_set_measurementunit(value);
  // @@protoc_insertion_point(field_set:NS3.InternalDimension.measurementUnit)
}
inline ::NS3::InternalDimension_eMeasurementUnit InternalDimension::_internal_measurementunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NS3::InternalDimension_eMeasurementUnit>(_impl_.measurementunit_);
}
inline void InternalDimension::_internal_set_measurementunit(::NS3::InternalDimension_eMeasurementUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NS3::InternalDimension_eMeasurementUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.measurementunit_ = value;
}

// -------------------------------------------------------------------

// UserDimension

// required string id = 1;
inline bool UserDimension::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserDimension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserDimension::id() const {
  // @@protoc_insertion_point(field_get:NS3.UserDimension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserDimension::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.UserDimension.id)
}
inline std::string* UserDimension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NS3.UserDimension.id)
  return _s;
}
inline const std::string& UserDimension::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void UserDimension::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDimension::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* UserDimension::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.UserDimension.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserDimension::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.UserDimension.id)
}

// required string units = 2;
inline bool UserDimension::has_units() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserDimension::clear_units() {
  _impl_.units_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserDimension::units() const {
  // @@protoc_insertion_point(field_get:NS3.UserDimension.units)
  return _internal_units();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserDimension::set_units(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.units_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.UserDimension.units)
}
inline std::string* UserDimension::mutable_units() {
  std::string* _s = _internal_mutable_units();
  // @@protoc_insertion_point(field_mutable:NS3.UserDimension.units)
  return _s;
}
inline const std::string& UserDimension::_internal_units() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.units_.Get();
}
inline void UserDimension::_internal_set_units(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.units_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDimension::_internal_mutable_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.units_.Mutable( GetArenaForAllocation());
}
inline std::string* UserDimension::release_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.UserDimension.units)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.units_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.units_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserDimension::set_allocated_units(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.units_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.units_.IsDefault()) {
          _impl_.units_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.UserDimension.units)
}

// -------------------------------------------------------------------

// DimensionConfiguration

// optional .NS3.InternalDimension timeConfig = 1;
inline bool DimensionConfiguration::has_timeconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timeconfig_ != nullptr);
  return value;
}
inline void DimensionConfiguration::clear_timeconfig() {
  if (_impl_.timeconfig_ != nullptr) _impl_.timeconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NS3::InternalDimension& DimensionConfiguration::_internal_timeconfig() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NS3::InternalDimension* p = _impl_.timeconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::NS3::InternalDimension&>(::NS3::_InternalDimension_default_instance_);
}
inline const ::NS3::InternalDimension& DimensionConfiguration::timeconfig() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionConfiguration.timeConfig)
  return _internal_timeconfig();
}
inline void DimensionConfiguration::unsafe_arena_set_allocated_timeconfig(::NS3::InternalDimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeconfig_);
  }
  _impl_.timeconfig_ = reinterpret_cast<::NS3::InternalDimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NS3.DimensionConfiguration.timeConfig)
}
inline ::NS3::InternalDimension* DimensionConfiguration::release_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NS3::InternalDimension* released = _impl_.timeconfig_;
  _impl_.timeconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NS3::InternalDimension* DimensionConfiguration::unsafe_arena_release_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.DimensionConfiguration.timeConfig)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NS3::InternalDimension* temp = _impl_.timeconfig_;
  _impl_.timeconfig_ = nullptr;
  return temp;
}
inline ::NS3::InternalDimension* DimensionConfiguration::_internal_mutable_timeconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timeconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::NS3::InternalDimension>(GetArenaForAllocation());
    _impl_.timeconfig_ = reinterpret_cast<::NS3::InternalDimension*>(p);
  }
  return _impl_.timeconfig_;
}
inline ::NS3::InternalDimension* DimensionConfiguration::mutable_timeconfig() {
  ::NS3::InternalDimension* _msg = _internal_mutable_timeconfig();
  // @@protoc_insertion_point(field_mutable:NS3.DimensionConfiguration.timeConfig)
  return _msg;
}
inline void DimensionConfiguration::set_allocated_timeconfig(::NS3::InternalDimension* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NS3::InternalDimension*>(_impl_.timeconfig_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NS3::InternalDimension*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timeconfig_ = reinterpret_cast<::NS3::InternalDimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionConfiguration.timeConfig)
}

// optional .NS3.InternalDimension distanceConfig = 2;
inline bool DimensionConfiguration::has_distanceconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distanceconfig_ != nullptr);
  return value;
}
inline void DimensionConfiguration::clear_distanceconfig() {
  if (_impl_.distanceconfig_ != nullptr) _impl_.distanceconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NS3::InternalDimension& DimensionConfiguration::_internal_distanceconfig() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NS3::InternalDimension* p = _impl_.distanceconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::NS3::InternalDimension&>(::NS3::_InternalDimension_default_instance_);
}
inline const ::NS3::InternalDimension& DimensionConfiguration::distanceconfig() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionConfiguration.distanceConfig)
  return _internal_distanceconfig();
}
inline void DimensionConfiguration::unsafe_arena_set_allocated_distanceconfig(::NS3::InternalDimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distanceconfig_);
  }
  _impl_.distanceconfig_ = reinterpret_cast<::NS3::InternalDimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NS3.DimensionConfiguration.distanceConfig)
}
inline ::NS3::InternalDimension* DimensionConfiguration::release_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NS3::InternalDimension* released = _impl_.distanceconfig_;
  _impl_.distanceconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NS3::InternalDimension* DimensionConfiguration::unsafe_arena_release_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.DimensionConfiguration.distanceConfig)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NS3::InternalDimension* temp = _impl_.distanceconfig_;
  _impl_.distanceconfig_ = nullptr;
  return temp;
}
inline ::NS3::InternalDimension* DimensionConfiguration::_internal_mutable_distanceconfig() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.distanceconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::NS3::InternalDimension>(GetArenaForAllocation());
    _impl_.distanceconfig_ = reinterpret_cast<::NS3::InternalDimension*>(p);
  }
  return _impl_.distanceconfig_;
}
inline ::NS3::InternalDimension* DimensionConfiguration::mutable_distanceconfig() {
  ::NS3::InternalDimension* _msg = _internal_mutable_distanceconfig();
  // @@protoc_insertion_point(field_mutable:NS3.DimensionConfiguration.distanceConfig)
  return _msg;
}
inline void DimensionConfiguration::set_allocated_distanceconfig(::NS3::InternalDimension* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NS3::InternalDimension*>(_impl_.distanceconfig_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NS3::InternalDimension*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.distanceconfig_ = reinterpret_cast<::NS3::InternalDimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionConfiguration.distanceConfig)
}

// repeated .NS3.UserDimension userDimensions = 3;
inline int DimensionConfiguration::_internal_userdimensions_size() const {
  return _internal_userdimensions().size();
}
inline int DimensionConfiguration::userdimensions_size() const {
  return _internal_userdimensions_size();
}
inline void DimensionConfiguration::clear_userdimensions() {
  _internal_mutable_userdimensions()->Clear();
}
inline ::NS3::UserDimension* DimensionConfiguration::mutable_userdimensions(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.DimensionConfiguration.userDimensions)
  return _internal_mutable_userdimensions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >*
DimensionConfiguration::mutable_userdimensions() {
  // @@protoc_insertion_point(field_mutable_list:NS3.DimensionConfiguration.userDimensions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_userdimensions();
}
inline const ::NS3::UserDimension& DimensionConfiguration::userdimensions(int index) const {
  // @@protoc_insertion_point(field_get:NS3.DimensionConfiguration.userDimensions)
    return _internal_userdimensions().Get(index);
}
inline ::NS3::UserDimension* DimensionConfiguration::add_userdimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::UserDimension* _add = _internal_mutable_userdimensions()->Add();
  // @@protoc_insertion_point(field_add:NS3.DimensionConfiguration.userDimensions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >&
DimensionConfiguration::userdimensions() const {
  // @@protoc_insertion_point(field_list:NS3.DimensionConfiguration.userDimensions)
  return _internal_userdimensions();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::UserDimension>&
DimensionConfiguration::_internal_userdimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userdimensions_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::UserDimension>*
DimensionConfiguration::_internal_mutable_userdimensions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.userdimensions_;
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Geocode::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:NS3.Geocode.longitude)
  return _internal_longitude();
}
inline void Geocode::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:NS3.Geocode.longitude)
}
inline float Geocode::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Geocode::_internal_set_longitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_ = value;
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Geocode::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:NS3.Geocode.latitude)
  return _internal_latitude();
}
inline void Geocode::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:NS3.Geocode.latitude)
}
inline float Geocode::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Geocode::_internal_set_latitude(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// UnitDimensionCost

// repeated string dimensionIds = 1;
inline int UnitDimensionCost::_internal_dimensionids_size() const {
  return _internal_dimensionids().size();
}
inline int UnitDimensionCost::dimensionids_size() const {
  return _internal_dimensionids_size();
}
inline void UnitDimensionCost::clear_dimensionids() {
  _internal_mutable_dimensionids()->Clear();
}
inline std::string* UnitDimensionCost::add_dimensionids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_dimensionids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.UnitDimensionCost.dimensionIds)
  return _s;
}
inline const std::string& UnitDimensionCost::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.dimensionIds)
  return _internal_dimensionids().Get(index);
}
inline std::string* UnitDimensionCost::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.UnitDimensionCost.dimensionIds)
  return _internal_mutable_dimensionids()->Mutable(index);
}
inline void UnitDimensionCost::set_dimensionids(int index, const std::string& value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::set_dimensionids(int index, std::string&& value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::set_dimensionids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dimensionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::set_dimensionids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::set_dimensionids(int index, absl::string_view value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.UnitDimensionCost.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UnitDimensionCost::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.UnitDimensionCost.dimensionIds)
  return _internal_dimensionids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* UnitDimensionCost::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.UnitDimensionCost.dimensionIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensionids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UnitDimensionCost::_internal_dimensionids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UnitDimensionCost::_internal_mutable_dimensionids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensionids_;
}

// repeated float dimensionCoefficients = 2;
inline int UnitDimensionCost::_internal_dimensioncoefficients_size() const {
  return _internal_dimensioncoefficients().size();
}
inline int UnitDimensionCost::dimensioncoefficients_size() const {
  return _internal_dimensioncoefficients_size();
}
inline void UnitDimensionCost::clear_dimensioncoefficients() {
  _internal_mutable_dimensioncoefficients()->Clear();
}
inline float UnitDimensionCost::dimensioncoefficients(int index) const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.dimensionCoefficients)
  return _internal_dimensioncoefficients().Get(index);
}
inline void UnitDimensionCost::set_dimensioncoefficients(int index, float value) {
  _internal_mutable_dimensioncoefficients()->Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionCoefficients)
}
inline void UnitDimensionCost::add_dimensioncoefficients(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensioncoefficients()->Add(value);
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionCoefficients)
}
inline const ::google::protobuf::RepeatedField<float>& UnitDimensionCost::dimensioncoefficients() const {
  // @@protoc_insertion_point(field_list:NS3.UnitDimensionCost.dimensionCoefficients)
  return _internal_dimensioncoefficients();
}
inline ::google::protobuf::RepeatedField<float>* UnitDimensionCost::mutable_dimensioncoefficients() {
  // @@protoc_insertion_point(field_mutable_list:NS3.UnitDimensionCost.dimensionCoefficients)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensioncoefficients();
}

inline const ::google::protobuf::RepeatedField<float>& UnitDimensionCost::_internal_dimensioncoefficients() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensioncoefficients_;
}
inline ::google::protobuf::RepeatedField<float>* UnitDimensionCost::_internal_mutable_dimensioncoefficients() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensioncoefficients_;
}

// required float costPerUnit = 3;
inline bool UnitDimensionCost::has_costperunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UnitDimensionCost::clear_costperunit() {
  _impl_.costperunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float UnitDimensionCost::costperunit() const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.costPerUnit)
  return _internal_costperunit();
}
inline void UnitDimensionCost::set_costperunit(float value) {
  _internal_set_costperunit(value);
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.costPerUnit)
}
inline float UnitDimensionCost::_internal_costperunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costperunit_;
}
inline void UnitDimensionCost::_internal_set_costperunit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.costperunit_ = value;
}

// -------------------------------------------------------------------

// FixedDimensionCost

// repeated string dimensionIds = 1;
inline int FixedDimensionCost::_internal_dimensionids_size() const {
  return _internal_dimensionids().size();
}
inline int FixedDimensionCost::dimensionids_size() const {
  return _internal_dimensionids_size();
}
inline void FixedDimensionCost::clear_dimensionids() {
  _internal_mutable_dimensionids()->Clear();
}
inline std::string* FixedDimensionCost::add_dimensionids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_dimensionids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.FixedDimensionCost.dimensionIds)
  return _s;
}
inline const std::string& FixedDimensionCost::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FixedDimensionCost.dimensionIds)
  return _internal_dimensionids().Get(index);
}
inline std::string* FixedDimensionCost::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.FixedDimensionCost.dimensionIds)
  return _internal_mutable_dimensionids()->Mutable(index);
}
inline void FixedDimensionCost::set_dimensionids(int index, const std::string& value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::set_dimensionids(int index, std::string&& value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::set_dimensionids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dimensionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::set_dimensionids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::set_dimensionids(int index, absl::string_view value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.FixedDimensionCost.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FixedDimensionCost::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.FixedDimensionCost.dimensionIds)
  return _internal_dimensionids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* FixedDimensionCost::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FixedDimensionCost.dimensionIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensionids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FixedDimensionCost::_internal_dimensionids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FixedDimensionCost::_internal_mutable_dimensionids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensionids_;
}

// required float fixedCost = 2;
inline bool FixedDimensionCost::has_fixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FixedDimensionCost::clear_fixedcost() {
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FixedDimensionCost::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.FixedDimensionCost.fixedCost)
  return _internal_fixedcost();
}
inline void FixedDimensionCost::set_fixedcost(float value) {
  _internal_set_fixedcost(value);
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.fixedCost)
}
inline float FixedDimensionCost::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline void FixedDimensionCost::_internal_set_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fixedcost_ = value;
}

// -------------------------------------------------------------------

// FlowDimensionalConstraint

// repeated string dimensionIds = 1;
inline int FlowDimensionalConstraint::_internal_dimensionids_size() const {
  return _internal_dimensionids().size();
}
inline int FlowDimensionalConstraint::dimensionids_size() const {
  return _internal_dimensionids_size();
}
inline void FlowDimensionalConstraint::clear_dimensionids() {
  _internal_mutable_dimensionids()->Clear();
}
inline std::string* FlowDimensionalConstraint::add_dimensionids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_dimensionids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.FlowDimensionalConstraint.dimensionIds)
  return _s;
}
inline const std::string& FlowDimensionalConstraint::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.dimensionIds)
  return _internal_dimensionids().Get(index);
}
inline std::string* FlowDimensionalConstraint::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.FlowDimensionalConstraint.dimensionIds)
  return _internal_mutable_dimensionids()->Mutable(index);
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const std::string& value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, std::string&& value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dimensionids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, absl::string_view value) {
  _internal_mutable_dimensionids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensionids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FlowDimensionalConstraint::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.FlowDimensionalConstraint.dimensionIds)
  return _internal_dimensionids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* FlowDimensionalConstraint::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FlowDimensionalConstraint.dimensionIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensionids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FlowDimensionalConstraint::_internal_dimensionids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FlowDimensionalConstraint::_internal_mutable_dimensionids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensionids_;
}

// repeated float dimensionCoefficients = 2;
inline int FlowDimensionalConstraint::_internal_dimensioncoefficients_size() const {
  return _internal_dimensioncoefficients().size();
}
inline int FlowDimensionalConstraint::dimensioncoefficients_size() const {
  return _internal_dimensioncoefficients_size();
}
inline void FlowDimensionalConstraint::clear_dimensioncoefficients() {
  _internal_mutable_dimensioncoefficients()->Clear();
}
inline float FlowDimensionalConstraint::dimensioncoefficients(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return _internal_dimensioncoefficients().Get(index);
}
inline void FlowDimensionalConstraint::set_dimensioncoefficients(int index, float value) {
  _internal_mutable_dimensioncoefficients()->Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionCoefficients)
}
inline void FlowDimensionalConstraint::add_dimensioncoefficients(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dimensioncoefficients()->Add(value);
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionCoefficients)
}
inline const ::google::protobuf::RepeatedField<float>& FlowDimensionalConstraint::dimensioncoefficients() const {
  // @@protoc_insertion_point(field_list:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return _internal_dimensioncoefficients();
}
inline ::google::protobuf::RepeatedField<float>* FlowDimensionalConstraint::mutable_dimensioncoefficients() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensioncoefficients();
}

inline const ::google::protobuf::RepeatedField<float>& FlowDimensionalConstraint::_internal_dimensioncoefficients() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensioncoefficients_;
}
inline ::google::protobuf::RepeatedField<float>* FlowDimensionalConstraint::_internal_mutable_dimensioncoefficients() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensioncoefficients_;
}

// required float flowMin = 3;
inline bool FlowDimensionalConstraint::has_flowmin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FlowDimensionalConstraint::clear_flowmin() {
  _impl_.flowmin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FlowDimensionalConstraint::flowmin() const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.flowMin)
  return _internal_flowmin();
}
inline void FlowDimensionalConstraint::set_flowmin(float value) {
  _internal_set_flowmin(value);
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.flowMin)
}
inline float FlowDimensionalConstraint::_internal_flowmin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowmin_;
}
inline void FlowDimensionalConstraint::_internal_set_flowmin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.flowmin_ = value;
}

// required float flowMax = 4;
inline bool FlowDimensionalConstraint::has_flowmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FlowDimensionalConstraint::clear_flowmax() {
  _impl_.flowmax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FlowDimensionalConstraint::flowmax() const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.flowMax)
  return _internal_flowmax();
}
inline void FlowDimensionalConstraint::set_flowmax(float value) {
  _internal_set_flowmax(value);
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.flowMax)
}
inline float FlowDimensionalConstraint::_internal_flowmax() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowmax_;
}
inline void FlowDimensionalConstraint::_internal_set_flowmax(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.flowmax_ = value;
}

// -------------------------------------------------------------------

// DimensionRange

// required string dimensionId = 1;
inline bool DimensionRange::has_dimensionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DimensionRange::clear_dimensionid() {
  _impl_.dimensionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DimensionRange::dimensionid() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.dimensionId)
  return _internal_dimensionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DimensionRange::set_dimensionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.dimensionId)
}
inline std::string* DimensionRange::mutable_dimensionid() {
  std::string* _s = _internal_mutable_dimensionid();
  // @@protoc_insertion_point(field_mutable:NS3.DimensionRange.dimensionId)
  return _s;
}
inline const std::string& DimensionRange::_internal_dimensionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionid_.Get();
}
inline void DimensionRange::_internal_set_dimensionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimensionid_.Set(value, GetArenaForAllocation());
}
inline std::string* DimensionRange::_internal_mutable_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dimensionid_.Mutable( GetArenaForAllocation());
}
inline std::string* DimensionRange::release_dimensionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.DimensionRange.dimensionId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dimensionid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimensionid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DimensionRange::set_allocated_dimensionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dimensionid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensionid_.IsDefault()) {
          _impl_.dimensionid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionRange.dimensionId)
}

// required float minRange = 2 [default = 0];
inline bool DimensionRange::has_minrange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DimensionRange::clear_minrange() {
  _impl_.minrange_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float DimensionRange::minrange() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.minRange)
  return _internal_minrange();
}
inline void DimensionRange::set_minrange(float value) {
  _internal_set_minrange(value);
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.minRange)
}
inline float DimensionRange::_internal_minrange() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minrange_;
}
inline void DimensionRange::_internal_set_minrange(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.minrange_ = value;
}

// required float maxRange = 3;
inline bool DimensionRange::has_maxrange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DimensionRange::clear_maxrange() {
  _impl_.maxrange_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float DimensionRange::maxrange() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.maxRange)
  return _internal_maxrange();
}
inline void DimensionRange::set_maxrange(float value) {
  _internal_set_maxrange(value);
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.maxRange)
}
inline float DimensionRange::_internal_maxrange() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxrange_;
}
inline void DimensionRange::_internal_set_maxrange(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.maxrange_ = value;
}

// required float flowPenalty = 4 [default = 0];
inline bool DimensionRange::has_flowpenalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DimensionRange::clear_flowpenalty() {
  _impl_.flowpenalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float DimensionRange::flowpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.flowPenalty)
  return _internal_flowpenalty();
}
inline void DimensionRange::set_flowpenalty(float value) {
  _internal_set_flowpenalty(value);
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.flowPenalty)
}
inline float DimensionRange::_internal_flowpenalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowpenalty_;
}
inline void DimensionRange::_internal_set_flowpenalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.flowpenalty_ = value;
}

// -------------------------------------------------------------------

// Node_ProductFlow

// required string productId = 1;
inline bool Node_ProductFlow::has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Node_ProductFlow::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Node_ProductFlow::productid() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.productId)
  return _internal_productid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Node_ProductFlow::set_productid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.Node.ProductFlow.productId)
}
inline std::string* Node_ProductFlow::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.productId)
  return _s;
}
inline const std::string& Node_ProductFlow::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_.Get();
}
inline void Node_ProductFlow::_internal_set_productid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* Node_ProductFlow::_internal_mutable_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productid_.Mutable( GetArenaForAllocation());
}
inline std::string* Node_ProductFlow::release_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Node.ProductFlow.productId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.productid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Node_ProductFlow::set_allocated_productid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productid_.IsDefault()) {
          _impl_.productid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductFlow.productId)
}

// repeated .NS3.DimensionRange dimensionRanges = 2;
inline int Node_ProductFlow::_internal_dimensionranges_size() const {
  return _internal_dimensionranges().size();
}
inline int Node_ProductFlow::dimensionranges_size() const {
  return _internal_dimensionranges_size();
}
inline void Node_ProductFlow::clear_dimensionranges() {
  _internal_mutable_dimensionranges()->Clear();
}
inline ::NS3::DimensionRange* Node_ProductFlow::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.dimensionRanges)
  return _internal_mutable_dimensionranges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_ProductFlow::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.dimensionRanges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensionranges();
}
inline const ::NS3::DimensionRange& Node_ProductFlow::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.dimensionRanges)
    return _internal_dimensionranges().Get(index);
}
inline ::NS3::DimensionRange* Node_ProductFlow::add_dimensionranges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::DimensionRange* _add = _internal_mutable_dimensionranges()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.dimensionRanges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_ProductFlow::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.dimensionRanges)
  return _internal_dimensionranges();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>&
Node_ProductFlow::_internal_dimensionranges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionranges_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>*
Node_ProductFlow::_internal_mutable_dimensionranges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensionranges_;
}

// repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
inline int Node_ProductFlow::_internal_fixeddimensioncosts_size() const {
  return _internal_fixeddimensioncosts().size();
}
inline int Node_ProductFlow::fixeddimensioncosts_size() const {
  return _internal_fixeddimensioncosts_size();
}
inline void Node_ProductFlow::clear_fixeddimensioncosts() {
  _internal_mutable_fixeddimensioncosts()->Clear();
}
inline ::NS3::FixedDimensionCost* Node_ProductFlow::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.FixedDimensionCosts)
  return _internal_mutable_fixeddimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_ProductFlow::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.FixedDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fixeddimensioncosts();
}
inline const ::NS3::FixedDimensionCost& Node_ProductFlow::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.FixedDimensionCosts)
    return _internal_fixeddimensioncosts().Get(index);
}
inline ::NS3::FixedDimensionCost* Node_ProductFlow::add_fixeddimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::FixedDimensionCost* _add = _internal_mutable_fixeddimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.FixedDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_ProductFlow::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.FixedDimensionCosts)
  return _internal_fixeddimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>&
Node_ProductFlow::_internal_fixeddimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixeddimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>*
Node_ProductFlow::_internal_mutable_fixeddimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
inline int Node_ProductFlow::_internal_unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts().size();
}
inline int Node_ProductFlow::unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts_size();
}
inline void Node_ProductFlow::clear_unitdimensioncosts() {
  _internal_mutable_unitdimensioncosts()->Clear();
}
inline ::NS3::UnitDimensionCost* Node_ProductFlow::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.unitDimensionCosts)
  return _internal_mutable_unitdimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_ProductFlow::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.unitDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unitdimensioncosts();
}
inline const ::NS3::UnitDimensionCost& Node_ProductFlow::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.unitDimensionCosts)
    return _internal_unitdimensioncosts().Get(index);
}
inline ::NS3::UnitDimensionCost* Node_ProductFlow::add_unitdimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::UnitDimensionCost* _add = _internal_mutable_unitdimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.unitDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_ProductFlow::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.unitDimensionCosts)
  return _internal_unitdimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>&
Node_ProductFlow::_internal_unitdimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unitdimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>*
Node_ProductFlow::_internal_mutable_unitdimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_Flow

// repeated .NS3.DimensionRange dimensionRanges = 1;
inline int Node_Flow::_internal_dimensionranges_size() const {
  return _internal_dimensionranges().size();
}
inline int Node_Flow::dimensionranges_size() const {
  return _internal_dimensionranges_size();
}
inline void Node_Flow::clear_dimensionranges() {
  _internal_mutable_dimensionranges()->Clear();
}
inline ::NS3::DimensionRange* Node_Flow::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.dimensionRanges)
  return _internal_mutable_dimensionranges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_Flow::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.dimensionRanges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensionranges();
}
inline const ::NS3::DimensionRange& Node_Flow::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.dimensionRanges)
    return _internal_dimensionranges().Get(index);
}
inline ::NS3::DimensionRange* Node_Flow::add_dimensionranges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::DimensionRange* _add = _internal_mutable_dimensionranges()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.dimensionRanges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_Flow::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.dimensionRanges)
  return _internal_dimensionranges();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>&
Node_Flow::_internal_dimensionranges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionranges_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>*
Node_Flow::_internal_mutable_dimensionranges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensionranges_;
}

// repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
inline int Node_Flow::_internal_fixeddimensioncosts_size() const {
  return _internal_fixeddimensioncosts().size();
}
inline int Node_Flow::fixeddimensioncosts_size() const {
  return _internal_fixeddimensioncosts_size();
}
inline void Node_Flow::clear_fixeddimensioncosts() {
  _internal_mutable_fixeddimensioncosts()->Clear();
}
inline ::NS3::FixedDimensionCost* Node_Flow::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.FixedDimensionCosts)
  return _internal_mutable_fixeddimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_Flow::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.FixedDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fixeddimensioncosts();
}
inline const ::NS3::FixedDimensionCost& Node_Flow::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.FixedDimensionCosts)
    return _internal_fixeddimensioncosts().Get(index);
}
inline ::NS3::FixedDimensionCost* Node_Flow::add_fixeddimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::FixedDimensionCost* _add = _internal_mutable_fixeddimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.FixedDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_Flow::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.FixedDimensionCosts)
  return _internal_fixeddimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>&
Node_Flow::_internal_fixeddimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixeddimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>*
Node_Flow::_internal_mutable_fixeddimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
inline int Node_Flow::_internal_unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts().size();
}
inline int Node_Flow::unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts_size();
}
inline void Node_Flow::clear_unitdimensioncosts() {
  _internal_mutable_unitdimensioncosts()->Clear();
}
inline ::NS3::UnitDimensionCost* Node_Flow::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.unitDimensionCosts)
  return _internal_mutable_unitdimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_Flow::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.unitDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unitdimensioncosts();
}
inline const ::NS3::UnitDimensionCost& Node_Flow::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.unitDimensionCosts)
    return _internal_unitdimensioncosts().Get(index);
}
inline ::NS3::UnitDimensionCost* Node_Flow::add_unitdimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::UnitDimensionCost* _add = _internal_mutable_unitdimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.unitDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_Flow::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.unitDimensionCosts)
  return _internal_unitdimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>&
Node_Flow::_internal_unitdimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unitdimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>*
Node_Flow::_internal_mutable_unitdimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_ProductTransform_Item

// required string productId = 1;
inline bool Node_ProductTransform_Item::has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Node_ProductTransform_Item::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Node_ProductTransform_Item::productid() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.productId)
  return _internal_productid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Node_ProductTransform_Item::set_productid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.Node.ProductTransform.Item.productId)
}
inline std::string* Node_ProductTransform_Item::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.productId)
  return _s;
}
inline const std::string& Node_ProductTransform_Item::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_.Get();
}
inline void Node_ProductTransform_Item::_internal_set_productid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* Node_ProductTransform_Item::_internal_mutable_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productid_.Mutable( GetArenaForAllocation());
}
inline std::string* Node_ProductTransform_Item::release_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Node.ProductTransform.Item.productId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.productid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Node_ProductTransform_Item::set_allocated_productid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productid_.IsDefault()) {
          _impl_.productid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductTransform.Item.productId)
}

// required int32 productRatio = 2;
inline bool Node_ProductTransform_Item::has_productratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Node_ProductTransform_Item::clear_productratio() {
  _impl_.productratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Node_ProductTransform_Item::productratio() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.productRatio)
  return _internal_productratio();
}
inline void Node_ProductTransform_Item::set_productratio(::int32_t value) {
  _internal_set_productratio(value);
  // @@protoc_insertion_point(field_set:NS3.Node.ProductTransform.Item.productRatio)
}
inline ::int32_t Node_ProductTransform_Item::_internal_productratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productratio_;
}
inline void Node_ProductTransform_Item::_internal_set_productratio(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.productratio_ = value;
}

// repeated .NS3.DimensionRange dimensionRanges = 3;
inline int Node_ProductTransform_Item::_internal_dimensionranges_size() const {
  return _internal_dimensionranges().size();
}
inline int Node_ProductTransform_Item::dimensionranges_size() const {
  return _internal_dimensionranges_size();
}
inline void Node_ProductTransform_Item::clear_dimensionranges() {
  _internal_mutable_dimensionranges()->Clear();
}
inline ::NS3::DimensionRange* Node_ProductTransform_Item::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.dimensionRanges)
  return _internal_mutable_dimensionranges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_ProductTransform_Item::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.Item.dimensionRanges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dimensionranges();
}
inline const ::NS3::DimensionRange& Node_ProductTransform_Item::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.dimensionRanges)
    return _internal_dimensionranges().Get(index);
}
inline ::NS3::DimensionRange* Node_ProductTransform_Item::add_dimensionranges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::DimensionRange* _add = _internal_mutable_dimensionranges()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.Item.dimensionRanges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_ProductTransform_Item::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.Item.dimensionRanges)
  return _internal_dimensionranges();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>&
Node_ProductTransform_Item::_internal_dimensionranges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensionranges_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::DimensionRange>*
Node_ProductTransform_Item::_internal_mutable_dimensionranges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dimensionranges_;
}

// repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
inline int Node_ProductTransform_Item::_internal_fixeddimensioncosts_size() const {
  return _internal_fixeddimensioncosts().size();
}
inline int Node_ProductTransform_Item::fixeddimensioncosts_size() const {
  return _internal_fixeddimensioncosts_size();
}
inline void Node_ProductTransform_Item::clear_fixeddimensioncosts() {
  _internal_mutable_fixeddimensioncosts()->Clear();
}
inline ::NS3::FixedDimensionCost* Node_ProductTransform_Item::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return _internal_mutable_fixeddimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_ProductTransform_Item::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fixeddimensioncosts();
}
inline const ::NS3::FixedDimensionCost& Node_ProductTransform_Item::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
    return _internal_fixeddimensioncosts().Get(index);
}
inline ::NS3::FixedDimensionCost* Node_ProductTransform_Item::add_fixeddimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::FixedDimensionCost* _add = _internal_mutable_fixeddimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_ProductTransform_Item::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return _internal_fixeddimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>&
Node_ProductTransform_Item::_internal_fixeddimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixeddimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::FixedDimensionCost>*
Node_ProductTransform_Item::_internal_mutable_fixeddimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
inline int Node_ProductTransform_Item::_internal_unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts().size();
}
inline int Node_ProductTransform_Item::unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts_size();
}
inline void Node_ProductTransform_Item::clear_unitdimensioncosts() {
  _internal_mutable_unitdimensioncosts()->Clear();
}
inline ::NS3::UnitDimensionCost* Node_ProductTransform_Item::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return _internal_mutable_unitdimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_ProductTransform_Item::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unitdimensioncosts();
}
inline const ::NS3::UnitDimensionCost& Node_ProductTransform_Item::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.unitDimensionCosts)
    return _internal_unitdimensioncosts().Get(index);
}
inline ::NS3::UnitDimensionCost* Node_ProductTransform_Item::add_unitdimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::UnitDimensionCost* _add = _internal_mutable_unitdimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_ProductTransform_Item::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return _internal_unitdimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>&
Node_ProductTransform_Item::_internal_unitdimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unitdimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>*
Node_ProductTransform_Item::_internal_mutable_unitdimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_ProductTransform

// required string productTransformId = 1;
inline bool Node_ProductTransform::has_producttransformid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Node_ProductTransform::clear_producttransformid() {
  _impl_.producttransformid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Node_ProductTransform::producttransformid() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.productTransformId)
  return _internal_producttransformid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Node_ProductTransform::set_producttransformid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producttransformid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.Node.ProductTransform.productTransformId)
}
inline std::string* Node_ProductTransform::mutable_producttransformid() {
  std::string* _s = _internal_mutable_producttransformid();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.productTransformId)
  return _s;
}
inline const std::string& Node_ProductTransform::_internal_producttransformid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producttransformid_.Get();
}
inline void Node_ProductTransform::_internal_set_producttransformid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producttransformid_.Set(value, GetArenaForAllocation());
}
inline std::string* Node_ProductTransform::_internal_mutable_producttransformid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.producttransformid_.Mutable( GetArenaForAllocation());
}
inline std::string* Node_ProductTransform::release_producttransformid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Node.ProductTransform.productTransformId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.producttransformid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producttransformid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Node_ProductTransform::set_allocated_producttransformid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.producttransformid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producttransformid_.IsDefault()) {
          _impl_.producttransformid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductTransform.productTransformId)
}

// repeated .NS3.Node.ProductTransform.Item inputItems = 2;
inline int Node_ProductTransform::_internal_inputitems_size() const {
  return _internal_inputitems().size();
}
inline int Node_ProductTransform::inputitems_size() const {
  return _internal_inputitems_size();
}
inline void Node_ProductTransform::clear_inputitems() {
  _internal_mutable_inputitems()->Clear();
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::mutable_inputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.inputItems)
  return _internal_mutable_inputitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
Node_ProductTransform::mutable_inputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.inputItems)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_inputitems();
}
inline const ::NS3::Node_ProductTransform_Item& Node_ProductTransform::inputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.inputItems)
    return _internal_inputitems().Get(index);
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::add_inputitems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node_ProductTransform_Item* _add = _internal_mutable_inputitems()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.inputItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
Node_ProductTransform::inputitems() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.inputItems)
  return _internal_inputitems();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>&
Node_ProductTransform::_internal_inputitems() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inputitems_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>*
Node_ProductTransform::_internal_mutable_inputitems() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.inputitems_;
}

// repeated .NS3.Node.ProductTransform.Item outputItems = 3;
inline int Node_ProductTransform::_internal_outputitems_size() const {
  return _internal_outputitems().size();
}
inline int Node_ProductTransform::outputitems_size() const {
  return _internal_outputitems_size();
}
inline void Node_ProductTransform::clear_outputitems() {
  _internal_mutable_outputitems()->Clear();
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::mutable_outputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.outputItems)
  return _internal_mutable_outputitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
Node_ProductTransform::mutable_outputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.outputItems)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_outputitems();
}
inline const ::NS3::Node_ProductTransform_Item& Node_ProductTransform::outputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.outputItems)
    return _internal_outputitems().Get(index);
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::add_outputitems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node_ProductTransform_Item* _add = _internal_mutable_outputitems()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.outputItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
Node_ProductTransform::outputitems() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.outputItems)
  return _internal_outputitems();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>&
Node_ProductTransform::_internal_outputitems() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outputitems_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform_Item>*
Node_ProductTransform::_internal_mutable_outputitems() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.outputitems_;
}

// -------------------------------------------------------------------

// Node

// required string id = 1;
inline bool Node::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Node::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:NS3.Node.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Node::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.Node.id)
}
inline std::string* Node::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NS3.Node.id)
  return _s;
}
inline const std::string& Node::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Node::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Node::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Node.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Node::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.id)
}

// required .NS3.Geocode geocode = 2;
inline bool Node::has_geocode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geocode_ != nullptr);
  return value;
}
inline void Node::clear_geocode() {
  if (_impl_.geocode_ != nullptr) _impl_.geocode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NS3::Geocode& Node::_internal_geocode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NS3::Geocode* p = _impl_.geocode_;
  return p != nullptr ? *p : reinterpret_cast<const ::NS3::Geocode&>(::NS3::_Geocode_default_instance_);
}
inline const ::NS3::Geocode& Node::geocode() const {
  // @@protoc_insertion_point(field_get:NS3.Node.geocode)
  return _internal_geocode();
}
inline void Node::unsafe_arena_set_allocated_geocode(::NS3::Geocode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geocode_);
  }
  _impl_.geocode_ = reinterpret_cast<::NS3::Geocode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NS3.Node.geocode)
}
inline ::NS3::Geocode* Node::release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NS3::Geocode* released = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NS3::Geocode* Node::unsafe_arena_release_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Node.geocode)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NS3::Geocode* temp = _impl_.geocode_;
  _impl_.geocode_ = nullptr;
  return temp;
}
inline ::NS3::Geocode* Node::_internal_mutable_geocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.geocode_ == nullptr) {
    auto* p = CreateMaybeMessage<::NS3::Geocode>(GetArenaForAllocation());
    _impl_.geocode_ = reinterpret_cast<::NS3::Geocode*>(p);
  }
  return _impl_.geocode_;
}
inline ::NS3::Geocode* Node::mutable_geocode() {
  ::NS3::Geocode* _msg = _internal_mutable_geocode();
  // @@protoc_insertion_point(field_mutable:NS3.Node.geocode)
  return _msg;
}
inline void Node::set_allocated_geocode(::NS3::Geocode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NS3::Geocode*>(_impl_.geocode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NS3::Geocode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.geocode_ = reinterpret_cast<::NS3::Geocode*>(value);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.geocode)
}

// repeated .NS3.Node.ProductFlow production = 3;
inline int Node::_internal_production_size() const {
  return _internal_production().size();
}
inline int Node::production_size() const {
  return _internal_production_size();
}
inline void Node::clear_production() {
  _internal_mutable_production()->Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_production(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.production)
  return _internal_mutable_production()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_production() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.production)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_production();
}
inline const ::NS3::Node_ProductFlow& Node::production(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.production)
    return _internal_production().Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_production() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node_ProductFlow* _add = _internal_mutable_production()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.production)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::production() const {
  // @@protoc_insertion_point(field_list:NS3.Node.production)
  return _internal_production();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>&
Node::_internal_production() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.production_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>*
Node::_internal_mutable_production() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.production_;
}

// repeated .NS3.Node.ProductFlow consumption = 4;
inline int Node::_internal_consumption_size() const {
  return _internal_consumption().size();
}
inline int Node::consumption_size() const {
  return _internal_consumption_size();
}
inline void Node::clear_consumption() {
  _internal_mutable_consumption()->Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_consumption(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.consumption)
  return _internal_mutable_consumption()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_consumption() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.consumption)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_consumption();
}
inline const ::NS3::Node_ProductFlow& Node::consumption(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.consumption)
    return _internal_consumption().Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_consumption() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node_ProductFlow* _add = _internal_mutable_consumption()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.consumption)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::consumption() const {
  // @@protoc_insertion_point(field_list:NS3.Node.consumption)
  return _internal_consumption();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>&
Node::_internal_consumption() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumption_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>*
Node::_internal_mutable_consumption() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.consumption_;
}

// optional .NS3.Node.Flow flow = 5;
inline bool Node::has_flow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flow_ != nullptr);
  return value;
}
inline void Node::clear_flow() {
  if (_impl_.flow_ != nullptr) _impl_.flow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::NS3::Node_Flow& Node::_internal_flow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NS3::Node_Flow* p = _impl_.flow_;
  return p != nullptr ? *p : reinterpret_cast<const ::NS3::Node_Flow&>(::NS3::_Node_Flow_default_instance_);
}
inline const ::NS3::Node_Flow& Node::flow() const {
  // @@protoc_insertion_point(field_get:NS3.Node.flow)
  return _internal_flow();
}
inline void Node::unsafe_arena_set_allocated_flow(::NS3::Node_Flow* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flow_);
  }
  _impl_.flow_ = reinterpret_cast<::NS3::Node_Flow*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NS3.Node.flow)
}
inline ::NS3::Node_Flow* Node::release_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NS3::Node_Flow* released = _impl_.flow_;
  _impl_.flow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NS3::Node_Flow* Node::unsafe_arena_release_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Node.flow)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NS3::Node_Flow* temp = _impl_.flow_;
  _impl_.flow_ = nullptr;
  return temp;
}
inline ::NS3::Node_Flow* Node::_internal_mutable_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.flow_ == nullptr) {
    auto* p = CreateMaybeMessage<::NS3::Node_Flow>(GetArenaForAllocation());
    _impl_.flow_ = reinterpret_cast<::NS3::Node_Flow*>(p);
  }
  return _impl_.flow_;
}
inline ::NS3::Node_Flow* Node::mutable_flow() {
  ::NS3::Node_Flow* _msg = _internal_mutable_flow();
  // @@protoc_insertion_point(field_mutable:NS3.Node.flow)
  return _msg;
}
inline void Node::set_allocated_flow(::NS3::Node_Flow* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NS3::Node_Flow*>(_impl_.flow_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NS3::Node_Flow*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.flow_ = reinterpret_cast<::NS3::Node_Flow*>(value);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.flow)
}

// repeated .NS3.Node.ProductFlow productFlows = 6;
inline int Node::_internal_productflows_size() const {
  return _internal_productflows().size();
}
inline int Node::productflows_size() const {
  return _internal_productflows_size();
}
inline void Node::clear_productflows() {
  _internal_mutable_productflows()->Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_productflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.productFlows)
  return _internal_mutable_productflows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_productflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.productFlows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_productflows();
}
inline const ::NS3::Node_ProductFlow& Node::productflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.productFlows)
    return _internal_productflows().Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_productflows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node_ProductFlow* _add = _internal_mutable_productflows()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.productFlows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::productflows() const {
  // @@protoc_insertion_point(field_list:NS3.Node.productFlows)
  return _internal_productflows();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>&
Node::_internal_productflows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productflows_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductFlow>*
Node::_internal_mutable_productflows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.productflows_;
}

// repeated string allowableSources = 7;
inline int Node::_internal_allowablesources_size() const {
  return _internal_allowablesources().size();
}
inline int Node::allowablesources_size() const {
  return _internal_allowablesources_size();
}
inline void Node::clear_allowablesources() {
  _internal_mutable_allowablesources()->Clear();
}
inline std::string* Node::add_allowablesources() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_allowablesources()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.Node.allowableSources)
  return _s;
}
inline const std::string& Node::allowablesources(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.allowableSources)
  return _internal_allowablesources().Get(index);
}
inline std::string* Node::mutable_allowablesources(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.allowableSources)
  return _internal_mutable_allowablesources()->Mutable(index);
}
inline void Node::set_allowablesources(int index, const std::string& value) {
  _internal_mutable_allowablesources()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.Node.allowableSources)
}
inline void Node::set_allowablesources(int index, std::string&& value) {
  _internal_mutable_allowablesources()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.Node.allowableSources)
}
inline void Node::set_allowablesources(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_allowablesources()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.Node.allowableSources)
}
inline void Node::set_allowablesources(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_allowablesources()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.allowableSources)
}
inline void Node::set_allowablesources(int index, absl::string_view value) {
  _internal_mutable_allowablesources()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowablesources()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowablesources()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowablesources()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowablesources()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowablesources()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.Node.allowableSources)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Node::allowablesources() const {
  // @@protoc_insertion_point(field_list:NS3.Node.allowableSources)
  return _internal_allowablesources();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Node::mutable_allowablesources() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.allowableSources)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allowablesources();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Node::_internal_allowablesources() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowablesources_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Node::_internal_mutable_allowablesources() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allowablesources_;
}

// optional int32 maximumSources = 8 [default = -1];
inline bool Node::has_maximumsources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Node::clear_maximumsources() {
  _impl_.maximumsources_ = -1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Node::maximumsources() const {
  // @@protoc_insertion_point(field_get:NS3.Node.maximumSources)
  return _internal_maximumsources();
}
inline void Node::set_maximumsources(::int32_t value) {
  _internal_set_maximumsources(value);
  // @@protoc_insertion_point(field_set:NS3.Node.maximumSources)
}
inline ::int32_t Node::_internal_maximumsources() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maximumsources_;
}
inline void Node::_internal_set_maximumsources(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.maximumsources_ = value;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
inline int Node::_internal_flowconstraints_size() const {
  return _internal_flowconstraints().size();
}
inline int Node::flowconstraints_size() const {
  return _internal_flowconstraints_size();
}
inline void Node::clear_flowconstraints() {
  _internal_mutable_flowconstraints()->Clear();
}
inline ::NS3::FlowDimensionalConstraint* Node::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.flowConstraints)
  return _internal_mutable_flowconstraints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
Node::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.flowConstraints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_flowconstraints();
}
inline const ::NS3::FlowDimensionalConstraint& Node::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.flowConstraints)
    return _internal_flowconstraints().Get(index);
}
inline ::NS3::FlowDimensionalConstraint* Node::add_flowconstraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::FlowDimensionalConstraint* _add = _internal_mutable_flowconstraints()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.flowConstraints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
Node::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.Node.flowConstraints)
  return _internal_flowconstraints();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>&
Node::_internal_flowconstraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowconstraints_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>*
Node::_internal_mutable_flowconstraints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.flowconstraints_;
}

// repeated .NS3.Node.ProductTransform productTransforms = 10;
inline int Node::_internal_producttransforms_size() const {
  return _internal_producttransforms().size();
}
inline int Node::producttransforms_size() const {
  return _internal_producttransforms_size();
}
inline void Node::clear_producttransforms() {
  _internal_mutable_producttransforms()->Clear();
}
inline ::NS3::Node_ProductTransform* Node::mutable_producttransforms(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.productTransforms)
  return _internal_mutable_producttransforms()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >*
Node::mutable_producttransforms() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.productTransforms)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_producttransforms();
}
inline const ::NS3::Node_ProductTransform& Node::producttransforms(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.productTransforms)
    return _internal_producttransforms().Get(index);
}
inline ::NS3::Node_ProductTransform* Node::add_producttransforms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node_ProductTransform* _add = _internal_mutable_producttransforms()->Add();
  // @@protoc_insertion_point(field_add:NS3.Node.productTransforms)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >&
Node::producttransforms() const {
  // @@protoc_insertion_point(field_list:NS3.Node.productTransforms)
  return _internal_producttransforms();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform>&
Node::_internal_producttransforms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producttransforms_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node_ProductTransform>*
Node::_internal_mutable_producttransforms() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.producttransforms_;
}

// -------------------------------------------------------------------

// ProductGroup_ProductSpecification

// required string baseDimension = 1;
inline bool ProductGroup_ProductSpecification::has_basedimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProductGroup_ProductSpecification::clear_basedimension() {
  _impl_.basedimension_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductGroup_ProductSpecification::basedimension() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.baseDimension)
  return _internal_basedimension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProductGroup_ProductSpecification::set_basedimension(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.basedimension_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.baseDimension)
}
inline std::string* ProductGroup_ProductSpecification::mutable_basedimension() {
  std::string* _s = _internal_mutable_basedimension();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.ProductSpecification.baseDimension)
  return _s;
}
inline const std::string& ProductGroup_ProductSpecification::_internal_basedimension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.basedimension_.Get();
}
inline void ProductGroup_ProductSpecification::_internal_set_basedimension(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.basedimension_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductGroup_ProductSpecification::_internal_mutable_basedimension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.basedimension_.Mutable( GetArenaForAllocation());
}
inline std::string* ProductGroup_ProductSpecification::release_basedimension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.ProductSpecification.baseDimension)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.basedimension_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.basedimension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProductGroup_ProductSpecification::set_allocated_basedimension(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.basedimension_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.basedimension_.IsDefault()) {
          _impl_.basedimension_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.ProductSpecification.baseDimension)
}

// repeated string targetDimension = 2;
inline int ProductGroup_ProductSpecification::_internal_targetdimension_size() const {
  return _internal_targetdimension().size();
}
inline int ProductGroup_ProductSpecification::targetdimension_size() const {
  return _internal_targetdimension_size();
}
inline void ProductGroup_ProductSpecification::clear_targetdimension() {
  _internal_mutable_targetdimension()->Clear();
}
inline std::string* ProductGroup_ProductSpecification::add_targetdimension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_targetdimension()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.ProductGroup.ProductSpecification.targetDimension)
  return _s;
}
inline const std::string& ProductGroup_ProductSpecification::targetdimension(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.targetDimension)
  return _internal_targetdimension().Get(index);
}
inline std::string* ProductGroup_ProductSpecification::mutable_targetdimension(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.ProductSpecification.targetDimension)
  return _internal_mutable_targetdimension()->Mutable(index);
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const std::string& value) {
  _internal_mutable_targetdimension()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, std::string&& value) {
  _internal_mutable_targetdimension()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_targetdimension()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_targetdimension()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, absl::string_view value) {
  _internal_mutable_targetdimension()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_targetdimension()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_targetdimension()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_targetdimension()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_targetdimension()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_targetdimension()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProductGroup_ProductSpecification::targetdimension() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.ProductSpecification.targetDimension)
  return _internal_targetdimension();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* ProductGroup_ProductSpecification::mutable_targetdimension() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.ProductSpecification.targetDimension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targetdimension();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProductGroup_ProductSpecification::_internal_targetdimension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetdimension_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProductGroup_ProductSpecification::_internal_mutable_targetdimension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targetdimension_;
}

// repeated float targetPerBase = 3;
inline int ProductGroup_ProductSpecification::_internal_targetperbase_size() const {
  return _internal_targetperbase().size();
}
inline int ProductGroup_ProductSpecification::targetperbase_size() const {
  return _internal_targetperbase_size();
}
inline void ProductGroup_ProductSpecification::clear_targetperbase() {
  _internal_mutable_targetperbase()->Clear();
}
inline float ProductGroup_ProductSpecification::targetperbase(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return _internal_targetperbase().Get(index);
}
inline void ProductGroup_ProductSpecification::set_targetperbase(int index, float value) {
  _internal_mutable_targetperbase()->Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetPerBase)
}
inline void ProductGroup_ProductSpecification::add_targetperbase(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_targetperbase()->Add(value);
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetPerBase)
}
inline const ::google::protobuf::RepeatedField<float>& ProductGroup_ProductSpecification::targetperbase() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return _internal_targetperbase();
}
inline ::google::protobuf::RepeatedField<float>* ProductGroup_ProductSpecification::mutable_targetperbase() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.ProductSpecification.targetPerBase)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targetperbase();
}

inline const ::google::protobuf::RepeatedField<float>& ProductGroup_ProductSpecification::_internal_targetperbase() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetperbase_;
}
inline ::google::protobuf::RepeatedField<float>* ProductGroup_ProductSpecification::_internal_mutable_targetperbase() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targetperbase_;
}

// -------------------------------------------------------------------

// ProductGroup

// required string productId = 1;
inline bool ProductGroup::has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProductGroup::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductGroup::productid() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productId)
  return _internal_productid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProductGroup::set_productid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.productId)
}
inline std::string* ProductGroup::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productId)
  return _s;
}
inline const std::string& ProductGroup::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_.Get();
}
inline void ProductGroup::_internal_set_productid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductGroup::_internal_mutable_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productid_.Mutable( GetArenaForAllocation());
}
inline std::string* ProductGroup::release_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.productId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.productid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProductGroup::set_allocated_productid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productid_.IsDefault()) {
          _impl_.productid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.productId)
}

// required string productGroupId = 2;
inline bool ProductGroup::has_productgroupid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProductGroup::clear_productgroupid() {
  _impl_.productgroupid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProductGroup::productgroupid() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productGroupId)
  return _internal_productgroupid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProductGroup::set_productgroupid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.productgroupid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.productGroupId)
}
inline std::string* ProductGroup::mutable_productgroupid() {
  std::string* _s = _internal_mutable_productgroupid();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productGroupId)
  return _s;
}
inline const std::string& ProductGroup::_internal_productgroupid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productgroupid_.Get();
}
inline void ProductGroup::_internal_set_productgroupid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.productgroupid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductGroup::_internal_mutable_productgroupid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.productgroupid_.Mutable( GetArenaForAllocation());
}
inline std::string* ProductGroup::release_productgroupid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.productGroupId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.productgroupid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productgroupid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProductGroup::set_allocated_productgroupid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.productgroupid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productgroupid_.IsDefault()) {
          _impl_.productgroupid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.productGroupId)
}

// repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
inline int ProductGroup::_internal_productspecification_size() const {
  return _internal_productspecification().size();
}
inline int ProductGroup::productspecification_size() const {
  return _internal_productspecification_size();
}
inline void ProductGroup::clear_productspecification() {
  _internal_mutable_productspecification()->Clear();
}
inline ::NS3::ProductGroup_ProductSpecification* ProductGroup::mutable_productspecification(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productSpecification)
  return _internal_mutable_productspecification()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >*
ProductGroup::mutable_productspecification() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.productSpecification)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_productspecification();
}
inline const ::NS3::ProductGroup_ProductSpecification& ProductGroup::productspecification(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productSpecification)
    return _internal_productspecification().Get(index);
}
inline ::NS3::ProductGroup_ProductSpecification* ProductGroup::add_productspecification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::ProductGroup_ProductSpecification* _add = _internal_mutable_productspecification()->Add();
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.productSpecification)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >&
ProductGroup::productspecification() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.productSpecification)
  return _internal_productspecification();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup_ProductSpecification>&
ProductGroup::_internal_productspecification() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productspecification_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup_ProductSpecification>*
ProductGroup::_internal_mutable_productspecification() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.productspecification_;
}

// -------------------------------------------------------------------

// LaneRate

// required string id = 1;
inline bool LaneRate::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LaneRate::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LaneRate::id() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LaneRate::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.LaneRate.id)
}
inline std::string* LaneRate::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.id)
  return _s;
}
inline const std::string& LaneRate::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void LaneRate::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* LaneRate::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* LaneRate::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.LaneRate.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LaneRate::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.id)
}

// required string source = 3;
inline bool LaneRate::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LaneRate::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LaneRate::source() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LaneRate::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.LaneRate.source)
}
inline std::string* LaneRate::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.source)
  return _s;
}
inline const std::string& LaneRate::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void LaneRate::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* LaneRate::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* LaneRate::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.LaneRate.source)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LaneRate::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.source)
}

// required string destination = 4;
inline bool LaneRate::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LaneRate::clear_destination() {
  _impl_.destination_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LaneRate::destination() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LaneRate::set_destination(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.LaneRate.destination)
}
inline std::string* LaneRate::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.destination)
  return _s;
}
inline const std::string& LaneRate::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destination_.Get();
}
inline void LaneRate::_internal_set_destination(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* LaneRate::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* LaneRate::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.LaneRate.destination)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.destination_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.destination_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LaneRate::set_allocated_destination(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.destination)
}

// repeated string productIds = 5;
inline int LaneRate::_internal_productids_size() const {
  return _internal_productids().size();
}
inline int LaneRate::productids_size() const {
  return _internal_productids_size();
}
inline void LaneRate::clear_productids() {
  _internal_mutable_productids()->Clear();
}
inline std::string* LaneRate::add_productids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_productids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.LaneRate.productIds)
  return _s;
}
inline const std::string& LaneRate::productids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.productIds)
  return _internal_productids().Get(index);
}
inline std::string* LaneRate::mutable_productids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.productIds)
  return _internal_mutable_productids()->Mutable(index);
}
inline void LaneRate::set_productids(int index, const std::string& value) {
  _internal_mutable_productids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productIds)
}
inline void LaneRate::set_productids(int index, std::string&& value) {
  _internal_mutable_productids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productIds)
}
inline void LaneRate::set_productids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_productids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.productIds)
}
inline void LaneRate::set_productids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_productids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.productIds)
}
inline void LaneRate::set_productids(int index, absl::string_view value) {
  _internal_mutable_productids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.LaneRate.productIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LaneRate::productids() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.productIds)
  return _internal_productids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* LaneRate::mutable_productids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.productIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_productids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LaneRate::_internal_productids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LaneRate::_internal_mutable_productids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.productids_;
}

// repeated string productGroupIds = 6;
inline int LaneRate::_internal_productgroupids_size() const {
  return _internal_productgroupids().size();
}
inline int LaneRate::productgroupids_size() const {
  return _internal_productgroupids_size();
}
inline void LaneRate::clear_productgroupids() {
  _internal_mutable_productgroupids()->Clear();
}
inline std::string* LaneRate::add_productgroupids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_productgroupids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.LaneRate.productGroupIds)
  return _s;
}
inline const std::string& LaneRate::productgroupids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.productGroupIds)
  return _internal_productgroupids().Get(index);
}
inline std::string* LaneRate::mutable_productgroupids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.productGroupIds)
  return _internal_mutable_productgroupids()->Mutable(index);
}
inline void LaneRate::set_productgroupids(int index, const std::string& value) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::set_productgroupids(int index, std::string&& value) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::set_productgroupids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_productgroupids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::set_productgroupids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::set_productgroupids(int index, absl::string_view value) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.LaneRate.productGroupIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LaneRate::productgroupids() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.productGroupIds)
  return _internal_productgroupids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* LaneRate::mutable_productgroupids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.productGroupIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_productgroupids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LaneRate::_internal_productgroupids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productgroupids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LaneRate::_internal_mutable_productgroupids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.productgroupids_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
inline int LaneRate::_internal_unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts().size();
}
inline int LaneRate::unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts_size();
}
inline void LaneRate::clear_unitdimensioncosts() {
  _internal_mutable_unitdimensioncosts()->Clear();
}
inline ::NS3::UnitDimensionCost* LaneRate::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.unitDimensionCosts)
  return _internal_mutable_unitdimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
LaneRate::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.unitDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unitdimensioncosts();
}
inline const ::NS3::UnitDimensionCost& LaneRate::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.unitDimensionCosts)
    return _internal_unitdimensioncosts().Get(index);
}
inline ::NS3::UnitDimensionCost* LaneRate::add_unitdimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::UnitDimensionCost* _add = _internal_mutable_unitdimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.LaneRate.unitDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
LaneRate::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.unitDimensionCosts)
  return _internal_unitdimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>&
LaneRate::_internal_unitdimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unitdimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>*
LaneRate::_internal_mutable_unitdimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unitdimensioncosts_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
inline int LaneRate::_internal_flowconstraints_size() const {
  return _internal_flowconstraints().size();
}
inline int LaneRate::flowconstraints_size() const {
  return _internal_flowconstraints_size();
}
inline void LaneRate::clear_flowconstraints() {
  _internal_mutable_flowconstraints()->Clear();
}
inline ::NS3::FlowDimensionalConstraint* LaneRate::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.flowConstraints)
  return _internal_mutable_flowconstraints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
LaneRate::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.flowConstraints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_flowconstraints();
}
inline const ::NS3::FlowDimensionalConstraint& LaneRate::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.flowConstraints)
    return _internal_flowconstraints().Get(index);
}
inline ::NS3::FlowDimensionalConstraint* LaneRate::add_flowconstraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::FlowDimensionalConstraint* _add = _internal_mutable_flowconstraints()->Add();
  // @@protoc_insertion_point(field_add:NS3.LaneRate.flowConstraints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
LaneRate::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.flowConstraints)
  return _internal_flowconstraints();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>&
LaneRate::_internal_flowconstraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowconstraints_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>*
LaneRate::_internal_mutable_flowconstraints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.flowconstraints_;
}

// -------------------------------------------------------------------

// CostModel

// required string id = 1;
inline bool CostModel::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CostModel::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CostModel::id() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CostModel::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.CostModel.id)
}
inline std::string* CostModel::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.id)
  return _s;
}
inline const std::string& CostModel::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CostModel::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CostModel::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* CostModel::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.CostModel.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CostModel::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.id)
}

// required string source = 2;
inline bool CostModel::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CostModel::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CostModel::source() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CostModel::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.CostModel.source)
}
inline std::string* CostModel::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.source)
  return _s;
}
inline const std::string& CostModel::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void CostModel::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* CostModel::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* CostModel::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.CostModel.source)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CostModel::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.source)
}

// repeated string productGroupIds = 3;
inline int CostModel::_internal_productgroupids_size() const {
  return _internal_productgroupids().size();
}
inline int CostModel::productgroupids_size() const {
  return _internal_productgroupids_size();
}
inline void CostModel::clear_productgroupids() {
  _internal_mutable_productgroupids()->Clear();
}
inline std::string* CostModel::add_productgroupids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_productgroupids()->Add();
  // @@protoc_insertion_point(field_add_mutable:NS3.CostModel.productGroupIds)
  return _s;
}
inline const std::string& CostModel::productgroupids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.productGroupIds)
  return _internal_productgroupids().Get(index);
}
inline std::string* CostModel::mutable_productgroupids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.productGroupIds)
  return _internal_mutable_productgroupids()->Mutable(index);
}
inline void CostModel::set_productgroupids(int index, const std::string& value) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.productGroupIds)
}
inline void CostModel::set_productgroupids(int index, std::string&& value) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NS3.CostModel.productGroupIds)
}
inline void CostModel::set_productgroupids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_productgroupids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.productGroupIds)
}
inline void CostModel::set_productgroupids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.productGroupIds)
}
inline void CostModel::set_productgroupids(int index, absl::string_view value) {
  _internal_mutable_productgroupids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_productgroupids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:NS3.CostModel.productGroupIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CostModel::productgroupids() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.productGroupIds)
  return _internal_productgroupids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* CostModel::mutable_productgroupids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.productGroupIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_productgroupids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CostModel::_internal_productgroupids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productgroupids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CostModel::_internal_mutable_productgroupids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.productgroupids_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
inline int CostModel::_internal_unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts().size();
}
inline int CostModel::unitdimensioncosts_size() const {
  return _internal_unitdimensioncosts_size();
}
inline void CostModel::clear_unitdimensioncosts() {
  _internal_mutable_unitdimensioncosts()->Clear();
}
inline ::NS3::UnitDimensionCost* CostModel::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.unitDimensionCosts)
  return _internal_mutable_unitdimensioncosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
CostModel::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.unitDimensionCosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unitdimensioncosts();
}
inline const ::NS3::UnitDimensionCost& CostModel::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.unitDimensionCosts)
    return _internal_unitdimensioncosts().Get(index);
}
inline ::NS3::UnitDimensionCost* CostModel::add_unitdimensioncosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::UnitDimensionCost* _add = _internal_mutable_unitdimensioncosts()->Add();
  // @@protoc_insertion_point(field_add:NS3.CostModel.unitDimensionCosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
CostModel::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.unitDimensionCosts)
  return _internal_unitdimensioncosts();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>&
CostModel::_internal_unitdimensioncosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unitdimensioncosts_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::UnitDimensionCost>*
CostModel::_internal_mutable_unitdimensioncosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unitdimensioncosts_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
inline int CostModel::_internal_flowconstraints_size() const {
  return _internal_flowconstraints().size();
}
inline int CostModel::flowconstraints_size() const {
  return _internal_flowconstraints_size();
}
inline void CostModel::clear_flowconstraints() {
  _internal_mutable_flowconstraints()->Clear();
}
inline ::NS3::FlowDimensionalConstraint* CostModel::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.flowConstraints)
  return _internal_mutable_flowconstraints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
CostModel::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.flowConstraints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_flowconstraints();
}
inline const ::NS3::FlowDimensionalConstraint& CostModel::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.flowConstraints)
    return _internal_flowconstraints().Get(index);
}
inline ::NS3::FlowDimensionalConstraint* CostModel::add_flowconstraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::FlowDimensionalConstraint* _add = _internal_mutable_flowconstraints()->Add();
  // @@protoc_insertion_point(field_add:NS3.CostModel.flowConstraints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
CostModel::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.flowConstraints)
  return _internal_flowconstraints();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>&
CostModel::_internal_flowconstraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowconstraints_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::FlowDimensionalConstraint>*
CostModel::_internal_mutable_flowconstraints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.flowconstraints_;
}

// -------------------------------------------------------------------

// Model

// required .NS3.DimensionConfiguration dimensions = 1;
inline bool Model::has_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimensions_ != nullptr);
  return value;
}
inline void Model::clear_dimensions() {
  if (_impl_.dimensions_ != nullptr) _impl_.dimensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NS3::DimensionConfiguration& Model::_internal_dimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NS3::DimensionConfiguration* p = _impl_.dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::NS3::DimensionConfiguration&>(::NS3::_DimensionConfiguration_default_instance_);
}
inline const ::NS3::DimensionConfiguration& Model::dimensions() const {
  // @@protoc_insertion_point(field_get:NS3.Model.dimensions)
  return _internal_dimensions();
}
inline void Model::unsafe_arena_set_allocated_dimensions(::NS3::DimensionConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }
  _impl_.dimensions_ = reinterpret_cast<::NS3::DimensionConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NS3.Model.dimensions)
}
inline ::NS3::DimensionConfiguration* Model::release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NS3::DimensionConfiguration* released = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NS3::DimensionConfiguration* Model::unsafe_arena_release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.Model.dimensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NS3::DimensionConfiguration* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  return temp;
}
inline ::NS3::DimensionConfiguration* Model::_internal_mutable_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dimensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::NS3::DimensionConfiguration>(GetArenaForAllocation());
    _impl_.dimensions_ = reinterpret_cast<::NS3::DimensionConfiguration*>(p);
  }
  return _impl_.dimensions_;
}
inline ::NS3::DimensionConfiguration* Model::mutable_dimensions() {
  ::NS3::DimensionConfiguration* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:NS3.Model.dimensions)
  return _msg;
}
inline void Model::set_allocated_dimensions(::NS3::DimensionConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NS3::DimensionConfiguration*>(_impl_.dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NS3::DimensionConfiguration*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimensions_ = reinterpret_cast<::NS3::DimensionConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:NS3.Model.dimensions)
}

// repeated .NS3.Node nodes = 2;
inline int Model::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int Model::nodes_size() const {
  return _internal_nodes_size();
}
inline void Model::clear_nodes() {
  _internal_mutable_nodes()->Clear();
}
inline ::NS3::Node* Model::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node >*
Model::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.nodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodes();
}
inline const ::NS3::Node& Model::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.nodes)
    return _internal_nodes().Get(index);
}
inline ::NS3::Node* Model::add_nodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::Node* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:NS3.Model.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node >&
Model::nodes() const {
  // @@protoc_insertion_point(field_list:NS3.Model.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::Node>&
Model::_internal_nodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::Node>*
Model::_internal_mutable_nodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodes_;
}

// repeated .NS3.LaneRate laneRates = 3;
inline int Model::_internal_lanerates_size() const {
  return _internal_lanerates().size();
}
inline int Model::lanerates_size() const {
  return _internal_lanerates_size();
}
inline void Model::clear_lanerates() {
  _internal_mutable_lanerates()->Clear();
}
inline ::NS3::LaneRate* Model::mutable_lanerates(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.laneRates)
  return _internal_mutable_lanerates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >*
Model::mutable_lanerates() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.laneRates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lanerates();
}
inline const ::NS3::LaneRate& Model::lanerates(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.laneRates)
    return _internal_lanerates().Get(index);
}
inline ::NS3::LaneRate* Model::add_lanerates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::LaneRate* _add = _internal_mutable_lanerates()->Add();
  // @@protoc_insertion_point(field_add:NS3.Model.laneRates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >&
Model::lanerates() const {
  // @@protoc_insertion_point(field_list:NS3.Model.laneRates)
  return _internal_lanerates();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::LaneRate>&
Model::_internal_lanerates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lanerates_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::LaneRate>*
Model::_internal_mutable_lanerates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lanerates_;
}

// repeated .NS3.CostModel costModels = 4;
inline int Model::_internal_costmodels_size() const {
  return _internal_costmodels().size();
}
inline int Model::costmodels_size() const {
  return _internal_costmodels_size();
}
inline void Model::clear_costmodels() {
  _internal_mutable_costmodels()->Clear();
}
inline ::NS3::CostModel* Model::mutable_costmodels(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.costModels)
  return _internal_mutable_costmodels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >*
Model::mutable_costmodels() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.costModels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_costmodels();
}
inline const ::NS3::CostModel& Model::costmodels(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.costModels)
    return _internal_costmodels().Get(index);
}
inline ::NS3::CostModel* Model::add_costmodels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::CostModel* _add = _internal_mutable_costmodels()->Add();
  // @@protoc_insertion_point(field_add:NS3.Model.costModels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >&
Model::costmodels() const {
  // @@protoc_insertion_point(field_list:NS3.Model.costModels)
  return _internal_costmodels();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::CostModel>&
Model::_internal_costmodels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costmodels_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::CostModel>*
Model::_internal_mutable_costmodels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.costmodels_;
}

// repeated .NS3.ProductGroup productGroups = 5;
inline int Model::_internal_productgroups_size() const {
  return _internal_productgroups().size();
}
inline int Model::productgroups_size() const {
  return _internal_productgroups_size();
}
inline void Model::clear_productgroups() {
  _internal_mutable_productgroups()->Clear();
}
inline ::NS3::ProductGroup* Model::mutable_productgroups(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.productGroups)
  return _internal_mutable_productgroups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >*
Model::mutable_productgroups() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.productGroups)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_productgroups();
}
inline const ::NS3::ProductGroup& Model::productgroups(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.productGroups)
    return _internal_productgroups().Get(index);
}
inline ::NS3::ProductGroup* Model::add_productgroups() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::ProductGroup* _add = _internal_mutable_productgroups()->Add();
  // @@protoc_insertion_point(field_add:NS3.Model.productGroups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >&
Model::productgroups() const {
  // @@protoc_insertion_point(field_list:NS3.Model.productGroups)
  return _internal_productgroups();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup>&
Model::_internal_productgroups() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productgroups_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::ProductGroup>*
Model::_internal_mutable_productgroups() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.productgroups_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .NS3.Model model = 1;
inline bool SolveRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void SolveRequest::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NS3::Model& SolveRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NS3::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::NS3::Model&>(::NS3::_Model_default_instance_);
}
inline const ::NS3::Model& SolveRequest::model() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.model)
  return _internal_model();
}
inline void SolveRequest::unsafe_arena_set_allocated_model(::NS3::Model* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::NS3::Model*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NS3.SolveRequest.model)
}
inline ::NS3::Model* SolveRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NS3::Model* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NS3::Model* SolveRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolveRequest.model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NS3::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::NS3::Model* SolveRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::NS3::Model>(GetArenaForAllocation());
    _impl_.model_ = reinterpret_cast<::NS3::Model*>(p);
  }
  return _impl_.model_;
}
inline ::NS3::Model* SolveRequest::mutable_model() {
  ::NS3::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:NS3.SolveRequest.model)
  return _msg;
}
inline void SolveRequest::set_allocated_model(::NS3::Model* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::NS3::Model*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::NS3::Model*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.model_ = reinterpret_cast<::NS3::Model*>(value);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolveRequest::clear_modelid() {
  _impl_.modelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.modelID)
  return _internal_modelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolveRequest::set_modelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.modelID)
}
inline std::string* SolveRequest::mutable_modelid() {
  std::string* _s = _internal_mutable_modelid();
  // @@protoc_insertion_point(field_mutable:NS3.SolveRequest.modelID)
  return _s;
}
inline const std::string& SolveRequest::_internal_modelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modelid_.Get();
}
inline void SolveRequest::_internal_set_modelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolveRequest::_internal_mutable_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolveRequest::release_modelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolveRequest.modelID)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolveRequest::set_allocated_modelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modelid_.IsDefault()) {
          _impl_.modelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolveRequest.modelID)
}

// optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolveRequest::clear_solvetype() {
  _impl_.solvetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::NS3::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.solveType)
  return _internal_solvetype();
}
inline void SolveRequest::set_solvetype(::NS3::SolveRequest_SolveType value) {
  _internal_set_solvetype(value);
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.solveType)
}
inline ::NS3::SolveRequest_SolveType SolveRequest::_internal_solvetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NS3::SolveRequest_SolveType>(_impl_.solvetype_);
}
inline void SolveRequest::_internal_set_solvetype(::NS3::SolveRequest_SolveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NS3::SolveRequest_SolveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.solvetype_ = value;
}

// optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
inline bool SolveRequest::has_geometryoutput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolveRequest::clear_geometryoutput() {
  _impl_.geometryoutput_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::NS3::SolveRequest_GeometryOutput SolveRequest::geometryoutput() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.geometryOutput)
  return _internal_geometryoutput();
}
inline void SolveRequest::set_geometryoutput(::NS3::SolveRequest_GeometryOutput value) {
  _internal_set_geometryoutput(value);
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.geometryOutput)
}
inline ::NS3::SolveRequest_GeometryOutput SolveRequest::_internal_geometryoutput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::NS3::SolveRequest_GeometryOutput>(_impl_.geometryoutput_);
}
inline void SolveRequest::_internal_set_geometryoutput(::NS3::SolveRequest_GeometryOutput value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::NS3::SolveRequest_GeometryOutput_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.geometryoutput_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_Assignment

// required string source = 1;
inline bool SolutionResponse_Assignment::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Assignment::source() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Assignment::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.source)
}
inline std::string* SolutionResponse_Assignment::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.source)
  return _s;
}
inline const std::string& SolutionResponse_Assignment::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void SolutionResponse_Assignment::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.source)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Assignment::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.source)
}

// required string destination = 2;
inline bool SolutionResponse_Assignment::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_destination() {
  _impl_.destination_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Assignment::destination() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Assignment::set_destination(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.destination)
}
inline std::string* SolutionResponse_Assignment::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.destination)
  return _s;
}
inline const std::string& SolutionResponse_Assignment::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destination_.Get();
}
inline void SolutionResponse_Assignment::_internal_set_destination(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.destination)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.destination_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.destination_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Assignment::set_allocated_destination(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.destination)
}

// required string productId = 3;
inline bool SolutionResponse_Assignment::has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SolutionResponse_Assignment::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.productId)
  return _internal_productid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Assignment::set_productid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.productid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.productId)
}
inline std::string* SolutionResponse_Assignment::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.productId)
  return _s;
}
inline const std::string& SolutionResponse_Assignment::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_.Get();
}
inline void SolutionResponse_Assignment::_internal_set_productid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::_internal_mutable_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.productid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::release_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.productId)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.productid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Assignment::set_allocated_productid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.productid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productid_.IsDefault()) {
          _impl_.productid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.productId)
}

// required float amount = 4;
inline bool SolutionResponse_Assignment::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_amount() {
  _impl_.amount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_Assignment::amount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.amount)
  return _internal_amount();
}
inline void SolutionResponse_Assignment::set_amount(float value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.amount)
}
inline float SolutionResponse_Assignment::_internal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.amount_;
}
inline void SolutionResponse_Assignment::_internal_set_amount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.amount_ = value;
}

// required float cost = 5;
inline bool SolutionResponse_Assignment::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_Assignment::cost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.cost)
  return _internal_cost();
}
inline void SolutionResponse_Assignment::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.cost)
}
inline float SolutionResponse_Assignment::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_Assignment::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cost_ = value;
}

// optional string laneRateId = 6;
inline bool SolutionResponse_Assignment::has_lanerateid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_lanerateid() {
  _impl_.lanerateid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SolutionResponse_Assignment::lanerateid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.laneRateId)
  return _internal_lanerateid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Assignment::set_lanerateid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.lanerateid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.laneRateId)
}
inline std::string* SolutionResponse_Assignment::mutable_lanerateid() {
  std::string* _s = _internal_mutable_lanerateid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.laneRateId)
  return _s;
}
inline const std::string& SolutionResponse_Assignment::_internal_lanerateid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lanerateid_.Get();
}
inline void SolutionResponse_Assignment::_internal_set_lanerateid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.lanerateid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::_internal_mutable_lanerateid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.lanerateid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::release_lanerateid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.laneRateId)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.lanerateid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lanerateid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Assignment::set_allocated_lanerateid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.lanerateid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lanerateid_.IsDefault()) {
          _impl_.lanerateid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.laneRateId)
}

// optional string costModelId = 7;
inline bool SolutionResponse_Assignment::has_costmodelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_costmodelid() {
  _impl_.costmodelid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SolutionResponse_Assignment::costmodelid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.costModelId)
  return _internal_costmodelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Assignment::set_costmodelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.costmodelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.costModelId)
}
inline std::string* SolutionResponse_Assignment::mutable_costmodelid() {
  std::string* _s = _internal_mutable_costmodelid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.costModelId)
  return _s;
}
inline const std::string& SolutionResponse_Assignment::_internal_costmodelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costmodelid_.Get();
}
inline void SolutionResponse_Assignment::_internal_set_costmodelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.costmodelid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::_internal_mutable_costmodelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.costmodelid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Assignment::release_costmodelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.costModelId)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.costmodelid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.costmodelid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Assignment::set_allocated_costmodelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.costmodelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.costmodelid_.IsDefault()) {
          _impl_.costmodelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.costModelId)
}

// required float distance = 8;
inline bool SolutionResponse_Assignment::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float SolutionResponse_Assignment::distance() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.distance)
  return _internal_distance();
}
inline void SolutionResponse_Assignment::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.distance)
}
inline float SolutionResponse_Assignment::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void SolutionResponse_Assignment::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.distance_ = value;
}

// required float duration = 9;
inline bool SolutionResponse_Assignment::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SolutionResponse_Assignment::clear_duration() {
  _impl_.duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float SolutionResponse_Assignment::duration() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.duration)
  return _internal_duration();
}
inline void SolutionResponse_Assignment::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.duration)
}
inline float SolutionResponse_Assignment::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void SolutionResponse_Assignment::_internal_set_duration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.duration_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductFlow

// required string nodeId = 1;
inline bool SolutionResponse_NodeProductFlow::has_nodeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_nodeid() {
  _impl_.nodeid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_NodeProductFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.nodeId)
  return _internal_nodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_NodeProductFlow::set_nodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nodeid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
inline std::string* SolutionResponse_NodeProductFlow::mutable_nodeid() {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductFlow.nodeId)
  return _s;
}
inline const std::string& SolutionResponse_NodeProductFlow::_internal_nodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeid_.Get();
}
inline void SolutionResponse_NodeProductFlow::_internal_set_nodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nodeid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductFlow::_internal_mutable_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nodeid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductFlow::release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductFlow.nodeId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nodeid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_NodeProductFlow::set_allocated_nodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nodeid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodeid_.IsDefault()) {
          _impl_.nodeid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductFlow.nodeId)
}

// required string productId = 2;
inline bool SolutionResponse_NodeProductFlow::has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_NodeProductFlow::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productId)
  return _internal_productid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_NodeProductFlow::set_productid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.productid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productId)
}
inline std::string* SolutionResponse_NodeProductFlow::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductFlow.productId)
  return _s;
}
inline const std::string& SolutionResponse_NodeProductFlow::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_.Get();
}
inline void SolutionResponse_NodeProductFlow::_internal_set_productid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductFlow::_internal_mutable_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.productid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductFlow::release_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductFlow.productId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.productid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_NodeProductFlow::set_allocated_productid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.productid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productid_.IsDefault()) {
          _impl_.productid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductFlow.productId)
}

// required float inFlow = 3;
inline bool SolutionResponse_NodeProductFlow::has_inflow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_inflow() {
  _impl_.inflow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_NodeProductFlow::inflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.inFlow)
  return _internal_inflow();
}
inline void SolutionResponse_NodeProductFlow::set_inflow(float value) {
  _internal_set_inflow(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.inFlow)
}
inline float SolutionResponse_NodeProductFlow::_internal_inflow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inflow_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_inflow(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.inflow_ = value;
}

// required float outFlow = 4;
inline bool SolutionResponse_NodeProductFlow::has_outflow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_outflow() {
  _impl_.outflow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_NodeProductFlow::outflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.outFlow)
  return _internal_outflow();
}
inline void SolutionResponse_NodeProductFlow::set_outflow(float value) {
  _internal_set_outflow(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.outFlow)
}
inline float SolutionResponse_NodeProductFlow::_internal_outflow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outflow_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_outflow(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.outflow_ = value;
}

// required float flowCost = 5;
inline bool SolutionResponse_NodeProductFlow::has_flowcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_flowcost() {
  _impl_.flowcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_NodeProductFlow::flowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.flowCost)
  return _internal_flowcost();
}
inline void SolutionResponse_NodeProductFlow::set_flowcost(float value) {
  _internal_set_flowcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.flowCost)
}
inline float SolutionResponse_NodeProductFlow::_internal_flowcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowcost_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_flowcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.flowcost_ = value;
}

// required float fixedCost = 6;
inline bool SolutionResponse_NodeProductFlow::has_fixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_fixedcost() {
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_NodeProductFlow::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.fixedCost)
  return _internal_fixedcost();
}
inline void SolutionResponse_NodeProductFlow::set_fixedcost(float value) {
  _internal_set_fixedcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.fixedCost)
}
inline float SolutionResponse_NodeProductFlow::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fixedcost_ = value;
}

// required float productionAmount = 7;
inline bool SolutionResponse_NodeProductFlow::has_productionamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_productionamount() {
  _impl_.productionamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_NodeProductFlow::productionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionAmount)
  return _internal_productionamount();
}
inline void SolutionResponse_NodeProductFlow::set_productionamount(float value) {
  _internal_set_productionamount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionAmount)
}
inline float SolutionResponse_NodeProductFlow::_internal_productionamount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productionamount_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_productionamount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.productionamount_ = value;
}

// required float productionPenalty = 8;
inline bool SolutionResponse_NodeProductFlow::has_productionpenalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_productionpenalty() {
  _impl_.productionpenalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float SolutionResponse_NodeProductFlow::productionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionPenalty)
  return _internal_productionpenalty();
}
inline void SolutionResponse_NodeProductFlow::set_productionpenalty(float value) {
  _internal_set_productionpenalty(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionPenalty)
}
inline float SolutionResponse_NodeProductFlow::_internal_productionpenalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productionpenalty_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_productionpenalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.productionpenalty_ = value;
}

// required float productionCost = 9;
inline bool SolutionResponse_NodeProductFlow::has_productioncost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_productioncost() {
  _impl_.productioncost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float SolutionResponse_NodeProductFlow::productioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionCost)
  return _internal_productioncost();
}
inline void SolutionResponse_NodeProductFlow::set_productioncost(float value) {
  _internal_set_productioncost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionCost)
}
inline float SolutionResponse_NodeProductFlow::_internal_productioncost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productioncost_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_productioncost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.productioncost_ = value;
}

// required float consumptionAmount = 10;
inline bool SolutionResponse_NodeProductFlow::has_consumptionamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptionamount() {
  _impl_.consumptionamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float SolutionResponse_NodeProductFlow::consumptionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionAmount)
  return _internal_consumptionamount();
}
inline void SolutionResponse_NodeProductFlow::set_consumptionamount(float value) {
  _internal_set_consumptionamount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionAmount)
}
inline float SolutionResponse_NodeProductFlow::_internal_consumptionamount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumptionamount_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_consumptionamount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.consumptionamount_ = value;
}

// required float consumptionPenalty = 11;
inline bool SolutionResponse_NodeProductFlow::has_consumptionpenalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptionpenalty() {
  _impl_.consumptionpenalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float SolutionResponse_NodeProductFlow::consumptionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionPenalty)
  return _internal_consumptionpenalty();
}
inline void SolutionResponse_NodeProductFlow::set_consumptionpenalty(float value) {
  _internal_set_consumptionpenalty(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionPenalty)
}
inline float SolutionResponse_NodeProductFlow::_internal_consumptionpenalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumptionpenalty_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_consumptionpenalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.consumptionpenalty_ = value;
}

// required float consumptionCost = 12;
inline bool SolutionResponse_NodeProductFlow::has_consumptioncost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptioncost() {
  _impl_.consumptioncost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float SolutionResponse_NodeProductFlow::consumptioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionCost)
  return _internal_consumptioncost();
}
inline void SolutionResponse_NodeProductFlow::set_consumptioncost(float value) {
  _internal_set_consumptioncost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionCost)
}
inline float SolutionResponse_NodeProductFlow::_internal_consumptioncost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumptioncost_;
}
inline void SolutionResponse_NodeProductFlow::_internal_set_consumptioncost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.consumptioncost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_NodeFlow

// required string nodeId = 1;
inline bool SolutionResponse_NodeFlow::has_nodeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_nodeid() {
  _impl_.nodeid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_NodeFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.nodeId)
  return _internal_nodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_NodeFlow::set_nodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nodeid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.nodeId)
}
inline std::string* SolutionResponse_NodeFlow::mutable_nodeid() {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeFlow.nodeId)
  return _s;
}
inline const std::string& SolutionResponse_NodeFlow::_internal_nodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeid_.Get();
}
inline void SolutionResponse_NodeFlow::_internal_set_nodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nodeid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeFlow::_internal_mutable_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nodeid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeFlow::release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeFlow.nodeId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nodeid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_NodeFlow::set_allocated_nodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nodeid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodeid_.IsDefault()) {
          _impl_.nodeid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeFlow.nodeId)
}

// required float inFlow = 2;
inline bool SolutionResponse_NodeFlow::has_inflow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_inflow() {
  _impl_.inflow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_NodeFlow::inflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.inFlow)
  return _internal_inflow();
}
inline void SolutionResponse_NodeFlow::set_inflow(float value) {
  _internal_set_inflow(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.inFlow)
}
inline float SolutionResponse_NodeFlow::_internal_inflow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inflow_;
}
inline void SolutionResponse_NodeFlow::_internal_set_inflow(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.inflow_ = value;
}

// required float outFlow = 3;
inline bool SolutionResponse_NodeFlow::has_outflow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_outflow() {
  _impl_.outflow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_NodeFlow::outflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.outFlow)
  return _internal_outflow();
}
inline void SolutionResponse_NodeFlow::set_outflow(float value) {
  _internal_set_outflow(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.outFlow)
}
inline float SolutionResponse_NodeFlow::_internal_outflow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outflow_;
}
inline void SolutionResponse_NodeFlow::_internal_set_outflow(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.outflow_ = value;
}

// required float flowCost = 4;
inline bool SolutionResponse_NodeFlow::has_flowcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_flowcost() {
  _impl_.flowcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_NodeFlow::flowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.flowCost)
  return _internal_flowcost();
}
inline void SolutionResponse_NodeFlow::set_flowcost(float value) {
  _internal_set_flowcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.flowCost)
}
inline float SolutionResponse_NodeFlow::_internal_flowcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flowcost_;
}
inline void SolutionResponse_NodeFlow::_internal_set_flowcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.flowcost_ = value;
}

// required float fixedCost = 5;
inline bool SolutionResponse_NodeFlow::has_fixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_fixedcost() {
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_NodeFlow::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.fixedCost)
  return _internal_fixedcost();
}
inline void SolutionResponse_NodeFlow::set_fixedcost(float value) {
  _internal_set_fixedcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.fixedCost)
}
inline float SolutionResponse_NodeFlow::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline void SolutionResponse_NodeFlow::_internal_set_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.fixedcost_ = value;
}

// required float productFlowCost = 6;
inline bool SolutionResponse_NodeFlow::has_productflowcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_productflowcost() {
  _impl_.productflowcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_NodeFlow::productflowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productFlowCost)
  return _internal_productflowcost();
}
inline void SolutionResponse_NodeFlow::set_productflowcost(float value) {
  _internal_set_productflowcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productFlowCost)
}
inline float SolutionResponse_NodeFlow::_internal_productflowcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productflowcost_;
}
inline void SolutionResponse_NodeFlow::_internal_set_productflowcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.productflowcost_ = value;
}

// required float productFixedCost = 7;
inline bool SolutionResponse_NodeFlow::has_productfixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_productfixedcost() {
  _impl_.productfixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SolutionResponse_NodeFlow::productfixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productFixedCost)
  return _internal_productfixedcost();
}
inline void SolutionResponse_NodeFlow::set_productfixedcost(float value) {
  _internal_set_productfixedcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productFixedCost)
}
inline float SolutionResponse_NodeFlow::_internal_productfixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productfixedcost_;
}
inline void SolutionResponse_NodeFlow::_internal_set_productfixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.productfixedcost_ = value;
}

// required float productionAmount = 8;
inline bool SolutionResponse_NodeFlow::has_productionamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_productionamount() {
  _impl_.productionamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float SolutionResponse_NodeFlow::productionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionAmount)
  return _internal_productionamount();
}
inline void SolutionResponse_NodeFlow::set_productionamount(float value) {
  _internal_set_productionamount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionAmount)
}
inline float SolutionResponse_NodeFlow::_internal_productionamount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productionamount_;
}
inline void SolutionResponse_NodeFlow::_internal_set_productionamount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.productionamount_ = value;
}

// required float productionPenalty = 9;
inline bool SolutionResponse_NodeFlow::has_productionpenalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_productionpenalty() {
  _impl_.productionpenalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float SolutionResponse_NodeFlow::productionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionPenalty)
  return _internal_productionpenalty();
}
inline void SolutionResponse_NodeFlow::set_productionpenalty(float value) {
  _internal_set_productionpenalty(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionPenalty)
}
inline float SolutionResponse_NodeFlow::_internal_productionpenalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productionpenalty_;
}
inline void SolutionResponse_NodeFlow::_internal_set_productionpenalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.productionpenalty_ = value;
}

// required float productionCost = 10;
inline bool SolutionResponse_NodeFlow::has_productioncost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_productioncost() {
  _impl_.productioncost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float SolutionResponse_NodeFlow::productioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionCost)
  return _internal_productioncost();
}
inline void SolutionResponse_NodeFlow::set_productioncost(float value) {
  _internal_set_productioncost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionCost)
}
inline float SolutionResponse_NodeFlow::_internal_productioncost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productioncost_;
}
inline void SolutionResponse_NodeFlow::_internal_set_productioncost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.productioncost_ = value;
}

// required float consumptionAmount = 11;
inline bool SolutionResponse_NodeFlow::has_consumptionamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_consumptionamount() {
  _impl_.consumptionamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float SolutionResponse_NodeFlow::consumptionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionAmount)
  return _internal_consumptionamount();
}
inline void SolutionResponse_NodeFlow::set_consumptionamount(float value) {
  _internal_set_consumptionamount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionAmount)
}
inline float SolutionResponse_NodeFlow::_internal_consumptionamount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumptionamount_;
}
inline void SolutionResponse_NodeFlow::_internal_set_consumptionamount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.consumptionamount_ = value;
}

// required float consumptionPenalty = 12;
inline bool SolutionResponse_NodeFlow::has_consumptionpenalty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_consumptionpenalty() {
  _impl_.consumptionpenalty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float SolutionResponse_NodeFlow::consumptionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionPenalty)
  return _internal_consumptionpenalty();
}
inline void SolutionResponse_NodeFlow::set_consumptionpenalty(float value) {
  _internal_set_consumptionpenalty(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionPenalty)
}
inline float SolutionResponse_NodeFlow::_internal_consumptionpenalty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumptionpenalty_;
}
inline void SolutionResponse_NodeFlow::_internal_set_consumptionpenalty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.consumptionpenalty_ = value;
}

// required float consumptionCost = 13;
inline bool SolutionResponse_NodeFlow::has_consumptioncost() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void SolutionResponse_NodeFlow::clear_consumptioncost() {
  _impl_.consumptioncost_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float SolutionResponse_NodeFlow::consumptioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionCost)
  return _internal_consumptioncost();
}
inline void SolutionResponse_NodeFlow::set_consumptioncost(float value) {
  _internal_set_consumptioncost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionCost)
}
inline float SolutionResponse_NodeFlow::_internal_consumptioncost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumptioncost_;
}
inline void SolutionResponse_NodeFlow::_internal_set_consumptioncost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.consumptioncost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_GeometrySequence

// repeated float x = 1;
inline int SolutionResponse_GeometrySequence::_internal_x_size() const {
  return _internal_x().size();
}
inline int SolutionResponse_GeometrySequence::x_size() const {
  return _internal_x_size();
}
inline void SolutionResponse_GeometrySequence::clear_x() {
  _internal_mutable_x()->Clear();
}
inline float SolutionResponse_GeometrySequence::x(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometrySequence.x)
  return _internal_x().Get(index);
}
inline void SolutionResponse_GeometrySequence::set_x(int index, float value) {
  _internal_mutable_x()->Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometrySequence.x)
}
inline void SolutionResponse_GeometrySequence::add_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x()->Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometrySequence.x)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_GeometrySequence::x() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometrySequence.x)
  return _internal_x();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_GeometrySequence::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometrySequence.x)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_GeometrySequence::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_GeometrySequence::_internal_mutable_x() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x_;
}

// repeated float y = 2;
inline int SolutionResponse_GeometrySequence::_internal_y_size() const {
  return _internal_y().size();
}
inline int SolutionResponse_GeometrySequence::y_size() const {
  return _internal_y_size();
}
inline void SolutionResponse_GeometrySequence::clear_y() {
  _internal_mutable_y()->Clear();
}
inline float SolutionResponse_GeometrySequence::y(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometrySequence.y)
  return _internal_y().Get(index);
}
inline void SolutionResponse_GeometrySequence::set_y(int index, float value) {
  _internal_mutable_y()->Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometrySequence.y)
}
inline void SolutionResponse_GeometrySequence::add_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_y()->Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometrySequence.y)
}
inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_GeometrySequence::y() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometrySequence.y)
  return _internal_y();
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_GeometrySequence::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometrySequence.y)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_y();
}

inline const ::google::protobuf::RepeatedField<float>& SolutionResponse_GeometrySequence::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline ::google::protobuf::RepeatedField<float>* SolutionResponse_GeometrySequence::_internal_mutable_y() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.y_;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string fromId = 1;
inline bool SolutionResponse_Route::has_fromid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_fromid() {
  _impl_.fromid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_Route::fromid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Route.fromId)
  return _internal_fromid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Route::set_fromid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Route.fromId)
}
inline std::string* SolutionResponse_Route::mutable_fromid() {
  std::string* _s = _internal_mutable_fromid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Route.fromId)
  return _s;
}
inline const std::string& SolutionResponse_Route::_internal_fromid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromid_.Get();
}
inline void SolutionResponse_Route::_internal_set_fromid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::_internal_mutable_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fromid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::release_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Route.fromId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fromid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fromid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Route::set_allocated_fromid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fromid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fromid_.IsDefault()) {
          _impl_.fromid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Route.fromId)
}

// required string toId = 2;
inline bool SolutionResponse_Route::has_toid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_Route::clear_toid() {
  _impl_.toid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_Route::toid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Route.toId)
  return _internal_toid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_Route::set_toid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Route.toId)
}
inline std::string* SolutionResponse_Route::mutable_toid() {
  std::string* _s = _internal_mutable_toid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Route.toId)
  return _s;
}
inline const std::string& SolutionResponse_Route::_internal_toid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.toid_.Get();
}
inline void SolutionResponse_Route::_internal_set_toid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::_internal_mutable_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.toid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_Route::release_toid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Route.toId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.toid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.toid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_Route::set_allocated_toid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.toid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.toid_.IsDefault()) {
          _impl_.toid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Route.toId)
}

// repeated int32 geometrySequence = 3;
inline int SolutionResponse_Route::_internal_geometrysequence_size() const {
  return _internal_geometrysequence().size();
}
inline int SolutionResponse_Route::geometrysequence_size() const {
  return _internal_geometrysequence_size();
}
inline void SolutionResponse_Route::clear_geometrysequence() {
  _internal_mutable_geometrysequence()->Clear();
}
inline ::int32_t SolutionResponse_Route::geometrysequence(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Route.geometrySequence)
  return _internal_geometrysequence().Get(index);
}
inline void SolutionResponse_Route::set_geometrysequence(int index, ::int32_t value) {
  _internal_mutable_geometrysequence()->Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Route.geometrySequence)
}
inline void SolutionResponse_Route::add_geometrysequence(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_geometrysequence()->Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.Route.geometrySequence)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SolutionResponse_Route::geometrysequence() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.Route.geometrySequence)
  return _internal_geometrysequence();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SolutionResponse_Route::mutable_geometrysequence() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.Route.geometrySequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometrysequence();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& SolutionResponse_Route::_internal_geometrysequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometrysequence_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SolutionResponse_Route::_internal_mutable_geometrysequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometrysequence_;
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductTransformAssignment_Item

// required string productId = 1;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_NodeProductTransformAssignment_Item::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
  return _internal_productid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_NodeProductTransformAssignment_Item::set_productid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}
inline std::string* SolutionResponse_NodeProductTransformAssignment_Item::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
  return _s;
}
inline const std::string& SolutionResponse_NodeProductTransformAssignment_Item::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_.Get();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::_internal_set_productid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductTransformAssignment_Item::_internal_mutable_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductTransformAssignment_Item::release_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.productid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_allocated_productid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productid_.IsDefault()) {
          _impl_.productid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}

// required float amount = 2;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_amount() {
  _impl_.amount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::amount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.amount)
  return _internal_amount();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_amount(float value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.amount)
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::_internal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.amount_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::_internal_set_amount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.amount_ = value;
}

// required float cost = 3;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_cost() {
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::cost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.cost)
  return _internal_cost();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.cost)
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::_internal_set_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cost_ = value;
}

// required float fixedCost = 4;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_fixedcost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_fixedcost() {
  _impl_.fixedcost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.fixedCost)
  return _internal_fixedcost();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_fixedcost(float value) {
  _internal_set_fixedcost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.fixedCost)
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::_internal_fixedcost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixedcost_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::_internal_set_fixedcost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fixedcost_ = value;
}

// required float penaltyAmount = 5;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_penaltyamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_penaltyamount() {
  _impl_.penaltyamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::penaltyamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyAmount)
  return _internal_penaltyamount();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_penaltyamount(float value) {
  _internal_set_penaltyamount(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyAmount)
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::_internal_penaltyamount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penaltyamount_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::_internal_set_penaltyamount(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.penaltyamount_ = value;
}

// required float penaltyCost = 6;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_penaltycost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_penaltycost() {
  _impl_.penaltycost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::penaltycost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyCost)
  return _internal_penaltycost();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_penaltycost(float value) {
  _internal_set_penaltycost(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyCost)
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::_internal_penaltycost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penaltycost_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::_internal_set_penaltycost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.penaltycost_ = value;
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductTransformAssignment

// required string nodeId = 1;
inline bool SolutionResponse_NodeProductTransformAssignment::has_nodeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_nodeid() {
  _impl_.nodeid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SolutionResponse_NodeProductTransformAssignment::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
  return _internal_nodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_NodeProductTransformAssignment::set_nodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nodeid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}
inline std::string* SolutionResponse_NodeProductTransformAssignment::mutable_nodeid() {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
  return _s;
}
inline const std::string& SolutionResponse_NodeProductTransformAssignment::_internal_nodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeid_.Get();
}
inline void SolutionResponse_NodeProductTransformAssignment::_internal_set_nodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nodeid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductTransformAssignment::_internal_mutable_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nodeid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductTransformAssignment::release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nodeid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_NodeProductTransformAssignment::set_allocated_nodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nodeid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodeid_.IsDefault()) {
          _impl_.nodeid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}

// required string productTransformId = 2;
inline bool SolutionResponse_NodeProductTransformAssignment::has_producttransformid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_producttransformid() {
  _impl_.producttransformid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SolutionResponse_NodeProductTransformAssignment::producttransformid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
  return _internal_producttransformid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SolutionResponse_NodeProductTransformAssignment::set_producttransformid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producttransformid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}
inline std::string* SolutionResponse_NodeProductTransformAssignment::mutable_producttransformid() {
  std::string* _s = _internal_mutable_producttransformid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
  return _s;
}
inline const std::string& SolutionResponse_NodeProductTransformAssignment::_internal_producttransformid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producttransformid_.Get();
}
inline void SolutionResponse_NodeProductTransformAssignment::_internal_set_producttransformid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producttransformid_.Set(value, GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductTransformAssignment::_internal_mutable_producttransformid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.producttransformid_.Mutable( GetArenaForAllocation());
}
inline std::string* SolutionResponse_NodeProductTransformAssignment::release_producttransformid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.producttransformid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producttransformid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SolutionResponse_NodeProductTransformAssignment::set_allocated_producttransformid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.producttransformid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producttransformid_.IsDefault()) {
          _impl_.producttransformid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}

// repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
inline int SolutionResponse_NodeProductTransformAssignment::_internal_inputitems_size() const {
  return _internal_inputitems().size();
}
inline int SolutionResponse_NodeProductTransformAssignment::inputitems_size() const {
  return _internal_inputitems_size();
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_inputitems() {
  _internal_mutable_inputitems()->Clear();
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::mutable_inputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return _internal_mutable_inputitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
SolutionResponse_NodeProductTransformAssignment::mutable_inputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_inputitems();
}
inline const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& SolutionResponse_NodeProductTransformAssignment::inputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
    return _internal_inputitems().Get(index);
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::add_inputitems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* _add = _internal_mutable_inputitems()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
SolutionResponse_NodeProductTransformAssignment::inputitems() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return _internal_inputitems();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>&
SolutionResponse_NodeProductTransformAssignment::_internal_inputitems() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inputitems_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>*
SolutionResponse_NodeProductTransformAssignment::_internal_mutable_inputitems() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.inputitems_;
}

// repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
inline int SolutionResponse_NodeProductTransformAssignment::_internal_outputitems_size() const {
  return _internal_outputitems().size();
}
inline int SolutionResponse_NodeProductTransformAssignment::outputitems_size() const {
  return _internal_outputitems_size();
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_outputitems() {
  _internal_mutable_outputitems()->Clear();
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::mutable_outputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return _internal_mutable_outputitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
SolutionResponse_NodeProductTransformAssignment::mutable_outputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_outputitems();
}
inline const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& SolutionResponse_NodeProductTransformAssignment::outputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
    return _internal_outputitems().Get(index);
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::add_outputitems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* _add = _internal_mutable_outputitems()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
SolutionResponse_NodeProductTransformAssignment::outputitems() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return _internal_outputitems();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>&
SolutionResponse_NodeProductTransformAssignment::_internal_outputitems() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outputitems_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>*
SolutionResponse_NodeProductTransformAssignment::_internal_mutable_outputitems() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.outputitems_;
}

// -------------------------------------------------------------------

// SolutionResponse

// required float objective = 1;
inline bool SolutionResponse::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SolutionResponse::clear_objective() {
  _impl_.objective_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.objective)
  return _internal_objective();
}
inline void SolutionResponse::set_objective(float value) {
  _internal_set_objective(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.objective)
}
inline float SolutionResponse::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objective_;
}
inline void SolutionResponse::_internal_set_objective(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.objective_ = value;
}

// optional float lowerBound = 2;
inline bool SolutionResponse::has_lowerbound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SolutionResponse::clear_lowerbound() {
  _impl_.lowerbound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SolutionResponse::lowerbound() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.lowerBound)
  return _internal_lowerbound();
}
inline void SolutionResponse::set_lowerbound(float value) {
  _internal_set_lowerbound(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.lowerBound)
}
inline float SolutionResponse::_internal_lowerbound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lowerbound_;
}
inline void SolutionResponse::_internal_set_lowerbound(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lowerbound_ = value;
}

// optional float optimalityGap = 3;
inline bool SolutionResponse::has_optimalitygap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SolutionResponse::clear_optimalitygap() {
  _impl_.optimalitygap_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SolutionResponse::optimalitygap() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.optimalityGap)
  return _internal_optimalitygap();
}
inline void SolutionResponse::set_optimalitygap(float value) {
  _internal_set_optimalitygap(value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.optimalityGap)
}
inline float SolutionResponse::_internal_optimalitygap() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optimalitygap_;
}
inline void SolutionResponse::_internal_set_optimalitygap(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.optimalitygap_ = value;
}

// repeated .NS3.SolutionResponse.Assignment assignments = 4;
inline int SolutionResponse::_internal_assignments_size() const {
  return _internal_assignments().size();
}
inline int SolutionResponse::assignments_size() const {
  return _internal_assignments_size();
}
inline void SolutionResponse::clear_assignments() {
  _internal_mutable_assignments()->Clear();
}
inline ::NS3::SolutionResponse_Assignment* SolutionResponse::mutable_assignments(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.assignments)
  return _internal_mutable_assignments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >*
SolutionResponse::mutable_assignments() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.assignments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_assignments();
}
inline const ::NS3::SolutionResponse_Assignment& SolutionResponse::assignments(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.assignments)
    return _internal_assignments().Get(index);
}
inline ::NS3::SolutionResponse_Assignment* SolutionResponse::add_assignments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_Assignment* _add = _internal_mutable_assignments()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.assignments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >&
SolutionResponse::assignments() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.assignments)
  return _internal_assignments();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Assignment>&
SolutionResponse::_internal_assignments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assignments_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Assignment>*
SolutionResponse::_internal_mutable_assignments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.assignments_;
}

// repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
inline int SolutionResponse::_internal_nodeflows_size() const {
  return _internal_nodeflows().size();
}
inline int SolutionResponse::nodeflows_size() const {
  return _internal_nodeflows_size();
}
inline void SolutionResponse::clear_nodeflows() {
  _internal_mutable_nodeflows()->Clear();
}
inline ::NS3::SolutionResponse_NodeFlow* SolutionResponse::mutable_nodeflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeFlows)
  return _internal_mutable_nodeflows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >*
SolutionResponse::mutable_nodeflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeFlows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodeflows();
}
inline const ::NS3::SolutionResponse_NodeFlow& SolutionResponse::nodeflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeFlows)
    return _internal_nodeflows().Get(index);
}
inline ::NS3::SolutionResponse_NodeFlow* SolutionResponse::add_nodeflows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_NodeFlow* _add = _internal_mutable_nodeflows()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeFlows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >&
SolutionResponse::nodeflows() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeFlows)
  return _internal_nodeflows();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeFlow>&
SolutionResponse::_internal_nodeflows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeflows_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeFlow>*
SolutionResponse::_internal_mutable_nodeflows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodeflows_;
}

// repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
inline int SolutionResponse::_internal_nodeproductflows_size() const {
  return _internal_nodeproductflows().size();
}
inline int SolutionResponse::nodeproductflows_size() const {
  return _internal_nodeproductflows_size();
}
inline void SolutionResponse::clear_nodeproductflows() {
  _internal_mutable_nodeproductflows()->Clear();
}
inline ::NS3::SolutionResponse_NodeProductFlow* SolutionResponse::mutable_nodeproductflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeProductFlows)
  return _internal_mutable_nodeproductflows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >*
SolutionResponse::mutable_nodeproductflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeProductFlows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodeproductflows();
}
inline const ::NS3::SolutionResponse_NodeProductFlow& SolutionResponse::nodeproductflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeProductFlows)
    return _internal_nodeproductflows().Get(index);
}
inline ::NS3::SolutionResponse_NodeProductFlow* SolutionResponse::add_nodeproductflows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_NodeProductFlow* _add = _internal_mutable_nodeproductflows()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeProductFlows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >&
SolutionResponse::nodeproductflows() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeProductFlows)
  return _internal_nodeproductflows();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductFlow>&
SolutionResponse::_internal_nodeproductflows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeproductflows_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductFlow>*
SolutionResponse::_internal_mutable_nodeproductflows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodeproductflows_;
}

// repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
inline int SolutionResponse::_internal_geometrysequence_size() const {
  return _internal_geometrysequence().size();
}
inline int SolutionResponse::geometrysequence_size() const {
  return _internal_geometrysequence_size();
}
inline void SolutionResponse::clear_geometrysequence() {
  _internal_mutable_geometrysequence()->Clear();
}
inline ::NS3::SolutionResponse_GeometrySequence* SolutionResponse::mutable_geometrysequence(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.geometrySequence)
  return _internal_mutable_geometrysequence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >*
SolutionResponse::mutable_geometrysequence() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.geometrySequence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geometrysequence();
}
inline const ::NS3::SolutionResponse_GeometrySequence& SolutionResponse::geometrysequence(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.geometrySequence)
    return _internal_geometrysequence().Get(index);
}
inline ::NS3::SolutionResponse_GeometrySequence* SolutionResponse::add_geometrysequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_GeometrySequence* _add = _internal_mutable_geometrysequence()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.geometrySequence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >&
SolutionResponse::geometrysequence() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.geometrySequence)
  return _internal_geometrysequence();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_GeometrySequence>&
SolutionResponse::_internal_geometrysequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geometrysequence_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_GeometrySequence>*
SolutionResponse::_internal_mutable_geometrysequence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geometrysequence_;
}

// repeated .NS3.SolutionResponse.Route routes = 8;
inline int SolutionResponse::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int SolutionResponse::routes_size() const {
  return _internal_routes_size();
}
inline void SolutionResponse::clear_routes() {
  _internal_mutable_routes()->Clear();
}
inline ::NS3::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::NS3::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.routes)
    return _internal_routes().Get(index);
}
inline ::NS3::SolutionResponse_Route* SolutionResponse::add_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_Route* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Route>&
SolutionResponse::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_Route>*
SolutionResponse::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

// repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
inline int SolutionResponse::_internal_nodeproducttransformassignments_size() const {
  return _internal_nodeproducttransformassignments().size();
}
inline int SolutionResponse::nodeproducttransformassignments_size() const {
  return _internal_nodeproducttransformassignments_size();
}
inline void SolutionResponse::clear_nodeproducttransformassignments() {
  _internal_mutable_nodeproducttransformassignments()->Clear();
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment* SolutionResponse::mutable_nodeproducttransformassignments(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeProductTransformAssignments)
  return _internal_mutable_nodeproducttransformassignments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >*
SolutionResponse::mutable_nodeproducttransformassignments() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeProductTransformAssignments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodeproducttransformassignments();
}
inline const ::NS3::SolutionResponse_NodeProductTransformAssignment& SolutionResponse::nodeproducttransformassignments(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeProductTransformAssignments)
    return _internal_nodeproducttransformassignments().Get(index);
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment* SolutionResponse::add_nodeproducttransformassignments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NS3::SolutionResponse_NodeProductTransformAssignment* _add = _internal_mutable_nodeproducttransformassignments()->Add();
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeProductTransformAssignments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >&
SolutionResponse::nodeproducttransformassignments() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeProductTransformAssignments)
  return _internal_nodeproducttransformassignments();
}
inline const ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment>&
SolutionResponse::_internal_nodeproducttransformassignments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeproducttransformassignments_;
}
inline ::google::protobuf::RepeatedPtrField<::NS3::SolutionResponse_NodeProductTransformAssignment>*
SolutionResponse::_internal_mutable_nodeproducttransformassignments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodeproducttransformassignments_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace NS3


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::NS3::InternalDimension_eMeasurementUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NS3::InternalDimension_eMeasurementUnit>() {
  return ::NS3::InternalDimension_eMeasurementUnit_descriptor();
}
template <>
struct is_proto_enum<::NS3::SolveRequest_SolveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NS3::SolveRequest_SolveType>() {
  return ::NS3::SolveRequest_SolveType_descriptor();
}
template <>
struct is_proto_enum<::NS3::SolveRequest_GeometryOutput> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::NS3::SolveRequest_GeometryOutput>() {
  return ::NS3::SolveRequest_GeometryOutput_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto_2epb_2eh
