// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ns3-tbfvuwtge2iq.proto

#ifndef PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto
#define PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ns3_2dtbfvuwtge2iq_2eproto 

namespace protobuf_ns3_2dtbfvuwtge2iq_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[27];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ns3_2dtbfvuwtge2iq_2eproto
namespace NS3 {
class CostModel;
class CostModelDefaultTypeInternal;
extern CostModelDefaultTypeInternal _CostModel_default_instance_;
class DimensionConfiguration;
class DimensionConfigurationDefaultTypeInternal;
extern DimensionConfigurationDefaultTypeInternal _DimensionConfiguration_default_instance_;
class DimensionRange;
class DimensionRangeDefaultTypeInternal;
extern DimensionRangeDefaultTypeInternal _DimensionRange_default_instance_;
class FixedDimensionCost;
class FixedDimensionCostDefaultTypeInternal;
extern FixedDimensionCostDefaultTypeInternal _FixedDimensionCost_default_instance_;
class FlowDimensionalConstraint;
class FlowDimensionalConstraintDefaultTypeInternal;
extern FlowDimensionalConstraintDefaultTypeInternal _FlowDimensionalConstraint_default_instance_;
class Geocode;
class GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class InternalDimension;
class InternalDimensionDefaultTypeInternal;
extern InternalDimensionDefaultTypeInternal _InternalDimension_default_instance_;
class LaneRate;
class LaneRateDefaultTypeInternal;
extern LaneRateDefaultTypeInternal _LaneRate_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Node_Flow;
class Node_FlowDefaultTypeInternal;
extern Node_FlowDefaultTypeInternal _Node_Flow_default_instance_;
class Node_ProductFlow;
class Node_ProductFlowDefaultTypeInternal;
extern Node_ProductFlowDefaultTypeInternal _Node_ProductFlow_default_instance_;
class Node_ProductTransform;
class Node_ProductTransformDefaultTypeInternal;
extern Node_ProductTransformDefaultTypeInternal _Node_ProductTransform_default_instance_;
class Node_ProductTransform_Item;
class Node_ProductTransform_ItemDefaultTypeInternal;
extern Node_ProductTransform_ItemDefaultTypeInternal _Node_ProductTransform_Item_default_instance_;
class ProductGroup;
class ProductGroupDefaultTypeInternal;
extern ProductGroupDefaultTypeInternal _ProductGroup_default_instance_;
class ProductGroup_ProductSpecification;
class ProductGroup_ProductSpecificationDefaultTypeInternal;
extern ProductGroup_ProductSpecificationDefaultTypeInternal _ProductGroup_ProductSpecification_default_instance_;
class SolutionResponse;
class SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Assignment;
class SolutionResponse_AssignmentDefaultTypeInternal;
extern SolutionResponse_AssignmentDefaultTypeInternal _SolutionResponse_Assignment_default_instance_;
class SolutionResponse_GeometrySequence;
class SolutionResponse_GeometrySequenceDefaultTypeInternal;
extern SolutionResponse_GeometrySequenceDefaultTypeInternal _SolutionResponse_GeometrySequence_default_instance_;
class SolutionResponse_NodeFlow;
class SolutionResponse_NodeFlowDefaultTypeInternal;
extern SolutionResponse_NodeFlowDefaultTypeInternal _SolutionResponse_NodeFlow_default_instance_;
class SolutionResponse_NodeProductFlow;
class SolutionResponse_NodeProductFlowDefaultTypeInternal;
extern SolutionResponse_NodeProductFlowDefaultTypeInternal _SolutionResponse_NodeProductFlow_default_instance_;
class SolutionResponse_NodeProductTransformAssignment;
class SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal;
extern SolutionResponse_NodeProductTransformAssignmentDefaultTypeInternal _SolutionResponse_NodeProductTransformAssignment_default_instance_;
class SolutionResponse_NodeProductTransformAssignment_Item;
class SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal;
extern SolutionResponse_NodeProductTransformAssignment_ItemDefaultTypeInternal _SolutionResponse_NodeProductTransformAssignment_Item_default_instance_;
class SolutionResponse_Route;
class SolutionResponse_RouteDefaultTypeInternal;
extern SolutionResponse_RouteDefaultTypeInternal _SolutionResponse_Route_default_instance_;
class SolveRequest;
class SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class UnitDimensionCost;
class UnitDimensionCostDefaultTypeInternal;
extern UnitDimensionCostDefaultTypeInternal _UnitDimensionCost_default_instance_;
class UserDimension;
class UserDimensionDefaultTypeInternal;
extern UserDimensionDefaultTypeInternal _UserDimension_default_instance_;
}  // namespace NS3
namespace google {
namespace protobuf {
template<> ::NS3::CostModel* Arena::CreateMaybeMessage<::NS3::CostModel>(Arena*);
template<> ::NS3::DimensionConfiguration* Arena::CreateMaybeMessage<::NS3::DimensionConfiguration>(Arena*);
template<> ::NS3::DimensionRange* Arena::CreateMaybeMessage<::NS3::DimensionRange>(Arena*);
template<> ::NS3::FixedDimensionCost* Arena::CreateMaybeMessage<::NS3::FixedDimensionCost>(Arena*);
template<> ::NS3::FlowDimensionalConstraint* Arena::CreateMaybeMessage<::NS3::FlowDimensionalConstraint>(Arena*);
template<> ::NS3::Geocode* Arena::CreateMaybeMessage<::NS3::Geocode>(Arena*);
template<> ::NS3::InternalDimension* Arena::CreateMaybeMessage<::NS3::InternalDimension>(Arena*);
template<> ::NS3::LaneRate* Arena::CreateMaybeMessage<::NS3::LaneRate>(Arena*);
template<> ::NS3::Model* Arena::CreateMaybeMessage<::NS3::Model>(Arena*);
template<> ::NS3::Node* Arena::CreateMaybeMessage<::NS3::Node>(Arena*);
template<> ::NS3::Node_Flow* Arena::CreateMaybeMessage<::NS3::Node_Flow>(Arena*);
template<> ::NS3::Node_ProductFlow* Arena::CreateMaybeMessage<::NS3::Node_ProductFlow>(Arena*);
template<> ::NS3::Node_ProductTransform* Arena::CreateMaybeMessage<::NS3::Node_ProductTransform>(Arena*);
template<> ::NS3::Node_ProductTransform_Item* Arena::CreateMaybeMessage<::NS3::Node_ProductTransform_Item>(Arena*);
template<> ::NS3::ProductGroup* Arena::CreateMaybeMessage<::NS3::ProductGroup>(Arena*);
template<> ::NS3::ProductGroup_ProductSpecification* Arena::CreateMaybeMessage<::NS3::ProductGroup_ProductSpecification>(Arena*);
template<> ::NS3::SolutionResponse* Arena::CreateMaybeMessage<::NS3::SolutionResponse>(Arena*);
template<> ::NS3::SolutionResponse_Assignment* Arena::CreateMaybeMessage<::NS3::SolutionResponse_Assignment>(Arena*);
template<> ::NS3::SolutionResponse_GeometrySequence* Arena::CreateMaybeMessage<::NS3::SolutionResponse_GeometrySequence>(Arena*);
template<> ::NS3::SolutionResponse_NodeFlow* Arena::CreateMaybeMessage<::NS3::SolutionResponse_NodeFlow>(Arena*);
template<> ::NS3::SolutionResponse_NodeProductFlow* Arena::CreateMaybeMessage<::NS3::SolutionResponse_NodeProductFlow>(Arena*);
template<> ::NS3::SolutionResponse_NodeProductTransformAssignment* Arena::CreateMaybeMessage<::NS3::SolutionResponse_NodeProductTransformAssignment>(Arena*);
template<> ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* Arena::CreateMaybeMessage<::NS3::SolutionResponse_NodeProductTransformAssignment_Item>(Arena*);
template<> ::NS3::SolutionResponse_Route* Arena::CreateMaybeMessage<::NS3::SolutionResponse_Route>(Arena*);
template<> ::NS3::SolveRequest* Arena::CreateMaybeMessage<::NS3::SolveRequest>(Arena*);
template<> ::NS3::UnitDimensionCost* Arena::CreateMaybeMessage<::NS3::UnitDimensionCost>(Arena*);
template<> ::NS3::UserDimension* Arena::CreateMaybeMessage<::NS3::UserDimension>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NS3 {

enum InternalDimension_eMeasurementUnit {
  InternalDimension_eMeasurementUnit_SECONDS = 0,
  InternalDimension_eMeasurementUnit_MINUTES = 1,
  InternalDimension_eMeasurementUnit_HOURS = 2,
  InternalDimension_eMeasurementUnit_DAYS = 3,
  InternalDimension_eMeasurementUnit_KILOMETRES = 4,
  InternalDimension_eMeasurementUnit_MILES = 5
};
bool InternalDimension_eMeasurementUnit_IsValid(int value);
const InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN = InternalDimension_eMeasurementUnit_SECONDS;
const InternalDimension_eMeasurementUnit InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX = InternalDimension_eMeasurementUnit_MILES;
const int InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE = InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* InternalDimension_eMeasurementUnit_descriptor();
inline const ::std::string& InternalDimension_eMeasurementUnit_Name(InternalDimension_eMeasurementUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    InternalDimension_eMeasurementUnit_descriptor(), value);
}
inline bool InternalDimension_eMeasurementUnit_Parse(
    const ::std::string& name, InternalDimension_eMeasurementUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalDimension_eMeasurementUnit>(
    InternalDimension_eMeasurementUnit_descriptor(), name, value);
}
enum SolveRequest_SolveType {
  SolveRequest_SolveType_Optimise = 0
};
bool SolveRequest_SolveType_IsValid(int value);
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = SolveRequest_SolveType_Optimise;
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = SolveRequest_SolveType_Optimise;
const int SolveRequest_SolveType_SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor();
inline const ::std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_SolveType_descriptor(), value);
}
inline bool SolveRequest_SolveType_Parse(
    const ::std::string& name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
    SolveRequest_SolveType_descriptor(), name, value);
}
enum SolveRequest_GeometryOutput {
  SolveRequest_GeometryOutput_None = 0,
  SolveRequest_GeometryOutput_Aggregate = 1
};
bool SolveRequest_GeometryOutput_IsValid(int value);
const SolveRequest_GeometryOutput SolveRequest_GeometryOutput_GeometryOutput_MIN = SolveRequest_GeometryOutput_None;
const SolveRequest_GeometryOutput SolveRequest_GeometryOutput_GeometryOutput_MAX = SolveRequest_GeometryOutput_Aggregate;
const int SolveRequest_GeometryOutput_GeometryOutput_ARRAYSIZE = SolveRequest_GeometryOutput_GeometryOutput_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_GeometryOutput_descriptor();
inline const ::std::string& SolveRequest_GeometryOutput_Name(SolveRequest_GeometryOutput value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_GeometryOutput_descriptor(), value);
}
inline bool SolveRequest_GeometryOutput_Parse(
    const ::std::string& name, SolveRequest_GeometryOutput* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_GeometryOutput>(
    SolveRequest_GeometryOutput_descriptor(), name, value);
}
// ===================================================================

class InternalDimension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.InternalDimension) */ {
 public:
  InternalDimension();
  virtual ~InternalDimension();

  InternalDimension(const InternalDimension& from);

  inline InternalDimension& operator=(const InternalDimension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InternalDimension(InternalDimension&& from) noexcept
    : InternalDimension() {
    *this = ::std::move(from);
  }

  inline InternalDimension& operator=(InternalDimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalDimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InternalDimension* internal_default_instance() {
    return reinterpret_cast<const InternalDimension*>(
               &_InternalDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InternalDimension* other);
  friend void swap(InternalDimension& a, InternalDimension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InternalDimension* New() const final {
    return CreateMaybeMessage<InternalDimension>(NULL);
  }

  InternalDimension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InternalDimension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InternalDimension& from);
  void MergeFrom(const InternalDimension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InternalDimension_eMeasurementUnit eMeasurementUnit;
  static const eMeasurementUnit SECONDS =
    InternalDimension_eMeasurementUnit_SECONDS;
  static const eMeasurementUnit MINUTES =
    InternalDimension_eMeasurementUnit_MINUTES;
  static const eMeasurementUnit HOURS =
    InternalDimension_eMeasurementUnit_HOURS;
  static const eMeasurementUnit DAYS =
    InternalDimension_eMeasurementUnit_DAYS;
  static const eMeasurementUnit KILOMETRES =
    InternalDimension_eMeasurementUnit_KILOMETRES;
  static const eMeasurementUnit MILES =
    InternalDimension_eMeasurementUnit_MILES;
  static inline bool eMeasurementUnit_IsValid(int value) {
    return InternalDimension_eMeasurementUnit_IsValid(value);
  }
  static const eMeasurementUnit eMeasurementUnit_MIN =
    InternalDimension_eMeasurementUnit_eMeasurementUnit_MIN;
  static const eMeasurementUnit eMeasurementUnit_MAX =
    InternalDimension_eMeasurementUnit_eMeasurementUnit_MAX;
  static const int eMeasurementUnit_ARRAYSIZE =
    InternalDimension_eMeasurementUnit_eMeasurementUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eMeasurementUnit_descriptor() {
    return InternalDimension_eMeasurementUnit_descriptor();
  }
  static inline const ::std::string& eMeasurementUnit_Name(eMeasurementUnit value) {
    return InternalDimension_eMeasurementUnit_Name(value);
  }
  static inline bool eMeasurementUnit_Parse(const ::std::string& name,
      eMeasurementUnit* value) {
    return InternalDimension_eMeasurementUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
  bool has_measurementunit() const;
  void clear_measurementunit();
  static const int kMeasurementUnitFieldNumber = 2;
  ::NS3::InternalDimension_eMeasurementUnit measurementunit() const;
  void set_measurementunit(::NS3::InternalDimension_eMeasurementUnit value);

  // @@protoc_insertion_point(class_scope:NS3.InternalDimension)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_measurementunit();
  void clear_has_measurementunit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int measurementunit_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDimension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.UserDimension) */ {
 public:
  UserDimension();
  virtual ~UserDimension();

  UserDimension(const UserDimension& from);

  inline UserDimension& operator=(const UserDimension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDimension(UserDimension&& from) noexcept
    : UserDimension() {
    *this = ::std::move(from);
  }

  inline UserDimension& operator=(UserDimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDimension* internal_default_instance() {
    return reinterpret_cast<const UserDimension*>(
               &_UserDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UserDimension* other);
  friend void swap(UserDimension& a, UserDimension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDimension* New() const final {
    return CreateMaybeMessage<UserDimension>(NULL);
  }

  UserDimension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDimension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDimension& from);
  void MergeFrom(const UserDimension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string units = 2;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  const ::std::string& units() const;
  void set_units(const ::std::string& value);
  #if LANG_CXX11
  void set_units(::std::string&& value);
  #endif
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  ::std::string* mutable_units();
  ::std::string* release_units();
  void set_allocated_units(::std::string* units);

  // @@protoc_insertion_point(class_scope:NS3.UserDimension)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_units();
  void clear_has_units();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr units_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DimensionConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.DimensionConfiguration) */ {
 public:
  DimensionConfiguration();
  virtual ~DimensionConfiguration();

  DimensionConfiguration(const DimensionConfiguration& from);

  inline DimensionConfiguration& operator=(const DimensionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DimensionConfiguration(DimensionConfiguration&& from) noexcept
    : DimensionConfiguration() {
    *this = ::std::move(from);
  }

  inline DimensionConfiguration& operator=(DimensionConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DimensionConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DimensionConfiguration* internal_default_instance() {
    return reinterpret_cast<const DimensionConfiguration*>(
               &_DimensionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DimensionConfiguration* other);
  friend void swap(DimensionConfiguration& a, DimensionConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DimensionConfiguration* New() const final {
    return CreateMaybeMessage<DimensionConfiguration>(NULL);
  }

  DimensionConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DimensionConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DimensionConfiguration& from);
  void MergeFrom(const DimensionConfiguration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.UserDimension userDimensions = 3;
  int userdimensions_size() const;
  void clear_userdimensions();
  static const int kUserDimensionsFieldNumber = 3;
  ::NS3::UserDimension* mutable_userdimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >*
      mutable_userdimensions();
  const ::NS3::UserDimension& userdimensions(int index) const;
  ::NS3::UserDimension* add_userdimensions();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >&
      userdimensions() const;

  // optional .NS3.InternalDimension timeConfig = 1;
  bool has_timeconfig() const;
  void clear_timeconfig();
  static const int kTimeConfigFieldNumber = 1;
  private:
  const ::NS3::InternalDimension& _internal_timeconfig() const;
  public:
  const ::NS3::InternalDimension& timeconfig() const;
  ::NS3::InternalDimension* release_timeconfig();
  ::NS3::InternalDimension* mutable_timeconfig();
  void set_allocated_timeconfig(::NS3::InternalDimension* timeconfig);

  // optional .NS3.InternalDimension distanceConfig = 2;
  bool has_distanceconfig() const;
  void clear_distanceconfig();
  static const int kDistanceConfigFieldNumber = 2;
  private:
  const ::NS3::InternalDimension& _internal_distanceconfig() const;
  public:
  const ::NS3::InternalDimension& distanceconfig() const;
  ::NS3::InternalDimension* release_distanceconfig();
  ::NS3::InternalDimension* mutable_distanceconfig();
  void set_allocated_distanceconfig(::NS3::InternalDimension* distanceconfig);

  // @@protoc_insertion_point(class_scope:NS3.DimensionConfiguration)
 private:
  void set_has_timeconfig();
  void clear_has_timeconfig();
  void set_has_distanceconfig();
  void clear_has_distanceconfig();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension > userdimensions_;
  ::NS3::InternalDimension* timeconfig_;
  ::NS3::InternalDimension* distanceconfig_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geocode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Geocode) */ {
 public:
  Geocode();
  virtual ~Geocode();

  Geocode(const Geocode& from);

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(Geocode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geocode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Geocode* other);
  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geocode* New() const final {
    return CreateMaybeMessage<Geocode>(NULL);
  }

  Geocode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geocode& from);
  void MergeFrom(const Geocode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  float longitude() const;
  void set_longitude(float value);

  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  float latitude() const;
  void set_latitude(float value);

  // @@protoc_insertion_point(class_scope:NS3.Geocode)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float longitude_;
  float latitude_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitDimensionCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.UnitDimensionCost) */ {
 public:
  UnitDimensionCost();
  virtual ~UnitDimensionCost();

  UnitDimensionCost(const UnitDimensionCost& from);

  inline UnitDimensionCost& operator=(const UnitDimensionCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitDimensionCost(UnitDimensionCost&& from) noexcept
    : UnitDimensionCost() {
    *this = ::std::move(from);
  }

  inline UnitDimensionCost& operator=(UnitDimensionCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitDimensionCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitDimensionCost* internal_default_instance() {
    return reinterpret_cast<const UnitDimensionCost*>(
               &_UnitDimensionCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UnitDimensionCost* other);
  friend void swap(UnitDimensionCost& a, UnitDimensionCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitDimensionCost* New() const final {
    return CreateMaybeMessage<UnitDimensionCost>(NULL);
  }

  UnitDimensionCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitDimensionCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitDimensionCost& from);
  void MergeFrom(const UnitDimensionCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitDimensionCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  void clear_dimensionids();
  static const int kDimensionIdsFieldNumber = 1;
  const ::std::string& dimensionids(int index) const;
  ::std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionids(int index, ::std::string&& value);
  #endif
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, size_t size);
  ::std::string* add_dimensionids();
  void add_dimensionids(const ::std::string& value);
  #if LANG_CXX11
  void add_dimensionids(::std::string&& value);
  #endif
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dimensionids();

  // repeated float dimensionCoefficients = 2;
  int dimensioncoefficients_size() const;
  void clear_dimensioncoefficients();
  static const int kDimensionCoefficientsFieldNumber = 2;
  float dimensioncoefficients(int index) const;
  void set_dimensioncoefficients(int index, float value);
  void add_dimensioncoefficients(float value);
  const ::google::protobuf::RepeatedField< float >&
      dimensioncoefficients() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dimensioncoefficients();

  // required float costPerUnit = 3;
  bool has_costperunit() const;
  void clear_costperunit();
  static const int kCostPerUnitFieldNumber = 3;
  float costperunit() const;
  void set_costperunit(float value);

  // @@protoc_insertion_point(class_scope:NS3.UnitDimensionCost)
 private:
  void set_has_costperunit();
  void clear_has_costperunit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dimensionids_;
  ::google::protobuf::RepeatedField< float > dimensioncoefficients_;
  float costperunit_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FixedDimensionCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.FixedDimensionCost) */ {
 public:
  FixedDimensionCost();
  virtual ~FixedDimensionCost();

  FixedDimensionCost(const FixedDimensionCost& from);

  inline FixedDimensionCost& operator=(const FixedDimensionCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixedDimensionCost(FixedDimensionCost&& from) noexcept
    : FixedDimensionCost() {
    *this = ::std::move(from);
  }

  inline FixedDimensionCost& operator=(FixedDimensionCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixedDimensionCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixedDimensionCost* internal_default_instance() {
    return reinterpret_cast<const FixedDimensionCost*>(
               &_FixedDimensionCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FixedDimensionCost* other);
  friend void swap(FixedDimensionCost& a, FixedDimensionCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixedDimensionCost* New() const final {
    return CreateMaybeMessage<FixedDimensionCost>(NULL);
  }

  FixedDimensionCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FixedDimensionCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FixedDimensionCost& from);
  void MergeFrom(const FixedDimensionCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixedDimensionCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  void clear_dimensionids();
  static const int kDimensionIdsFieldNumber = 1;
  const ::std::string& dimensionids(int index) const;
  ::std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionids(int index, ::std::string&& value);
  #endif
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, size_t size);
  ::std::string* add_dimensionids();
  void add_dimensionids(const ::std::string& value);
  #if LANG_CXX11
  void add_dimensionids(::std::string&& value);
  #endif
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dimensionids();

  // required float fixedCost = 2;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 2;
  float fixedcost() const;
  void set_fixedcost(float value);

  // @@protoc_insertion_point(class_scope:NS3.FixedDimensionCost)
 private:
  void set_has_fixedcost();
  void clear_has_fixedcost();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dimensionids_;
  float fixedcost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowDimensionalConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.FlowDimensionalConstraint) */ {
 public:
  FlowDimensionalConstraint();
  virtual ~FlowDimensionalConstraint();

  FlowDimensionalConstraint(const FlowDimensionalConstraint& from);

  inline FlowDimensionalConstraint& operator=(const FlowDimensionalConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowDimensionalConstraint(FlowDimensionalConstraint&& from) noexcept
    : FlowDimensionalConstraint() {
    *this = ::std::move(from);
  }

  inline FlowDimensionalConstraint& operator=(FlowDimensionalConstraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowDimensionalConstraint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowDimensionalConstraint* internal_default_instance() {
    return reinterpret_cast<const FlowDimensionalConstraint*>(
               &_FlowDimensionalConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FlowDimensionalConstraint* other);
  friend void swap(FlowDimensionalConstraint& a, FlowDimensionalConstraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowDimensionalConstraint* New() const final {
    return CreateMaybeMessage<FlowDimensionalConstraint>(NULL);
  }

  FlowDimensionalConstraint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowDimensionalConstraint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowDimensionalConstraint& from);
  void MergeFrom(const FlowDimensionalConstraint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowDimensionalConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  void clear_dimensionids();
  static const int kDimensionIdsFieldNumber = 1;
  const ::std::string& dimensionids(int index) const;
  ::std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionids(int index, ::std::string&& value);
  #endif
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, size_t size);
  ::std::string* add_dimensionids();
  void add_dimensionids(const ::std::string& value);
  #if LANG_CXX11
  void add_dimensionids(::std::string&& value);
  #endif
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dimensionids();

  // repeated float dimensionCoefficients = 2;
  int dimensioncoefficients_size() const;
  void clear_dimensioncoefficients();
  static const int kDimensionCoefficientsFieldNumber = 2;
  float dimensioncoefficients(int index) const;
  void set_dimensioncoefficients(int index, float value);
  void add_dimensioncoefficients(float value);
  const ::google::protobuf::RepeatedField< float >&
      dimensioncoefficients() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dimensioncoefficients();

  // required float flowMin = 3;
  bool has_flowmin() const;
  void clear_flowmin();
  static const int kFlowMinFieldNumber = 3;
  float flowmin() const;
  void set_flowmin(float value);

  // required float flowMax = 4;
  bool has_flowmax() const;
  void clear_flowmax();
  static const int kFlowMaxFieldNumber = 4;
  float flowmax() const;
  void set_flowmax(float value);

  // @@protoc_insertion_point(class_scope:NS3.FlowDimensionalConstraint)
 private:
  void set_has_flowmin();
  void clear_has_flowmin();
  void set_has_flowmax();
  void clear_has_flowmax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dimensionids_;
  ::google::protobuf::RepeatedField< float > dimensioncoefficients_;
  float flowmin_;
  float flowmax_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DimensionRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.DimensionRange) */ {
 public:
  DimensionRange();
  virtual ~DimensionRange();

  DimensionRange(const DimensionRange& from);

  inline DimensionRange& operator=(const DimensionRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DimensionRange(DimensionRange&& from) noexcept
    : DimensionRange() {
    *this = ::std::move(from);
  }

  inline DimensionRange& operator=(DimensionRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DimensionRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DimensionRange* internal_default_instance() {
    return reinterpret_cast<const DimensionRange*>(
               &_DimensionRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DimensionRange* other);
  friend void swap(DimensionRange& a, DimensionRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DimensionRange* New() const final {
    return CreateMaybeMessage<DimensionRange>(NULL);
  }

  DimensionRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DimensionRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DimensionRange& from);
  void MergeFrom(const DimensionRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // required float minRange = 2 [default = 0];
  bool has_minrange() const;
  void clear_minrange();
  static const int kMinRangeFieldNumber = 2;
  float minrange() const;
  void set_minrange(float value);

  // required float maxRange = 3;
  bool has_maxrange() const;
  void clear_maxrange();
  static const int kMaxRangeFieldNumber = 3;
  float maxrange() const;
  void set_maxrange(float value);

  // required float flowPenalty = 4 [default = 0];
  bool has_flowpenalty() const;
  void clear_flowpenalty();
  static const int kFlowPenaltyFieldNumber = 4;
  float flowpenalty() const;
  void set_flowpenalty(float value);

  // @@protoc_insertion_point(class_scope:NS3.DimensionRange)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_minrange();
  void clear_has_minrange();
  void set_has_maxrange();
  void clear_has_maxrange();
  void set_has_flowpenalty();
  void clear_has_flowpenalty();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  float minrange_;
  float maxrange_;
  float flowpenalty_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node_ProductFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductFlow) */ {
 public:
  Node_ProductFlow();
  virtual ~Node_ProductFlow();

  Node_ProductFlow(const Node_ProductFlow& from);

  inline Node_ProductFlow& operator=(const Node_ProductFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node_ProductFlow(Node_ProductFlow&& from) noexcept
    : Node_ProductFlow() {
    *this = ::std::move(from);
  }

  inline Node_ProductFlow& operator=(Node_ProductFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_ProductFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node_ProductFlow* internal_default_instance() {
    return reinterpret_cast<const Node_ProductFlow*>(
               &_Node_ProductFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Node_ProductFlow* other);
  friend void swap(Node_ProductFlow& a, Node_ProductFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node_ProductFlow* New() const final {
    return CreateMaybeMessage<Node_ProductFlow>(NULL);
  }

  Node_ProductFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node_ProductFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node_ProductFlow& from);
  void MergeFrom(const Node_ProductFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.DimensionRange dimensionRanges = 2;
  int dimensionranges_size() const;
  void clear_dimensionranges();
  static const int kDimensionRangesFieldNumber = 2;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;

  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
  int fixeddimensioncosts_size() const;
  void clear_fixeddimensioncosts();
  static const int kFixedDimensionCostsFieldNumber = 3;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 4;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // required string productId = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // @@protoc_insertion_point(class_scope:NS3.Node.ProductFlow)
 private:
  void set_has_productid();
  void clear_has_productid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node_Flow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.Flow) */ {
 public:
  Node_Flow();
  virtual ~Node_Flow();

  Node_Flow(const Node_Flow& from);

  inline Node_Flow& operator=(const Node_Flow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node_Flow(Node_Flow&& from) noexcept
    : Node_Flow() {
    *this = ::std::move(from);
  }

  inline Node_Flow& operator=(Node_Flow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_Flow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node_Flow* internal_default_instance() {
    return reinterpret_cast<const Node_Flow*>(
               &_Node_Flow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Node_Flow* other);
  friend void swap(Node_Flow& a, Node_Flow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node_Flow* New() const final {
    return CreateMaybeMessage<Node_Flow>(NULL);
  }

  Node_Flow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node_Flow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node_Flow& from);
  void MergeFrom(const Node_Flow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_Flow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.DimensionRange dimensionRanges = 1;
  int dimensionranges_size() const;
  void clear_dimensionranges();
  static const int kDimensionRangesFieldNumber = 1;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;

  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
  int fixeddimensioncosts_size() const;
  void clear_fixeddimensioncosts();
  static const int kFixedDimensionCostsFieldNumber = 2;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 3;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // @@protoc_insertion_point(class_scope:NS3.Node.Flow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node_ProductTransform_Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductTransform.Item) */ {
 public:
  Node_ProductTransform_Item();
  virtual ~Node_ProductTransform_Item();

  Node_ProductTransform_Item(const Node_ProductTransform_Item& from);

  inline Node_ProductTransform_Item& operator=(const Node_ProductTransform_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node_ProductTransform_Item(Node_ProductTransform_Item&& from) noexcept
    : Node_ProductTransform_Item() {
    *this = ::std::move(from);
  }

  inline Node_ProductTransform_Item& operator=(Node_ProductTransform_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_ProductTransform_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node_ProductTransform_Item* internal_default_instance() {
    return reinterpret_cast<const Node_ProductTransform_Item*>(
               &_Node_ProductTransform_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Node_ProductTransform_Item* other);
  friend void swap(Node_ProductTransform_Item& a, Node_ProductTransform_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node_ProductTransform_Item* New() const final {
    return CreateMaybeMessage<Node_ProductTransform_Item>(NULL);
  }

  Node_ProductTransform_Item* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node_ProductTransform_Item>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node_ProductTransform_Item& from);
  void MergeFrom(const Node_ProductTransform_Item& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductTransform_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.DimensionRange dimensionRanges = 3;
  int dimensionranges_size() const;
  void clear_dimensionranges();
  static const int kDimensionRangesFieldNumber = 3;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;

  // repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
  int fixeddimensioncosts_size() const;
  void clear_fixeddimensioncosts();
  static const int kFixedDimensionCostsFieldNumber = 4;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 5;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // required string productId = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required int32 productRatio = 2;
  bool has_productratio() const;
  void clear_productratio();
  static const int kProductRatioFieldNumber = 2;
  ::google::protobuf::int32 productratio() const;
  void set_productratio(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NS3.Node.ProductTransform.Item)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_productratio();
  void clear_has_productratio();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::int32 productratio_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node_ProductTransform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductTransform) */ {
 public:
  Node_ProductTransform();
  virtual ~Node_ProductTransform();

  Node_ProductTransform(const Node_ProductTransform& from);

  inline Node_ProductTransform& operator=(const Node_ProductTransform& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node_ProductTransform(Node_ProductTransform&& from) noexcept
    : Node_ProductTransform() {
    *this = ::std::move(from);
  }

  inline Node_ProductTransform& operator=(Node_ProductTransform&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_ProductTransform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node_ProductTransform* internal_default_instance() {
    return reinterpret_cast<const Node_ProductTransform*>(
               &_Node_ProductTransform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Node_ProductTransform* other);
  friend void swap(Node_ProductTransform& a, Node_ProductTransform& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node_ProductTransform* New() const final {
    return CreateMaybeMessage<Node_ProductTransform>(NULL);
  }

  Node_ProductTransform* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node_ProductTransform>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node_ProductTransform& from);
  void MergeFrom(const Node_ProductTransform& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductTransform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Node_ProductTransform_Item Item;

  // accessors -------------------------------------------------------

  // repeated .NS3.Node.ProductTransform.Item inputItems = 2;
  int inputitems_size() const;
  void clear_inputitems();
  static const int kInputItemsFieldNumber = 2;
  ::NS3::Node_ProductTransform_Item* mutable_inputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
      mutable_inputitems();
  const ::NS3::Node_ProductTransform_Item& inputitems(int index) const;
  ::NS3::Node_ProductTransform_Item* add_inputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
      inputitems() const;

  // repeated .NS3.Node.ProductTransform.Item outputItems = 3;
  int outputitems_size() const;
  void clear_outputitems();
  static const int kOutputItemsFieldNumber = 3;
  ::NS3::Node_ProductTransform_Item* mutable_outputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
      mutable_outputitems();
  const ::NS3::Node_ProductTransform_Item& outputitems(int index) const;
  ::NS3::Node_ProductTransform_Item* add_outputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
      outputitems() const;

  // required string productTransformId = 1;
  bool has_producttransformid() const;
  void clear_producttransformid();
  static const int kProductTransformIdFieldNumber = 1;
  const ::std::string& producttransformid() const;
  void set_producttransformid(const ::std::string& value);
  #if LANG_CXX11
  void set_producttransformid(::std::string&& value);
  #endif
  void set_producttransformid(const char* value);
  void set_producttransformid(const char* value, size_t size);
  ::std::string* mutable_producttransformid();
  ::std::string* release_producttransformid();
  void set_allocated_producttransformid(::std::string* producttransformid);

  // @@protoc_insertion_point(class_scope:NS3.Node.ProductTransform)
 private:
  void set_has_producttransformid();
  void clear_has_producttransformid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item > inputitems_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item > outputitems_;
  ::google::protobuf::internal::ArenaStringPtr producttransformid_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(NULL);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Node_ProductFlow ProductFlow;
  typedef Node_Flow Flow;
  typedef Node_ProductTransform ProductTransform;

  // accessors -------------------------------------------------------

  // repeated .NS3.Node.ProductFlow production = 3;
  int production_size() const;
  void clear_production();
  static const int kProductionFieldNumber = 3;
  ::NS3::Node_ProductFlow* mutable_production(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_production();
  const ::NS3::Node_ProductFlow& production(int index) const;
  ::NS3::Node_ProductFlow* add_production();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      production() const;

  // repeated .NS3.Node.ProductFlow consumption = 4;
  int consumption_size() const;
  void clear_consumption();
  static const int kConsumptionFieldNumber = 4;
  ::NS3::Node_ProductFlow* mutable_consumption(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_consumption();
  const ::NS3::Node_ProductFlow& consumption(int index) const;
  ::NS3::Node_ProductFlow* add_consumption();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      consumption() const;

  // repeated .NS3.Node.ProductFlow productFlows = 6;
  int productflows_size() const;
  void clear_productflows();
  static const int kProductFlowsFieldNumber = 6;
  ::NS3::Node_ProductFlow* mutable_productflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_productflows();
  const ::NS3::Node_ProductFlow& productflows(int index) const;
  ::NS3::Node_ProductFlow* add_productflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      productflows() const;

  // repeated string allowableSources = 7;
  int allowablesources_size() const;
  void clear_allowablesources();
  static const int kAllowableSourcesFieldNumber = 7;
  const ::std::string& allowablesources(int index) const;
  ::std::string* mutable_allowablesources(int index);
  void set_allowablesources(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_allowablesources(int index, ::std::string&& value);
  #endif
  void set_allowablesources(int index, const char* value);
  void set_allowablesources(int index, const char* value, size_t size);
  ::std::string* add_allowablesources();
  void add_allowablesources(const ::std::string& value);
  #if LANG_CXX11
  void add_allowablesources(::std::string&& value);
  #endif
  void add_allowablesources(const char* value);
  void add_allowablesources(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& allowablesources() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allowablesources();

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
  int flowconstraints_size() const;
  void clear_flowconstraints();
  static const int kFlowConstraintsFieldNumber = 9;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;

  // repeated .NS3.Node.ProductTransform productTransforms = 10;
  int producttransforms_size() const;
  void clear_producttransforms();
  static const int kProductTransformsFieldNumber = 10;
  ::NS3::Node_ProductTransform* mutable_producttransforms(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >*
      mutable_producttransforms();
  const ::NS3::Node_ProductTransform& producttransforms(int index) const;
  ::NS3::Node_ProductTransform* add_producttransforms();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >&
      producttransforms() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .NS3.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode();
  static const int kGeocodeFieldNumber = 2;
  private:
  const ::NS3::Geocode& _internal_geocode() const;
  public:
  const ::NS3::Geocode& geocode() const;
  ::NS3::Geocode* release_geocode();
  ::NS3::Geocode* mutable_geocode();
  void set_allocated_geocode(::NS3::Geocode* geocode);

  // optional .NS3.Node.Flow flow = 5;
  bool has_flow() const;
  void clear_flow();
  static const int kFlowFieldNumber = 5;
  private:
  const ::NS3::Node_Flow& _internal_flow() const;
  public:
  const ::NS3::Node_Flow& flow() const;
  ::NS3::Node_Flow* release_flow();
  ::NS3::Node_Flow* mutable_flow();
  void set_allocated_flow(::NS3::Node_Flow* flow);

  // optional int32 maximumSources = 8 [default = -1];
  bool has_maximumsources() const;
  void clear_maximumsources();
  static const int kMaximumSourcesFieldNumber = 8;
  ::google::protobuf::int32 maximumsources() const;
  void set_maximumsources(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NS3.Node)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_geocode();
  void clear_has_geocode();
  void set_has_flow();
  void clear_has_flow();
  void set_has_maximumsources();
  void clear_has_maximumsources();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > production_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > consumption_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > productflows_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allowablesources_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform > producttransforms_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::NS3::Geocode* geocode_;
  ::NS3::Node_Flow* flow_;
  ::google::protobuf::int32 maximumsources_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProductGroup_ProductSpecification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.ProductGroup.ProductSpecification) */ {
 public:
  ProductGroup_ProductSpecification();
  virtual ~ProductGroup_ProductSpecification();

  ProductGroup_ProductSpecification(const ProductGroup_ProductSpecification& from);

  inline ProductGroup_ProductSpecification& operator=(const ProductGroup_ProductSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProductGroup_ProductSpecification(ProductGroup_ProductSpecification&& from) noexcept
    : ProductGroup_ProductSpecification() {
    *this = ::std::move(from);
  }

  inline ProductGroup_ProductSpecification& operator=(ProductGroup_ProductSpecification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductGroup_ProductSpecification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProductGroup_ProductSpecification* internal_default_instance() {
    return reinterpret_cast<const ProductGroup_ProductSpecification*>(
               &_ProductGroup_ProductSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ProductGroup_ProductSpecification* other);
  friend void swap(ProductGroup_ProductSpecification& a, ProductGroup_ProductSpecification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProductGroup_ProductSpecification* New() const final {
    return CreateMaybeMessage<ProductGroup_ProductSpecification>(NULL);
  }

  ProductGroup_ProductSpecification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProductGroup_ProductSpecification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProductGroup_ProductSpecification& from);
  void MergeFrom(const ProductGroup_ProductSpecification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductGroup_ProductSpecification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string targetDimension = 2;
  int targetdimension_size() const;
  void clear_targetdimension();
  static const int kTargetDimensionFieldNumber = 2;
  const ::std::string& targetdimension(int index) const;
  ::std::string* mutable_targetdimension(int index);
  void set_targetdimension(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_targetdimension(int index, ::std::string&& value);
  #endif
  void set_targetdimension(int index, const char* value);
  void set_targetdimension(int index, const char* value, size_t size);
  ::std::string* add_targetdimension();
  void add_targetdimension(const ::std::string& value);
  #if LANG_CXX11
  void add_targetdimension(::std::string&& value);
  #endif
  void add_targetdimension(const char* value);
  void add_targetdimension(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& targetdimension() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_targetdimension();

  // repeated float targetPerBase = 3;
  int targetperbase_size() const;
  void clear_targetperbase();
  static const int kTargetPerBaseFieldNumber = 3;
  float targetperbase(int index) const;
  void set_targetperbase(int index, float value);
  void add_targetperbase(float value);
  const ::google::protobuf::RepeatedField< float >&
      targetperbase() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_targetperbase();

  // required string baseDimension = 1;
  bool has_basedimension() const;
  void clear_basedimension();
  static const int kBaseDimensionFieldNumber = 1;
  const ::std::string& basedimension() const;
  void set_basedimension(const ::std::string& value);
  #if LANG_CXX11
  void set_basedimension(::std::string&& value);
  #endif
  void set_basedimension(const char* value);
  void set_basedimension(const char* value, size_t size);
  ::std::string* mutable_basedimension();
  ::std::string* release_basedimension();
  void set_allocated_basedimension(::std::string* basedimension);

  // @@protoc_insertion_point(class_scope:NS3.ProductGroup.ProductSpecification)
 private:
  void set_has_basedimension();
  void clear_has_basedimension();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> targetdimension_;
  ::google::protobuf::RepeatedField< float > targetperbase_;
  ::google::protobuf::internal::ArenaStringPtr basedimension_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProductGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.ProductGroup) */ {
 public:
  ProductGroup();
  virtual ~ProductGroup();

  ProductGroup(const ProductGroup& from);

  inline ProductGroup& operator=(const ProductGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProductGroup(ProductGroup&& from) noexcept
    : ProductGroup() {
    *this = ::std::move(from);
  }

  inline ProductGroup& operator=(ProductGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProductGroup* internal_default_instance() {
    return reinterpret_cast<const ProductGroup*>(
               &_ProductGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ProductGroup* other);
  friend void swap(ProductGroup& a, ProductGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProductGroup* New() const final {
    return CreateMaybeMessage<ProductGroup>(NULL);
  }

  ProductGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProductGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProductGroup& from);
  void MergeFrom(const ProductGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProductGroup_ProductSpecification ProductSpecification;

  // accessors -------------------------------------------------------

  // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
  int productspecification_size() const;
  void clear_productspecification();
  static const int kProductSpecificationFieldNumber = 3;
  ::NS3::ProductGroup_ProductSpecification* mutable_productspecification(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >*
      mutable_productspecification();
  const ::NS3::ProductGroup_ProductSpecification& productspecification(int index) const;
  ::NS3::ProductGroup_ProductSpecification* add_productspecification();
  const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >&
      productspecification() const;

  // required string productId = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required string productGroupId = 2;
  bool has_productgroupid() const;
  void clear_productgroupid();
  static const int kProductGroupIdFieldNumber = 2;
  const ::std::string& productgroupid() const;
  void set_productgroupid(const ::std::string& value);
  #if LANG_CXX11
  void set_productgroupid(::std::string&& value);
  #endif
  void set_productgroupid(const char* value);
  void set_productgroupid(const char* value, size_t size);
  ::std::string* mutable_productgroupid();
  ::std::string* release_productgroupid();
  void set_allocated_productgroupid(::std::string* productgroupid);

  // @@protoc_insertion_point(class_scope:NS3.ProductGroup)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_productgroupid();
  void clear_has_productgroupid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification > productspecification_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr productgroupid_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.LaneRate) */ {
 public:
  LaneRate();
  virtual ~LaneRate();

  LaneRate(const LaneRate& from);

  inline LaneRate& operator=(const LaneRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneRate(LaneRate&& from) noexcept
    : LaneRate() {
    *this = ::std::move(from);
  }

  inline LaneRate& operator=(LaneRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneRate* internal_default_instance() {
    return reinterpret_cast<const LaneRate*>(
               &_LaneRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(LaneRate* other);
  friend void swap(LaneRate& a, LaneRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneRate* New() const final {
    return CreateMaybeMessage<LaneRate>(NULL);
  }

  LaneRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneRate& from);
  void MergeFrom(const LaneRate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string productIds = 5;
  int productids_size() const;
  void clear_productids();
  static const int kProductIdsFieldNumber = 5;
  const ::std::string& productids(int index) const;
  ::std::string* mutable_productids(int index);
  void set_productids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productids(int index, ::std::string&& value);
  #endif
  void set_productids(int index, const char* value);
  void set_productids(int index, const char* value, size_t size);
  ::std::string* add_productids();
  void add_productids(const ::std::string& value);
  #if LANG_CXX11
  void add_productids(::std::string&& value);
  #endif
  void add_productids(const char* value);
  void add_productids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productids();

  // repeated string productGroupIds = 6;
  int productgroupids_size() const;
  void clear_productgroupids();
  static const int kProductGroupIdsFieldNumber = 6;
  const ::std::string& productgroupids(int index) const;
  ::std::string* mutable_productgroupids(int index);
  void set_productgroupids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productgroupids(int index, ::std::string&& value);
  #endif
  void set_productgroupids(int index, const char* value);
  void set_productgroupids(int index, const char* value, size_t size);
  ::std::string* add_productgroupids();
  void add_productgroupids(const ::std::string& value);
  #if LANG_CXX11
  void add_productgroupids(::std::string&& value);
  #endif
  void add_productgroupids(const char* value);
  void add_productgroupids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productgroupids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productgroupids();

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 7;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
  int flowconstraints_size() const;
  void clear_flowconstraints();
  static const int kFlowConstraintsFieldNumber = 8;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // required string destination = 4;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 4;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // @@protoc_insertion_point(class_scope:NS3.LaneRate)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productgroupids_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CostModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.CostModel) */ {
 public:
  CostModel();
  virtual ~CostModel();

  CostModel(const CostModel& from);

  inline CostModel& operator=(const CostModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CostModel(CostModel&& from) noexcept
    : CostModel() {
    *this = ::std::move(from);
  }

  inline CostModel& operator=(CostModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CostModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CostModel* internal_default_instance() {
    return reinterpret_cast<const CostModel*>(
               &_CostModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CostModel* other);
  friend void swap(CostModel& a, CostModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CostModel* New() const final {
    return CreateMaybeMessage<CostModel>(NULL);
  }

  CostModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CostModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CostModel& from);
  void MergeFrom(const CostModel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string productGroupIds = 3;
  int productgroupids_size() const;
  void clear_productgroupids();
  static const int kProductGroupIdsFieldNumber = 3;
  const ::std::string& productgroupids(int index) const;
  ::std::string* mutable_productgroupids(int index);
  void set_productgroupids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productgroupids(int index, ::std::string&& value);
  #endif
  void set_productgroupids(int index, const char* value);
  void set_productgroupids(int index, const char* value, size_t size);
  ::std::string* add_productgroupids();
  void add_productgroupids(const ::std::string& value);
  #if LANG_CXX11
  void add_productgroupids(::std::string&& value);
  #endif
  void add_productgroupids(const char* value);
  void add_productgroupids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productgroupids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productgroupids();

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 4;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
  int flowconstraints_size() const;
  void clear_flowconstraints();
  static const int kFlowConstraintsFieldNumber = 5;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // @@protoc_insertion_point(class_scope:NS3.CostModel)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_source();
  void clear_has_source();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productgroupids_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(NULL);
  }

  Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.Node nodes = 2;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  ::NS3::Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node >*
      mutable_nodes();
  const ::NS3::Node& nodes(int index) const;
  ::NS3::Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node >&
      nodes() const;

  // repeated .NS3.LaneRate laneRates = 3;
  int lanerates_size() const;
  void clear_lanerates();
  static const int kLaneRatesFieldNumber = 3;
  ::NS3::LaneRate* mutable_lanerates(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >*
      mutable_lanerates();
  const ::NS3::LaneRate& lanerates(int index) const;
  ::NS3::LaneRate* add_lanerates();
  const ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >&
      lanerates() const;

  // repeated .NS3.CostModel costModels = 4;
  int costmodels_size() const;
  void clear_costmodels();
  static const int kCostModelsFieldNumber = 4;
  ::NS3::CostModel* mutable_costmodels(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >*
      mutable_costmodels();
  const ::NS3::CostModel& costmodels(int index) const;
  ::NS3::CostModel* add_costmodels();
  const ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >&
      costmodels() const;

  // repeated .NS3.ProductGroup productGroups = 5;
  int productgroups_size() const;
  void clear_productgroups();
  static const int kProductGroupsFieldNumber = 5;
  ::NS3::ProductGroup* mutable_productgroups(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >*
      mutable_productgroups();
  const ::NS3::ProductGroup& productgroups(int index) const;
  ::NS3::ProductGroup* add_productgroups();
  const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >&
      productgroups() const;

  // required .NS3.DimensionConfiguration dimensions = 1;
  bool has_dimensions() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 1;
  private:
  const ::NS3::DimensionConfiguration& _internal_dimensions() const;
  public:
  const ::NS3::DimensionConfiguration& dimensions() const;
  ::NS3::DimensionConfiguration* release_dimensions();
  ::NS3::DimensionConfiguration* mutable_dimensions();
  void set_allocated_dimensions(::NS3::DimensionConfiguration* dimensions);

  // @@protoc_insertion_point(class_scope:NS3.Model)
 private:
  void set_has_dimensions();
  void clear_has_dimensions();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node > nodes_;
  ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate > lanerates_;
  ::google::protobuf::RepeatedPtrField< ::NS3::CostModel > costmodels_;
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup > productgroups_;
  ::NS3::DimensionConfiguration* dimensions_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolveRequest) */ {
 public:
  SolveRequest();
  virtual ~SolveRequest();

  SolveRequest(const SolveRequest& from);

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(SolveRequest* other);
  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolveRequest* New() const final {
    return CreateMaybeMessage<SolveRequest>(NULL);
  }

  SolveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolveRequest& from);
  void MergeFrom(const SolveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolveRequest_SolveType SolveType;
  static const SolveType Optimise =
    SolveRequest_SolveType_Optimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static const SolveType SolveType_MIN =
    SolveRequest_SolveType_SolveType_MIN;
  static const SolveType SolveType_MAX =
    SolveRequest_SolveType_SolveType_MAX;
  static const int SolveType_ARRAYSIZE =
    SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  static inline const ::std::string& SolveType_Name(SolveType value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(const ::std::string& name,
      SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  typedef SolveRequest_GeometryOutput GeometryOutput;
  static const GeometryOutput None =
    SolveRequest_GeometryOutput_None;
  static const GeometryOutput Aggregate =
    SolveRequest_GeometryOutput_Aggregate;
  static inline bool GeometryOutput_IsValid(int value) {
    return SolveRequest_GeometryOutput_IsValid(value);
  }
  static const GeometryOutput GeometryOutput_MIN =
    SolveRequest_GeometryOutput_GeometryOutput_MIN;
  static const GeometryOutput GeometryOutput_MAX =
    SolveRequest_GeometryOutput_GeometryOutput_MAX;
  static const int GeometryOutput_ARRAYSIZE =
    SolveRequest_GeometryOutput_GeometryOutput_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GeometryOutput_descriptor() {
    return SolveRequest_GeometryOutput_descriptor();
  }
  static inline const ::std::string& GeometryOutput_Name(GeometryOutput value) {
    return SolveRequest_GeometryOutput_Name(value);
  }
  static inline bool GeometryOutput_Parse(const ::std::string& name,
      GeometryOutput* value) {
    return SolveRequest_GeometryOutput_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIDFieldNumber = 2;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // optional .NS3.Model model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  private:
  const ::NS3::Model& _internal_model() const;
  public:
  const ::NS3::Model& model() const;
  ::NS3::Model* release_model();
  ::NS3::Model* mutable_model();
  void set_allocated_model(::NS3::Model* model);

  // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype();
  static const int kSolveTypeFieldNumber = 4;
  ::NS3::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::NS3::SolveRequest_SolveType value);

  // optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
  bool has_geometryoutput() const;
  void clear_geometryoutput();
  static const int kGeometryOutputFieldNumber = 5;
  ::NS3::SolveRequest_GeometryOutput geometryoutput() const;
  void set_geometryoutput(::NS3::SolveRequest_GeometryOutput value);

  // @@protoc_insertion_point(class_scope:NS3.SolveRequest)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_modelid();
  void clear_has_modelid();
  void set_has_solvetype();
  void clear_has_solvetype();
  void set_has_geometryoutput();
  void clear_has_geometryoutput();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  ::NS3::Model* model_;
  int solvetype_;
  int geometryoutput_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Assignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.Assignment) */ {
 public:
  SolutionResponse_Assignment();
  virtual ~SolutionResponse_Assignment();

  SolutionResponse_Assignment(const SolutionResponse_Assignment& from);

  inline SolutionResponse_Assignment& operator=(const SolutionResponse_Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Assignment(SolutionResponse_Assignment&& from) noexcept
    : SolutionResponse_Assignment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Assignment& operator=(SolutionResponse_Assignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Assignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Assignment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Assignment*>(
               &_SolutionResponse_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SolutionResponse_Assignment* other);
  friend void swap(SolutionResponse_Assignment& a, SolutionResponse_Assignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Assignment* New() const final {
    return CreateMaybeMessage<SolutionResponse_Assignment>(NULL);
  }

  SolutionResponse_Assignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Assignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Assignment& from);
  void MergeFrom(const SolutionResponse_Assignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Assignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // required string destination = 2;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // required string productId = 3;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 3;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string laneRateId = 6;
  bool has_lanerateid() const;
  void clear_lanerateid();
  static const int kLaneRateIdFieldNumber = 6;
  const ::std::string& lanerateid() const;
  void set_lanerateid(const ::std::string& value);
  #if LANG_CXX11
  void set_lanerateid(::std::string&& value);
  #endif
  void set_lanerateid(const char* value);
  void set_lanerateid(const char* value, size_t size);
  ::std::string* mutable_lanerateid();
  ::std::string* release_lanerateid();
  void set_allocated_lanerateid(::std::string* lanerateid);

  // optional string costModelId = 7;
  bool has_costmodelid() const;
  void clear_costmodelid();
  static const int kCostModelIdFieldNumber = 7;
  const ::std::string& costmodelid() const;
  void set_costmodelid(const ::std::string& value);
  #if LANG_CXX11
  void set_costmodelid(::std::string&& value);
  #endif
  void set_costmodelid(const char* value);
  void set_costmodelid(const char* value, size_t size);
  ::std::string* mutable_costmodelid();
  ::std::string* release_costmodelid();
  void set_allocated_costmodelid(::std::string* costmodelid);

  // required float amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  float amount() const;
  void set_amount(float value);

  // required float cost = 5;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 5;
  float cost() const;
  void set_cost(float value);

  // required float distance = 8;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 8;
  float distance() const;
  void set_distance(float value);

  // required float duration = 9;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 9;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.Assignment)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_productid();
  void clear_has_productid();
  void set_has_amount();
  void clear_has_amount();
  void set_has_cost();
  void clear_has_cost();
  void set_has_lanerateid();
  void clear_has_lanerateid();
  void set_has_costmodelid();
  void clear_has_costmodelid();
  void set_has_distance();
  void clear_has_distance();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr lanerateid_;
  ::google::protobuf::internal::ArenaStringPtr costmodelid_;
  float amount_;
  float cost_;
  float distance_;
  float duration_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_NodeProductFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductFlow) */ {
 public:
  SolutionResponse_NodeProductFlow();
  virtual ~SolutionResponse_NodeProductFlow();

  SolutionResponse_NodeProductFlow(const SolutionResponse_NodeProductFlow& from);

  inline SolutionResponse_NodeProductFlow& operator=(const SolutionResponse_NodeProductFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_NodeProductFlow(SolutionResponse_NodeProductFlow&& from) noexcept
    : SolutionResponse_NodeProductFlow() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductFlow& operator=(SolutionResponse_NodeProductFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_NodeProductFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_NodeProductFlow* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductFlow*>(
               &_SolutionResponse_NodeProductFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(SolutionResponse_NodeProductFlow* other);
  friend void swap(SolutionResponse_NodeProductFlow& a, SolutionResponse_NodeProductFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_NodeProductFlow* New() const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductFlow>(NULL);
  }

  SolutionResponse_NodeProductFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_NodeProductFlow& from);
  void MergeFrom(const SolutionResponse_NodeProductFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // required string productId = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required float inFlow = 3;
  bool has_inflow() const;
  void clear_inflow();
  static const int kInFlowFieldNumber = 3;
  float inflow() const;
  void set_inflow(float value);

  // required float outFlow = 4;
  bool has_outflow() const;
  void clear_outflow();
  static const int kOutFlowFieldNumber = 4;
  float outflow() const;
  void set_outflow(float value);

  // required float flowCost = 5;
  bool has_flowcost() const;
  void clear_flowcost();
  static const int kFlowCostFieldNumber = 5;
  float flowcost() const;
  void set_flowcost(float value);

  // required float fixedCost = 6;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 6;
  float fixedcost() const;
  void set_fixedcost(float value);

  // required float productionAmount = 7;
  bool has_productionamount() const;
  void clear_productionamount();
  static const int kProductionAmountFieldNumber = 7;
  float productionamount() const;
  void set_productionamount(float value);

  // required float productionPenalty = 8;
  bool has_productionpenalty() const;
  void clear_productionpenalty();
  static const int kProductionPenaltyFieldNumber = 8;
  float productionpenalty() const;
  void set_productionpenalty(float value);

  // required float productionCost = 9;
  bool has_productioncost() const;
  void clear_productioncost();
  static const int kProductionCostFieldNumber = 9;
  float productioncost() const;
  void set_productioncost(float value);

  // required float consumptionAmount = 10;
  bool has_consumptionamount() const;
  void clear_consumptionamount();
  static const int kConsumptionAmountFieldNumber = 10;
  float consumptionamount() const;
  void set_consumptionamount(float value);

  // required float consumptionPenalty = 11;
  bool has_consumptionpenalty() const;
  void clear_consumptionpenalty();
  static const int kConsumptionPenaltyFieldNumber = 11;
  float consumptionpenalty() const;
  void set_consumptionpenalty(float value);

  // required float consumptionCost = 12;
  bool has_consumptioncost() const;
  void clear_consumptioncost();
  static const int kConsumptionCostFieldNumber = 12;
  float consumptioncost() const;
  void set_consumptioncost(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductFlow)
 private:
  void set_has_nodeid();
  void clear_has_nodeid();
  void set_has_productid();
  void clear_has_productid();
  void set_has_inflow();
  void clear_has_inflow();
  void set_has_outflow();
  void clear_has_outflow();
  void set_has_flowcost();
  void clear_has_flowcost();
  void set_has_fixedcost();
  void clear_has_fixedcost();
  void set_has_productionamount();
  void clear_has_productionamount();
  void set_has_productionpenalty();
  void clear_has_productionpenalty();
  void set_has_productioncost();
  void clear_has_productioncost();
  void set_has_consumptionamount();
  void clear_has_consumptionamount();
  void set_has_consumptionpenalty();
  void clear_has_consumptionpenalty();
  void set_has_consumptioncost();
  void clear_has_consumptioncost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  float inflow_;
  float outflow_;
  float flowcost_;
  float fixedcost_;
  float productionamount_;
  float productionpenalty_;
  float productioncost_;
  float consumptionamount_;
  float consumptionpenalty_;
  float consumptioncost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_NodeFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeFlow) */ {
 public:
  SolutionResponse_NodeFlow();
  virtual ~SolutionResponse_NodeFlow();

  SolutionResponse_NodeFlow(const SolutionResponse_NodeFlow& from);

  inline SolutionResponse_NodeFlow& operator=(const SolutionResponse_NodeFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_NodeFlow(SolutionResponse_NodeFlow&& from) noexcept
    : SolutionResponse_NodeFlow() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeFlow& operator=(SolutionResponse_NodeFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_NodeFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_NodeFlow* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeFlow*>(
               &_SolutionResponse_NodeFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(SolutionResponse_NodeFlow* other);
  friend void swap(SolutionResponse_NodeFlow& a, SolutionResponse_NodeFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_NodeFlow* New() const final {
    return CreateMaybeMessage<SolutionResponse_NodeFlow>(NULL);
  }

  SolutionResponse_NodeFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_NodeFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_NodeFlow& from);
  void MergeFrom(const SolutionResponse_NodeFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // required float inFlow = 2;
  bool has_inflow() const;
  void clear_inflow();
  static const int kInFlowFieldNumber = 2;
  float inflow() const;
  void set_inflow(float value);

  // required float outFlow = 3;
  bool has_outflow() const;
  void clear_outflow();
  static const int kOutFlowFieldNumber = 3;
  float outflow() const;
  void set_outflow(float value);

  // required float flowCost = 4;
  bool has_flowcost() const;
  void clear_flowcost();
  static const int kFlowCostFieldNumber = 4;
  float flowcost() const;
  void set_flowcost(float value);

  // required float fixedCost = 5;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 5;
  float fixedcost() const;
  void set_fixedcost(float value);

  // required float productFlowCost = 6;
  bool has_productflowcost() const;
  void clear_productflowcost();
  static const int kProductFlowCostFieldNumber = 6;
  float productflowcost() const;
  void set_productflowcost(float value);

  // required float productFixedCost = 7;
  bool has_productfixedcost() const;
  void clear_productfixedcost();
  static const int kProductFixedCostFieldNumber = 7;
  float productfixedcost() const;
  void set_productfixedcost(float value);

  // required float productionAmount = 8;
  bool has_productionamount() const;
  void clear_productionamount();
  static const int kProductionAmountFieldNumber = 8;
  float productionamount() const;
  void set_productionamount(float value);

  // required float productionPenalty = 9;
  bool has_productionpenalty() const;
  void clear_productionpenalty();
  static const int kProductionPenaltyFieldNumber = 9;
  float productionpenalty() const;
  void set_productionpenalty(float value);

  // required float productionCost = 10;
  bool has_productioncost() const;
  void clear_productioncost();
  static const int kProductionCostFieldNumber = 10;
  float productioncost() const;
  void set_productioncost(float value);

  // required float consumptionAmount = 11;
  bool has_consumptionamount() const;
  void clear_consumptionamount();
  static const int kConsumptionAmountFieldNumber = 11;
  float consumptionamount() const;
  void set_consumptionamount(float value);

  // required float consumptionPenalty = 12;
  bool has_consumptionpenalty() const;
  void clear_consumptionpenalty();
  static const int kConsumptionPenaltyFieldNumber = 12;
  float consumptionpenalty() const;
  void set_consumptionpenalty(float value);

  // required float consumptionCost = 13;
  bool has_consumptioncost() const;
  void clear_consumptioncost();
  static const int kConsumptionCostFieldNumber = 13;
  float consumptioncost() const;
  void set_consumptioncost(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeFlow)
 private:
  void set_has_nodeid();
  void clear_has_nodeid();
  void set_has_inflow();
  void clear_has_inflow();
  void set_has_outflow();
  void clear_has_outflow();
  void set_has_flowcost();
  void clear_has_flowcost();
  void set_has_fixedcost();
  void clear_has_fixedcost();
  void set_has_productflowcost();
  void clear_has_productflowcost();
  void set_has_productfixedcost();
  void clear_has_productfixedcost();
  void set_has_productionamount();
  void clear_has_productionamount();
  void set_has_productionpenalty();
  void clear_has_productionpenalty();
  void set_has_productioncost();
  void clear_has_productioncost();
  void set_has_consumptionamount();
  void clear_has_consumptionamount();
  void set_has_consumptionpenalty();
  void clear_has_consumptionpenalty();
  void set_has_consumptioncost();
  void clear_has_consumptioncost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  float inflow_;
  float outflow_;
  float flowcost_;
  float fixedcost_;
  float productflowcost_;
  float productfixedcost_;
  float productionamount_;
  float productionpenalty_;
  float productioncost_;
  float consumptionamount_;
  float consumptionpenalty_;
  float consumptioncost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_GeometrySequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.GeometrySequence) */ {
 public:
  SolutionResponse_GeometrySequence();
  virtual ~SolutionResponse_GeometrySequence();

  SolutionResponse_GeometrySequence(const SolutionResponse_GeometrySequence& from);

  inline SolutionResponse_GeometrySequence& operator=(const SolutionResponse_GeometrySequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_GeometrySequence(SolutionResponse_GeometrySequence&& from) noexcept
    : SolutionResponse_GeometrySequence() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_GeometrySequence& operator=(SolutionResponse_GeometrySequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_GeometrySequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_GeometrySequence* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_GeometrySequence*>(
               &_SolutionResponse_GeometrySequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(SolutionResponse_GeometrySequence* other);
  friend void swap(SolutionResponse_GeometrySequence& a, SolutionResponse_GeometrySequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_GeometrySequence* New() const final {
    return CreateMaybeMessage<SolutionResponse_GeometrySequence>(NULL);
  }

  SolutionResponse_GeometrySequence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_GeometrySequence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_GeometrySequence& from);
  void MergeFrom(const SolutionResponse_GeometrySequence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_GeometrySequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float x = 1;
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 2;
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.GeometrySequence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > x_;
  ::google::protobuf::RepeatedField< float > y_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.Route) */ {
 public:
  SolutionResponse_Route();
  virtual ~SolutionResponse_Route();

  SolutionResponse_Route(const SolutionResponse_Route& from);

  inline SolutionResponse_Route& operator=(const SolutionResponse_Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Route(SolutionResponse_Route&& from) noexcept
    : SolutionResponse_Route() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Route& operator=(SolutionResponse_Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Route& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Route* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Route*>(
               &_SolutionResponse_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(SolutionResponse_Route* other);
  friend void swap(SolutionResponse_Route& a, SolutionResponse_Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Route* New() const final {
    return CreateMaybeMessage<SolutionResponse_Route>(NULL);
  }

  SolutionResponse_Route* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Route>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Route& from);
  void MergeFrom(const SolutionResponse_Route& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 geometrySequence = 3;
  int geometrysequence_size() const;
  void clear_geometrysequence();
  static const int kGeometrySequenceFieldNumber = 3;
  ::google::protobuf::int32 geometrysequence(int index) const;
  void set_geometrysequence(int index, ::google::protobuf::int32 value);
  void add_geometrysequence(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      geometrysequence() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_geometrysequence();

  // required string fromId = 1;
  bool has_fromid() const;
  void clear_fromid();
  static const int kFromIdFieldNumber = 1;
  const ::std::string& fromid() const;
  void set_fromid(const ::std::string& value);
  #if LANG_CXX11
  void set_fromid(::std::string&& value);
  #endif
  void set_fromid(const char* value);
  void set_fromid(const char* value, size_t size);
  ::std::string* mutable_fromid();
  ::std::string* release_fromid();
  void set_allocated_fromid(::std::string* fromid);

  // required string toId = 2;
  bool has_toid() const;
  void clear_toid();
  static const int kToIdFieldNumber = 2;
  const ::std::string& toid() const;
  void set_toid(const ::std::string& value);
  #if LANG_CXX11
  void set_toid(::std::string&& value);
  #endif
  void set_toid(const char* value);
  void set_toid(const char* value, size_t size);
  ::std::string* mutable_toid();
  ::std::string* release_toid();
  void set_allocated_toid(::std::string* toid);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.Route)
 private:
  void set_has_fromid();
  void clear_has_fromid();
  void set_has_toid();
  void clear_has_toid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > geometrysequence_;
  ::google::protobuf::internal::ArenaStringPtr fromid_;
  ::google::protobuf::internal::ArenaStringPtr toid_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_NodeProductTransformAssignment_Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductTransformAssignment.Item) */ {
 public:
  SolutionResponse_NodeProductTransformAssignment_Item();
  virtual ~SolutionResponse_NodeProductTransformAssignment_Item();

  SolutionResponse_NodeProductTransformAssignment_Item(const SolutionResponse_NodeProductTransformAssignment_Item& from);

  inline SolutionResponse_NodeProductTransformAssignment_Item& operator=(const SolutionResponse_NodeProductTransformAssignment_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_NodeProductTransformAssignment_Item(SolutionResponse_NodeProductTransformAssignment_Item&& from) noexcept
    : SolutionResponse_NodeProductTransformAssignment_Item() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductTransformAssignment_Item& operator=(SolutionResponse_NodeProductTransformAssignment_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_NodeProductTransformAssignment_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_NodeProductTransformAssignment_Item* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductTransformAssignment_Item*>(
               &_SolutionResponse_NodeProductTransformAssignment_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(SolutionResponse_NodeProductTransformAssignment_Item* other);
  friend void swap(SolutionResponse_NodeProductTransformAssignment_Item& a, SolutionResponse_NodeProductTransformAssignment_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_NodeProductTransformAssignment_Item* New() const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductTransformAssignment_Item>(NULL);
  }

  SolutionResponse_NodeProductTransformAssignment_Item* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductTransformAssignment_Item>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_NodeProductTransformAssignment_Item& from);
  void MergeFrom(const SolutionResponse_NodeProductTransformAssignment_Item& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductTransformAssignment_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string productId = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required float amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  float amount() const;
  void set_amount(float value);

  // required float cost = 3;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 3;
  float cost() const;
  void set_cost(float value);

  // required float fixedCost = 4;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 4;
  float fixedcost() const;
  void set_fixedcost(float value);

  // required float penaltyAmount = 5;
  bool has_penaltyamount() const;
  void clear_penaltyamount();
  static const int kPenaltyAmountFieldNumber = 5;
  float penaltyamount() const;
  void set_penaltyamount(float value);

  // required float penaltyCost = 6;
  bool has_penaltycost() const;
  void clear_penaltycost();
  static const int kPenaltyCostFieldNumber = 6;
  float penaltycost() const;
  void set_penaltycost(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductTransformAssignment.Item)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_amount();
  void clear_has_amount();
  void set_has_cost();
  void clear_has_cost();
  void set_has_fixedcost();
  void clear_has_fixedcost();
  void set_has_penaltyamount();
  void clear_has_penaltyamount();
  void set_has_penaltycost();
  void clear_has_penaltycost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  float amount_;
  float cost_;
  float fixedcost_;
  float penaltyamount_;
  float penaltycost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_NodeProductTransformAssignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductTransformAssignment) */ {
 public:
  SolutionResponse_NodeProductTransformAssignment();
  virtual ~SolutionResponse_NodeProductTransformAssignment();

  SolutionResponse_NodeProductTransformAssignment(const SolutionResponse_NodeProductTransformAssignment& from);

  inline SolutionResponse_NodeProductTransformAssignment& operator=(const SolutionResponse_NodeProductTransformAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_NodeProductTransformAssignment(SolutionResponse_NodeProductTransformAssignment&& from) noexcept
    : SolutionResponse_NodeProductTransformAssignment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductTransformAssignment& operator=(SolutionResponse_NodeProductTransformAssignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_NodeProductTransformAssignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_NodeProductTransformAssignment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductTransformAssignment*>(
               &_SolutionResponse_NodeProductTransformAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(SolutionResponse_NodeProductTransformAssignment* other);
  friend void swap(SolutionResponse_NodeProductTransformAssignment& a, SolutionResponse_NodeProductTransformAssignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_NodeProductTransformAssignment* New() const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductTransformAssignment>(NULL);
  }

  SolutionResponse_NodeProductTransformAssignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductTransformAssignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_NodeProductTransformAssignment& from);
  void MergeFrom(const SolutionResponse_NodeProductTransformAssignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductTransformAssignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_NodeProductTransformAssignment_Item Item;

  // accessors -------------------------------------------------------

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
  int inputitems_size() const;
  void clear_inputitems();
  static const int kInputItemsFieldNumber = 3;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* mutable_inputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
      mutable_inputitems();
  const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& inputitems(int index) const;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* add_inputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
      inputitems() const;

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
  int outputitems_size() const;
  void clear_outputitems();
  static const int kOutputItemsFieldNumber = 4;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* mutable_outputitems(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
      mutable_outputitems();
  const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& outputitems(int index) const;
  ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* add_outputitems();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
      outputitems() const;

  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // required string productTransformId = 2;
  bool has_producttransformid() const;
  void clear_producttransformid();
  static const int kProductTransformIdFieldNumber = 2;
  const ::std::string& producttransformid() const;
  void set_producttransformid(const ::std::string& value);
  #if LANG_CXX11
  void set_producttransformid(::std::string&& value);
  #endif
  void set_producttransformid(const char* value);
  void set_producttransformid(const char* value, size_t size);
  ::std::string* mutable_producttransformid();
  ::std::string* release_producttransformid();
  void set_allocated_producttransformid(::std::string* producttransformid);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductTransformAssignment)
 private:
  void set_has_nodeid();
  void clear_has_nodeid();
  void set_has_producttransformid();
  void clear_has_producttransformid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item > inputitems_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item > outputitems_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr producttransformid_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse) */ {
 public:
  SolutionResponse();
  virtual ~SolutionResponse();

  SolutionResponse(const SolutionResponse& from);

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(SolutionResponse* other);
  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse* New() const final {
    return CreateMaybeMessage<SolutionResponse>(NULL);
  }

  SolutionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse& from);
  void MergeFrom(const SolutionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Assignment Assignment;
  typedef SolutionResponse_NodeProductFlow NodeProductFlow;
  typedef SolutionResponse_NodeFlow NodeFlow;
  typedef SolutionResponse_GeometrySequence GeometrySequence;
  typedef SolutionResponse_Route Route;
  typedef SolutionResponse_NodeProductTransformAssignment NodeProductTransformAssignment;

  // accessors -------------------------------------------------------

  // repeated .NS3.SolutionResponse.Assignment assignments = 4;
  int assignments_size() const;
  void clear_assignments();
  static const int kAssignmentsFieldNumber = 4;
  ::NS3::SolutionResponse_Assignment* mutable_assignments(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >*
      mutable_assignments();
  const ::NS3::SolutionResponse_Assignment& assignments(int index) const;
  ::NS3::SolutionResponse_Assignment* add_assignments();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >&
      assignments() const;

  // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
  int nodeflows_size() const;
  void clear_nodeflows();
  static const int kNodeFlowsFieldNumber = 5;
  ::NS3::SolutionResponse_NodeFlow* mutable_nodeflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >*
      mutable_nodeflows();
  const ::NS3::SolutionResponse_NodeFlow& nodeflows(int index) const;
  ::NS3::SolutionResponse_NodeFlow* add_nodeflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >&
      nodeflows() const;

  // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
  int nodeproductflows_size() const;
  void clear_nodeproductflows();
  static const int kNodeProductFlowsFieldNumber = 6;
  ::NS3::SolutionResponse_NodeProductFlow* mutable_nodeproductflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >*
      mutable_nodeproductflows();
  const ::NS3::SolutionResponse_NodeProductFlow& nodeproductflows(int index) const;
  ::NS3::SolutionResponse_NodeProductFlow* add_nodeproductflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >&
      nodeproductflows() const;

  // repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
  int geometrysequence_size() const;
  void clear_geometrysequence();
  static const int kGeometrySequenceFieldNumber = 7;
  ::NS3::SolutionResponse_GeometrySequence* mutable_geometrysequence(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >*
      mutable_geometrysequence();
  const ::NS3::SolutionResponse_GeometrySequence& geometrysequence(int index) const;
  ::NS3::SolutionResponse_GeometrySequence* add_geometrysequence();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >&
      geometrysequence() const;

  // repeated .NS3.SolutionResponse.Route routes = 8;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 8;
  ::NS3::SolutionResponse_Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >*
      mutable_routes();
  const ::NS3::SolutionResponse_Route& routes(int index) const;
  ::NS3::SolutionResponse_Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >&
      routes() const;

  // repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
  int nodeproducttransformassignments_size() const;
  void clear_nodeproducttransformassignments();
  static const int kNodeProductTransformAssignmentsFieldNumber = 9;
  ::NS3::SolutionResponse_NodeProductTransformAssignment* mutable_nodeproducttransformassignments(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >*
      mutable_nodeproducttransformassignments();
  const ::NS3::SolutionResponse_NodeProductTransformAssignment& nodeproducttransformassignments(int index) const;
  ::NS3::SolutionResponse_NodeProductTransformAssignment* add_nodeproducttransformassignments();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >&
      nodeproducttransformassignments() const;

  // required float objective = 1;
  bool has_objective() const;
  void clear_objective();
  static const int kObjectiveFieldNumber = 1;
  float objective() const;
  void set_objective(float value);

  // optional float lowerBound = 2;
  bool has_lowerbound() const;
  void clear_lowerbound();
  static const int kLowerBoundFieldNumber = 2;
  float lowerbound() const;
  void set_lowerbound(float value);

  // optional float optimalityGap = 3;
  bool has_optimalitygap() const;
  void clear_optimalitygap();
  static const int kOptimalityGapFieldNumber = 3;
  float optimalitygap() const;
  void set_optimalitygap(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse)
 private:
  void set_has_objective();
  void clear_has_objective();
  void set_has_lowerbound();
  void clear_has_lowerbound();
  void set_has_optimalitygap();
  void clear_has_optimalitygap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment > assignments_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow > nodeflows_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow > nodeproductflows_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence > geometrysequence_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route > routes_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment > nodeproducttransformassignments_;
  float objective_;
  float lowerbound_;
  float optimalitygap_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InternalDimension

// required string id = 1;
inline bool InternalDimension::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalDimension::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalDimension::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalDimension::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& InternalDimension::id() const {
  // @@protoc_insertion_point(field_get:NS3.InternalDimension.id)
  return id_.GetNoArena();
}
inline void InternalDimension::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.InternalDimension.id)
}
#if LANG_CXX11
inline void InternalDimension::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.InternalDimension.id)
}
#endif
inline void InternalDimension::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.InternalDimension.id)
}
inline void InternalDimension::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.InternalDimension.id)
}
inline ::std::string* InternalDimension::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.InternalDimension.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalDimension::release_id() {
  // @@protoc_insertion_point(field_release:NS3.InternalDimension.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalDimension::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.InternalDimension.id)
}

// required .NS3.InternalDimension.eMeasurementUnit measurementUnit = 2;
inline bool InternalDimension::has_measurementunit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalDimension::set_has_measurementunit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalDimension::clear_has_measurementunit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalDimension::clear_measurementunit() {
  measurementunit_ = 0;
  clear_has_measurementunit();
}
inline ::NS3::InternalDimension_eMeasurementUnit InternalDimension::measurementunit() const {
  // @@protoc_insertion_point(field_get:NS3.InternalDimension.measurementUnit)
  return static_cast< ::NS3::InternalDimension_eMeasurementUnit >(measurementunit_);
}
inline void InternalDimension::set_measurementunit(::NS3::InternalDimension_eMeasurementUnit value) {
  assert(::NS3::InternalDimension_eMeasurementUnit_IsValid(value));
  set_has_measurementunit();
  measurementunit_ = value;
  // @@protoc_insertion_point(field_set:NS3.InternalDimension.measurementUnit)
}

// -------------------------------------------------------------------

// UserDimension

// required string id = 1;
inline bool UserDimension::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDimension::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDimension::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDimension::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& UserDimension::id() const {
  // @@protoc_insertion_point(field_get:NS3.UserDimension.id)
  return id_.GetNoArena();
}
inline void UserDimension::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.UserDimension.id)
}
#if LANG_CXX11
inline void UserDimension::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.UserDimension.id)
}
#endif
inline void UserDimension::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.UserDimension.id)
}
inline void UserDimension::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.UserDimension.id)
}
inline ::std::string* UserDimension::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.UserDimension.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserDimension::release_id() {
  // @@protoc_insertion_point(field_release:NS3.UserDimension.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserDimension::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.UserDimension.id)
}

// required string units = 2;
inline bool UserDimension::has_units() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDimension::set_has_units() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDimension::clear_has_units() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDimension::clear_units() {
  units_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_units();
}
inline const ::std::string& UserDimension::units() const {
  // @@protoc_insertion_point(field_get:NS3.UserDimension.units)
  return units_.GetNoArena();
}
inline void UserDimension::set_units(const ::std::string& value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.UserDimension.units)
}
#if LANG_CXX11
inline void UserDimension::set_units(::std::string&& value) {
  set_has_units();
  units_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.UserDimension.units)
}
#endif
inline void UserDimension::set_units(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.UserDimension.units)
}
inline void UserDimension::set_units(const char* value, size_t size) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.UserDimension.units)
}
inline ::std::string* UserDimension::mutable_units() {
  set_has_units();
  // @@protoc_insertion_point(field_mutable:NS3.UserDimension.units)
  return units_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserDimension::release_units() {
  // @@protoc_insertion_point(field_release:NS3.UserDimension.units)
  if (!has_units()) {
    return NULL;
  }
  clear_has_units();
  return units_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserDimension::set_allocated_units(::std::string* units) {
  if (units != NULL) {
    set_has_units();
  } else {
    clear_has_units();
  }
  units_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:NS3.UserDimension.units)
}

// -------------------------------------------------------------------

// DimensionConfiguration

// optional .NS3.InternalDimension timeConfig = 1;
inline bool DimensionConfiguration::has_timeconfig() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DimensionConfiguration::set_has_timeconfig() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DimensionConfiguration::clear_has_timeconfig() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DimensionConfiguration::clear_timeconfig() {
  if (timeconfig_ != NULL) timeconfig_->Clear();
  clear_has_timeconfig();
}
inline const ::NS3::InternalDimension& DimensionConfiguration::_internal_timeconfig() const {
  return *timeconfig_;
}
inline const ::NS3::InternalDimension& DimensionConfiguration::timeconfig() const {
  const ::NS3::InternalDimension* p = timeconfig_;
  // @@protoc_insertion_point(field_get:NS3.DimensionConfiguration.timeConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::InternalDimension*>(
      &::NS3::_InternalDimension_default_instance_);
}
inline ::NS3::InternalDimension* DimensionConfiguration::release_timeconfig() {
  // @@protoc_insertion_point(field_release:NS3.DimensionConfiguration.timeConfig)
  clear_has_timeconfig();
  ::NS3::InternalDimension* temp = timeconfig_;
  timeconfig_ = NULL;
  return temp;
}
inline ::NS3::InternalDimension* DimensionConfiguration::mutable_timeconfig() {
  set_has_timeconfig();
  if (timeconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::InternalDimension>(GetArenaNoVirtual());
    timeconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.DimensionConfiguration.timeConfig)
  return timeconfig_;
}
inline void DimensionConfiguration::set_allocated_timeconfig(::NS3::InternalDimension* timeconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timeconfig_;
  }
  if (timeconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timeconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeconfig, submessage_arena);
    }
    set_has_timeconfig();
  } else {
    clear_has_timeconfig();
  }
  timeconfig_ = timeconfig;
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionConfiguration.timeConfig)
}

// optional .NS3.InternalDimension distanceConfig = 2;
inline bool DimensionConfiguration::has_distanceconfig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DimensionConfiguration::set_has_distanceconfig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DimensionConfiguration::clear_has_distanceconfig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DimensionConfiguration::clear_distanceconfig() {
  if (distanceconfig_ != NULL) distanceconfig_->Clear();
  clear_has_distanceconfig();
}
inline const ::NS3::InternalDimension& DimensionConfiguration::_internal_distanceconfig() const {
  return *distanceconfig_;
}
inline const ::NS3::InternalDimension& DimensionConfiguration::distanceconfig() const {
  const ::NS3::InternalDimension* p = distanceconfig_;
  // @@protoc_insertion_point(field_get:NS3.DimensionConfiguration.distanceConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::InternalDimension*>(
      &::NS3::_InternalDimension_default_instance_);
}
inline ::NS3::InternalDimension* DimensionConfiguration::release_distanceconfig() {
  // @@protoc_insertion_point(field_release:NS3.DimensionConfiguration.distanceConfig)
  clear_has_distanceconfig();
  ::NS3::InternalDimension* temp = distanceconfig_;
  distanceconfig_ = NULL;
  return temp;
}
inline ::NS3::InternalDimension* DimensionConfiguration::mutable_distanceconfig() {
  set_has_distanceconfig();
  if (distanceconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::InternalDimension>(GetArenaNoVirtual());
    distanceconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.DimensionConfiguration.distanceConfig)
  return distanceconfig_;
}
inline void DimensionConfiguration::set_allocated_distanceconfig(::NS3::InternalDimension* distanceconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete distanceconfig_;
  }
  if (distanceconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      distanceconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distanceconfig, submessage_arena);
    }
    set_has_distanceconfig();
  } else {
    clear_has_distanceconfig();
  }
  distanceconfig_ = distanceconfig;
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionConfiguration.distanceConfig)
}

// repeated .NS3.UserDimension userDimensions = 3;
inline int DimensionConfiguration::userdimensions_size() const {
  return userdimensions_.size();
}
inline void DimensionConfiguration::clear_userdimensions() {
  userdimensions_.Clear();
}
inline ::NS3::UserDimension* DimensionConfiguration::mutable_userdimensions(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.DimensionConfiguration.userDimensions)
  return userdimensions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >*
DimensionConfiguration::mutable_userdimensions() {
  // @@protoc_insertion_point(field_mutable_list:NS3.DimensionConfiguration.userDimensions)
  return &userdimensions_;
}
inline const ::NS3::UserDimension& DimensionConfiguration::userdimensions(int index) const {
  // @@protoc_insertion_point(field_get:NS3.DimensionConfiguration.userDimensions)
  return userdimensions_.Get(index);
}
inline ::NS3::UserDimension* DimensionConfiguration::add_userdimensions() {
  // @@protoc_insertion_point(field_add:NS3.DimensionConfiguration.userDimensions)
  return userdimensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UserDimension >&
DimensionConfiguration::userdimensions() const {
  // @@protoc_insertion_point(field_list:NS3.DimensionConfiguration.userDimensions)
  return userdimensions_;
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geocode::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geocode::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geocode::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:NS3.Geocode.longitude)
  return longitude_;
}
inline void Geocode::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:NS3.Geocode.longitude)
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geocode::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geocode::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geocode::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:NS3.Geocode.latitude)
  return latitude_;
}
inline void Geocode::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:NS3.Geocode.latitude)
}

// -------------------------------------------------------------------

// UnitDimensionCost

// repeated string dimensionIds = 1;
inline int UnitDimensionCost::dimensionids_size() const {
  return dimensionids_.size();
}
inline void UnitDimensionCost::clear_dimensionids() {
  dimensionids_.Clear();
}
inline const ::std::string& UnitDimensionCost::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_.Get(index);
}
inline ::std::string* UnitDimensionCost::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_.Mutable(index);
}
inline void UnitDimensionCost::set_dimensionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void UnitDimensionCost::set_dimensionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void UnitDimensionCost::set_dimensionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::set_dimensionids(int index, const char* value, size_t size) {
  dimensionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.UnitDimensionCost.dimensionIds)
}
inline ::std::string* UnitDimensionCost::add_dimensionids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_.Add();
}
inline void UnitDimensionCost::add_dimensionids(const ::std::string& value) {
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionIds)
}
#if LANG_CXX11
inline void UnitDimensionCost::add_dimensionids(::std::string&& value) {
  dimensionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionIds)
}
#endif
inline void UnitDimensionCost::add_dimensionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(const char* value, size_t size) {
  dimensionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.UnitDimensionCost.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UnitDimensionCost::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UnitDimensionCost::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.UnitDimensionCost.dimensionIds)
  return &dimensionids_;
}

// repeated float dimensionCoefficients = 2;
inline int UnitDimensionCost::dimensioncoefficients_size() const {
  return dimensioncoefficients_.size();
}
inline void UnitDimensionCost::clear_dimensioncoefficients() {
  dimensioncoefficients_.Clear();
}
inline float UnitDimensionCost::dimensioncoefficients(int index) const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.dimensionCoefficients)
  return dimensioncoefficients_.Get(index);
}
inline void UnitDimensionCost::set_dimensioncoefficients(int index, float value) {
  dimensioncoefficients_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionCoefficients)
}
inline void UnitDimensionCost::add_dimensioncoefficients(float value) {
  dimensioncoefficients_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionCoefficients)
}
inline const ::google::protobuf::RepeatedField< float >&
UnitDimensionCost::dimensioncoefficients() const {
  // @@protoc_insertion_point(field_list:NS3.UnitDimensionCost.dimensionCoefficients)
  return dimensioncoefficients_;
}
inline ::google::protobuf::RepeatedField< float >*
UnitDimensionCost::mutable_dimensioncoefficients() {
  // @@protoc_insertion_point(field_mutable_list:NS3.UnitDimensionCost.dimensionCoefficients)
  return &dimensioncoefficients_;
}

// required float costPerUnit = 3;
inline bool UnitDimensionCost::has_costperunit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitDimensionCost::set_has_costperunit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitDimensionCost::clear_has_costperunit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitDimensionCost::clear_costperunit() {
  costperunit_ = 0;
  clear_has_costperunit();
}
inline float UnitDimensionCost::costperunit() const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.costPerUnit)
  return costperunit_;
}
inline void UnitDimensionCost::set_costperunit(float value) {
  set_has_costperunit();
  costperunit_ = value;
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.costPerUnit)
}

// -------------------------------------------------------------------

// FixedDimensionCost

// repeated string dimensionIds = 1;
inline int FixedDimensionCost::dimensionids_size() const {
  return dimensionids_.size();
}
inline void FixedDimensionCost::clear_dimensionids() {
  dimensionids_.Clear();
}
inline const ::std::string& FixedDimensionCost::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_.Get(index);
}
inline ::std::string* FixedDimensionCost::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_.Mutable(index);
}
inline void FixedDimensionCost::set_dimensionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FixedDimensionCost::set_dimensionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FixedDimensionCost::set_dimensionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::set_dimensionids(int index, const char* value, size_t size) {
  dimensionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.FixedDimensionCost.dimensionIds)
}
inline ::std::string* FixedDimensionCost::add_dimensionids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_.Add();
}
inline void FixedDimensionCost::add_dimensionids(const ::std::string& value) {
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.FixedDimensionCost.dimensionIds)
}
#if LANG_CXX11
inline void FixedDimensionCost::add_dimensionids(::std::string&& value) {
  dimensionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.FixedDimensionCost.dimensionIds)
}
#endif
inline void FixedDimensionCost::add_dimensionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(const char* value, size_t size) {
  dimensionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.FixedDimensionCost.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FixedDimensionCost::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FixedDimensionCost::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FixedDimensionCost.dimensionIds)
  return &dimensionids_;
}

// required float fixedCost = 2;
inline bool FixedDimensionCost::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixedDimensionCost::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixedDimensionCost::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixedDimensionCost::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float FixedDimensionCost::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.FixedDimensionCost.fixedCost)
  return fixedcost_;
}
inline void FixedDimensionCost::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.fixedCost)
}

// -------------------------------------------------------------------

// FlowDimensionalConstraint

// repeated string dimensionIds = 1;
inline int FlowDimensionalConstraint::dimensionids_size() const {
  return dimensionids_.size();
}
inline void FlowDimensionalConstraint::clear_dimensionids() {
  dimensionids_.Clear();
}
inline const ::std::string& FlowDimensionalConstraint::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_.Get(index);
}
inline ::std::string* FlowDimensionalConstraint::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_.Mutable(index);
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionIds)
  dimensionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FlowDimensionalConstraint::set_dimensionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionIds)
  dimensionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FlowDimensionalConstraint::set_dimensionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const char* value, size_t size) {
  dimensionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline ::std::string* FlowDimensionalConstraint::add_dimensionids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_.Add();
}
inline void FlowDimensionalConstraint::add_dimensionids(const ::std::string& value) {
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionIds)
}
#if LANG_CXX11
inline void FlowDimensionalConstraint::add_dimensionids(::std::string&& value) {
  dimensionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionIds)
}
#endif
inline void FlowDimensionalConstraint::add_dimensionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(const char* value, size_t size) {
  dimensionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FlowDimensionalConstraint::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FlowDimensionalConstraint::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FlowDimensionalConstraint.dimensionIds)
  return &dimensionids_;
}

// repeated float dimensionCoefficients = 2;
inline int FlowDimensionalConstraint::dimensioncoefficients_size() const {
  return dimensioncoefficients_.size();
}
inline void FlowDimensionalConstraint::clear_dimensioncoefficients() {
  dimensioncoefficients_.Clear();
}
inline float FlowDimensionalConstraint::dimensioncoefficients(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return dimensioncoefficients_.Get(index);
}
inline void FlowDimensionalConstraint::set_dimensioncoefficients(int index, float value) {
  dimensioncoefficients_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionCoefficients)
}
inline void FlowDimensionalConstraint::add_dimensioncoefficients(float value) {
  dimensioncoefficients_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionCoefficients)
}
inline const ::google::protobuf::RepeatedField< float >&
FlowDimensionalConstraint::dimensioncoefficients() const {
  // @@protoc_insertion_point(field_list:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return dimensioncoefficients_;
}
inline ::google::protobuf::RepeatedField< float >*
FlowDimensionalConstraint::mutable_dimensioncoefficients() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return &dimensioncoefficients_;
}

// required float flowMin = 3;
inline bool FlowDimensionalConstraint::has_flowmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowDimensionalConstraint::set_has_flowmin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowDimensionalConstraint::clear_has_flowmin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowDimensionalConstraint::clear_flowmin() {
  flowmin_ = 0;
  clear_has_flowmin();
}
inline float FlowDimensionalConstraint::flowmin() const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.flowMin)
  return flowmin_;
}
inline void FlowDimensionalConstraint::set_flowmin(float value) {
  set_has_flowmin();
  flowmin_ = value;
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.flowMin)
}

// required float flowMax = 4;
inline bool FlowDimensionalConstraint::has_flowmax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowDimensionalConstraint::set_has_flowmax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowDimensionalConstraint::clear_has_flowmax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowDimensionalConstraint::clear_flowmax() {
  flowmax_ = 0;
  clear_has_flowmax();
}
inline float FlowDimensionalConstraint::flowmax() const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.flowMax)
  return flowmax_;
}
inline void FlowDimensionalConstraint::set_flowmax(float value) {
  set_has_flowmax();
  flowmax_ = value;
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.flowMax)
}

// -------------------------------------------------------------------

// DimensionRange

// required string dimensionId = 1;
inline bool DimensionRange::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DimensionRange::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DimensionRange::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DimensionRange::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& DimensionRange::dimensionid() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void DimensionRange::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.dimensionId)
}
#if LANG_CXX11
inline void DimensionRange::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.DimensionRange.dimensionId)
}
#endif
inline void DimensionRange::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.DimensionRange.dimensionId)
}
inline void DimensionRange::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.DimensionRange.dimensionId)
}
inline ::std::string* DimensionRange::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NS3.DimensionRange.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DimensionRange::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NS3.DimensionRange.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DimensionRange::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionRange.dimensionId)
}

// required float minRange = 2 [default = 0];
inline bool DimensionRange::has_minrange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DimensionRange::set_has_minrange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DimensionRange::clear_has_minrange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DimensionRange::clear_minrange() {
  minrange_ = 0;
  clear_has_minrange();
}
inline float DimensionRange::minrange() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.minRange)
  return minrange_;
}
inline void DimensionRange::set_minrange(float value) {
  set_has_minrange();
  minrange_ = value;
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.minRange)
}

// required float maxRange = 3;
inline bool DimensionRange::has_maxrange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DimensionRange::set_has_maxrange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DimensionRange::clear_has_maxrange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DimensionRange::clear_maxrange() {
  maxrange_ = 0;
  clear_has_maxrange();
}
inline float DimensionRange::maxrange() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.maxRange)
  return maxrange_;
}
inline void DimensionRange::set_maxrange(float value) {
  set_has_maxrange();
  maxrange_ = value;
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.maxRange)
}

// required float flowPenalty = 4 [default = 0];
inline bool DimensionRange::has_flowpenalty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DimensionRange::set_has_flowpenalty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DimensionRange::clear_has_flowpenalty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DimensionRange::clear_flowpenalty() {
  flowpenalty_ = 0;
  clear_has_flowpenalty();
}
inline float DimensionRange::flowpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.flowPenalty)
  return flowpenalty_;
}
inline void DimensionRange::set_flowpenalty(float value) {
  set_has_flowpenalty();
  flowpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.flowPenalty)
}

// -------------------------------------------------------------------

// Node_ProductFlow

// required string productId = 1;
inline bool Node_ProductFlow::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node_ProductFlow::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node_ProductFlow::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node_ProductFlow::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& Node_ProductFlow::productid() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.productId)
  return productid_.GetNoArena();
}
inline void Node_ProductFlow::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Node.ProductFlow.productId)
}
#if LANG_CXX11
inline void Node_ProductFlow::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Node.ProductFlow.productId)
}
#endif
inline void Node_ProductFlow::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Node.ProductFlow.productId)
}
inline void Node_ProductFlow::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.ProductFlow.productId)
}
inline ::std::string* Node_ProductFlow::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node_ProductFlow::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.Node.ProductFlow.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_ProductFlow::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductFlow.productId)
}

// repeated .NS3.DimensionRange dimensionRanges = 2;
inline int Node_ProductFlow::dimensionranges_size() const {
  return dimensionranges_.size();
}
inline void Node_ProductFlow::clear_dimensionranges() {
  dimensionranges_.Clear();
}
inline ::NS3::DimensionRange* Node_ProductFlow::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_ProductFlow::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.dimensionRanges)
  return &dimensionranges_;
}
inline const ::NS3::DimensionRange& Node_ProductFlow::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_.Get(index);
}
inline ::NS3::DimensionRange* Node_ProductFlow::add_dimensionranges() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_ProductFlow::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_;
}

// repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
inline int Node_ProductFlow::fixeddimensioncosts_size() const {
  return fixeddimensioncosts_.size();
}
inline void Node_ProductFlow::clear_fixeddimensioncosts() {
  fixeddimensioncosts_.Clear();
}
inline ::NS3::FixedDimensionCost* Node_ProductFlow::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_ProductFlow::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.FixedDimensionCosts)
  return &fixeddimensioncosts_;
}
inline const ::NS3::FixedDimensionCost& Node_ProductFlow::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_.Get(index);
}
inline ::NS3::FixedDimensionCost* Node_ProductFlow::add_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_ProductFlow::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
inline int Node_ProductFlow::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void Node_ProductFlow::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* Node_ProductFlow::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_ProductFlow::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& Node_ProductFlow::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* Node_ProductFlow::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_ProductFlow::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_Flow

// repeated .NS3.DimensionRange dimensionRanges = 1;
inline int Node_Flow::dimensionranges_size() const {
  return dimensionranges_.size();
}
inline void Node_Flow::clear_dimensionranges() {
  dimensionranges_.Clear();
}
inline ::NS3::DimensionRange* Node_Flow::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_Flow::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.dimensionRanges)
  return &dimensionranges_;
}
inline const ::NS3::DimensionRange& Node_Flow::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_.Get(index);
}
inline ::NS3::DimensionRange* Node_Flow::add_dimensionranges() {
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_Flow::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_;
}

// repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
inline int Node_Flow::fixeddimensioncosts_size() const {
  return fixeddimensioncosts_.size();
}
inline void Node_Flow::clear_fixeddimensioncosts() {
  fixeddimensioncosts_.Clear();
}
inline ::NS3::FixedDimensionCost* Node_Flow::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_Flow::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.FixedDimensionCosts)
  return &fixeddimensioncosts_;
}
inline const ::NS3::FixedDimensionCost& Node_Flow::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_.Get(index);
}
inline ::NS3::FixedDimensionCost* Node_Flow::add_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_Flow::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
inline int Node_Flow::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void Node_Flow::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* Node_Flow::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_Flow::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& Node_Flow::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* Node_Flow::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_Flow::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_ProductTransform_Item

// required string productId = 1;
inline bool Node_ProductTransform_Item::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node_ProductTransform_Item::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node_ProductTransform_Item::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node_ProductTransform_Item::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& Node_ProductTransform_Item::productid() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.productId)
  return productid_.GetNoArena();
}
inline void Node_ProductTransform_Item::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Node.ProductTransform.Item.productId)
}
#if LANG_CXX11
inline void Node_ProductTransform_Item::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Node.ProductTransform.Item.productId)
}
#endif
inline void Node_ProductTransform_Item::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Node.ProductTransform.Item.productId)
}
inline void Node_ProductTransform_Item::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.ProductTransform.Item.productId)
}
inline ::std::string* Node_ProductTransform_Item::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node_ProductTransform_Item::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.Node.ProductTransform.Item.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_ProductTransform_Item::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductTransform.Item.productId)
}

// required int32 productRatio = 2;
inline bool Node_ProductTransform_Item::has_productratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node_ProductTransform_Item::set_has_productratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node_ProductTransform_Item::clear_has_productratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node_ProductTransform_Item::clear_productratio() {
  productratio_ = 0;
  clear_has_productratio();
}
inline ::google::protobuf::int32 Node_ProductTransform_Item::productratio() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.productRatio)
  return productratio_;
}
inline void Node_ProductTransform_Item::set_productratio(::google::protobuf::int32 value) {
  set_has_productratio();
  productratio_ = value;
  // @@protoc_insertion_point(field_set:NS3.Node.ProductTransform.Item.productRatio)
}

// repeated .NS3.DimensionRange dimensionRanges = 3;
inline int Node_ProductTransform_Item::dimensionranges_size() const {
  return dimensionranges_.size();
}
inline void Node_ProductTransform_Item::clear_dimensionranges() {
  dimensionranges_.Clear();
}
inline ::NS3::DimensionRange* Node_ProductTransform_Item::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.dimensionRanges)
  return dimensionranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_ProductTransform_Item::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.Item.dimensionRanges)
  return &dimensionranges_;
}
inline const ::NS3::DimensionRange& Node_ProductTransform_Item::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.dimensionRanges)
  return dimensionranges_.Get(index);
}
inline ::NS3::DimensionRange* Node_ProductTransform_Item::add_dimensionranges() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.Item.dimensionRanges)
  return dimensionranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_ProductTransform_Item::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.Item.dimensionRanges)
  return dimensionranges_;
}

// repeated .NS3.FixedDimensionCost fixedDimensionCosts = 4;
inline int Node_ProductTransform_Item::fixeddimensioncosts_size() const {
  return fixeddimensioncosts_.size();
}
inline void Node_ProductTransform_Item::clear_fixeddimensioncosts() {
  fixeddimensioncosts_.Clear();
}
inline ::NS3::FixedDimensionCost* Node_ProductTransform_Item::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return fixeddimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_ProductTransform_Item::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return &fixeddimensioncosts_;
}
inline const ::NS3::FixedDimensionCost& Node_ProductTransform_Item::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return fixeddimensioncosts_.Get(index);
}
inline ::NS3::FixedDimensionCost* Node_ProductTransform_Item::add_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return fixeddimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_ProductTransform_Item::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.Item.fixedDimensionCosts)
  return fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 5;
inline int Node_ProductTransform_Item::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void Node_ProductTransform_Item::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* Node_ProductTransform_Item::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_ProductTransform_Item::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& Node_ProductTransform_Item::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* Node_ProductTransform_Item::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_ProductTransform_Item::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.Item.unitDimensionCosts)
  return unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_ProductTransform

// required string productTransformId = 1;
inline bool Node_ProductTransform::has_producttransformid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node_ProductTransform::set_has_producttransformid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node_ProductTransform::clear_has_producttransformid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node_ProductTransform::clear_producttransformid() {
  producttransformid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producttransformid();
}
inline const ::std::string& Node_ProductTransform::producttransformid() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.productTransformId)
  return producttransformid_.GetNoArena();
}
inline void Node_ProductTransform::set_producttransformid(const ::std::string& value) {
  set_has_producttransformid();
  producttransformid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Node.ProductTransform.productTransformId)
}
#if LANG_CXX11
inline void Node_ProductTransform::set_producttransformid(::std::string&& value) {
  set_has_producttransformid();
  producttransformid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Node.ProductTransform.productTransformId)
}
#endif
inline void Node_ProductTransform::set_producttransformid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_producttransformid();
  producttransformid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Node.ProductTransform.productTransformId)
}
inline void Node_ProductTransform::set_producttransformid(const char* value, size_t size) {
  set_has_producttransformid();
  producttransformid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.ProductTransform.productTransformId)
}
inline ::std::string* Node_ProductTransform::mutable_producttransformid() {
  set_has_producttransformid();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.productTransformId)
  return producttransformid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node_ProductTransform::release_producttransformid() {
  // @@protoc_insertion_point(field_release:NS3.Node.ProductTransform.productTransformId)
  if (!has_producttransformid()) {
    return NULL;
  }
  clear_has_producttransformid();
  return producttransformid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_ProductTransform::set_allocated_producttransformid(::std::string* producttransformid) {
  if (producttransformid != NULL) {
    set_has_producttransformid();
  } else {
    clear_has_producttransformid();
  }
  producttransformid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producttransformid);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductTransform.productTransformId)
}

// repeated .NS3.Node.ProductTransform.Item inputItems = 2;
inline int Node_ProductTransform::inputitems_size() const {
  return inputitems_.size();
}
inline void Node_ProductTransform::clear_inputitems() {
  inputitems_.Clear();
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::mutable_inputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.inputItems)
  return inputitems_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
Node_ProductTransform::mutable_inputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.inputItems)
  return &inputitems_;
}
inline const ::NS3::Node_ProductTransform_Item& Node_ProductTransform::inputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.inputItems)
  return inputitems_.Get(index);
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::add_inputitems() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.inputItems)
  return inputitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
Node_ProductTransform::inputitems() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.inputItems)
  return inputitems_;
}

// repeated .NS3.Node.ProductTransform.Item outputItems = 3;
inline int Node_ProductTransform::outputitems_size() const {
  return outputitems_.size();
}
inline void Node_ProductTransform::clear_outputitems() {
  outputitems_.Clear();
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::mutable_outputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductTransform.outputItems)
  return outputitems_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >*
Node_ProductTransform::mutable_outputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductTransform.outputItems)
  return &outputitems_;
}
inline const ::NS3::Node_ProductTransform_Item& Node_ProductTransform::outputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductTransform.outputItems)
  return outputitems_.Get(index);
}
inline ::NS3::Node_ProductTransform_Item* Node_ProductTransform::add_outputitems() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductTransform.outputItems)
  return outputitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform_Item >&
Node_ProductTransform::outputitems() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductTransform.outputItems)
  return outputitems_;
}

// -------------------------------------------------------------------

// Node

// required string id = 1;
inline bool Node::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:NS3.Node.id)
  return id_.GetNoArena();
}
inline void Node::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Node.id)
}
#if LANG_CXX11
inline void Node::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Node.id)
}
#endif
inline void Node::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Node.id)
}
inline void Node::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.id)
}
inline ::std::string* Node::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.Node.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:NS3.Node.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.id)
}

// required .NS3.Geocode geocode = 2;
inline bool Node::has_geocode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_geocode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_geocode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_geocode() {
  if (geocode_ != NULL) geocode_->Clear();
  clear_has_geocode();
}
inline const ::NS3::Geocode& Node::_internal_geocode() const {
  return *geocode_;
}
inline const ::NS3::Geocode& Node::geocode() const {
  const ::NS3::Geocode* p = geocode_;
  // @@protoc_insertion_point(field_get:NS3.Node.geocode)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::Geocode*>(
      &::NS3::_Geocode_default_instance_);
}
inline ::NS3::Geocode* Node::release_geocode() {
  // @@protoc_insertion_point(field_release:NS3.Node.geocode)
  clear_has_geocode();
  ::NS3::Geocode* temp = geocode_;
  geocode_ = NULL;
  return temp;
}
inline ::NS3::Geocode* Node::mutable_geocode() {
  set_has_geocode();
  if (geocode_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::Geocode>(GetArenaNoVirtual());
    geocode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.Node.geocode)
  return geocode_;
}
inline void Node::set_allocated_geocode(::NS3::Geocode* geocode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geocode_;
  }
  if (geocode) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geocode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geocode, submessage_arena);
    }
    set_has_geocode();
  } else {
    clear_has_geocode();
  }
  geocode_ = geocode;
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.geocode)
}

// repeated .NS3.Node.ProductFlow production = 3;
inline int Node::production_size() const {
  return production_.size();
}
inline void Node::clear_production() {
  production_.Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_production(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.production)
  return production_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_production() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.production)
  return &production_;
}
inline const ::NS3::Node_ProductFlow& Node::production(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.production)
  return production_.Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_production() {
  // @@protoc_insertion_point(field_add:NS3.Node.production)
  return production_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::production() const {
  // @@protoc_insertion_point(field_list:NS3.Node.production)
  return production_;
}

// repeated .NS3.Node.ProductFlow consumption = 4;
inline int Node::consumption_size() const {
  return consumption_.size();
}
inline void Node::clear_consumption() {
  consumption_.Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_consumption(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.consumption)
  return consumption_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_consumption() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.consumption)
  return &consumption_;
}
inline const ::NS3::Node_ProductFlow& Node::consumption(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.consumption)
  return consumption_.Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_consumption() {
  // @@protoc_insertion_point(field_add:NS3.Node.consumption)
  return consumption_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::consumption() const {
  // @@protoc_insertion_point(field_list:NS3.Node.consumption)
  return consumption_;
}

// optional .NS3.Node.Flow flow = 5;
inline bool Node::has_flow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_flow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_flow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_flow() {
  if (flow_ != NULL) flow_->Clear();
  clear_has_flow();
}
inline const ::NS3::Node_Flow& Node::_internal_flow() const {
  return *flow_;
}
inline const ::NS3::Node_Flow& Node::flow() const {
  const ::NS3::Node_Flow* p = flow_;
  // @@protoc_insertion_point(field_get:NS3.Node.flow)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::Node_Flow*>(
      &::NS3::_Node_Flow_default_instance_);
}
inline ::NS3::Node_Flow* Node::release_flow() {
  // @@protoc_insertion_point(field_release:NS3.Node.flow)
  clear_has_flow();
  ::NS3::Node_Flow* temp = flow_;
  flow_ = NULL;
  return temp;
}
inline ::NS3::Node_Flow* Node::mutable_flow() {
  set_has_flow();
  if (flow_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::Node_Flow>(GetArenaNoVirtual());
    flow_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.Node.flow)
  return flow_;
}
inline void Node::set_allocated_flow(::NS3::Node_Flow* flow) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete flow_;
  }
  if (flow) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      flow = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, flow, submessage_arena);
    }
    set_has_flow();
  } else {
    clear_has_flow();
  }
  flow_ = flow;
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.flow)
}

// repeated .NS3.Node.ProductFlow productFlows = 6;
inline int Node::productflows_size() const {
  return productflows_.size();
}
inline void Node::clear_productflows() {
  productflows_.Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_productflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.productFlows)
  return productflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_productflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.productFlows)
  return &productflows_;
}
inline const ::NS3::Node_ProductFlow& Node::productflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.productFlows)
  return productflows_.Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_productflows() {
  // @@protoc_insertion_point(field_add:NS3.Node.productFlows)
  return productflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::productflows() const {
  // @@protoc_insertion_point(field_list:NS3.Node.productFlows)
  return productflows_;
}

// repeated string allowableSources = 7;
inline int Node::allowablesources_size() const {
  return allowablesources_.size();
}
inline void Node::clear_allowablesources() {
  allowablesources_.Clear();
}
inline const ::std::string& Node::allowablesources(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.allowableSources)
  return allowablesources_.Get(index);
}
inline ::std::string* Node::mutable_allowablesources(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.allowableSources)
  return allowablesources_.Mutable(index);
}
inline void Node::set_allowablesources(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.Node.allowableSources)
  allowablesources_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Node::set_allowablesources(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.Node.allowableSources)
  allowablesources_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Node::set_allowablesources(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allowablesources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.Node.allowableSources)
}
inline void Node::set_allowablesources(int index, const char* value, size_t size) {
  allowablesources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.allowableSources)
}
inline ::std::string* Node::add_allowablesources() {
  // @@protoc_insertion_point(field_add_mutable:NS3.Node.allowableSources)
  return allowablesources_.Add();
}
inline void Node::add_allowablesources(const ::std::string& value) {
  allowablesources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.Node.allowableSources)
}
#if LANG_CXX11
inline void Node::add_allowablesources(::std::string&& value) {
  allowablesources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.Node.allowableSources)
}
#endif
inline void Node::add_allowablesources(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allowablesources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(const char* value, size_t size) {
  allowablesources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.Node.allowableSources)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::allowablesources() const {
  // @@protoc_insertion_point(field_list:NS3.Node.allowableSources)
  return allowablesources_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_allowablesources() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.allowableSources)
  return &allowablesources_;
}

// optional int32 maximumSources = 8 [default = -1];
inline bool Node::has_maximumsources() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_maximumsources() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_maximumsources() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_maximumsources() {
  maximumsources_ = -1;
  clear_has_maximumsources();
}
inline ::google::protobuf::int32 Node::maximumsources() const {
  // @@protoc_insertion_point(field_get:NS3.Node.maximumSources)
  return maximumsources_;
}
inline void Node::set_maximumsources(::google::protobuf::int32 value) {
  set_has_maximumsources();
  maximumsources_ = value;
  // @@protoc_insertion_point(field_set:NS3.Node.maximumSources)
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 9;
inline int Node::flowconstraints_size() const {
  return flowconstraints_.size();
}
inline void Node::clear_flowconstraints() {
  flowconstraints_.Clear();
}
inline ::NS3::FlowDimensionalConstraint* Node::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.flowConstraints)
  return flowconstraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
Node::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.flowConstraints)
  return &flowconstraints_;
}
inline const ::NS3::FlowDimensionalConstraint& Node::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.flowConstraints)
  return flowconstraints_.Get(index);
}
inline ::NS3::FlowDimensionalConstraint* Node::add_flowconstraints() {
  // @@protoc_insertion_point(field_add:NS3.Node.flowConstraints)
  return flowconstraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
Node::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.Node.flowConstraints)
  return flowconstraints_;
}

// repeated .NS3.Node.ProductTransform productTransforms = 10;
inline int Node::producttransforms_size() const {
  return producttransforms_.size();
}
inline void Node::clear_producttransforms() {
  producttransforms_.Clear();
}
inline ::NS3::Node_ProductTransform* Node::mutable_producttransforms(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.productTransforms)
  return producttransforms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >*
Node::mutable_producttransforms() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.productTransforms)
  return &producttransforms_;
}
inline const ::NS3::Node_ProductTransform& Node::producttransforms(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.productTransforms)
  return producttransforms_.Get(index);
}
inline ::NS3::Node_ProductTransform* Node::add_producttransforms() {
  // @@protoc_insertion_point(field_add:NS3.Node.productTransforms)
  return producttransforms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductTransform >&
Node::producttransforms() const {
  // @@protoc_insertion_point(field_list:NS3.Node.productTransforms)
  return producttransforms_;
}

// -------------------------------------------------------------------

// ProductGroup_ProductSpecification

// required string baseDimension = 1;
inline bool ProductGroup_ProductSpecification::has_basedimension() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductGroup_ProductSpecification::set_has_basedimension() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductGroup_ProductSpecification::clear_has_basedimension() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductGroup_ProductSpecification::clear_basedimension() {
  basedimension_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_basedimension();
}
inline const ::std::string& ProductGroup_ProductSpecification::basedimension() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.baseDimension)
  return basedimension_.GetNoArena();
}
inline void ProductGroup_ProductSpecification::set_basedimension(const ::std::string& value) {
  set_has_basedimension();
  basedimension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.baseDimension)
}
#if LANG_CXX11
inline void ProductGroup_ProductSpecification::set_basedimension(::std::string&& value) {
  set_has_basedimension();
  basedimension_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.ProductGroup.ProductSpecification.baseDimension)
}
#endif
inline void ProductGroup_ProductSpecification::set_basedimension(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_basedimension();
  basedimension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.ProductSpecification.baseDimension)
}
inline void ProductGroup_ProductSpecification::set_basedimension(const char* value, size_t size) {
  set_has_basedimension();
  basedimension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.ProductSpecification.baseDimension)
}
inline ::std::string* ProductGroup_ProductSpecification::mutable_basedimension() {
  set_has_basedimension();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.ProductSpecification.baseDimension)
  return basedimension_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProductGroup_ProductSpecification::release_basedimension() {
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.ProductSpecification.baseDimension)
  if (!has_basedimension()) {
    return NULL;
  }
  clear_has_basedimension();
  return basedimension_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProductGroup_ProductSpecification::set_allocated_basedimension(::std::string* basedimension) {
  if (basedimension != NULL) {
    set_has_basedimension();
  } else {
    clear_has_basedimension();
  }
  basedimension_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), basedimension);
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.ProductSpecification.baseDimension)
}

// repeated string targetDimension = 2;
inline int ProductGroup_ProductSpecification::targetdimension_size() const {
  return targetdimension_.size();
}
inline void ProductGroup_ProductSpecification::clear_targetdimension() {
  targetdimension_.Clear();
}
inline const ::std::string& ProductGroup_ProductSpecification::targetdimension(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_.Get(index);
}
inline ::std::string* ProductGroup_ProductSpecification::mutable_targetdimension(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_.Mutable(index);
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetDimension)
  targetdimension_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetDimension)
  targetdimension_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  targetdimension_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const char* value, size_t size) {
  targetdimension_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline ::std::string* ProductGroup_ProductSpecification::add_targetdimension() {
  // @@protoc_insertion_point(field_add_mutable:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_.Add();
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const ::std::string& value) {
  targetdimension_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetDimension)
}
#if LANG_CXX11
inline void ProductGroup_ProductSpecification::add_targetdimension(::std::string&& value) {
  targetdimension_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetDimension)
}
#endif
inline void ProductGroup_ProductSpecification::add_targetdimension(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  targetdimension_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const char* value, size_t size) {
  targetdimension_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProductGroup_ProductSpecification::targetdimension() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProductGroup_ProductSpecification::mutable_targetdimension() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.ProductSpecification.targetDimension)
  return &targetdimension_;
}

// repeated float targetPerBase = 3;
inline int ProductGroup_ProductSpecification::targetperbase_size() const {
  return targetperbase_.size();
}
inline void ProductGroup_ProductSpecification::clear_targetperbase() {
  targetperbase_.Clear();
}
inline float ProductGroup_ProductSpecification::targetperbase(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return targetperbase_.Get(index);
}
inline void ProductGroup_ProductSpecification::set_targetperbase(int index, float value) {
  targetperbase_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetPerBase)
}
inline void ProductGroup_ProductSpecification::add_targetperbase(float value) {
  targetperbase_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetPerBase)
}
inline const ::google::protobuf::RepeatedField< float >&
ProductGroup_ProductSpecification::targetperbase() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return targetperbase_;
}
inline ::google::protobuf::RepeatedField< float >*
ProductGroup_ProductSpecification::mutable_targetperbase() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return &targetperbase_;
}

// -------------------------------------------------------------------

// ProductGroup

// required string productId = 1;
inline bool ProductGroup::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductGroup::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductGroup::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductGroup::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& ProductGroup::productid() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productId)
  return productid_.GetNoArena();
}
inline void ProductGroup::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.productId)
}
#if LANG_CXX11
inline void ProductGroup::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.ProductGroup.productId)
}
#endif
inline void ProductGroup::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.productId)
}
inline void ProductGroup::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.productId)
}
inline ::std::string* ProductGroup::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProductGroup::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProductGroup::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.productId)
}

// required string productGroupId = 2;
inline bool ProductGroup::has_productgroupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductGroup::set_has_productgroupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductGroup::clear_has_productgroupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductGroup::clear_productgroupid() {
  productgroupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productgroupid();
}
inline const ::std::string& ProductGroup::productgroupid() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productGroupId)
  return productgroupid_.GetNoArena();
}
inline void ProductGroup::set_productgroupid(const ::std::string& value) {
  set_has_productgroupid();
  productgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.productGroupId)
}
#if LANG_CXX11
inline void ProductGroup::set_productgroupid(::std::string&& value) {
  set_has_productgroupid();
  productgroupid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.ProductGroup.productGroupId)
}
#endif
inline void ProductGroup::set_productgroupid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productgroupid();
  productgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.productGroupId)
}
inline void ProductGroup::set_productgroupid(const char* value, size_t size) {
  set_has_productgroupid();
  productgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.productGroupId)
}
inline ::std::string* ProductGroup::mutable_productgroupid() {
  set_has_productgroupid();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productGroupId)
  return productgroupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProductGroup::release_productgroupid() {
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.productGroupId)
  if (!has_productgroupid()) {
    return NULL;
  }
  clear_has_productgroupid();
  return productgroupid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProductGroup::set_allocated_productgroupid(::std::string* productgroupid) {
  if (productgroupid != NULL) {
    set_has_productgroupid();
  } else {
    clear_has_productgroupid();
  }
  productgroupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productgroupid);
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.productGroupId)
}

// repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
inline int ProductGroup::productspecification_size() const {
  return productspecification_.size();
}
inline void ProductGroup::clear_productspecification() {
  productspecification_.Clear();
}
inline ::NS3::ProductGroup_ProductSpecification* ProductGroup::mutable_productspecification(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productSpecification)
  return productspecification_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >*
ProductGroup::mutable_productspecification() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.productSpecification)
  return &productspecification_;
}
inline const ::NS3::ProductGroup_ProductSpecification& ProductGroup::productspecification(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productSpecification)
  return productspecification_.Get(index);
}
inline ::NS3::ProductGroup_ProductSpecification* ProductGroup::add_productspecification() {
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.productSpecification)
  return productspecification_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >&
ProductGroup::productspecification() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.productSpecification)
  return productspecification_;
}

// -------------------------------------------------------------------

// LaneRate

// required string id = 1;
inline bool LaneRate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneRate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneRate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneRate::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LaneRate::id() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.id)
  return id_.GetNoArena();
}
inline void LaneRate::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.id)
}
#if LANG_CXX11
inline void LaneRate::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.LaneRate.id)
}
#endif
inline void LaneRate::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.id)
}
inline void LaneRate::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.id)
}
inline ::std::string* LaneRate::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRate::release_id() {
  // @@protoc_insertion_point(field_release:NS3.LaneRate.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRate::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.id)
}

// required string source = 3;
inline bool LaneRate::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneRate::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneRate::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneRate::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& LaneRate::source() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.source)
  return source_.GetNoArena();
}
inline void LaneRate::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.source)
}
#if LANG_CXX11
inline void LaneRate::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.LaneRate.source)
}
#endif
inline void LaneRate::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.source)
}
inline void LaneRate::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.source)
}
inline ::std::string* LaneRate::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRate::release_source() {
  // @@protoc_insertion_point(field_release:NS3.LaneRate.source)
  if (!has_source()) {
    return NULL;
  }
  clear_has_source();
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRate::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.source)
}

// required string destination = 4;
inline bool LaneRate::has_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneRate::set_has_destination() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneRate::clear_has_destination() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneRate::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination();
}
inline const ::std::string& LaneRate::destination() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.destination)
  return destination_.GetNoArena();
}
inline void LaneRate::set_destination(const ::std::string& value) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.destination)
}
#if LANG_CXX11
inline void LaneRate::set_destination(::std::string&& value) {
  set_has_destination();
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.LaneRate.destination)
}
#endif
inline void LaneRate::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.destination)
}
inline void LaneRate::set_destination(const char* value, size_t size) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.destination)
}
inline ::std::string* LaneRate::mutable_destination() {
  set_has_destination();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRate::release_destination() {
  // @@protoc_insertion_point(field_release:NS3.LaneRate.destination)
  if (!has_destination()) {
    return NULL;
  }
  clear_has_destination();
  return destination_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRate::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.destination)
}

// repeated string productIds = 5;
inline int LaneRate::productids_size() const {
  return productids_.size();
}
inline void LaneRate::clear_productids() {
  productids_.Clear();
}
inline const ::std::string& LaneRate::productids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.productIds)
  return productids_.Get(index);
}
inline ::std::string* LaneRate::mutable_productids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.productIds)
  return productids_.Mutable(index);
}
inline void LaneRate::set_productids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productIds)
  productids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LaneRate::set_productids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productIds)
  productids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LaneRate::set_productids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.productIds)
}
inline void LaneRate::set_productids(int index, const char* value, size_t size) {
  productids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.productIds)
}
inline ::std::string* LaneRate::add_productids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.LaneRate.productIds)
  return productids_.Add();
}
inline void LaneRate::add_productids(const ::std::string& value) {
  productids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productIds)
}
#if LANG_CXX11
inline void LaneRate::add_productids(::std::string&& value) {
  productids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productIds)
}
#endif
inline void LaneRate::add_productids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(const char* value, size_t size) {
  productids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.LaneRate.productIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LaneRate::productids() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.productIds)
  return productids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LaneRate::mutable_productids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.productIds)
  return &productids_;
}

// repeated string productGroupIds = 6;
inline int LaneRate::productgroupids_size() const {
  return productgroupids_.size();
}
inline void LaneRate::clear_productgroupids() {
  productgroupids_.Clear();
}
inline const ::std::string& LaneRate::productgroupids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.productGroupIds)
  return productgroupids_.Get(index);
}
inline ::std::string* LaneRate::mutable_productgroupids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.productGroupIds)
  return productgroupids_.Mutable(index);
}
inline void LaneRate::set_productgroupids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productGroupIds)
  productgroupids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LaneRate::set_productgroupids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productGroupIds)
  productgroupids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LaneRate::set_productgroupids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::set_productgroupids(int index, const char* value, size_t size) {
  productgroupids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.productGroupIds)
}
inline ::std::string* LaneRate::add_productgroupids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.LaneRate.productGroupIds)
  return productgroupids_.Add();
}
inline void LaneRate::add_productgroupids(const ::std::string& value) {
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productGroupIds)
}
#if LANG_CXX11
inline void LaneRate::add_productgroupids(::std::string&& value) {
  productgroupids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productGroupIds)
}
#endif
inline void LaneRate::add_productgroupids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(const char* value, size_t size) {
  productgroupids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.LaneRate.productGroupIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LaneRate::productgroupids() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.productGroupIds)
  return productgroupids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LaneRate::mutable_productgroupids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.productGroupIds)
  return &productgroupids_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
inline int LaneRate::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void LaneRate::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* LaneRate::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
LaneRate::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& LaneRate::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* LaneRate::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
LaneRate::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
inline int LaneRate::flowconstraints_size() const {
  return flowconstraints_.size();
}
inline void LaneRate::clear_flowconstraints() {
  flowconstraints_.Clear();
}
inline ::NS3::FlowDimensionalConstraint* LaneRate::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.flowConstraints)
  return flowconstraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
LaneRate::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.flowConstraints)
  return &flowconstraints_;
}
inline const ::NS3::FlowDimensionalConstraint& LaneRate::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.flowConstraints)
  return flowconstraints_.Get(index);
}
inline ::NS3::FlowDimensionalConstraint* LaneRate::add_flowconstraints() {
  // @@protoc_insertion_point(field_add:NS3.LaneRate.flowConstraints)
  return flowconstraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
LaneRate::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.flowConstraints)
  return flowconstraints_;
}

// -------------------------------------------------------------------

// CostModel

// required string id = 1;
inline bool CostModel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CostModel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CostModel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CostModel::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& CostModel::id() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.id)
  return id_.GetNoArena();
}
inline void CostModel::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.id)
}
#if LANG_CXX11
inline void CostModel::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.CostModel.id)
}
#endif
inline void CostModel::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.id)
}
inline void CostModel::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.id)
}
inline ::std::string* CostModel::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostModel::release_id() {
  // @@protoc_insertion_point(field_release:NS3.CostModel.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CostModel::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.id)
}

// required string source = 2;
inline bool CostModel::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CostModel::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CostModel::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CostModel::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& CostModel::source() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.source)
  return source_.GetNoArena();
}
inline void CostModel::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.source)
}
#if LANG_CXX11
inline void CostModel::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.CostModel.source)
}
#endif
inline void CostModel::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.source)
}
inline void CostModel::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.source)
}
inline ::std::string* CostModel::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostModel::release_source() {
  // @@protoc_insertion_point(field_release:NS3.CostModel.source)
  if (!has_source()) {
    return NULL;
  }
  clear_has_source();
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CostModel::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.source)
}

// repeated string productGroupIds = 3;
inline int CostModel::productgroupids_size() const {
  return productgroupids_.size();
}
inline void CostModel::clear_productgroupids() {
  productgroupids_.Clear();
}
inline const ::std::string& CostModel::productgroupids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.productGroupIds)
  return productgroupids_.Get(index);
}
inline ::std::string* CostModel::mutable_productgroupids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.productGroupIds)
  return productgroupids_.Mutable(index);
}
inline void CostModel::set_productgroupids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.CostModel.productGroupIds)
  productgroupids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CostModel::set_productgroupids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.CostModel.productGroupIds)
  productgroupids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CostModel::set_productgroupids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.productGroupIds)
}
inline void CostModel::set_productgroupids(int index, const char* value, size_t size) {
  productgroupids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.productGroupIds)
}
inline ::std::string* CostModel::add_productgroupids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.CostModel.productGroupIds)
  return productgroupids_.Add();
}
inline void CostModel::add_productgroupids(const ::std::string& value) {
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.CostModel.productGroupIds)
}
#if LANG_CXX11
inline void CostModel::add_productgroupids(::std::string&& value) {
  productgroupids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.CostModel.productGroupIds)
}
#endif
inline void CostModel::add_productgroupids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(const char* value, size_t size) {
  productgroupids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.CostModel.productGroupIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostModel::productgroupids() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.productGroupIds)
  return productgroupids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostModel::mutable_productgroupids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.productGroupIds)
  return &productgroupids_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
inline int CostModel::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void CostModel::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* CostModel::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
CostModel::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& CostModel::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* CostModel::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.CostModel.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
CostModel::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.unitDimensionCosts)
  return unitdimensioncosts_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 5;
inline int CostModel::flowconstraints_size() const {
  return flowconstraints_.size();
}
inline void CostModel::clear_flowconstraints() {
  flowconstraints_.Clear();
}
inline ::NS3::FlowDimensionalConstraint* CostModel::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.flowConstraints)
  return flowconstraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
CostModel::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.flowConstraints)
  return &flowconstraints_;
}
inline const ::NS3::FlowDimensionalConstraint& CostModel::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.flowConstraints)
  return flowconstraints_.Get(index);
}
inline ::NS3::FlowDimensionalConstraint* CostModel::add_flowconstraints() {
  // @@protoc_insertion_point(field_add:NS3.CostModel.flowConstraints)
  return flowconstraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
CostModel::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.flowConstraints)
  return flowconstraints_;
}

// -------------------------------------------------------------------

// Model

// required .NS3.DimensionConfiguration dimensions = 1;
inline bool Model::has_dimensions() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_dimensions() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_dimensions() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_dimensions() {
  if (dimensions_ != NULL) dimensions_->Clear();
  clear_has_dimensions();
}
inline const ::NS3::DimensionConfiguration& Model::_internal_dimensions() const {
  return *dimensions_;
}
inline const ::NS3::DimensionConfiguration& Model::dimensions() const {
  const ::NS3::DimensionConfiguration* p = dimensions_;
  // @@protoc_insertion_point(field_get:NS3.Model.dimensions)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::DimensionConfiguration*>(
      &::NS3::_DimensionConfiguration_default_instance_);
}
inline ::NS3::DimensionConfiguration* Model::release_dimensions() {
  // @@protoc_insertion_point(field_release:NS3.Model.dimensions)
  clear_has_dimensions();
  ::NS3::DimensionConfiguration* temp = dimensions_;
  dimensions_ = NULL;
  return temp;
}
inline ::NS3::DimensionConfiguration* Model::mutable_dimensions() {
  set_has_dimensions();
  if (dimensions_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::DimensionConfiguration>(GetArenaNoVirtual());
    dimensions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.Model.dimensions)
  return dimensions_;
}
inline void Model::set_allocated_dimensions(::NS3::DimensionConfiguration* dimensions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dimensions_;
  }
  if (dimensions) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dimensions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dimensions, submessage_arena);
    }
    set_has_dimensions();
  } else {
    clear_has_dimensions();
  }
  dimensions_ = dimensions;
  // @@protoc_insertion_point(field_set_allocated:NS3.Model.dimensions)
}

// repeated .NS3.Node nodes = 2;
inline int Model::nodes_size() const {
  return nodes_.size();
}
inline void Model::clear_nodes() {
  nodes_.Clear();
}
inline ::NS3::Node* Model::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node >*
Model::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.nodes)
  return &nodes_;
}
inline const ::NS3::Node& Model::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.nodes)
  return nodes_.Get(index);
}
inline ::NS3::Node* Model::add_nodes() {
  // @@protoc_insertion_point(field_add:NS3.Model.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node >&
Model::nodes() const {
  // @@protoc_insertion_point(field_list:NS3.Model.nodes)
  return nodes_;
}

// repeated .NS3.LaneRate laneRates = 3;
inline int Model::lanerates_size() const {
  return lanerates_.size();
}
inline void Model::clear_lanerates() {
  lanerates_.Clear();
}
inline ::NS3::LaneRate* Model::mutable_lanerates(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.laneRates)
  return lanerates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >*
Model::mutable_lanerates() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.laneRates)
  return &lanerates_;
}
inline const ::NS3::LaneRate& Model::lanerates(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.laneRates)
  return lanerates_.Get(index);
}
inline ::NS3::LaneRate* Model::add_lanerates() {
  // @@protoc_insertion_point(field_add:NS3.Model.laneRates)
  return lanerates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >&
Model::lanerates() const {
  // @@protoc_insertion_point(field_list:NS3.Model.laneRates)
  return lanerates_;
}

// repeated .NS3.CostModel costModels = 4;
inline int Model::costmodels_size() const {
  return costmodels_.size();
}
inline void Model::clear_costmodels() {
  costmodels_.Clear();
}
inline ::NS3::CostModel* Model::mutable_costmodels(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.costModels)
  return costmodels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >*
Model::mutable_costmodels() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.costModels)
  return &costmodels_;
}
inline const ::NS3::CostModel& Model::costmodels(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.costModels)
  return costmodels_.Get(index);
}
inline ::NS3::CostModel* Model::add_costmodels() {
  // @@protoc_insertion_point(field_add:NS3.Model.costModels)
  return costmodels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >&
Model::costmodels() const {
  // @@protoc_insertion_point(field_list:NS3.Model.costModels)
  return costmodels_;
}

// repeated .NS3.ProductGroup productGroups = 5;
inline int Model::productgroups_size() const {
  return productgroups_.size();
}
inline void Model::clear_productgroups() {
  productgroups_.Clear();
}
inline ::NS3::ProductGroup* Model::mutable_productgroups(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.productGroups)
  return productgroups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >*
Model::mutable_productgroups() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.productGroups)
  return &productgroups_;
}
inline const ::NS3::ProductGroup& Model::productgroups(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.productGroups)
  return productgroups_.Get(index);
}
inline ::NS3::ProductGroup* Model::add_productgroups() {
  // @@protoc_insertion_point(field_add:NS3.Model.productGroups)
  return productgroups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >&
Model::productgroups() const {
  // @@protoc_insertion_point(field_list:NS3.Model.productGroups)
  return productgroups_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .NS3.Model model = 1;
inline bool SolveRequest::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolveRequest::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolveRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolveRequest::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::NS3::Model& SolveRequest::_internal_model() const {
  return *model_;
}
inline const ::NS3::Model& SolveRequest::model() const {
  const ::NS3::Model* p = model_;
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.model)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::Model*>(
      &::NS3::_Model_default_instance_);
}
inline ::NS3::Model* SolveRequest::release_model() {
  // @@protoc_insertion_point(field_release:NS3.SolveRequest.model)
  clear_has_model();
  ::NS3::Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::NS3::Model* SolveRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.SolveRequest.model)
  return model_;
}
inline void SolveRequest::set_allocated_model(::NS3::Model* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:NS3.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolveRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolveRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolveRequest::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.modelID)
  return modelid_.GetNoArena();
}
inline void SolveRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.modelID)
}
#if LANG_CXX11
inline void SolveRequest::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolveRequest.modelID)
}
#endif
inline void SolveRequest::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolveRequest.modelID)
}
inline void SolveRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolveRequest.modelID)
}
inline ::std::string* SolveRequest::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:NS3.SolveRequest.modelID)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolveRequest::release_modelid() {
  // @@protoc_insertion_point(field_release:NS3.SolveRequest.modelID)
  if (!has_modelid()) {
    return NULL;
  }
  clear_has_modelid();
  return modelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolveRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolveRequest.modelID)
}

// optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolveRequest::set_has_solvetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolveRequest::clear_has_solvetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolveRequest::clear_solvetype() {
  solvetype_ = 0;
  clear_has_solvetype();
}
inline ::NS3::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.solveType)
  return static_cast< ::NS3::SolveRequest_SolveType >(solvetype_);
}
inline void SolveRequest::set_solvetype(::NS3::SolveRequest_SolveType value) {
  assert(::NS3::SolveRequest_SolveType_IsValid(value));
  set_has_solvetype();
  solvetype_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.solveType)
}

// optional .NS3.SolveRequest.GeometryOutput geometryOutput = 5 [default = None];
inline bool SolveRequest::has_geometryoutput() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolveRequest::set_has_geometryoutput() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolveRequest::clear_has_geometryoutput() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolveRequest::clear_geometryoutput() {
  geometryoutput_ = 0;
  clear_has_geometryoutput();
}
inline ::NS3::SolveRequest_GeometryOutput SolveRequest::geometryoutput() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.geometryOutput)
  return static_cast< ::NS3::SolveRequest_GeometryOutput >(geometryoutput_);
}
inline void SolveRequest::set_geometryoutput(::NS3::SolveRequest_GeometryOutput value) {
  assert(::NS3::SolveRequest_GeometryOutput_IsValid(value));
  set_has_geometryoutput();
  geometryoutput_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.geometryOutput)
}

// -------------------------------------------------------------------

// SolutionResponse_Assignment

// required string source = 1;
inline bool SolutionResponse_Assignment::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Assignment::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Assignment::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Assignment::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& SolutionResponse_Assignment::source() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.source)
  return source_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.source)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.source)
}
#endif
inline void SolutionResponse_Assignment::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.source)
}
inline void SolutionResponse_Assignment::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.source)
}
inline ::std::string* SolutionResponse_Assignment::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_source() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.source)
  if (!has_source()) {
    return NULL;
  }
  clear_has_source();
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.source)
}

// required string destination = 2;
inline bool SolutionResponse_Assignment::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Assignment::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Assignment::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Assignment::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination();
}
inline const ::std::string& SolutionResponse_Assignment::destination() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.destination)
  return destination_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_destination(const ::std::string& value) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.destination)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_destination(::std::string&& value) {
  set_has_destination();
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.destination)
}
#endif
inline void SolutionResponse_Assignment::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.destination)
}
inline void SolutionResponse_Assignment::set_destination(const char* value, size_t size) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.destination)
}
inline ::std::string* SolutionResponse_Assignment::mutable_destination() {
  set_has_destination();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_destination() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.destination)
  if (!has_destination()) {
    return NULL;
  }
  clear_has_destination();
  return destination_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.destination)
}

// required string productId = 3;
inline bool SolutionResponse_Assignment::has_productid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Assignment::set_has_productid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Assignment::clear_has_productid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Assignment::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& SolutionResponse_Assignment::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.productId)
  return productid_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.productId)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.productId)
}
#endif
inline void SolutionResponse_Assignment::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.productId)
}
inline void SolutionResponse_Assignment::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.productId)
}
inline ::std::string* SolutionResponse_Assignment::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.productId)
}

// required float amount = 4;
inline bool SolutionResponse_Assignment::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_Assignment::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_Assignment::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_Assignment::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline float SolutionResponse_Assignment::amount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.amount)
  return amount_;
}
inline void SolutionResponse_Assignment::set_amount(float value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.amount)
}

// required float cost = 5;
inline bool SolutionResponse_Assignment::has_cost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_Assignment::set_has_cost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_Assignment::clear_has_cost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_Assignment::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_Assignment::cost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.cost)
  return cost_;
}
inline void SolutionResponse_Assignment::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.cost)
}

// optional string laneRateId = 6;
inline bool SolutionResponse_Assignment::has_lanerateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Assignment::set_has_lanerateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Assignment::clear_has_lanerateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Assignment::clear_lanerateid() {
  lanerateid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lanerateid();
}
inline const ::std::string& SolutionResponse_Assignment::lanerateid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.laneRateId)
  return lanerateid_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_lanerateid(const ::std::string& value) {
  set_has_lanerateid();
  lanerateid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.laneRateId)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_lanerateid(::std::string&& value) {
  set_has_lanerateid();
  lanerateid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.laneRateId)
}
#endif
inline void SolutionResponse_Assignment::set_lanerateid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lanerateid();
  lanerateid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.laneRateId)
}
inline void SolutionResponse_Assignment::set_lanerateid(const char* value, size_t size) {
  set_has_lanerateid();
  lanerateid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.laneRateId)
}
inline ::std::string* SolutionResponse_Assignment::mutable_lanerateid() {
  set_has_lanerateid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.laneRateId)
  return lanerateid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_lanerateid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.laneRateId)
  if (!has_lanerateid()) {
    return NULL;
  }
  clear_has_lanerateid();
  return lanerateid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_lanerateid(::std::string* lanerateid) {
  if (lanerateid != NULL) {
    set_has_lanerateid();
  } else {
    clear_has_lanerateid();
  }
  lanerateid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lanerateid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.laneRateId)
}

// optional string costModelId = 7;
inline bool SolutionResponse_Assignment::has_costmodelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_Assignment::set_has_costmodelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_Assignment::clear_has_costmodelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_Assignment::clear_costmodelid() {
  costmodelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_costmodelid();
}
inline const ::std::string& SolutionResponse_Assignment::costmodelid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.costModelId)
  return costmodelid_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_costmodelid(const ::std::string& value) {
  set_has_costmodelid();
  costmodelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.costModelId)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_costmodelid(::std::string&& value) {
  set_has_costmodelid();
  costmodelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.costModelId)
}
#endif
inline void SolutionResponse_Assignment::set_costmodelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_costmodelid();
  costmodelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.costModelId)
}
inline void SolutionResponse_Assignment::set_costmodelid(const char* value, size_t size) {
  set_has_costmodelid();
  costmodelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.costModelId)
}
inline ::std::string* SolutionResponse_Assignment::mutable_costmodelid() {
  set_has_costmodelid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.costModelId)
  return costmodelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_costmodelid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.costModelId)
  if (!has_costmodelid()) {
    return NULL;
  }
  clear_has_costmodelid();
  return costmodelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_costmodelid(::std::string* costmodelid) {
  if (costmodelid != NULL) {
    set_has_costmodelid();
  } else {
    clear_has_costmodelid();
  }
  costmodelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), costmodelid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.costModelId)
}

// required float distance = 8;
inline bool SolutionResponse_Assignment::has_distance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_Assignment::set_has_distance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_Assignment::clear_has_distance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_Assignment::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float SolutionResponse_Assignment::distance() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.distance)
  return distance_;
}
inline void SolutionResponse_Assignment::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.distance)
}

// required float duration = 9;
inline bool SolutionResponse_Assignment::has_duration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolutionResponse_Assignment::set_has_duration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolutionResponse_Assignment::clear_has_duration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolutionResponse_Assignment::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float SolutionResponse_Assignment::duration() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.duration)
  return duration_;
}
inline void SolutionResponse_Assignment::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.duration)
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductFlow

// required string nodeId = 1;
inline bool SolutionResponse_NodeProductFlow::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_NodeProductFlow::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& SolutionResponse_NodeProductFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.nodeId)
  return nodeid_.GetNoArena();
}
inline void SolutionResponse_NodeProductFlow::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductFlow::set_nodeid(::std::string&& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
#endif
inline void SolutionResponse_NodeProductFlow::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
inline void SolutionResponse_NodeProductFlow::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
inline ::std::string* SolutionResponse_NodeProductFlow::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductFlow.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductFlow::release_nodeid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductFlow.nodeId)
  if (!has_nodeid()) {
    return NULL;
  }
  clear_has_nodeid();
  return nodeid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductFlow::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductFlow.nodeId)
}

// required string productId = 2;
inline bool SolutionResponse_NodeProductFlow::has_productid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_NodeProductFlow::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& SolutionResponse_NodeProductFlow::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productId)
  return productid_.GetNoArena();
}
inline void SolutionResponse_NodeProductFlow::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductFlow::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductFlow.productId)
}
#endif
inline void SolutionResponse_NodeProductFlow::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductFlow.productId)
}
inline void SolutionResponse_NodeProductFlow::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductFlow.productId)
}
inline ::std::string* SolutionResponse_NodeProductFlow::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductFlow.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductFlow::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductFlow.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductFlow::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductFlow.productId)
}

// required float inFlow = 3;
inline bool SolutionResponse_NodeProductFlow::has_inflow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_inflow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_inflow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_NodeProductFlow::clear_inflow() {
  inflow_ = 0;
  clear_has_inflow();
}
inline float SolutionResponse_NodeProductFlow::inflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.inFlow)
  return inflow_;
}
inline void SolutionResponse_NodeProductFlow::set_inflow(float value) {
  set_has_inflow();
  inflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.inFlow)
}

// required float outFlow = 4;
inline bool SolutionResponse_NodeProductFlow::has_outflow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_outflow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_outflow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_NodeProductFlow::clear_outflow() {
  outflow_ = 0;
  clear_has_outflow();
}
inline float SolutionResponse_NodeProductFlow::outflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.outFlow)
  return outflow_;
}
inline void SolutionResponse_NodeProductFlow::set_outflow(float value) {
  set_has_outflow();
  outflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.outFlow)
}

// required float flowCost = 5;
inline bool SolutionResponse_NodeProductFlow::has_flowcost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_flowcost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_flowcost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_NodeProductFlow::clear_flowcost() {
  flowcost_ = 0;
  clear_has_flowcost();
}
inline float SolutionResponse_NodeProductFlow::flowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.flowCost)
  return flowcost_;
}
inline void SolutionResponse_NodeProductFlow::set_flowcost(float value) {
  set_has_flowcost();
  flowcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.flowCost)
}

// required float fixedCost = 6;
inline bool SolutionResponse_NodeProductFlow::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_NodeProductFlow::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float SolutionResponse_NodeProductFlow::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.fixedCost)
  return fixedcost_;
}
inline void SolutionResponse_NodeProductFlow::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.fixedCost)
}

// required float productionAmount = 7;
inline bool SolutionResponse_NodeProductFlow::has_productionamount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productionamount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productionamount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_NodeProductFlow::clear_productionamount() {
  productionamount_ = 0;
  clear_has_productionamount();
}
inline float SolutionResponse_NodeProductFlow::productionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionAmount)
  return productionamount_;
}
inline void SolutionResponse_NodeProductFlow::set_productionamount(float value) {
  set_has_productionamount();
  productionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionAmount)
}

// required float productionPenalty = 8;
inline bool SolutionResponse_NodeProductFlow::has_productionpenalty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productionpenalty() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productionpenalty() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_NodeProductFlow::clear_productionpenalty() {
  productionpenalty_ = 0;
  clear_has_productionpenalty();
}
inline float SolutionResponse_NodeProductFlow::productionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionPenalty)
  return productionpenalty_;
}
inline void SolutionResponse_NodeProductFlow::set_productionpenalty(float value) {
  set_has_productionpenalty();
  productionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionPenalty)
}

// required float productionCost = 9;
inline bool SolutionResponse_NodeProductFlow::has_productioncost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productioncost() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productioncost() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolutionResponse_NodeProductFlow::clear_productioncost() {
  productioncost_ = 0;
  clear_has_productioncost();
}
inline float SolutionResponse_NodeProductFlow::productioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionCost)
  return productioncost_;
}
inline void SolutionResponse_NodeProductFlow::set_productioncost(float value) {
  set_has_productioncost();
  productioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionCost)
}

// required float consumptionAmount = 10;
inline bool SolutionResponse_NodeProductFlow::has_consumptionamount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_consumptionamount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_consumptionamount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptionamount() {
  consumptionamount_ = 0;
  clear_has_consumptionamount();
}
inline float SolutionResponse_NodeProductFlow::consumptionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionAmount)
  return consumptionamount_;
}
inline void SolutionResponse_NodeProductFlow::set_consumptionamount(float value) {
  set_has_consumptionamount();
  consumptionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionAmount)
}

// required float consumptionPenalty = 11;
inline bool SolutionResponse_NodeProductFlow::has_consumptionpenalty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_consumptionpenalty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_consumptionpenalty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptionpenalty() {
  consumptionpenalty_ = 0;
  clear_has_consumptionpenalty();
}
inline float SolutionResponse_NodeProductFlow::consumptionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionPenalty)
  return consumptionpenalty_;
}
inline void SolutionResponse_NodeProductFlow::set_consumptionpenalty(float value) {
  set_has_consumptionpenalty();
  consumptionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionPenalty)
}

// required float consumptionCost = 12;
inline bool SolutionResponse_NodeProductFlow::has_consumptioncost() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_consumptioncost() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_consumptioncost() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptioncost() {
  consumptioncost_ = 0;
  clear_has_consumptioncost();
}
inline float SolutionResponse_NodeProductFlow::consumptioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionCost)
  return consumptioncost_;
}
inline void SolutionResponse_NodeProductFlow::set_consumptioncost(float value) {
  set_has_consumptioncost();
  consumptioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionCost)
}

// -------------------------------------------------------------------

// SolutionResponse_NodeFlow

// required string nodeId = 1;
inline bool SolutionResponse_NodeFlow::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_NodeFlow::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_NodeFlow::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& SolutionResponse_NodeFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.nodeId)
  return nodeid_.GetNoArena();
}
inline void SolutionResponse_NodeFlow::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.nodeId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeFlow::set_nodeid(::std::string&& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeFlow.nodeId)
}
#endif
inline void SolutionResponse_NodeFlow::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeFlow.nodeId)
}
inline void SolutionResponse_NodeFlow::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeFlow.nodeId)
}
inline ::std::string* SolutionResponse_NodeFlow::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeFlow.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeFlow::release_nodeid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeFlow.nodeId)
  if (!has_nodeid()) {
    return NULL;
  }
  clear_has_nodeid();
  return nodeid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeFlow::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeFlow.nodeId)
}

// required float inFlow = 2;
inline bool SolutionResponse_NodeFlow::has_inflow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_inflow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_NodeFlow::clear_has_inflow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_NodeFlow::clear_inflow() {
  inflow_ = 0;
  clear_has_inflow();
}
inline float SolutionResponse_NodeFlow::inflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.inFlow)
  return inflow_;
}
inline void SolutionResponse_NodeFlow::set_inflow(float value) {
  set_has_inflow();
  inflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.inFlow)
}

// required float outFlow = 3;
inline bool SolutionResponse_NodeFlow::has_outflow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_outflow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_NodeFlow::clear_has_outflow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_NodeFlow::clear_outflow() {
  outflow_ = 0;
  clear_has_outflow();
}
inline float SolutionResponse_NodeFlow::outflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.outFlow)
  return outflow_;
}
inline void SolutionResponse_NodeFlow::set_outflow(float value) {
  set_has_outflow();
  outflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.outFlow)
}

// required float flowCost = 4;
inline bool SolutionResponse_NodeFlow::has_flowcost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_flowcost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_NodeFlow::clear_has_flowcost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_NodeFlow::clear_flowcost() {
  flowcost_ = 0;
  clear_has_flowcost();
}
inline float SolutionResponse_NodeFlow::flowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.flowCost)
  return flowcost_;
}
inline void SolutionResponse_NodeFlow::set_flowcost(float value) {
  set_has_flowcost();
  flowcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.flowCost)
}

// required float fixedCost = 5;
inline bool SolutionResponse_NodeFlow::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_NodeFlow::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_NodeFlow::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float SolutionResponse_NodeFlow::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.fixedCost)
  return fixedcost_;
}
inline void SolutionResponse_NodeFlow::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.fixedCost)
}

// required float productFlowCost = 6;
inline bool SolutionResponse_NodeFlow::has_productflowcost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productflowcost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_NodeFlow::clear_has_productflowcost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_NodeFlow::clear_productflowcost() {
  productflowcost_ = 0;
  clear_has_productflowcost();
}
inline float SolutionResponse_NodeFlow::productflowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productFlowCost)
  return productflowcost_;
}
inline void SolutionResponse_NodeFlow::set_productflowcost(float value) {
  set_has_productflowcost();
  productflowcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productFlowCost)
}

// required float productFixedCost = 7;
inline bool SolutionResponse_NodeFlow::has_productfixedcost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productfixedcost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_NodeFlow::clear_has_productfixedcost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_NodeFlow::clear_productfixedcost() {
  productfixedcost_ = 0;
  clear_has_productfixedcost();
}
inline float SolutionResponse_NodeFlow::productfixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productFixedCost)
  return productfixedcost_;
}
inline void SolutionResponse_NodeFlow::set_productfixedcost(float value) {
  set_has_productfixedcost();
  productfixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productFixedCost)
}

// required float productionAmount = 8;
inline bool SolutionResponse_NodeFlow::has_productionamount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productionamount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_NodeFlow::clear_has_productionamount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_NodeFlow::clear_productionamount() {
  productionamount_ = 0;
  clear_has_productionamount();
}
inline float SolutionResponse_NodeFlow::productionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionAmount)
  return productionamount_;
}
inline void SolutionResponse_NodeFlow::set_productionamount(float value) {
  set_has_productionamount();
  productionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionAmount)
}

// required float productionPenalty = 9;
inline bool SolutionResponse_NodeFlow::has_productionpenalty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productionpenalty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolutionResponse_NodeFlow::clear_has_productionpenalty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolutionResponse_NodeFlow::clear_productionpenalty() {
  productionpenalty_ = 0;
  clear_has_productionpenalty();
}
inline float SolutionResponse_NodeFlow::productionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionPenalty)
  return productionpenalty_;
}
inline void SolutionResponse_NodeFlow::set_productionpenalty(float value) {
  set_has_productionpenalty();
  productionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionPenalty)
}

// required float productionCost = 10;
inline bool SolutionResponse_NodeFlow::has_productioncost() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productioncost() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolutionResponse_NodeFlow::clear_has_productioncost() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolutionResponse_NodeFlow::clear_productioncost() {
  productioncost_ = 0;
  clear_has_productioncost();
}
inline float SolutionResponse_NodeFlow::productioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionCost)
  return productioncost_;
}
inline void SolutionResponse_NodeFlow::set_productioncost(float value) {
  set_has_productioncost();
  productioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionCost)
}

// required float consumptionAmount = 11;
inline bool SolutionResponse_NodeFlow::has_consumptionamount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_consumptionamount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolutionResponse_NodeFlow::clear_has_consumptionamount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolutionResponse_NodeFlow::clear_consumptionamount() {
  consumptionamount_ = 0;
  clear_has_consumptionamount();
}
inline float SolutionResponse_NodeFlow::consumptionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionAmount)
  return consumptionamount_;
}
inline void SolutionResponse_NodeFlow::set_consumptionamount(float value) {
  set_has_consumptionamount();
  consumptionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionAmount)
}

// required float consumptionPenalty = 12;
inline bool SolutionResponse_NodeFlow::has_consumptionpenalty() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_consumptionpenalty() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolutionResponse_NodeFlow::clear_has_consumptionpenalty() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolutionResponse_NodeFlow::clear_consumptionpenalty() {
  consumptionpenalty_ = 0;
  clear_has_consumptionpenalty();
}
inline float SolutionResponse_NodeFlow::consumptionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionPenalty)
  return consumptionpenalty_;
}
inline void SolutionResponse_NodeFlow::set_consumptionpenalty(float value) {
  set_has_consumptionpenalty();
  consumptionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionPenalty)
}

// required float consumptionCost = 13;
inline bool SolutionResponse_NodeFlow::has_consumptioncost() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_consumptioncost() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SolutionResponse_NodeFlow::clear_has_consumptioncost() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SolutionResponse_NodeFlow::clear_consumptioncost() {
  consumptioncost_ = 0;
  clear_has_consumptioncost();
}
inline float SolutionResponse_NodeFlow::consumptioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionCost)
  return consumptioncost_;
}
inline void SolutionResponse_NodeFlow::set_consumptioncost(float value) {
  set_has_consumptioncost();
  consumptioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionCost)
}

// -------------------------------------------------------------------

// SolutionResponse_GeometrySequence

// repeated float x = 1;
inline int SolutionResponse_GeometrySequence::x_size() const {
  return x_.size();
}
inline void SolutionResponse_GeometrySequence::clear_x() {
  x_.Clear();
}
inline float SolutionResponse_GeometrySequence::x(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometrySequence.x)
  return x_.Get(index);
}
inline void SolutionResponse_GeometrySequence::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometrySequence.x)
}
inline void SolutionResponse_GeometrySequence::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometrySequence.x)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometrySequence::x() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometrySequence.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometrySequence::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometrySequence.x)
  return &x_;
}

// repeated float y = 2;
inline int SolutionResponse_GeometrySequence::y_size() const {
  return y_.size();
}
inline void SolutionResponse_GeometrySequence::clear_y() {
  y_.Clear();
}
inline float SolutionResponse_GeometrySequence::y(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometrySequence.y)
  return y_.Get(index);
}
inline void SolutionResponse_GeometrySequence::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometrySequence.y)
}
inline void SolutionResponse_GeometrySequence::add_y(float value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometrySequence.y)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometrySequence::y() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometrySequence.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometrySequence::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometrySequence.y)
  return &y_;
}

// -------------------------------------------------------------------

// SolutionResponse_Route

// required string fromId = 1;
inline bool SolutionResponse_Route::has_fromid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Route::set_has_fromid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Route::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Route::clear_fromid() {
  fromid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromid();
}
inline const ::std::string& SolutionResponse_Route::fromid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Route.fromId)
  return fromid_.GetNoArena();
}
inline void SolutionResponse_Route::set_fromid(const ::std::string& value) {
  set_has_fromid();
  fromid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Route.fromId)
}
#if LANG_CXX11
inline void SolutionResponse_Route::set_fromid(::std::string&& value) {
  set_has_fromid();
  fromid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Route.fromId)
}
#endif
inline void SolutionResponse_Route::set_fromid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromid();
  fromid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Route.fromId)
}
inline void SolutionResponse_Route::set_fromid(const char* value, size_t size) {
  set_has_fromid();
  fromid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Route.fromId)
}
inline ::std::string* SolutionResponse_Route::mutable_fromid() {
  set_has_fromid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Route.fromId)
  return fromid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Route::release_fromid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Route.fromId)
  if (!has_fromid()) {
    return NULL;
  }
  clear_has_fromid();
  return fromid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Route::set_allocated_fromid(::std::string* fromid) {
  if (fromid != NULL) {
    set_has_fromid();
  } else {
    clear_has_fromid();
  }
  fromid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Route.fromId)
}

// required string toId = 2;
inline bool SolutionResponse_Route::has_toid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Route::set_has_toid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Route::clear_has_toid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Route::clear_toid() {
  toid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_toid();
}
inline const ::std::string& SolutionResponse_Route::toid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Route.toId)
  return toid_.GetNoArena();
}
inline void SolutionResponse_Route::set_toid(const ::std::string& value) {
  set_has_toid();
  toid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Route.toId)
}
#if LANG_CXX11
inline void SolutionResponse_Route::set_toid(::std::string&& value) {
  set_has_toid();
  toid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Route.toId)
}
#endif
inline void SolutionResponse_Route::set_toid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_toid();
  toid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Route.toId)
}
inline void SolutionResponse_Route::set_toid(const char* value, size_t size) {
  set_has_toid();
  toid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Route.toId)
}
inline ::std::string* SolutionResponse_Route::mutable_toid() {
  set_has_toid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Route.toId)
  return toid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Route::release_toid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Route.toId)
  if (!has_toid()) {
    return NULL;
  }
  clear_has_toid();
  return toid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Route::set_allocated_toid(::std::string* toid) {
  if (toid != NULL) {
    set_has_toid();
  } else {
    clear_has_toid();
  }
  toid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), toid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Route.toId)
}

// repeated int32 geometrySequence = 3;
inline int SolutionResponse_Route::geometrysequence_size() const {
  return geometrysequence_.size();
}
inline void SolutionResponse_Route::clear_geometrysequence() {
  geometrysequence_.Clear();
}
inline ::google::protobuf::int32 SolutionResponse_Route::geometrysequence(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Route.geometrySequence)
  return geometrysequence_.Get(index);
}
inline void SolutionResponse_Route::set_geometrysequence(int index, ::google::protobuf::int32 value) {
  geometrysequence_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Route.geometrySequence)
}
inline void SolutionResponse_Route::add_geometrysequence(::google::protobuf::int32 value) {
  geometrysequence_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.Route.geometrySequence)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SolutionResponse_Route::geometrysequence() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.Route.geometrySequence)
  return geometrysequence_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SolutionResponse_Route::mutable_geometrysequence() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.Route.geometrySequence)
  return &geometrysequence_;
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductTransformAssignment_Item

// required string productId = 1;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& SolutionResponse_NodeProductTransformAssignment_Item::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
  return productid_.GetNoArena();
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}
#endif
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}
inline ::std::string* SolutionResponse_NodeProductTransformAssignment_Item::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductTransformAssignment_Item::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductTransformAssignment.Item.productId)
}

// required float amount = 2;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::amount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.amount)
  return amount_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_amount(float value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.amount)
}

// required float cost = 3;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_has_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_has_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::cost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.cost)
  return cost_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.cost)
}

// required float fixedCost = 4;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.fixedCost)
  return fixedcost_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.fixedCost)
}

// required float penaltyAmount = 5;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_penaltyamount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_has_penaltyamount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_has_penaltyamount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_penaltyamount() {
  penaltyamount_ = 0;
  clear_has_penaltyamount();
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::penaltyamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyAmount)
  return penaltyamount_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_penaltyamount(float value) {
  set_has_penaltyamount();
  penaltyamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyAmount)
}

// required float penaltyCost = 6;
inline bool SolutionResponse_NodeProductTransformAssignment_Item::has_penaltycost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_has_penaltycost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_has_penaltycost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::clear_penaltycost() {
  penaltycost_ = 0;
  clear_has_penaltycost();
}
inline float SolutionResponse_NodeProductTransformAssignment_Item::penaltycost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyCost)
  return penaltycost_;
}
inline void SolutionResponse_NodeProductTransformAssignment_Item::set_penaltycost(float value) {
  set_has_penaltycost();
  penaltycost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.Item.penaltyCost)
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductTransformAssignment

// required string nodeId = 1;
inline bool SolutionResponse_NodeProductTransformAssignment::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& SolutionResponse_NodeProductTransformAssignment::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
  return nodeid_.GetNoArena();
}
inline void SolutionResponse_NodeProductTransformAssignment::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductTransformAssignment::set_nodeid(::std::string&& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}
#endif
inline void SolutionResponse_NodeProductTransformAssignment::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}
inline void SolutionResponse_NodeProductTransformAssignment::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}
inline ::std::string* SolutionResponse_NodeProductTransformAssignment::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductTransformAssignment::release_nodeid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
  if (!has_nodeid()) {
    return NULL;
  }
  clear_has_nodeid();
  return nodeid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductTransformAssignment::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductTransformAssignment.nodeId)
}

// required string productTransformId = 2;
inline bool SolutionResponse_NodeProductTransformAssignment::has_producttransformid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_NodeProductTransformAssignment::set_has_producttransformid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_has_producttransformid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_producttransformid() {
  producttransformid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producttransformid();
}
inline const ::std::string& SolutionResponse_NodeProductTransformAssignment::producttransformid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
  return producttransformid_.GetNoArena();
}
inline void SolutionResponse_NodeProductTransformAssignment::set_producttransformid(const ::std::string& value) {
  set_has_producttransformid();
  producttransformid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductTransformAssignment::set_producttransformid(::std::string&& value) {
  set_has_producttransformid();
  producttransformid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}
#endif
inline void SolutionResponse_NodeProductTransformAssignment::set_producttransformid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_producttransformid();
  producttransformid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}
inline void SolutionResponse_NodeProductTransformAssignment::set_producttransformid(const char* value, size_t size) {
  set_has_producttransformid();
  producttransformid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}
inline ::std::string* SolutionResponse_NodeProductTransformAssignment::mutable_producttransformid() {
  set_has_producttransformid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
  return producttransformid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductTransformAssignment::release_producttransformid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
  if (!has_producttransformid()) {
    return NULL;
  }
  clear_has_producttransformid();
  return producttransformid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductTransformAssignment::set_allocated_producttransformid(::std::string* producttransformid) {
  if (producttransformid != NULL) {
    set_has_producttransformid();
  } else {
    clear_has_producttransformid();
  }
  producttransformid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producttransformid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductTransformAssignment.productTransformId)
}

// repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item inputItems = 3;
inline int SolutionResponse_NodeProductTransformAssignment::inputitems_size() const {
  return inputitems_.size();
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_inputitems() {
  inputitems_.Clear();
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::mutable_inputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return inputitems_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
SolutionResponse_NodeProductTransformAssignment::mutable_inputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return &inputitems_;
}
inline const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& SolutionResponse_NodeProductTransformAssignment::inputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return inputitems_.Get(index);
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::add_inputitems() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return inputitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
SolutionResponse_NodeProductTransformAssignment::inputitems() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.NodeProductTransformAssignment.inputItems)
  return inputitems_;
}

// repeated .NS3.SolutionResponse.NodeProductTransformAssignment.Item outputItems = 4;
inline int SolutionResponse_NodeProductTransformAssignment::outputitems_size() const {
  return outputitems_.size();
}
inline void SolutionResponse_NodeProductTransformAssignment::clear_outputitems() {
  outputitems_.Clear();
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::mutable_outputitems(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return outputitems_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >*
SolutionResponse_NodeProductTransformAssignment::mutable_outputitems() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return &outputitems_;
}
inline const ::NS3::SolutionResponse_NodeProductTransformAssignment_Item& SolutionResponse_NodeProductTransformAssignment::outputitems(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return outputitems_.Get(index);
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment_Item* SolutionResponse_NodeProductTransformAssignment::add_outputitems() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return outputitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment_Item >&
SolutionResponse_NodeProductTransformAssignment::outputitems() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.NodeProductTransformAssignment.outputItems)
  return outputitems_;
}

// -------------------------------------------------------------------

// SolutionResponse

// required float objective = 1;
inline bool SolutionResponse::has_objective() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse::set_has_objective() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse::clear_has_objective() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse::clear_objective() {
  objective_ = 0;
  clear_has_objective();
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.objective)
  return objective_;
}
inline void SolutionResponse::set_objective(float value) {
  set_has_objective();
  objective_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.objective)
}

// optional float lowerBound = 2;
inline bool SolutionResponse::has_lowerbound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse::set_has_lowerbound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse::clear_has_lowerbound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse::clear_lowerbound() {
  lowerbound_ = 0;
  clear_has_lowerbound();
}
inline float SolutionResponse::lowerbound() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.lowerBound)
  return lowerbound_;
}
inline void SolutionResponse::set_lowerbound(float value) {
  set_has_lowerbound();
  lowerbound_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.lowerBound)
}

// optional float optimalityGap = 3;
inline bool SolutionResponse::has_optimalitygap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse::set_has_optimalitygap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse::clear_has_optimalitygap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse::clear_optimalitygap() {
  optimalitygap_ = 0;
  clear_has_optimalitygap();
}
inline float SolutionResponse::optimalitygap() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.optimalityGap)
  return optimalitygap_;
}
inline void SolutionResponse::set_optimalitygap(float value) {
  set_has_optimalitygap();
  optimalitygap_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.optimalityGap)
}

// repeated .NS3.SolutionResponse.Assignment assignments = 4;
inline int SolutionResponse::assignments_size() const {
  return assignments_.size();
}
inline void SolutionResponse::clear_assignments() {
  assignments_.Clear();
}
inline ::NS3::SolutionResponse_Assignment* SolutionResponse::mutable_assignments(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.assignments)
  return assignments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >*
SolutionResponse::mutable_assignments() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.assignments)
  return &assignments_;
}
inline const ::NS3::SolutionResponse_Assignment& SolutionResponse::assignments(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.assignments)
  return assignments_.Get(index);
}
inline ::NS3::SolutionResponse_Assignment* SolutionResponse::add_assignments() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.assignments)
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >&
SolutionResponse::assignments() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.assignments)
  return assignments_;
}

// repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
inline int SolutionResponse::nodeflows_size() const {
  return nodeflows_.size();
}
inline void SolutionResponse::clear_nodeflows() {
  nodeflows_.Clear();
}
inline ::NS3::SolutionResponse_NodeFlow* SolutionResponse::mutable_nodeflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeFlows)
  return nodeflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >*
SolutionResponse::mutable_nodeflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeFlows)
  return &nodeflows_;
}
inline const ::NS3::SolutionResponse_NodeFlow& SolutionResponse::nodeflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeFlows)
  return nodeflows_.Get(index);
}
inline ::NS3::SolutionResponse_NodeFlow* SolutionResponse::add_nodeflows() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeFlows)
  return nodeflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >&
SolutionResponse::nodeflows() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeFlows)
  return nodeflows_;
}

// repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
inline int SolutionResponse::nodeproductflows_size() const {
  return nodeproductflows_.size();
}
inline void SolutionResponse::clear_nodeproductflows() {
  nodeproductflows_.Clear();
}
inline ::NS3::SolutionResponse_NodeProductFlow* SolutionResponse::mutable_nodeproductflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >*
SolutionResponse::mutable_nodeproductflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeProductFlows)
  return &nodeproductflows_;
}
inline const ::NS3::SolutionResponse_NodeProductFlow& SolutionResponse::nodeproductflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_.Get(index);
}
inline ::NS3::SolutionResponse_NodeProductFlow* SolutionResponse::add_nodeproductflows() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >&
SolutionResponse::nodeproductflows() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_;
}

// repeated .NS3.SolutionResponse.GeometrySequence geometrySequence = 7;
inline int SolutionResponse::geometrysequence_size() const {
  return geometrysequence_.size();
}
inline void SolutionResponse::clear_geometrysequence() {
  geometrysequence_.Clear();
}
inline ::NS3::SolutionResponse_GeometrySequence* SolutionResponse::mutable_geometrysequence(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.geometrySequence)
  return geometrysequence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >*
SolutionResponse::mutable_geometrysequence() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.geometrySequence)
  return &geometrysequence_;
}
inline const ::NS3::SolutionResponse_GeometrySequence& SolutionResponse::geometrysequence(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.geometrySequence)
  return geometrysequence_.Get(index);
}
inline ::NS3::SolutionResponse_GeometrySequence* SolutionResponse::add_geometrysequence() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.geometrySequence)
  return geometrysequence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometrySequence >&
SolutionResponse::geometrysequence() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.geometrySequence)
  return geometrysequence_;
}

// repeated .NS3.SolutionResponse.Route routes = 8;
inline int SolutionResponse::routes_size() const {
  return routes_.size();
}
inline void SolutionResponse::clear_routes() {
  routes_.Clear();
}
inline ::NS3::SolutionResponse_Route* SolutionResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >*
SolutionResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.routes)
  return &routes_;
}
inline const ::NS3::SolutionResponse_Route& SolutionResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.routes)
  return routes_.Get(index);
}
inline ::NS3::SolutionResponse_Route* SolutionResponse::add_routes() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Route >&
SolutionResponse::routes() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.routes)
  return routes_;
}

// repeated .NS3.SolutionResponse.NodeProductTransformAssignment nodeProductTransformAssignments = 9;
inline int SolutionResponse::nodeproducttransformassignments_size() const {
  return nodeproducttransformassignments_.size();
}
inline void SolutionResponse::clear_nodeproducttransformassignments() {
  nodeproducttransformassignments_.Clear();
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment* SolutionResponse::mutable_nodeproducttransformassignments(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeProductTransformAssignments)
  return nodeproducttransformassignments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >*
SolutionResponse::mutable_nodeproducttransformassignments() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeProductTransformAssignments)
  return &nodeproducttransformassignments_;
}
inline const ::NS3::SolutionResponse_NodeProductTransformAssignment& SolutionResponse::nodeproducttransformassignments(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeProductTransformAssignments)
  return nodeproducttransformassignments_.Get(index);
}
inline ::NS3::SolutionResponse_NodeProductTransformAssignment* SolutionResponse::add_nodeproducttransformassignments() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeProductTransformAssignments)
  return nodeproducttransformassignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductTransformAssignment >&
SolutionResponse::nodeproducttransformassignments() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeProductTransformAssignments)
  return nodeproducttransformassignments_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NS3

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NS3::InternalDimension_eMeasurementUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NS3::InternalDimension_eMeasurementUnit>() {
  return ::NS3::InternalDimension_eMeasurementUnit_descriptor();
}
template <> struct is_proto_enum< ::NS3::SolveRequest_SolveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NS3::SolveRequest_SolveType>() {
  return ::NS3::SolveRequest_SolveType_descriptor();
}
template <> struct is_proto_enum< ::NS3::SolveRequest_GeometryOutput> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NS3::SolveRequest_GeometryOutput>() {
  return ::NS3::SolveRequest_GeometryOutput_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto
