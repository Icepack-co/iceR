// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ns3-tbfvuwtge2iq.proto

#ifndef PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto
#define PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ns3_2dtbfvuwtge2iq_2eproto 

namespace protobuf_ns3_2dtbfvuwtge2iq_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ns3_2dtbfvuwtge2iq_2eproto
namespace NS3 {
class CostModel;
class CostModelDefaultTypeInternal;
extern CostModelDefaultTypeInternal _CostModel_default_instance_;
class Dimension;
class DimensionDefaultTypeInternal;
extern DimensionDefaultTypeInternal _Dimension_default_instance_;
class DimensionRange;
class DimensionRangeDefaultTypeInternal;
extern DimensionRangeDefaultTypeInternal _DimensionRange_default_instance_;
class FixedDimensionCost;
class FixedDimensionCostDefaultTypeInternal;
extern FixedDimensionCostDefaultTypeInternal _FixedDimensionCost_default_instance_;
class FlowDimensionalConstraint;
class FlowDimensionalConstraintDefaultTypeInternal;
extern FlowDimensionalConstraintDefaultTypeInternal _FlowDimensionalConstraint_default_instance_;
class Geocode;
class GeocodeDefaultTypeInternal;
extern GeocodeDefaultTypeInternal _Geocode_default_instance_;
class LaneRate;
class LaneRateDefaultTypeInternal;
extern LaneRateDefaultTypeInternal _LaneRate_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Node_Flow;
class Node_FlowDefaultTypeInternal;
extern Node_FlowDefaultTypeInternal _Node_Flow_default_instance_;
class Node_ProductFlow;
class Node_ProductFlowDefaultTypeInternal;
extern Node_ProductFlowDefaultTypeInternal _Node_ProductFlow_default_instance_;
class ProductGroup;
class ProductGroupDefaultTypeInternal;
extern ProductGroupDefaultTypeInternal _ProductGroup_default_instance_;
class ProductGroup_ProductSpecification;
class ProductGroup_ProductSpecificationDefaultTypeInternal;
extern ProductGroup_ProductSpecificationDefaultTypeInternal _ProductGroup_ProductSpecification_default_instance_;
class SolutionResponse;
class SolutionResponseDefaultTypeInternal;
extern SolutionResponseDefaultTypeInternal _SolutionResponse_default_instance_;
class SolutionResponse_Assignment;
class SolutionResponse_AssignmentDefaultTypeInternal;
extern SolutionResponse_AssignmentDefaultTypeInternal _SolutionResponse_Assignment_default_instance_;
class SolutionResponse_GeometryEdgeSummary;
class SolutionResponse_GeometryEdgeSummaryDefaultTypeInternal;
extern SolutionResponse_GeometryEdgeSummaryDefaultTypeInternal _SolutionResponse_GeometryEdgeSummary_default_instance_;
class SolutionResponse_NodeFlow;
class SolutionResponse_NodeFlowDefaultTypeInternal;
extern SolutionResponse_NodeFlowDefaultTypeInternal _SolutionResponse_NodeFlow_default_instance_;
class SolutionResponse_NodeProductFlow;
class SolutionResponse_NodeProductFlowDefaultTypeInternal;
extern SolutionResponse_NodeProductFlowDefaultTypeInternal _SolutionResponse_NodeProductFlow_default_instance_;
class SolveRequest;
class SolveRequestDefaultTypeInternal;
extern SolveRequestDefaultTypeInternal _SolveRequest_default_instance_;
class UnitDimensionCost;
class UnitDimensionCostDefaultTypeInternal;
extern UnitDimensionCostDefaultTypeInternal _UnitDimensionCost_default_instance_;
}  // namespace NS3
namespace google {
namespace protobuf {
template<> ::NS3::CostModel* Arena::CreateMaybeMessage<::NS3::CostModel>(Arena*);
template<> ::NS3::Dimension* Arena::CreateMaybeMessage<::NS3::Dimension>(Arena*);
template<> ::NS3::DimensionRange* Arena::CreateMaybeMessage<::NS3::DimensionRange>(Arena*);
template<> ::NS3::FixedDimensionCost* Arena::CreateMaybeMessage<::NS3::FixedDimensionCost>(Arena*);
template<> ::NS3::FlowDimensionalConstraint* Arena::CreateMaybeMessage<::NS3::FlowDimensionalConstraint>(Arena*);
template<> ::NS3::Geocode* Arena::CreateMaybeMessage<::NS3::Geocode>(Arena*);
template<> ::NS3::LaneRate* Arena::CreateMaybeMessage<::NS3::LaneRate>(Arena*);
template<> ::NS3::Model* Arena::CreateMaybeMessage<::NS3::Model>(Arena*);
template<> ::NS3::Node* Arena::CreateMaybeMessage<::NS3::Node>(Arena*);
template<> ::NS3::Node_Flow* Arena::CreateMaybeMessage<::NS3::Node_Flow>(Arena*);
template<> ::NS3::Node_ProductFlow* Arena::CreateMaybeMessage<::NS3::Node_ProductFlow>(Arena*);
template<> ::NS3::ProductGroup* Arena::CreateMaybeMessage<::NS3::ProductGroup>(Arena*);
template<> ::NS3::ProductGroup_ProductSpecification* Arena::CreateMaybeMessage<::NS3::ProductGroup_ProductSpecification>(Arena*);
template<> ::NS3::SolutionResponse* Arena::CreateMaybeMessage<::NS3::SolutionResponse>(Arena*);
template<> ::NS3::SolutionResponse_Assignment* Arena::CreateMaybeMessage<::NS3::SolutionResponse_Assignment>(Arena*);
template<> ::NS3::SolutionResponse_GeometryEdgeSummary* Arena::CreateMaybeMessage<::NS3::SolutionResponse_GeometryEdgeSummary>(Arena*);
template<> ::NS3::SolutionResponse_NodeFlow* Arena::CreateMaybeMessage<::NS3::SolutionResponse_NodeFlow>(Arena*);
template<> ::NS3::SolutionResponse_NodeProductFlow* Arena::CreateMaybeMessage<::NS3::SolutionResponse_NodeProductFlow>(Arena*);
template<> ::NS3::SolveRequest* Arena::CreateMaybeMessage<::NS3::SolveRequest>(Arena*);
template<> ::NS3::UnitDimensionCost* Arena::CreateMaybeMessage<::NS3::UnitDimensionCost>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NS3 {

enum SolveRequest_SolveType {
  SolveRequest_SolveType_Optimise = 0
};
bool SolveRequest_SolveType_IsValid(int value);
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MIN = SolveRequest_SolveType_Optimise;
const SolveRequest_SolveType SolveRequest_SolveType_SolveType_MAX = SolveRequest_SolveType_Optimise;
const int SolveRequest_SolveType_SolveType_ARRAYSIZE = SolveRequest_SolveType_SolveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolveRequest_SolveType_descriptor();
inline const ::std::string& SolveRequest_SolveType_Name(SolveRequest_SolveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolveRequest_SolveType_descriptor(), value);
}
inline bool SolveRequest_SolveType_Parse(
    const ::std::string& name, SolveRequest_SolveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolveRequest_SolveType>(
    SolveRequest_SolveType_descriptor(), name, value);
}
// ===================================================================

class Dimension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Dimension) */ {
 public:
  Dimension();
  virtual ~Dimension();

  Dimension(const Dimension& from);

  inline Dimension& operator=(const Dimension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dimension(Dimension&& from) noexcept
    : Dimension() {
    *this = ::std::move(from);
  }

  inline Dimension& operator=(Dimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Dimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dimension* internal_default_instance() {
    return reinterpret_cast<const Dimension*>(
               &_Dimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Dimension* other);
  friend void swap(Dimension& a, Dimension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dimension* New() const final {
    return CreateMaybeMessage<Dimension>(NULL);
  }

  Dimension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dimension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dimension& from);
  void MergeFrom(const Dimension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:NS3.Dimension)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geocode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Geocode) */ {
 public:
  Geocode();
  virtual ~Geocode();

  Geocode(const Geocode& from);

  inline Geocode& operator=(const Geocode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geocode(Geocode&& from) noexcept
    : Geocode() {
    *this = ::std::move(from);
  }

  inline Geocode& operator=(Geocode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geocode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geocode* internal_default_instance() {
    return reinterpret_cast<const Geocode*>(
               &_Geocode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Geocode* other);
  friend void swap(Geocode& a, Geocode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geocode* New() const final {
    return CreateMaybeMessage<Geocode>(NULL);
  }

  Geocode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geocode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geocode& from);
  void MergeFrom(const Geocode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geocode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  float longitude() const;
  void set_longitude(float value);

  // required float latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  float latitude() const;
  void set_latitude(float value);

  // @@protoc_insertion_point(class_scope:NS3.Geocode)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float longitude_;
  float latitude_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitDimensionCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.UnitDimensionCost) */ {
 public:
  UnitDimensionCost();
  virtual ~UnitDimensionCost();

  UnitDimensionCost(const UnitDimensionCost& from);

  inline UnitDimensionCost& operator=(const UnitDimensionCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitDimensionCost(UnitDimensionCost&& from) noexcept
    : UnitDimensionCost() {
    *this = ::std::move(from);
  }

  inline UnitDimensionCost& operator=(UnitDimensionCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitDimensionCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitDimensionCost* internal_default_instance() {
    return reinterpret_cast<const UnitDimensionCost*>(
               &_UnitDimensionCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UnitDimensionCost* other);
  friend void swap(UnitDimensionCost& a, UnitDimensionCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitDimensionCost* New() const final {
    return CreateMaybeMessage<UnitDimensionCost>(NULL);
  }

  UnitDimensionCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitDimensionCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitDimensionCost& from);
  void MergeFrom(const UnitDimensionCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitDimensionCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  void clear_dimensionids();
  static const int kDimensionIdsFieldNumber = 1;
  const ::std::string& dimensionids(int index) const;
  ::std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionids(int index, ::std::string&& value);
  #endif
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, size_t size);
  ::std::string* add_dimensionids();
  void add_dimensionids(const ::std::string& value);
  #if LANG_CXX11
  void add_dimensionids(::std::string&& value);
  #endif
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dimensionids();

  // repeated float dimensionCoefficients = 2;
  int dimensioncoefficients_size() const;
  void clear_dimensioncoefficients();
  static const int kDimensionCoefficientsFieldNumber = 2;
  float dimensioncoefficients(int index) const;
  void set_dimensioncoefficients(int index, float value);
  void add_dimensioncoefficients(float value);
  const ::google::protobuf::RepeatedField< float >&
      dimensioncoefficients() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dimensioncoefficients();

  // required float costPerUnit = 3;
  bool has_costperunit() const;
  void clear_costperunit();
  static const int kCostPerUnitFieldNumber = 3;
  float costperunit() const;
  void set_costperunit(float value);

  // @@protoc_insertion_point(class_scope:NS3.UnitDimensionCost)
 private:
  void set_has_costperunit();
  void clear_has_costperunit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dimensionids_;
  ::google::protobuf::RepeatedField< float > dimensioncoefficients_;
  float costperunit_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FixedDimensionCost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.FixedDimensionCost) */ {
 public:
  FixedDimensionCost();
  virtual ~FixedDimensionCost();

  FixedDimensionCost(const FixedDimensionCost& from);

  inline FixedDimensionCost& operator=(const FixedDimensionCost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixedDimensionCost(FixedDimensionCost&& from) noexcept
    : FixedDimensionCost() {
    *this = ::std::move(from);
  }

  inline FixedDimensionCost& operator=(FixedDimensionCost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixedDimensionCost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixedDimensionCost* internal_default_instance() {
    return reinterpret_cast<const FixedDimensionCost*>(
               &_FixedDimensionCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FixedDimensionCost* other);
  friend void swap(FixedDimensionCost& a, FixedDimensionCost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixedDimensionCost* New() const final {
    return CreateMaybeMessage<FixedDimensionCost>(NULL);
  }

  FixedDimensionCost* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FixedDimensionCost>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FixedDimensionCost& from);
  void MergeFrom(const FixedDimensionCost& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixedDimensionCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  void clear_dimensionids();
  static const int kDimensionIdsFieldNumber = 1;
  const ::std::string& dimensionids(int index) const;
  ::std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionids(int index, ::std::string&& value);
  #endif
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, size_t size);
  ::std::string* add_dimensionids();
  void add_dimensionids(const ::std::string& value);
  #if LANG_CXX11
  void add_dimensionids(::std::string&& value);
  #endif
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dimensionids();

  // required float fixedCost = 2;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 2;
  float fixedcost() const;
  void set_fixedcost(float value);

  // @@protoc_insertion_point(class_scope:NS3.FixedDimensionCost)
 private:
  void set_has_fixedcost();
  void clear_has_fixedcost();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dimensionids_;
  float fixedcost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowDimensionalConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.FlowDimensionalConstraint) */ {
 public:
  FlowDimensionalConstraint();
  virtual ~FlowDimensionalConstraint();

  FlowDimensionalConstraint(const FlowDimensionalConstraint& from);

  inline FlowDimensionalConstraint& operator=(const FlowDimensionalConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowDimensionalConstraint(FlowDimensionalConstraint&& from) noexcept
    : FlowDimensionalConstraint() {
    *this = ::std::move(from);
  }

  inline FlowDimensionalConstraint& operator=(FlowDimensionalConstraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowDimensionalConstraint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowDimensionalConstraint* internal_default_instance() {
    return reinterpret_cast<const FlowDimensionalConstraint*>(
               &_FlowDimensionalConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FlowDimensionalConstraint* other);
  friend void swap(FlowDimensionalConstraint& a, FlowDimensionalConstraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowDimensionalConstraint* New() const final {
    return CreateMaybeMessage<FlowDimensionalConstraint>(NULL);
  }

  FlowDimensionalConstraint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowDimensionalConstraint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowDimensionalConstraint& from);
  void MergeFrom(const FlowDimensionalConstraint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowDimensionalConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dimensionIds = 1;
  int dimensionids_size() const;
  void clear_dimensionids();
  static const int kDimensionIdsFieldNumber = 1;
  const ::std::string& dimensionids(int index) const;
  ::std::string* mutable_dimensionids(int index);
  void set_dimensionids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionids(int index, ::std::string&& value);
  #endif
  void set_dimensionids(int index, const char* value);
  void set_dimensionids(int index, const char* value, size_t size);
  ::std::string* add_dimensionids();
  void add_dimensionids(const ::std::string& value);
  #if LANG_CXX11
  void add_dimensionids(::std::string&& value);
  #endif
  void add_dimensionids(const char* value);
  void add_dimensionids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dimensionids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dimensionids();

  // repeated float dimensionCoefficients = 2;
  int dimensioncoefficients_size() const;
  void clear_dimensioncoefficients();
  static const int kDimensionCoefficientsFieldNumber = 2;
  float dimensioncoefficients(int index) const;
  void set_dimensioncoefficients(int index, float value);
  void add_dimensioncoefficients(float value);
  const ::google::protobuf::RepeatedField< float >&
      dimensioncoefficients() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dimensioncoefficients();

  // required float flowMin = 3;
  bool has_flowmin() const;
  void clear_flowmin();
  static const int kFlowMinFieldNumber = 3;
  float flowmin() const;
  void set_flowmin(float value);

  // required float flowMax = 4;
  bool has_flowmax() const;
  void clear_flowmax();
  static const int kFlowMaxFieldNumber = 4;
  float flowmax() const;
  void set_flowmax(float value);

  // @@protoc_insertion_point(class_scope:NS3.FlowDimensionalConstraint)
 private:
  void set_has_flowmin();
  void clear_has_flowmin();
  void set_has_flowmax();
  void clear_has_flowmax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dimensionids_;
  ::google::protobuf::RepeatedField< float > dimensioncoefficients_;
  float flowmin_;
  float flowmax_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DimensionRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.DimensionRange) */ {
 public:
  DimensionRange();
  virtual ~DimensionRange();

  DimensionRange(const DimensionRange& from);

  inline DimensionRange& operator=(const DimensionRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DimensionRange(DimensionRange&& from) noexcept
    : DimensionRange() {
    *this = ::std::move(from);
  }

  inline DimensionRange& operator=(DimensionRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DimensionRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DimensionRange* internal_default_instance() {
    return reinterpret_cast<const DimensionRange*>(
               &_DimensionRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DimensionRange* other);
  friend void swap(DimensionRange& a, DimensionRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DimensionRange* New() const final {
    return CreateMaybeMessage<DimensionRange>(NULL);
  }

  DimensionRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DimensionRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DimensionRange& from);
  void MergeFrom(const DimensionRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DimensionRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dimensionId = 1;
  bool has_dimensionid() const;
  void clear_dimensionid();
  static const int kDimensionIdFieldNumber = 1;
  const ::std::string& dimensionid() const;
  void set_dimensionid(const ::std::string& value);
  #if LANG_CXX11
  void set_dimensionid(::std::string&& value);
  #endif
  void set_dimensionid(const char* value);
  void set_dimensionid(const char* value, size_t size);
  ::std::string* mutable_dimensionid();
  ::std::string* release_dimensionid();
  void set_allocated_dimensionid(::std::string* dimensionid);

  // required float minRange = 2 [default = 0];
  bool has_minrange() const;
  void clear_minrange();
  static const int kMinRangeFieldNumber = 2;
  float minrange() const;
  void set_minrange(float value);

  // required float maxRange = 3;
  bool has_maxrange() const;
  void clear_maxrange();
  static const int kMaxRangeFieldNumber = 3;
  float maxrange() const;
  void set_maxrange(float value);

  // required float flowPenalty = 4 [default = 0];
  bool has_flowpenalty() const;
  void clear_flowpenalty();
  static const int kFlowPenaltyFieldNumber = 4;
  float flowpenalty() const;
  void set_flowpenalty(float value);

  // @@protoc_insertion_point(class_scope:NS3.DimensionRange)
 private:
  void set_has_dimensionid();
  void clear_has_dimensionid();
  void set_has_minrange();
  void clear_has_minrange();
  void set_has_maxrange();
  void clear_has_maxrange();
  void set_has_flowpenalty();
  void clear_has_flowpenalty();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dimensionid_;
  float minrange_;
  float maxrange_;
  float flowpenalty_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node_ProductFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.ProductFlow) */ {
 public:
  Node_ProductFlow();
  virtual ~Node_ProductFlow();

  Node_ProductFlow(const Node_ProductFlow& from);

  inline Node_ProductFlow& operator=(const Node_ProductFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node_ProductFlow(Node_ProductFlow&& from) noexcept
    : Node_ProductFlow() {
    *this = ::std::move(from);
  }

  inline Node_ProductFlow& operator=(Node_ProductFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_ProductFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node_ProductFlow* internal_default_instance() {
    return reinterpret_cast<const Node_ProductFlow*>(
               &_Node_ProductFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Node_ProductFlow* other);
  friend void swap(Node_ProductFlow& a, Node_ProductFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node_ProductFlow* New() const final {
    return CreateMaybeMessage<Node_ProductFlow>(NULL);
  }

  Node_ProductFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node_ProductFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node_ProductFlow& from);
  void MergeFrom(const Node_ProductFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_ProductFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.DimensionRange dimensionRanges = 2;
  int dimensionranges_size() const;
  void clear_dimensionranges();
  static const int kDimensionRangesFieldNumber = 2;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;

  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
  int fixeddimensioncosts_size() const;
  void clear_fixeddimensioncosts();
  static const int kFixedDimensionCostsFieldNumber = 3;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 4;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:NS3.Node.ProductFlow)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node_Flow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node.Flow) */ {
 public:
  Node_Flow();
  virtual ~Node_Flow();

  Node_Flow(const Node_Flow& from);

  inline Node_Flow& operator=(const Node_Flow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node_Flow(Node_Flow&& from) noexcept
    : Node_Flow() {
    *this = ::std::move(from);
  }

  inline Node_Flow& operator=(Node_Flow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_Flow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node_Flow* internal_default_instance() {
    return reinterpret_cast<const Node_Flow*>(
               &_Node_Flow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Node_Flow* other);
  friend void swap(Node_Flow& a, Node_Flow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node_Flow* New() const final {
    return CreateMaybeMessage<Node_Flow>(NULL);
  }

  Node_Flow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node_Flow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node_Flow& from);
  void MergeFrom(const Node_Flow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node_Flow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.DimensionRange dimensionRanges = 1;
  int dimensionranges_size() const;
  void clear_dimensionranges();
  static const int kDimensionRangesFieldNumber = 1;
  ::NS3::DimensionRange* mutable_dimensionranges(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
      mutable_dimensionranges();
  const ::NS3::DimensionRange& dimensionranges(int index) const;
  ::NS3::DimensionRange* add_dimensionranges();
  const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
      dimensionranges() const;

  // repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
  int fixeddimensioncosts_size() const;
  void clear_fixeddimensioncosts();
  static const int kFixedDimensionCostsFieldNumber = 2;
  ::NS3::FixedDimensionCost* mutable_fixeddimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
      mutable_fixeddimensioncosts();
  const ::NS3::FixedDimensionCost& fixeddimensioncosts(int index) const;
  ::NS3::FixedDimensionCost* add_fixeddimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
      fixeddimensioncosts() const;

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 3;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // @@protoc_insertion_point(class_scope:NS3.Node.Flow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange > dimensionranges_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost > fixeddimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(NULL);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Node_ProductFlow ProductFlow;
  typedef Node_Flow Flow;

  // accessors -------------------------------------------------------

  // repeated .NS3.Node.ProductFlow production = 3;
  int production_size() const;
  void clear_production();
  static const int kProductionFieldNumber = 3;
  ::NS3::Node_ProductFlow* mutable_production(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_production();
  const ::NS3::Node_ProductFlow& production(int index) const;
  ::NS3::Node_ProductFlow* add_production();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      production() const;

  // repeated .NS3.Node.ProductFlow consumption = 4;
  int consumption_size() const;
  void clear_consumption();
  static const int kConsumptionFieldNumber = 4;
  ::NS3::Node_ProductFlow* mutable_consumption(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_consumption();
  const ::NS3::Node_ProductFlow& consumption(int index) const;
  ::NS3::Node_ProductFlow* add_consumption();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      consumption() const;

  // repeated .NS3.Node.ProductFlow productFlows = 6;
  int productflows_size() const;
  void clear_productflows();
  static const int kProductFlowsFieldNumber = 6;
  ::NS3::Node_ProductFlow* mutable_productflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
      mutable_productflows();
  const ::NS3::Node_ProductFlow& productflows(int index) const;
  ::NS3::Node_ProductFlow* add_productflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
      productflows() const;

  // repeated string allowableSources = 7;
  int allowablesources_size() const;
  void clear_allowablesources();
  static const int kAllowableSourcesFieldNumber = 7;
  const ::std::string& allowablesources(int index) const;
  ::std::string* mutable_allowablesources(int index);
  void set_allowablesources(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_allowablesources(int index, ::std::string&& value);
  #endif
  void set_allowablesources(int index, const char* value);
  void set_allowablesources(int index, const char* value, size_t size);
  ::std::string* add_allowablesources();
  void add_allowablesources(const ::std::string& value);
  #if LANG_CXX11
  void add_allowablesources(::std::string&& value);
  #endif
  void add_allowablesources(const char* value);
  void add_allowablesources(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& allowablesources() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allowablesources();

  // repeated string allowableServiceClasses = 9;
  int allowableserviceclasses_size() const;
  void clear_allowableserviceclasses();
  static const int kAllowableServiceClassesFieldNumber = 9;
  const ::std::string& allowableserviceclasses(int index) const;
  ::std::string* mutable_allowableserviceclasses(int index);
  void set_allowableserviceclasses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_allowableserviceclasses(int index, ::std::string&& value);
  #endif
  void set_allowableserviceclasses(int index, const char* value);
  void set_allowableserviceclasses(int index, const char* value, size_t size);
  ::std::string* add_allowableserviceclasses();
  void add_allowableserviceclasses(const ::std::string& value);
  #if LANG_CXX11
  void add_allowableserviceclasses(::std::string&& value);
  #endif
  void add_allowableserviceclasses(const char* value);
  void add_allowableserviceclasses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& allowableserviceclasses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allowableserviceclasses();

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 10;
  int flowconstraints_size() const;
  void clear_flowconstraints();
  static const int kFlowConstraintsFieldNumber = 10;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .NS3.Geocode geocode = 2;
  bool has_geocode() const;
  void clear_geocode();
  static const int kGeocodeFieldNumber = 2;
  private:
  const ::NS3::Geocode& _internal_geocode() const;
  public:
  const ::NS3::Geocode& geocode() const;
  ::NS3::Geocode* release_geocode();
  ::NS3::Geocode* mutable_geocode();
  void set_allocated_geocode(::NS3::Geocode* geocode);

  // optional .NS3.Node.Flow flow = 5;
  bool has_flow() const;
  void clear_flow();
  static const int kFlowFieldNumber = 5;
  private:
  const ::NS3::Node_Flow& _internal_flow() const;
  public:
  const ::NS3::Node_Flow& flow() const;
  ::NS3::Node_Flow* release_flow();
  ::NS3::Node_Flow* mutable_flow();
  void set_allocated_flow(::NS3::Node_Flow* flow);

  // optional int32 maximumSources = 8;
  bool has_maximumsources() const;
  void clear_maximumsources();
  static const int kMaximumSourcesFieldNumber = 8;
  ::google::protobuf::int32 maximumsources() const;
  void set_maximumsources(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NS3.Node)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_geocode();
  void clear_has_geocode();
  void set_has_flow();
  void clear_has_flow();
  void set_has_maximumsources();
  void clear_has_maximumsources();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > production_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > consumption_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow > productflows_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allowablesources_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allowableserviceclasses_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::NS3::Geocode* geocode_;
  ::NS3::Node_Flow* flow_;
  ::google::protobuf::int32 maximumsources_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProductGroup_ProductSpecification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.ProductGroup.ProductSpecification) */ {
 public:
  ProductGroup_ProductSpecification();
  virtual ~ProductGroup_ProductSpecification();

  ProductGroup_ProductSpecification(const ProductGroup_ProductSpecification& from);

  inline ProductGroup_ProductSpecification& operator=(const ProductGroup_ProductSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProductGroup_ProductSpecification(ProductGroup_ProductSpecification&& from) noexcept
    : ProductGroup_ProductSpecification() {
    *this = ::std::move(from);
  }

  inline ProductGroup_ProductSpecification& operator=(ProductGroup_ProductSpecification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductGroup_ProductSpecification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProductGroup_ProductSpecification* internal_default_instance() {
    return reinterpret_cast<const ProductGroup_ProductSpecification*>(
               &_ProductGroup_ProductSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ProductGroup_ProductSpecification* other);
  friend void swap(ProductGroup_ProductSpecification& a, ProductGroup_ProductSpecification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProductGroup_ProductSpecification* New() const final {
    return CreateMaybeMessage<ProductGroup_ProductSpecification>(NULL);
  }

  ProductGroup_ProductSpecification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProductGroup_ProductSpecification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProductGroup_ProductSpecification& from);
  void MergeFrom(const ProductGroup_ProductSpecification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductGroup_ProductSpecification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string targetDimension = 2;
  int targetdimension_size() const;
  void clear_targetdimension();
  static const int kTargetDimensionFieldNumber = 2;
  const ::std::string& targetdimension(int index) const;
  ::std::string* mutable_targetdimension(int index);
  void set_targetdimension(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_targetdimension(int index, ::std::string&& value);
  #endif
  void set_targetdimension(int index, const char* value);
  void set_targetdimension(int index, const char* value, size_t size);
  ::std::string* add_targetdimension();
  void add_targetdimension(const ::std::string& value);
  #if LANG_CXX11
  void add_targetdimension(::std::string&& value);
  #endif
  void add_targetdimension(const char* value);
  void add_targetdimension(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& targetdimension() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_targetdimension();

  // repeated float targetPerBase = 3;
  int targetperbase_size() const;
  void clear_targetperbase();
  static const int kTargetPerBaseFieldNumber = 3;
  float targetperbase(int index) const;
  void set_targetperbase(int index, float value);
  void add_targetperbase(float value);
  const ::google::protobuf::RepeatedField< float >&
      targetperbase() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_targetperbase();

  // required string baseDimension = 1;
  bool has_basedimension() const;
  void clear_basedimension();
  static const int kBaseDimensionFieldNumber = 1;
  const ::std::string& basedimension() const;
  void set_basedimension(const ::std::string& value);
  #if LANG_CXX11
  void set_basedimension(::std::string&& value);
  #endif
  void set_basedimension(const char* value);
  void set_basedimension(const char* value, size_t size);
  ::std::string* mutable_basedimension();
  ::std::string* release_basedimension();
  void set_allocated_basedimension(::std::string* basedimension);

  // @@protoc_insertion_point(class_scope:NS3.ProductGroup.ProductSpecification)
 private:
  void set_has_basedimension();
  void clear_has_basedimension();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> targetdimension_;
  ::google::protobuf::RepeatedField< float > targetperbase_;
  ::google::protobuf::internal::ArenaStringPtr basedimension_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProductGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.ProductGroup) */ {
 public:
  ProductGroup();
  virtual ~ProductGroup();

  ProductGroup(const ProductGroup& from);

  inline ProductGroup& operator=(const ProductGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProductGroup(ProductGroup&& from) noexcept
    : ProductGroup() {
    *this = ::std::move(from);
  }

  inline ProductGroup& operator=(ProductGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProductGroup* internal_default_instance() {
    return reinterpret_cast<const ProductGroup*>(
               &_ProductGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ProductGroup* other);
  friend void swap(ProductGroup& a, ProductGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProductGroup* New() const final {
    return CreateMaybeMessage<ProductGroup>(NULL);
  }

  ProductGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProductGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProductGroup& from);
  void MergeFrom(const ProductGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProductGroup_ProductSpecification ProductSpecification;

  // accessors -------------------------------------------------------

  // repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
  int productspecification_size() const;
  void clear_productspecification();
  static const int kProductSpecificationFieldNumber = 3;
  ::NS3::ProductGroup_ProductSpecification* mutable_productspecification(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >*
      mutable_productspecification();
  const ::NS3::ProductGroup_ProductSpecification& productspecification(int index) const;
  ::NS3::ProductGroup_ProductSpecification* add_productspecification();
  const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >&
      productspecification() const;

  // required string product = 1;
  bool has_product() const;
  void clear_product();
  static const int kProductFieldNumber = 1;
  const ::std::string& product() const;
  void set_product(const ::std::string& value);
  #if LANG_CXX11
  void set_product(::std::string&& value);
  #endif
  void set_product(const char* value);
  void set_product(const char* value, size_t size);
  ::std::string* mutable_product();
  ::std::string* release_product();
  void set_allocated_product(::std::string* product);

  // required string productGroup = 2;
  bool has_productgroup() const;
  void clear_productgroup();
  static const int kProductGroupFieldNumber = 2;
  const ::std::string& productgroup() const;
  void set_productgroup(const ::std::string& value);
  #if LANG_CXX11
  void set_productgroup(::std::string&& value);
  #endif
  void set_productgroup(const char* value);
  void set_productgroup(const char* value, size_t size);
  ::std::string* mutable_productgroup();
  ::std::string* release_productgroup();
  void set_allocated_productgroup(::std::string* productgroup);

  // @@protoc_insertion_point(class_scope:NS3.ProductGroup)
 private:
  void set_has_product();
  void clear_has_product();
  void set_has_productgroup();
  void clear_has_productgroup();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification > productspecification_;
  ::google::protobuf::internal::ArenaStringPtr product_;
  ::google::protobuf::internal::ArenaStringPtr productgroup_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.LaneRate) */ {
 public:
  LaneRate();
  virtual ~LaneRate();

  LaneRate(const LaneRate& from);

  inline LaneRate& operator=(const LaneRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneRate(LaneRate&& from) noexcept
    : LaneRate() {
    *this = ::std::move(from);
  }

  inline LaneRate& operator=(LaneRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneRate* internal_default_instance() {
    return reinterpret_cast<const LaneRate*>(
               &_LaneRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(LaneRate* other);
  friend void swap(LaneRate& a, LaneRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneRate* New() const final {
    return CreateMaybeMessage<LaneRate>(NULL);
  }

  LaneRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneRate& from);
  void MergeFrom(const LaneRate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string productIds = 5;
  int productids_size() const;
  void clear_productids();
  static const int kProductIdsFieldNumber = 5;
  const ::std::string& productids(int index) const;
  ::std::string* mutable_productids(int index);
  void set_productids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productids(int index, ::std::string&& value);
  #endif
  void set_productids(int index, const char* value);
  void set_productids(int index, const char* value, size_t size);
  ::std::string* add_productids();
  void add_productids(const ::std::string& value);
  #if LANG_CXX11
  void add_productids(::std::string&& value);
  #endif
  void add_productids(const char* value);
  void add_productids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productids();

  // repeated string productGroupIds = 6;
  int productgroupids_size() const;
  void clear_productgroupids();
  static const int kProductGroupIdsFieldNumber = 6;
  const ::std::string& productgroupids(int index) const;
  ::std::string* mutable_productgroupids(int index);
  void set_productgroupids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productgroupids(int index, ::std::string&& value);
  #endif
  void set_productgroupids(int index, const char* value);
  void set_productgroupids(int index, const char* value, size_t size);
  ::std::string* add_productgroupids();
  void add_productgroupids(const ::std::string& value);
  #if LANG_CXX11
  void add_productgroupids(::std::string&& value);
  #endif
  void add_productgroupids(const char* value);
  void add_productgroupids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productgroupids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productgroupids();

  // repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
  int unitdimensioncosts_size() const;
  void clear_unitdimensioncosts();
  static const int kUnitDimensionCostsFieldNumber = 7;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncosts(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncosts();
  const ::NS3::UnitDimensionCost& unitdimensioncosts(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncosts();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncosts() const;

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
  int flowconstraints_size() const;
  void clear_flowconstraints();
  static const int kFlowConstraintsFieldNumber = 8;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // required string destination = 4;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 4;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // @@protoc_insertion_point(class_scope:NS3.LaneRate)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productgroupids_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncosts_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CostModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.CostModel) */ {
 public:
  CostModel();
  virtual ~CostModel();

  CostModel(const CostModel& from);

  inline CostModel& operator=(const CostModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CostModel(CostModel&& from) noexcept
    : CostModel() {
    *this = ::std::move(from);
  }

  inline CostModel& operator=(CostModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CostModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CostModel* internal_default_instance() {
    return reinterpret_cast<const CostModel*>(
               &_CostModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CostModel* other);
  friend void swap(CostModel& a, CostModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CostModel* New() const final {
    return CreateMaybeMessage<CostModel>(NULL);
  }

  CostModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CostModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CostModel& from);
  void MergeFrom(const CostModel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string productGroupIds = 5;
  int productgroupids_size() const;
  void clear_productgroupids();
  static const int kProductGroupIdsFieldNumber = 5;
  const ::std::string& productgroupids(int index) const;
  ::std::string* mutable_productgroupids(int index);
  void set_productgroupids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productgroupids(int index, ::std::string&& value);
  #endif
  void set_productgroupids(int index, const char* value);
  void set_productgroupids(int index, const char* value, size_t size);
  ::std::string* add_productgroupids();
  void add_productgroupids(const ::std::string& value);
  #if LANG_CXX11
  void add_productgroupids(::std::string&& value);
  #endif
  void add_productgroupids(const char* value);
  void add_productgroupids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productgroupids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productgroupids();

  // repeated .NS3.UnitDimensionCost unitDimensionCost = 6;
  int unitdimensioncost_size() const;
  void clear_unitdimensioncost();
  static const int kUnitDimensionCostFieldNumber = 6;
  ::NS3::UnitDimensionCost* mutable_unitdimensioncost(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
      mutable_unitdimensioncost();
  const ::NS3::UnitDimensionCost& unitdimensioncost(int index) const;
  ::NS3::UnitDimensionCost* add_unitdimensioncost();
  const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
      unitdimensioncost() const;

  // repeated .NS3.FlowDimensionalConstraint flowConstraints = 7;
  int flowconstraints_size() const;
  void clear_flowconstraints();
  static const int kFlowConstraintsFieldNumber = 7;
  ::NS3::FlowDimensionalConstraint* mutable_flowconstraints(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
      mutable_flowconstraints();
  const ::NS3::FlowDimensionalConstraint& flowconstraints(int index) const;
  ::NS3::FlowDimensionalConstraint* add_flowconstraints();
  const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
      flowconstraints() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional string destination = 4;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 4;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // optional string serviceClass = 8;
  bool has_serviceclass() const;
  void clear_serviceclass();
  static const int kServiceClassFieldNumber = 8;
  const ::std::string& serviceclass() const;
  void set_serviceclass(const ::std::string& value);
  #if LANG_CXX11
  void set_serviceclass(::std::string&& value);
  #endif
  void set_serviceclass(const char* value);
  void set_serviceclass(const char* value, size_t size);
  ::std::string* mutable_serviceclass();
  ::std::string* release_serviceclass();
  void set_allocated_serviceclass(::std::string* serviceclass);

  // @@protoc_insertion_point(class_scope:NS3.CostModel)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_serviceclass();
  void clear_has_serviceclass();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productgroupids_;
  ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost > unitdimensioncost_;
  ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint > flowconstraints_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr serviceclass_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(NULL);
  }

  Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.Dimension dimensions = 1;
  int dimensions_size() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 1;
  ::NS3::Dimension* mutable_dimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Dimension >*
      mutable_dimensions();
  const ::NS3::Dimension& dimensions(int index) const;
  ::NS3::Dimension* add_dimensions();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Dimension >&
      dimensions() const;

  // repeated .NS3.Node nodes = 2;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  ::NS3::Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Node >*
      mutable_nodes();
  const ::NS3::Node& nodes(int index) const;
  ::NS3::Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Node >&
      nodes() const;

  // repeated .NS3.LaneRate laneRates = 3;
  int lanerates_size() const;
  void clear_lanerates();
  static const int kLaneRatesFieldNumber = 3;
  ::NS3::LaneRate* mutable_lanerates(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >*
      mutable_lanerates();
  const ::NS3::LaneRate& lanerates(int index) const;
  ::NS3::LaneRate* add_lanerates();
  const ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >&
      lanerates() const;

  // repeated .NS3.CostModel costModels = 4;
  int costmodels_size() const;
  void clear_costmodels();
  static const int kCostModelsFieldNumber = 4;
  ::NS3::CostModel* mutable_costmodels(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >*
      mutable_costmodels();
  const ::NS3::CostModel& costmodels(int index) const;
  ::NS3::CostModel* add_costmodels();
  const ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >&
      costmodels() const;

  // repeated .NS3.ProductGroup productGroups = 5;
  int productgroups_size() const;
  void clear_productgroups();
  static const int kProductGroupsFieldNumber = 5;
  ::NS3::ProductGroup* mutable_productgroups(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >*
      mutable_productgroups();
  const ::NS3::ProductGroup& productgroups(int index) const;
  ::NS3::ProductGroup* add_productgroups();
  const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >&
      productgroups() const;

  // @@protoc_insertion_point(class_scope:NS3.Model)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Dimension > dimensions_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Node > nodes_;
  ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate > lanerates_;
  ::google::protobuf::RepeatedPtrField< ::NS3::CostModel > costmodels_;
  ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup > productgroups_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolveRequest) */ {
 public:
  SolveRequest();
  virtual ~SolveRequest();

  SolveRequest(const SolveRequest& from);

  inline SolveRequest& operator=(const SolveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolveRequest(SolveRequest&& from) noexcept
    : SolveRequest() {
    *this = ::std::move(from);
  }

  inline SolveRequest& operator=(SolveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolveRequest* internal_default_instance() {
    return reinterpret_cast<const SolveRequest*>(
               &_SolveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(SolveRequest* other);
  friend void swap(SolveRequest& a, SolveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolveRequest* New() const final {
    return CreateMaybeMessage<SolveRequest>(NULL);
  }

  SolveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolveRequest& from);
  void MergeFrom(const SolveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolveRequest_SolveType SolveType;
  static const SolveType Optimise =
    SolveRequest_SolveType_Optimise;
  static inline bool SolveType_IsValid(int value) {
    return SolveRequest_SolveType_IsValid(value);
  }
  static const SolveType SolveType_MIN =
    SolveRequest_SolveType_SolveType_MIN;
  static const SolveType SolveType_MAX =
    SolveRequest_SolveType_SolveType_MAX;
  static const int SolveType_ARRAYSIZE =
    SolveRequest_SolveType_SolveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolveType_descriptor() {
    return SolveRequest_SolveType_descriptor();
  }
  static inline const ::std::string& SolveType_Name(SolveType value) {
    return SolveRequest_SolveType_Name(value);
  }
  static inline bool SolveType_Parse(const ::std::string& name,
      SolveType* value) {
    return SolveRequest_SolveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string modelID = 2;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIDFieldNumber = 2;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // optional .NS3.Model model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  private:
  const ::NS3::Model& _internal_model() const;
  public:
  const ::NS3::Model& model() const;
  ::NS3::Model* release_model();
  ::NS3::Model* mutable_model();
  void set_allocated_model(::NS3::Model* model);

  // optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
  bool has_solvetype() const;
  void clear_solvetype();
  static const int kSolveTypeFieldNumber = 4;
  ::NS3::SolveRequest_SolveType solvetype() const;
  void set_solvetype(::NS3::SolveRequest_SolveType value);

  // @@protoc_insertion_point(class_scope:NS3.SolveRequest)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_modelid();
  void clear_has_modelid();
  void set_has_solvetype();
  void clear_has_solvetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  ::NS3::Model* model_;
  int solvetype_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_Assignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.Assignment) */ {
 public:
  SolutionResponse_Assignment();
  virtual ~SolutionResponse_Assignment();

  SolutionResponse_Assignment(const SolutionResponse_Assignment& from);

  inline SolutionResponse_Assignment& operator=(const SolutionResponse_Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_Assignment(SolutionResponse_Assignment&& from) noexcept
    : SolutionResponse_Assignment() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_Assignment& operator=(SolutionResponse_Assignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_Assignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_Assignment* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_Assignment*>(
               &_SolutionResponse_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SolutionResponse_Assignment* other);
  friend void swap(SolutionResponse_Assignment& a, SolutionResponse_Assignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_Assignment* New() const final {
    return CreateMaybeMessage<SolutionResponse_Assignment>(NULL);
  }

  SolutionResponse_Assignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_Assignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_Assignment& from);
  void MergeFrom(const SolutionResponse_Assignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_Assignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NS3.Geocode geometry = 10;
  int geometry_size() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 10;
  ::NS3::Geocode* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::Geocode >*
      mutable_geometry();
  const ::NS3::Geocode& geometry(int index) const;
  ::NS3::Geocode* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::NS3::Geocode >&
      geometry() const;

  // required string source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // required string destination = 2;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // required string productId = 3;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 3;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string laneRateId = 6;
  bool has_lanerateid() const;
  void clear_lanerateid();
  static const int kLaneRateIdFieldNumber = 6;
  const ::std::string& lanerateid() const;
  void set_lanerateid(const ::std::string& value);
  #if LANG_CXX11
  void set_lanerateid(::std::string&& value);
  #endif
  void set_lanerateid(const char* value);
  void set_lanerateid(const char* value, size_t size);
  ::std::string* mutable_lanerateid();
  ::std::string* release_lanerateid();
  void set_allocated_lanerateid(::std::string* lanerateid);

  // optional string costModelId = 7;
  bool has_costmodelid() const;
  void clear_costmodelid();
  static const int kCostModelIdFieldNumber = 7;
  const ::std::string& costmodelid() const;
  void set_costmodelid(const ::std::string& value);
  #if LANG_CXX11
  void set_costmodelid(::std::string&& value);
  #endif
  void set_costmodelid(const char* value);
  void set_costmodelid(const char* value, size_t size);
  ::std::string* mutable_costmodelid();
  ::std::string* release_costmodelid();
  void set_allocated_costmodelid(::std::string* costmodelid);

  // required float amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  float amount() const;
  void set_amount(float value);

  // required float cost = 5;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 5;
  float cost() const;
  void set_cost(float value);

  // required float distance = 8;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 8;
  float distance() const;
  void set_distance(float value);

  // required float duration = 9;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 9;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.Assignment)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_productid();
  void clear_has_productid();
  void set_has_amount();
  void clear_has_amount();
  void set_has_cost();
  void clear_has_cost();
  void set_has_lanerateid();
  void clear_has_lanerateid();
  void set_has_costmodelid();
  void clear_has_costmodelid();
  void set_has_distance();
  void clear_has_distance();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::Geocode > geometry_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr lanerateid_;
  ::google::protobuf::internal::ArenaStringPtr costmodelid_;
  float amount_;
  float cost_;
  float distance_;
  float duration_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_NodeProductFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeProductFlow) */ {
 public:
  SolutionResponse_NodeProductFlow();
  virtual ~SolutionResponse_NodeProductFlow();

  SolutionResponse_NodeProductFlow(const SolutionResponse_NodeProductFlow& from);

  inline SolutionResponse_NodeProductFlow& operator=(const SolutionResponse_NodeProductFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_NodeProductFlow(SolutionResponse_NodeProductFlow&& from) noexcept
    : SolutionResponse_NodeProductFlow() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeProductFlow& operator=(SolutionResponse_NodeProductFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_NodeProductFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_NodeProductFlow* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeProductFlow*>(
               &_SolutionResponse_NodeProductFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SolutionResponse_NodeProductFlow* other);
  friend void swap(SolutionResponse_NodeProductFlow& a, SolutionResponse_NodeProductFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_NodeProductFlow* New() const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductFlow>(NULL);
  }

  SolutionResponse_NodeProductFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_NodeProductFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_NodeProductFlow& from);
  void MergeFrom(const SolutionResponse_NodeProductFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeProductFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // required string productId = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIdFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required float inFlow = 3;
  bool has_inflow() const;
  void clear_inflow();
  static const int kInFlowFieldNumber = 3;
  float inflow() const;
  void set_inflow(float value);

  // required float outFlow = 4;
  bool has_outflow() const;
  void clear_outflow();
  static const int kOutFlowFieldNumber = 4;
  float outflow() const;
  void set_outflow(float value);

  // required float flowCost = 5;
  bool has_flowcost() const;
  void clear_flowcost();
  static const int kFlowCostFieldNumber = 5;
  float flowcost() const;
  void set_flowcost(float value);

  // required float fixedCost = 6;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 6;
  float fixedcost() const;
  void set_fixedcost(float value);

  // required float productionAmount = 7;
  bool has_productionamount() const;
  void clear_productionamount();
  static const int kProductionAmountFieldNumber = 7;
  float productionamount() const;
  void set_productionamount(float value);

  // required float productionPenalty = 8;
  bool has_productionpenalty() const;
  void clear_productionpenalty();
  static const int kProductionPenaltyFieldNumber = 8;
  float productionpenalty() const;
  void set_productionpenalty(float value);

  // required float productionCost = 9;
  bool has_productioncost() const;
  void clear_productioncost();
  static const int kProductionCostFieldNumber = 9;
  float productioncost() const;
  void set_productioncost(float value);

  // required float consumptionAmount = 10;
  bool has_consumptionamount() const;
  void clear_consumptionamount();
  static const int kConsumptionAmountFieldNumber = 10;
  float consumptionamount() const;
  void set_consumptionamount(float value);

  // required float consumptionPenalty = 11;
  bool has_consumptionpenalty() const;
  void clear_consumptionpenalty();
  static const int kConsumptionPenaltyFieldNumber = 11;
  float consumptionpenalty() const;
  void set_consumptionpenalty(float value);

  // required float consumptionCost = 12;
  bool has_consumptioncost() const;
  void clear_consumptioncost();
  static const int kConsumptionCostFieldNumber = 12;
  float consumptioncost() const;
  void set_consumptioncost(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeProductFlow)
 private:
  void set_has_nodeid();
  void clear_has_nodeid();
  void set_has_productid();
  void clear_has_productid();
  void set_has_inflow();
  void clear_has_inflow();
  void set_has_outflow();
  void clear_has_outflow();
  void set_has_flowcost();
  void clear_has_flowcost();
  void set_has_fixedcost();
  void clear_has_fixedcost();
  void set_has_productionamount();
  void clear_has_productionamount();
  void set_has_productionpenalty();
  void clear_has_productionpenalty();
  void set_has_productioncost();
  void clear_has_productioncost();
  void set_has_consumptionamount();
  void clear_has_consumptionamount();
  void set_has_consumptionpenalty();
  void clear_has_consumptionpenalty();
  void set_has_consumptioncost();
  void clear_has_consumptioncost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  float inflow_;
  float outflow_;
  float flowcost_;
  float fixedcost_;
  float productionamount_;
  float productionpenalty_;
  float productioncost_;
  float consumptionamount_;
  float consumptionpenalty_;
  float consumptioncost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_NodeFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.NodeFlow) */ {
 public:
  SolutionResponse_NodeFlow();
  virtual ~SolutionResponse_NodeFlow();

  SolutionResponse_NodeFlow(const SolutionResponse_NodeFlow& from);

  inline SolutionResponse_NodeFlow& operator=(const SolutionResponse_NodeFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_NodeFlow(SolutionResponse_NodeFlow&& from) noexcept
    : SolutionResponse_NodeFlow() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_NodeFlow& operator=(SolutionResponse_NodeFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_NodeFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_NodeFlow* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_NodeFlow*>(
               &_SolutionResponse_NodeFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(SolutionResponse_NodeFlow* other);
  friend void swap(SolutionResponse_NodeFlow& a, SolutionResponse_NodeFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_NodeFlow* New() const final {
    return CreateMaybeMessage<SolutionResponse_NodeFlow>(NULL);
  }

  SolutionResponse_NodeFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_NodeFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_NodeFlow& from);
  void MergeFrom(const SolutionResponse_NodeFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_NodeFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nodeId = 1;
  bool has_nodeid() const;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // required float inFlow = 2;
  bool has_inflow() const;
  void clear_inflow();
  static const int kInFlowFieldNumber = 2;
  float inflow() const;
  void set_inflow(float value);

  // required float outFlow = 3;
  bool has_outflow() const;
  void clear_outflow();
  static const int kOutFlowFieldNumber = 3;
  float outflow() const;
  void set_outflow(float value);

  // required float flowCost = 4;
  bool has_flowcost() const;
  void clear_flowcost();
  static const int kFlowCostFieldNumber = 4;
  float flowcost() const;
  void set_flowcost(float value);

  // required float fixedCost = 5;
  bool has_fixedcost() const;
  void clear_fixedcost();
  static const int kFixedCostFieldNumber = 5;
  float fixedcost() const;
  void set_fixedcost(float value);

  // required float productFlowCost = 6;
  bool has_productflowcost() const;
  void clear_productflowcost();
  static const int kProductFlowCostFieldNumber = 6;
  float productflowcost() const;
  void set_productflowcost(float value);

  // required float productFixedCost = 7;
  bool has_productfixedcost() const;
  void clear_productfixedcost();
  static const int kProductFixedCostFieldNumber = 7;
  float productfixedcost() const;
  void set_productfixedcost(float value);

  // required float productionAmount = 8;
  bool has_productionamount() const;
  void clear_productionamount();
  static const int kProductionAmountFieldNumber = 8;
  float productionamount() const;
  void set_productionamount(float value);

  // required float productionPenalty = 9;
  bool has_productionpenalty() const;
  void clear_productionpenalty();
  static const int kProductionPenaltyFieldNumber = 9;
  float productionpenalty() const;
  void set_productionpenalty(float value);

  // required float productionCost = 10;
  bool has_productioncost() const;
  void clear_productioncost();
  static const int kProductionCostFieldNumber = 10;
  float productioncost() const;
  void set_productioncost(float value);

  // required float consumptionAmount = 11;
  bool has_consumptionamount() const;
  void clear_consumptionamount();
  static const int kConsumptionAmountFieldNumber = 11;
  float consumptionamount() const;
  void set_consumptionamount(float value);

  // required float consumptionPenalty = 12;
  bool has_consumptionpenalty() const;
  void clear_consumptionpenalty();
  static const int kConsumptionPenaltyFieldNumber = 12;
  float consumptionpenalty() const;
  void set_consumptionpenalty(float value);

  // required float consumptionCost = 13;
  bool has_consumptioncost() const;
  void clear_consumptioncost();
  static const int kConsumptionCostFieldNumber = 13;
  float consumptioncost() const;
  void set_consumptioncost(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.NodeFlow)
 private:
  void set_has_nodeid();
  void clear_has_nodeid();
  void set_has_inflow();
  void clear_has_inflow();
  void set_has_outflow();
  void clear_has_outflow();
  void set_has_flowcost();
  void clear_has_flowcost();
  void set_has_fixedcost();
  void clear_has_fixedcost();
  void set_has_productflowcost();
  void clear_has_productflowcost();
  void set_has_productfixedcost();
  void clear_has_productfixedcost();
  void set_has_productionamount();
  void clear_has_productionamount();
  void set_has_productionpenalty();
  void clear_has_productionpenalty();
  void set_has_productioncost();
  void clear_has_productioncost();
  void set_has_consumptionamount();
  void clear_has_consumptionamount();
  void set_has_consumptionpenalty();
  void clear_has_consumptionpenalty();
  void set_has_consumptioncost();
  void clear_has_consumptioncost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  float inflow_;
  float outflow_;
  float flowcost_;
  float fixedcost_;
  float productflowcost_;
  float productfixedcost_;
  float productionamount_;
  float productionpenalty_;
  float productioncost_;
  float consumptionamount_;
  float consumptionpenalty_;
  float consumptioncost_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse_GeometryEdgeSummary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse.GeometryEdgeSummary) */ {
 public:
  SolutionResponse_GeometryEdgeSummary();
  virtual ~SolutionResponse_GeometryEdgeSummary();

  SolutionResponse_GeometryEdgeSummary(const SolutionResponse_GeometryEdgeSummary& from);

  inline SolutionResponse_GeometryEdgeSummary& operator=(const SolutionResponse_GeometryEdgeSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse_GeometryEdgeSummary(SolutionResponse_GeometryEdgeSummary&& from) noexcept
    : SolutionResponse_GeometryEdgeSummary() {
    *this = ::std::move(from);
  }

  inline SolutionResponse_GeometryEdgeSummary& operator=(SolutionResponse_GeometryEdgeSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse_GeometryEdgeSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse_GeometryEdgeSummary* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse_GeometryEdgeSummary*>(
               &_SolutionResponse_GeometryEdgeSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(SolutionResponse_GeometryEdgeSummary* other);
  friend void swap(SolutionResponse_GeometryEdgeSummary& a, SolutionResponse_GeometryEdgeSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse_GeometryEdgeSummary* New() const final {
    return CreateMaybeMessage<SolutionResponse_GeometryEdgeSummary>(NULL);
  }

  SolutionResponse_GeometryEdgeSummary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse_GeometryEdgeSummary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse_GeometryEdgeSummary& from);
  void MergeFrom(const SolutionResponse_GeometryEdgeSummary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse_GeometryEdgeSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float fxs = 1;
  int fxs_size() const;
  void clear_fxs();
  static const int kFxsFieldNumber = 1;
  float fxs(int index) const;
  void set_fxs(int index, float value);
  void add_fxs(float value);
  const ::google::protobuf::RepeatedField< float >&
      fxs() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_fxs();

  // repeated float fys = 2;
  int fys_size() const;
  void clear_fys();
  static const int kFysFieldNumber = 2;
  float fys(int index) const;
  void set_fys(int index, float value);
  void add_fys(float value);
  const ::google::protobuf::RepeatedField< float >&
      fys() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_fys();

  // repeated float txs = 3;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 3;
  float txs(int index) const;
  void set_txs(int index, float value);
  void add_txs(float value);
  const ::google::protobuf::RepeatedField< float >&
      txs() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_txs();

  // repeated float tys = 4;
  int tys_size() const;
  void clear_tys();
  static const int kTysFieldNumber = 4;
  float tys(int index) const;
  void set_tys(int index, float value);
  void add_tys(float value);
  const ::google::protobuf::RepeatedField< float >&
      tys() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_tys();

  // repeated float weights = 5;
  int weights_size() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 5;
  float weights(int index) const;
  void set_weights(int index, float value);
  void add_weights(float value);
  const ::google::protobuf::RepeatedField< float >&
      weights() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_weights();

  // repeated int32 types = 6;
  int types_size() const;
  void clear_types();
  static const int kTypesFieldNumber = 6;
  ::google::protobuf::int32 types(int index) const;
  void set_types(int index, ::google::protobuf::int32 value);
  void add_types(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      types() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse.GeometryEdgeSummary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > fxs_;
  ::google::protobuf::RepeatedField< float > fys_;
  ::google::protobuf::RepeatedField< float > txs_;
  ::google::protobuf::RepeatedField< float > tys_;
  ::google::protobuf::RepeatedField< float > weights_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > types_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SolutionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NS3.SolutionResponse) */ {
 public:
  SolutionResponse();
  virtual ~SolutionResponse();

  SolutionResponse(const SolutionResponse& from);

  inline SolutionResponse& operator=(const SolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolutionResponse(SolutionResponse&& from) noexcept
    : SolutionResponse() {
    *this = ::std::move(from);
  }

  inline SolutionResponse& operator=(SolutionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolutionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolutionResponse* internal_default_instance() {
    return reinterpret_cast<const SolutionResponse*>(
               &_SolutionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SolutionResponse* other);
  friend void swap(SolutionResponse& a, SolutionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolutionResponse* New() const final {
    return CreateMaybeMessage<SolutionResponse>(NULL);
  }

  SolutionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolutionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolutionResponse& from);
  void MergeFrom(const SolutionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolutionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SolutionResponse_Assignment Assignment;
  typedef SolutionResponse_NodeProductFlow NodeProductFlow;
  typedef SolutionResponse_NodeFlow NodeFlow;
  typedef SolutionResponse_GeometryEdgeSummary GeometryEdgeSummary;

  // accessors -------------------------------------------------------

  // repeated .NS3.SolutionResponse.Assignment assignments = 4;
  int assignments_size() const;
  void clear_assignments();
  static const int kAssignmentsFieldNumber = 4;
  ::NS3::SolutionResponse_Assignment* mutable_assignments(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >*
      mutable_assignments();
  const ::NS3::SolutionResponse_Assignment& assignments(int index) const;
  ::NS3::SolutionResponse_Assignment* add_assignments();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >&
      assignments() const;

  // repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
  int nodeflows_size() const;
  void clear_nodeflows();
  static const int kNodeFlowsFieldNumber = 5;
  ::NS3::SolutionResponse_NodeFlow* mutable_nodeflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >*
      mutable_nodeflows();
  const ::NS3::SolutionResponse_NodeFlow& nodeflows(int index) const;
  ::NS3::SolutionResponse_NodeFlow* add_nodeflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >&
      nodeflows() const;

  // repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
  int nodeproductflows_size() const;
  void clear_nodeproductflows();
  static const int kNodeProductFlowsFieldNumber = 6;
  ::NS3::SolutionResponse_NodeProductFlow* mutable_nodeproductflows(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >*
      mutable_nodeproductflows();
  const ::NS3::SolutionResponse_NodeProductFlow& nodeproductflows(int index) const;
  ::NS3::SolutionResponse_NodeProductFlow* add_nodeproductflows();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >&
      nodeproductflows() const;

  // repeated .NS3.SolutionResponse.GeometryEdgeSummary geometryEdgeSummary = 7;
  int geometryedgesummary_size() const;
  void clear_geometryedgesummary();
  static const int kGeometryEdgeSummaryFieldNumber = 7;
  ::NS3::SolutionResponse_GeometryEdgeSummary* mutable_geometryedgesummary(int index);
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometryEdgeSummary >*
      mutable_geometryedgesummary();
  const ::NS3::SolutionResponse_GeometryEdgeSummary& geometryedgesummary(int index) const;
  ::NS3::SolutionResponse_GeometryEdgeSummary* add_geometryedgesummary();
  const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometryEdgeSummary >&
      geometryedgesummary() const;

  // required float objective = 1;
  bool has_objective() const;
  void clear_objective();
  static const int kObjectiveFieldNumber = 1;
  float objective() const;
  void set_objective(float value);

  // optional float lowerBound = 2;
  bool has_lowerbound() const;
  void clear_lowerbound();
  static const int kLowerBoundFieldNumber = 2;
  float lowerbound() const;
  void set_lowerbound(float value);

  // optional float optimalityGap = 3;
  bool has_optimalitygap() const;
  void clear_optimalitygap();
  static const int kOptimalityGapFieldNumber = 3;
  float optimalitygap() const;
  void set_optimalitygap(float value);

  // @@protoc_insertion_point(class_scope:NS3.SolutionResponse)
 private:
  void set_has_objective();
  void clear_has_objective();
  void set_has_lowerbound();
  void clear_has_lowerbound();
  void set_has_optimalitygap();
  void clear_has_optimalitygap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment > assignments_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow > nodeflows_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow > nodeproductflows_;
  ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometryEdgeSummary > geometryedgesummary_;
  float objective_;
  float lowerbound_;
  float optimalitygap_;
  friend struct ::protobuf_ns3_2dtbfvuwtge2iq_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Dimension

// required string name = 1;
inline bool Dimension::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Dimension::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Dimension::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Dimension::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Dimension::name() const {
  // @@protoc_insertion_point(field_get:NS3.Dimension.name)
  return name_.GetNoArena();
}
inline void Dimension::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Dimension.name)
}
#if LANG_CXX11
inline void Dimension::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Dimension.name)
}
#endif
inline void Dimension::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Dimension.name)
}
inline void Dimension::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Dimension.name)
}
inline ::std::string* Dimension::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NS3.Dimension.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Dimension::release_name() {
  // @@protoc_insertion_point(field_release:NS3.Dimension.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Dimension::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NS3.Dimension.name)
}

// -------------------------------------------------------------------

// Geocode

// required float longitude = 1;
inline bool Geocode::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geocode::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geocode::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geocode::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Geocode::longitude() const {
  // @@protoc_insertion_point(field_get:NS3.Geocode.longitude)
  return longitude_;
}
inline void Geocode::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:NS3.Geocode.longitude)
}

// required float latitude = 2;
inline bool Geocode::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geocode::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geocode::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geocode::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Geocode::latitude() const {
  // @@protoc_insertion_point(field_get:NS3.Geocode.latitude)
  return latitude_;
}
inline void Geocode::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:NS3.Geocode.latitude)
}

// -------------------------------------------------------------------

// UnitDimensionCost

// repeated string dimensionIds = 1;
inline int UnitDimensionCost::dimensionids_size() const {
  return dimensionids_.size();
}
inline void UnitDimensionCost::clear_dimensionids() {
  dimensionids_.Clear();
}
inline const ::std::string& UnitDimensionCost::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_.Get(index);
}
inline ::std::string* UnitDimensionCost::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_.Mutable(index);
}
inline void UnitDimensionCost::set_dimensionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void UnitDimensionCost::set_dimensionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void UnitDimensionCost::set_dimensionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::set_dimensionids(int index, const char* value, size_t size) {
  dimensionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.UnitDimensionCost.dimensionIds)
}
inline ::std::string* UnitDimensionCost::add_dimensionids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_.Add();
}
inline void UnitDimensionCost::add_dimensionids(const ::std::string& value) {
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionIds)
}
#if LANG_CXX11
inline void UnitDimensionCost::add_dimensionids(::std::string&& value) {
  dimensionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionIds)
}
#endif
inline void UnitDimensionCost::add_dimensionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.UnitDimensionCost.dimensionIds)
}
inline void UnitDimensionCost::add_dimensionids(const char* value, size_t size) {
  dimensionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.UnitDimensionCost.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UnitDimensionCost::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.UnitDimensionCost.dimensionIds)
  return dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UnitDimensionCost::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.UnitDimensionCost.dimensionIds)
  return &dimensionids_;
}

// repeated float dimensionCoefficients = 2;
inline int UnitDimensionCost::dimensioncoefficients_size() const {
  return dimensioncoefficients_.size();
}
inline void UnitDimensionCost::clear_dimensioncoefficients() {
  dimensioncoefficients_.Clear();
}
inline float UnitDimensionCost::dimensioncoefficients(int index) const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.dimensionCoefficients)
  return dimensioncoefficients_.Get(index);
}
inline void UnitDimensionCost::set_dimensioncoefficients(int index, float value) {
  dimensioncoefficients_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.dimensionCoefficients)
}
inline void UnitDimensionCost::add_dimensioncoefficients(float value) {
  dimensioncoefficients_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.UnitDimensionCost.dimensionCoefficients)
}
inline const ::google::protobuf::RepeatedField< float >&
UnitDimensionCost::dimensioncoefficients() const {
  // @@protoc_insertion_point(field_list:NS3.UnitDimensionCost.dimensionCoefficients)
  return dimensioncoefficients_;
}
inline ::google::protobuf::RepeatedField< float >*
UnitDimensionCost::mutable_dimensioncoefficients() {
  // @@protoc_insertion_point(field_mutable_list:NS3.UnitDimensionCost.dimensionCoefficients)
  return &dimensioncoefficients_;
}

// required float costPerUnit = 3;
inline bool UnitDimensionCost::has_costperunit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitDimensionCost::set_has_costperunit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitDimensionCost::clear_has_costperunit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitDimensionCost::clear_costperunit() {
  costperunit_ = 0;
  clear_has_costperunit();
}
inline float UnitDimensionCost::costperunit() const {
  // @@protoc_insertion_point(field_get:NS3.UnitDimensionCost.costPerUnit)
  return costperunit_;
}
inline void UnitDimensionCost::set_costperunit(float value) {
  set_has_costperunit();
  costperunit_ = value;
  // @@protoc_insertion_point(field_set:NS3.UnitDimensionCost.costPerUnit)
}

// -------------------------------------------------------------------

// FixedDimensionCost

// repeated string dimensionIds = 1;
inline int FixedDimensionCost::dimensionids_size() const {
  return dimensionids_.size();
}
inline void FixedDimensionCost::clear_dimensionids() {
  dimensionids_.Clear();
}
inline const ::std::string& FixedDimensionCost::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_.Get(index);
}
inline ::std::string* FixedDimensionCost::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_.Mutable(index);
}
inline void FixedDimensionCost::set_dimensionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FixedDimensionCost::set_dimensionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.dimensionIds)
  dimensionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FixedDimensionCost::set_dimensionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::set_dimensionids(int index, const char* value, size_t size) {
  dimensionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.FixedDimensionCost.dimensionIds)
}
inline ::std::string* FixedDimensionCost::add_dimensionids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_.Add();
}
inline void FixedDimensionCost::add_dimensionids(const ::std::string& value) {
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.FixedDimensionCost.dimensionIds)
}
#if LANG_CXX11
inline void FixedDimensionCost::add_dimensionids(::std::string&& value) {
  dimensionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.FixedDimensionCost.dimensionIds)
}
#endif
inline void FixedDimensionCost::add_dimensionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.FixedDimensionCost.dimensionIds)
}
inline void FixedDimensionCost::add_dimensionids(const char* value, size_t size) {
  dimensionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.FixedDimensionCost.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FixedDimensionCost::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.FixedDimensionCost.dimensionIds)
  return dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FixedDimensionCost::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FixedDimensionCost.dimensionIds)
  return &dimensionids_;
}

// required float fixedCost = 2;
inline bool FixedDimensionCost::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixedDimensionCost::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixedDimensionCost::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixedDimensionCost::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float FixedDimensionCost::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.FixedDimensionCost.fixedCost)
  return fixedcost_;
}
inline void FixedDimensionCost::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.FixedDimensionCost.fixedCost)
}

// -------------------------------------------------------------------

// FlowDimensionalConstraint

// repeated string dimensionIds = 1;
inline int FlowDimensionalConstraint::dimensionids_size() const {
  return dimensionids_.size();
}
inline void FlowDimensionalConstraint::clear_dimensionids() {
  dimensionids_.Clear();
}
inline const ::std::string& FlowDimensionalConstraint::dimensionids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_.Get(index);
}
inline ::std::string* FlowDimensionalConstraint::mutable_dimensionids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_.Mutable(index);
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionIds)
  dimensionids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FlowDimensionalConstraint::set_dimensionids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionIds)
  dimensionids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FlowDimensionalConstraint::set_dimensionids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::set_dimensionids(int index, const char* value, size_t size) {
  dimensionids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline ::std::string* FlowDimensionalConstraint::add_dimensionids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_.Add();
}
inline void FlowDimensionalConstraint::add_dimensionids(const ::std::string& value) {
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionIds)
}
#if LANG_CXX11
inline void FlowDimensionalConstraint::add_dimensionids(::std::string&& value) {
  dimensionids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionIds)
}
#endif
inline void FlowDimensionalConstraint::add_dimensionids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dimensionids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline void FlowDimensionalConstraint::add_dimensionids(const char* value, size_t size) {
  dimensionids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.FlowDimensionalConstraint.dimensionIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FlowDimensionalConstraint::dimensionids() const {
  // @@protoc_insertion_point(field_list:NS3.FlowDimensionalConstraint.dimensionIds)
  return dimensionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FlowDimensionalConstraint::mutable_dimensionids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FlowDimensionalConstraint.dimensionIds)
  return &dimensionids_;
}

// repeated float dimensionCoefficients = 2;
inline int FlowDimensionalConstraint::dimensioncoefficients_size() const {
  return dimensioncoefficients_.size();
}
inline void FlowDimensionalConstraint::clear_dimensioncoefficients() {
  dimensioncoefficients_.Clear();
}
inline float FlowDimensionalConstraint::dimensioncoefficients(int index) const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return dimensioncoefficients_.Get(index);
}
inline void FlowDimensionalConstraint::set_dimensioncoefficients(int index, float value) {
  dimensioncoefficients_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.dimensionCoefficients)
}
inline void FlowDimensionalConstraint::add_dimensioncoefficients(float value) {
  dimensioncoefficients_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.FlowDimensionalConstraint.dimensionCoefficients)
}
inline const ::google::protobuf::RepeatedField< float >&
FlowDimensionalConstraint::dimensioncoefficients() const {
  // @@protoc_insertion_point(field_list:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return dimensioncoefficients_;
}
inline ::google::protobuf::RepeatedField< float >*
FlowDimensionalConstraint::mutable_dimensioncoefficients() {
  // @@protoc_insertion_point(field_mutable_list:NS3.FlowDimensionalConstraint.dimensionCoefficients)
  return &dimensioncoefficients_;
}

// required float flowMin = 3;
inline bool FlowDimensionalConstraint::has_flowmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowDimensionalConstraint::set_has_flowmin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowDimensionalConstraint::clear_has_flowmin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowDimensionalConstraint::clear_flowmin() {
  flowmin_ = 0;
  clear_has_flowmin();
}
inline float FlowDimensionalConstraint::flowmin() const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.flowMin)
  return flowmin_;
}
inline void FlowDimensionalConstraint::set_flowmin(float value) {
  set_has_flowmin();
  flowmin_ = value;
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.flowMin)
}

// required float flowMax = 4;
inline bool FlowDimensionalConstraint::has_flowmax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowDimensionalConstraint::set_has_flowmax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowDimensionalConstraint::clear_has_flowmax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowDimensionalConstraint::clear_flowmax() {
  flowmax_ = 0;
  clear_has_flowmax();
}
inline float FlowDimensionalConstraint::flowmax() const {
  // @@protoc_insertion_point(field_get:NS3.FlowDimensionalConstraint.flowMax)
  return flowmax_;
}
inline void FlowDimensionalConstraint::set_flowmax(float value) {
  set_has_flowmax();
  flowmax_ = value;
  // @@protoc_insertion_point(field_set:NS3.FlowDimensionalConstraint.flowMax)
}

// -------------------------------------------------------------------

// DimensionRange

// required string dimensionId = 1;
inline bool DimensionRange::has_dimensionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DimensionRange::set_has_dimensionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DimensionRange::clear_has_dimensionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DimensionRange::clear_dimensionid() {
  dimensionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dimensionid();
}
inline const ::std::string& DimensionRange::dimensionid() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.dimensionId)
  return dimensionid_.GetNoArena();
}
inline void DimensionRange::set_dimensionid(const ::std::string& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.dimensionId)
}
#if LANG_CXX11
inline void DimensionRange::set_dimensionid(::std::string&& value) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.DimensionRange.dimensionId)
}
#endif
inline void DimensionRange::set_dimensionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.DimensionRange.dimensionId)
}
inline void DimensionRange::set_dimensionid(const char* value, size_t size) {
  set_has_dimensionid();
  dimensionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.DimensionRange.dimensionId)
}
inline ::std::string* DimensionRange::mutable_dimensionid() {
  set_has_dimensionid();
  // @@protoc_insertion_point(field_mutable:NS3.DimensionRange.dimensionId)
  return dimensionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DimensionRange::release_dimensionid() {
  // @@protoc_insertion_point(field_release:NS3.DimensionRange.dimensionId)
  if (!has_dimensionid()) {
    return NULL;
  }
  clear_has_dimensionid();
  return dimensionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DimensionRange::set_allocated_dimensionid(::std::string* dimensionid) {
  if (dimensionid != NULL) {
    set_has_dimensionid();
  } else {
    clear_has_dimensionid();
  }
  dimensionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dimensionid);
  // @@protoc_insertion_point(field_set_allocated:NS3.DimensionRange.dimensionId)
}

// required float minRange = 2 [default = 0];
inline bool DimensionRange::has_minrange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DimensionRange::set_has_minrange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DimensionRange::clear_has_minrange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DimensionRange::clear_minrange() {
  minrange_ = 0;
  clear_has_minrange();
}
inline float DimensionRange::minrange() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.minRange)
  return minrange_;
}
inline void DimensionRange::set_minrange(float value) {
  set_has_minrange();
  minrange_ = value;
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.minRange)
}

// required float maxRange = 3;
inline bool DimensionRange::has_maxrange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DimensionRange::set_has_maxrange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DimensionRange::clear_has_maxrange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DimensionRange::clear_maxrange() {
  maxrange_ = 0;
  clear_has_maxrange();
}
inline float DimensionRange::maxrange() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.maxRange)
  return maxrange_;
}
inline void DimensionRange::set_maxrange(float value) {
  set_has_maxrange();
  maxrange_ = value;
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.maxRange)
}

// required float flowPenalty = 4 [default = 0];
inline bool DimensionRange::has_flowpenalty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DimensionRange::set_has_flowpenalty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DimensionRange::clear_has_flowpenalty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DimensionRange::clear_flowpenalty() {
  flowpenalty_ = 0;
  clear_has_flowpenalty();
}
inline float DimensionRange::flowpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.DimensionRange.flowPenalty)
  return flowpenalty_;
}
inline void DimensionRange::set_flowpenalty(float value) {
  set_has_flowpenalty();
  flowpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.DimensionRange.flowPenalty)
}

// -------------------------------------------------------------------

// Node_ProductFlow

// required string id = 1;
inline bool Node_ProductFlow::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node_ProductFlow::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node_ProductFlow::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node_ProductFlow::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Node_ProductFlow::id() const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.id)
  return id_.GetNoArena();
}
inline void Node_ProductFlow::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Node.ProductFlow.id)
}
#if LANG_CXX11
inline void Node_ProductFlow::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Node.ProductFlow.id)
}
#endif
inline void Node_ProductFlow::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Node.ProductFlow.id)
}
inline void Node_ProductFlow::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.ProductFlow.id)
}
inline ::std::string* Node_ProductFlow::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node_ProductFlow::release_id() {
  // @@protoc_insertion_point(field_release:NS3.Node.ProductFlow.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_ProductFlow::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.ProductFlow.id)
}

// repeated .NS3.DimensionRange dimensionRanges = 2;
inline int Node_ProductFlow::dimensionranges_size() const {
  return dimensionranges_.size();
}
inline void Node_ProductFlow::clear_dimensionranges() {
  dimensionranges_.Clear();
}
inline ::NS3::DimensionRange* Node_ProductFlow::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_ProductFlow::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.dimensionRanges)
  return &dimensionranges_;
}
inline const ::NS3::DimensionRange& Node_ProductFlow::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_.Get(index);
}
inline ::NS3::DimensionRange* Node_ProductFlow::add_dimensionranges() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_ProductFlow::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.dimensionRanges)
  return dimensionranges_;
}

// repeated .NS3.FixedDimensionCost FixedDimensionCosts = 3;
inline int Node_ProductFlow::fixeddimensioncosts_size() const {
  return fixeddimensioncosts_.size();
}
inline void Node_ProductFlow::clear_fixeddimensioncosts() {
  fixeddimensioncosts_.Clear();
}
inline ::NS3::FixedDimensionCost* Node_ProductFlow::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_ProductFlow::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.FixedDimensionCosts)
  return &fixeddimensioncosts_;
}
inline const ::NS3::FixedDimensionCost& Node_ProductFlow::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_.Get(index);
}
inline ::NS3::FixedDimensionCost* Node_ProductFlow::add_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_ProductFlow::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.FixedDimensionCosts)
  return fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 4;
inline int Node_ProductFlow::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void Node_ProductFlow::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* Node_ProductFlow::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_ProductFlow::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.ProductFlow.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& Node_ProductFlow::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* Node_ProductFlow::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_ProductFlow::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.ProductFlow.unitDimensionCosts)
  return unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node_Flow

// repeated .NS3.DimensionRange dimensionRanges = 1;
inline int Node_Flow::dimensionranges_size() const {
  return dimensionranges_.size();
}
inline void Node_Flow::clear_dimensionranges() {
  dimensionranges_.Clear();
}
inline ::NS3::DimensionRange* Node_Flow::mutable_dimensionranges(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >*
Node_Flow::mutable_dimensionranges() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.dimensionRanges)
  return &dimensionranges_;
}
inline const ::NS3::DimensionRange& Node_Flow::dimensionranges(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_.Get(index);
}
inline ::NS3::DimensionRange* Node_Flow::add_dimensionranges() {
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::DimensionRange >&
Node_Flow::dimensionranges() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.dimensionRanges)
  return dimensionranges_;
}

// repeated .NS3.FixedDimensionCost FixedDimensionCosts = 2;
inline int Node_Flow::fixeddimensioncosts_size() const {
  return fixeddimensioncosts_.size();
}
inline void Node_Flow::clear_fixeddimensioncosts() {
  fixeddimensioncosts_.Clear();
}
inline ::NS3::FixedDimensionCost* Node_Flow::mutable_fixeddimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >*
Node_Flow::mutable_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.FixedDimensionCosts)
  return &fixeddimensioncosts_;
}
inline const ::NS3::FixedDimensionCost& Node_Flow::fixeddimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_.Get(index);
}
inline ::NS3::FixedDimensionCost* Node_Flow::add_fixeddimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FixedDimensionCost >&
Node_Flow::fixeddimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.FixedDimensionCosts)
  return fixeddimensioncosts_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 3;
inline int Node_Flow::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void Node_Flow::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* Node_Flow::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
Node_Flow::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.Flow.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& Node_Flow::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* Node_Flow::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
Node_Flow::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.Node.Flow.unitDimensionCosts)
  return unitdimensioncosts_;
}

// -------------------------------------------------------------------

// Node

// required string id = 1;
inline bool Node::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:NS3.Node.id)
  return id_.GetNoArena();
}
inline void Node::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.Node.id)
}
#if LANG_CXX11
inline void Node::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.Node.id)
}
#endif
inline void Node::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.Node.id)
}
inline void Node::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.id)
}
inline ::std::string* Node::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.Node.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:NS3.Node.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.id)
}

// required .NS3.Geocode geocode = 2;
inline bool Node::has_geocode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_geocode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_geocode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_geocode() {
  if (geocode_ != NULL) geocode_->Clear();
  clear_has_geocode();
}
inline const ::NS3::Geocode& Node::_internal_geocode() const {
  return *geocode_;
}
inline const ::NS3::Geocode& Node::geocode() const {
  const ::NS3::Geocode* p = geocode_;
  // @@protoc_insertion_point(field_get:NS3.Node.geocode)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::Geocode*>(
      &::NS3::_Geocode_default_instance_);
}
inline ::NS3::Geocode* Node::release_geocode() {
  // @@protoc_insertion_point(field_release:NS3.Node.geocode)
  clear_has_geocode();
  ::NS3::Geocode* temp = geocode_;
  geocode_ = NULL;
  return temp;
}
inline ::NS3::Geocode* Node::mutable_geocode() {
  set_has_geocode();
  if (geocode_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::Geocode>(GetArenaNoVirtual());
    geocode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.Node.geocode)
  return geocode_;
}
inline void Node::set_allocated_geocode(::NS3::Geocode* geocode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geocode_;
  }
  if (geocode) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geocode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geocode, submessage_arena);
    }
    set_has_geocode();
  } else {
    clear_has_geocode();
  }
  geocode_ = geocode;
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.geocode)
}

// repeated .NS3.Node.ProductFlow production = 3;
inline int Node::production_size() const {
  return production_.size();
}
inline void Node::clear_production() {
  production_.Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_production(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.production)
  return production_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_production() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.production)
  return &production_;
}
inline const ::NS3::Node_ProductFlow& Node::production(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.production)
  return production_.Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_production() {
  // @@protoc_insertion_point(field_add:NS3.Node.production)
  return production_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::production() const {
  // @@protoc_insertion_point(field_list:NS3.Node.production)
  return production_;
}

// repeated .NS3.Node.ProductFlow consumption = 4;
inline int Node::consumption_size() const {
  return consumption_.size();
}
inline void Node::clear_consumption() {
  consumption_.Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_consumption(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.consumption)
  return consumption_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_consumption() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.consumption)
  return &consumption_;
}
inline const ::NS3::Node_ProductFlow& Node::consumption(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.consumption)
  return consumption_.Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_consumption() {
  // @@protoc_insertion_point(field_add:NS3.Node.consumption)
  return consumption_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::consumption() const {
  // @@protoc_insertion_point(field_list:NS3.Node.consumption)
  return consumption_;
}

// optional .NS3.Node.Flow flow = 5;
inline bool Node::has_flow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_flow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_flow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_flow() {
  if (flow_ != NULL) flow_->Clear();
  clear_has_flow();
}
inline const ::NS3::Node_Flow& Node::_internal_flow() const {
  return *flow_;
}
inline const ::NS3::Node_Flow& Node::flow() const {
  const ::NS3::Node_Flow* p = flow_;
  // @@protoc_insertion_point(field_get:NS3.Node.flow)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::Node_Flow*>(
      &::NS3::_Node_Flow_default_instance_);
}
inline ::NS3::Node_Flow* Node::release_flow() {
  // @@protoc_insertion_point(field_release:NS3.Node.flow)
  clear_has_flow();
  ::NS3::Node_Flow* temp = flow_;
  flow_ = NULL;
  return temp;
}
inline ::NS3::Node_Flow* Node::mutable_flow() {
  set_has_flow();
  if (flow_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::Node_Flow>(GetArenaNoVirtual());
    flow_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.Node.flow)
  return flow_;
}
inline void Node::set_allocated_flow(::NS3::Node_Flow* flow) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete flow_;
  }
  if (flow) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      flow = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, flow, submessage_arena);
    }
    set_has_flow();
  } else {
    clear_has_flow();
  }
  flow_ = flow;
  // @@protoc_insertion_point(field_set_allocated:NS3.Node.flow)
}

// repeated .NS3.Node.ProductFlow productFlows = 6;
inline int Node::productflows_size() const {
  return productflows_.size();
}
inline void Node::clear_productflows() {
  productflows_.Clear();
}
inline ::NS3::Node_ProductFlow* Node::mutable_productflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.productFlows)
  return productflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >*
Node::mutable_productflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.productFlows)
  return &productflows_;
}
inline const ::NS3::Node_ProductFlow& Node::productflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.productFlows)
  return productflows_.Get(index);
}
inline ::NS3::Node_ProductFlow* Node::add_productflows() {
  // @@protoc_insertion_point(field_add:NS3.Node.productFlows)
  return productflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node_ProductFlow >&
Node::productflows() const {
  // @@protoc_insertion_point(field_list:NS3.Node.productFlows)
  return productflows_;
}

// repeated string allowableSources = 7;
inline int Node::allowablesources_size() const {
  return allowablesources_.size();
}
inline void Node::clear_allowablesources() {
  allowablesources_.Clear();
}
inline const ::std::string& Node::allowablesources(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.allowableSources)
  return allowablesources_.Get(index);
}
inline ::std::string* Node::mutable_allowablesources(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.allowableSources)
  return allowablesources_.Mutable(index);
}
inline void Node::set_allowablesources(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.Node.allowableSources)
  allowablesources_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Node::set_allowablesources(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.Node.allowableSources)
  allowablesources_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Node::set_allowablesources(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allowablesources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.Node.allowableSources)
}
inline void Node::set_allowablesources(int index, const char* value, size_t size) {
  allowablesources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.allowableSources)
}
inline ::std::string* Node::add_allowablesources() {
  // @@protoc_insertion_point(field_add_mutable:NS3.Node.allowableSources)
  return allowablesources_.Add();
}
inline void Node::add_allowablesources(const ::std::string& value) {
  allowablesources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.Node.allowableSources)
}
#if LANG_CXX11
inline void Node::add_allowablesources(::std::string&& value) {
  allowablesources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.Node.allowableSources)
}
#endif
inline void Node::add_allowablesources(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allowablesources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.Node.allowableSources)
}
inline void Node::add_allowablesources(const char* value, size_t size) {
  allowablesources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.Node.allowableSources)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::allowablesources() const {
  // @@protoc_insertion_point(field_list:NS3.Node.allowableSources)
  return allowablesources_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_allowablesources() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.allowableSources)
  return &allowablesources_;
}

// optional int32 maximumSources = 8;
inline bool Node::has_maximumsources() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_maximumsources() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_maximumsources() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_maximumsources() {
  maximumsources_ = 0;
  clear_has_maximumsources();
}
inline ::google::protobuf::int32 Node::maximumsources() const {
  // @@protoc_insertion_point(field_get:NS3.Node.maximumSources)
  return maximumsources_;
}
inline void Node::set_maximumsources(::google::protobuf::int32 value) {
  set_has_maximumsources();
  maximumsources_ = value;
  // @@protoc_insertion_point(field_set:NS3.Node.maximumSources)
}

// repeated string allowableServiceClasses = 9;
inline int Node::allowableserviceclasses_size() const {
  return allowableserviceclasses_.size();
}
inline void Node::clear_allowableserviceclasses() {
  allowableserviceclasses_.Clear();
}
inline const ::std::string& Node::allowableserviceclasses(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.allowableServiceClasses)
  return allowableserviceclasses_.Get(index);
}
inline ::std::string* Node::mutable_allowableserviceclasses(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.allowableServiceClasses)
  return allowableserviceclasses_.Mutable(index);
}
inline void Node::set_allowableserviceclasses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.Node.allowableServiceClasses)
  allowableserviceclasses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Node::set_allowableserviceclasses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.Node.allowableServiceClasses)
  allowableserviceclasses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Node::set_allowableserviceclasses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allowableserviceclasses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.Node.allowableServiceClasses)
}
inline void Node::set_allowableserviceclasses(int index, const char* value, size_t size) {
  allowableserviceclasses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.Node.allowableServiceClasses)
}
inline ::std::string* Node::add_allowableserviceclasses() {
  // @@protoc_insertion_point(field_add_mutable:NS3.Node.allowableServiceClasses)
  return allowableserviceclasses_.Add();
}
inline void Node::add_allowableserviceclasses(const ::std::string& value) {
  allowableserviceclasses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.Node.allowableServiceClasses)
}
#if LANG_CXX11
inline void Node::add_allowableserviceclasses(::std::string&& value) {
  allowableserviceclasses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.Node.allowableServiceClasses)
}
#endif
inline void Node::add_allowableserviceclasses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allowableserviceclasses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.Node.allowableServiceClasses)
}
inline void Node::add_allowableserviceclasses(const char* value, size_t size) {
  allowableserviceclasses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.Node.allowableServiceClasses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::allowableserviceclasses() const {
  // @@protoc_insertion_point(field_list:NS3.Node.allowableServiceClasses)
  return allowableserviceclasses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_allowableserviceclasses() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.allowableServiceClasses)
  return &allowableserviceclasses_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 10;
inline int Node::flowconstraints_size() const {
  return flowconstraints_.size();
}
inline void Node::clear_flowconstraints() {
  flowconstraints_.Clear();
}
inline ::NS3::FlowDimensionalConstraint* Node::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Node.flowConstraints)
  return flowconstraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
Node::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Node.flowConstraints)
  return &flowconstraints_;
}
inline const ::NS3::FlowDimensionalConstraint& Node::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Node.flowConstraints)
  return flowconstraints_.Get(index);
}
inline ::NS3::FlowDimensionalConstraint* Node::add_flowconstraints() {
  // @@protoc_insertion_point(field_add:NS3.Node.flowConstraints)
  return flowconstraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
Node::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.Node.flowConstraints)
  return flowconstraints_;
}

// -------------------------------------------------------------------

// ProductGroup_ProductSpecification

// required string baseDimension = 1;
inline bool ProductGroup_ProductSpecification::has_basedimension() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductGroup_ProductSpecification::set_has_basedimension() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductGroup_ProductSpecification::clear_has_basedimension() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductGroup_ProductSpecification::clear_basedimension() {
  basedimension_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_basedimension();
}
inline const ::std::string& ProductGroup_ProductSpecification::basedimension() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.baseDimension)
  return basedimension_.GetNoArena();
}
inline void ProductGroup_ProductSpecification::set_basedimension(const ::std::string& value) {
  set_has_basedimension();
  basedimension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.baseDimension)
}
#if LANG_CXX11
inline void ProductGroup_ProductSpecification::set_basedimension(::std::string&& value) {
  set_has_basedimension();
  basedimension_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.ProductGroup.ProductSpecification.baseDimension)
}
#endif
inline void ProductGroup_ProductSpecification::set_basedimension(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_basedimension();
  basedimension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.ProductSpecification.baseDimension)
}
inline void ProductGroup_ProductSpecification::set_basedimension(const char* value, size_t size) {
  set_has_basedimension();
  basedimension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.ProductSpecification.baseDimension)
}
inline ::std::string* ProductGroup_ProductSpecification::mutable_basedimension() {
  set_has_basedimension();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.ProductSpecification.baseDimension)
  return basedimension_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProductGroup_ProductSpecification::release_basedimension() {
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.ProductSpecification.baseDimension)
  if (!has_basedimension()) {
    return NULL;
  }
  clear_has_basedimension();
  return basedimension_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProductGroup_ProductSpecification::set_allocated_basedimension(::std::string* basedimension) {
  if (basedimension != NULL) {
    set_has_basedimension();
  } else {
    clear_has_basedimension();
  }
  basedimension_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), basedimension);
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.ProductSpecification.baseDimension)
}

// repeated string targetDimension = 2;
inline int ProductGroup_ProductSpecification::targetdimension_size() const {
  return targetdimension_.size();
}
inline void ProductGroup_ProductSpecification::clear_targetdimension() {
  targetdimension_.Clear();
}
inline const ::std::string& ProductGroup_ProductSpecification::targetdimension(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_.Get(index);
}
inline ::std::string* ProductGroup_ProductSpecification::mutable_targetdimension(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_.Mutable(index);
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetDimension)
  targetdimension_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetDimension)
  targetdimension_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  targetdimension_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::set_targetdimension(int index, const char* value, size_t size) {
  targetdimension_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline ::std::string* ProductGroup_ProductSpecification::add_targetdimension() {
  // @@protoc_insertion_point(field_add_mutable:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_.Add();
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const ::std::string& value) {
  targetdimension_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetDimension)
}
#if LANG_CXX11
inline void ProductGroup_ProductSpecification::add_targetdimension(::std::string&& value) {
  targetdimension_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetDimension)
}
#endif
inline void ProductGroup_ProductSpecification::add_targetdimension(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  targetdimension_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline void ProductGroup_ProductSpecification::add_targetdimension(const char* value, size_t size) {
  targetdimension_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.ProductGroup.ProductSpecification.targetDimension)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProductGroup_ProductSpecification::targetdimension() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.ProductSpecification.targetDimension)
  return targetdimension_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProductGroup_ProductSpecification::mutable_targetdimension() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.ProductSpecification.targetDimension)
  return &targetdimension_;
}

// repeated float targetPerBase = 3;
inline int ProductGroup_ProductSpecification::targetperbase_size() const {
  return targetperbase_.size();
}
inline void ProductGroup_ProductSpecification::clear_targetperbase() {
  targetperbase_.Clear();
}
inline float ProductGroup_ProductSpecification::targetperbase(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return targetperbase_.Get(index);
}
inline void ProductGroup_ProductSpecification::set_targetperbase(int index, float value) {
  targetperbase_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.ProductSpecification.targetPerBase)
}
inline void ProductGroup_ProductSpecification::add_targetperbase(float value) {
  targetperbase_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.ProductSpecification.targetPerBase)
}
inline const ::google::protobuf::RepeatedField< float >&
ProductGroup_ProductSpecification::targetperbase() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return targetperbase_;
}
inline ::google::protobuf::RepeatedField< float >*
ProductGroup_ProductSpecification::mutable_targetperbase() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.ProductSpecification.targetPerBase)
  return &targetperbase_;
}

// -------------------------------------------------------------------

// ProductGroup

// required string product = 1;
inline bool ProductGroup::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductGroup::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductGroup::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductGroup::clear_product() {
  product_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_product();
}
inline const ::std::string& ProductGroup::product() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.product)
  return product_.GetNoArena();
}
inline void ProductGroup::set_product(const ::std::string& value) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.product)
}
#if LANG_CXX11
inline void ProductGroup::set_product(::std::string&& value) {
  set_has_product();
  product_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.ProductGroup.product)
}
#endif
inline void ProductGroup::set_product(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.product)
}
inline void ProductGroup::set_product(const char* value, size_t size) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.product)
}
inline ::std::string* ProductGroup::mutable_product() {
  set_has_product();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.product)
  return product_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProductGroup::release_product() {
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.product)
  if (!has_product()) {
    return NULL;
  }
  clear_has_product();
  return product_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProductGroup::set_allocated_product(::std::string* product) {
  if (product != NULL) {
    set_has_product();
  } else {
    clear_has_product();
  }
  product_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product);
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.product)
}

// required string productGroup = 2;
inline bool ProductGroup::has_productgroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductGroup::set_has_productgroup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductGroup::clear_has_productgroup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductGroup::clear_productgroup() {
  productgroup_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productgroup();
}
inline const ::std::string& ProductGroup::productgroup() const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productGroup)
  return productgroup_.GetNoArena();
}
inline void ProductGroup::set_productgroup(const ::std::string& value) {
  set_has_productgroup();
  productgroup_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.ProductGroup.productGroup)
}
#if LANG_CXX11
inline void ProductGroup::set_productgroup(::std::string&& value) {
  set_has_productgroup();
  productgroup_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.ProductGroup.productGroup)
}
#endif
inline void ProductGroup::set_productgroup(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productgroup();
  productgroup_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.ProductGroup.productGroup)
}
inline void ProductGroup::set_productgroup(const char* value, size_t size) {
  set_has_productgroup();
  productgroup_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.ProductGroup.productGroup)
}
inline ::std::string* ProductGroup::mutable_productgroup() {
  set_has_productgroup();
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productGroup)
  return productgroup_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProductGroup::release_productgroup() {
  // @@protoc_insertion_point(field_release:NS3.ProductGroup.productGroup)
  if (!has_productgroup()) {
    return NULL;
  }
  clear_has_productgroup();
  return productgroup_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProductGroup::set_allocated_productgroup(::std::string* productgroup) {
  if (productgroup != NULL) {
    set_has_productgroup();
  } else {
    clear_has_productgroup();
  }
  productgroup_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productgroup);
  // @@protoc_insertion_point(field_set_allocated:NS3.ProductGroup.productGroup)
}

// repeated .NS3.ProductGroup.ProductSpecification productSpecification = 3;
inline int ProductGroup::productspecification_size() const {
  return productspecification_.size();
}
inline void ProductGroup::clear_productspecification() {
  productspecification_.Clear();
}
inline ::NS3::ProductGroup_ProductSpecification* ProductGroup::mutable_productspecification(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.ProductGroup.productSpecification)
  return productspecification_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >*
ProductGroup::mutable_productspecification() {
  // @@protoc_insertion_point(field_mutable_list:NS3.ProductGroup.productSpecification)
  return &productspecification_;
}
inline const ::NS3::ProductGroup_ProductSpecification& ProductGroup::productspecification(int index) const {
  // @@protoc_insertion_point(field_get:NS3.ProductGroup.productSpecification)
  return productspecification_.Get(index);
}
inline ::NS3::ProductGroup_ProductSpecification* ProductGroup::add_productspecification() {
  // @@protoc_insertion_point(field_add:NS3.ProductGroup.productSpecification)
  return productspecification_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup_ProductSpecification >&
ProductGroup::productspecification() const {
  // @@protoc_insertion_point(field_list:NS3.ProductGroup.productSpecification)
  return productspecification_;
}

// -------------------------------------------------------------------

// LaneRate

// required string id = 1;
inline bool LaneRate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneRate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneRate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneRate::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LaneRate::id() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.id)
  return id_.GetNoArena();
}
inline void LaneRate::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.id)
}
#if LANG_CXX11
inline void LaneRate::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.LaneRate.id)
}
#endif
inline void LaneRate::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.id)
}
inline void LaneRate::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.id)
}
inline ::std::string* LaneRate::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRate::release_id() {
  // @@protoc_insertion_point(field_release:NS3.LaneRate.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRate::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.id)
}

// required string source = 3;
inline bool LaneRate::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneRate::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneRate::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneRate::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& LaneRate::source() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.source)
  return source_.GetNoArena();
}
inline void LaneRate::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.source)
}
#if LANG_CXX11
inline void LaneRate::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.LaneRate.source)
}
#endif
inline void LaneRate::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.source)
}
inline void LaneRate::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.source)
}
inline ::std::string* LaneRate::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRate::release_source() {
  // @@protoc_insertion_point(field_release:NS3.LaneRate.source)
  if (!has_source()) {
    return NULL;
  }
  clear_has_source();
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRate::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.source)
}

// required string destination = 4;
inline bool LaneRate::has_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneRate::set_has_destination() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneRate::clear_has_destination() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneRate::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination();
}
inline const ::std::string& LaneRate::destination() const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.destination)
  return destination_.GetNoArena();
}
inline void LaneRate::set_destination(const ::std::string& value) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.LaneRate.destination)
}
#if LANG_CXX11
inline void LaneRate::set_destination(::std::string&& value) {
  set_has_destination();
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.LaneRate.destination)
}
#endif
inline void LaneRate::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.destination)
}
inline void LaneRate::set_destination(const char* value, size_t size) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.destination)
}
inline ::std::string* LaneRate::mutable_destination() {
  set_has_destination();
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneRate::release_destination() {
  // @@protoc_insertion_point(field_release:NS3.LaneRate.destination)
  if (!has_destination()) {
    return NULL;
  }
  clear_has_destination();
  return destination_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneRate::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:NS3.LaneRate.destination)
}

// repeated string productIds = 5;
inline int LaneRate::productids_size() const {
  return productids_.size();
}
inline void LaneRate::clear_productids() {
  productids_.Clear();
}
inline const ::std::string& LaneRate::productids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.productIds)
  return productids_.Get(index);
}
inline ::std::string* LaneRate::mutable_productids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.productIds)
  return productids_.Mutable(index);
}
inline void LaneRate::set_productids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productIds)
  productids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LaneRate::set_productids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productIds)
  productids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LaneRate::set_productids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.productIds)
}
inline void LaneRate::set_productids(int index, const char* value, size_t size) {
  productids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.productIds)
}
inline ::std::string* LaneRate::add_productids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.LaneRate.productIds)
  return productids_.Add();
}
inline void LaneRate::add_productids(const ::std::string& value) {
  productids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productIds)
}
#if LANG_CXX11
inline void LaneRate::add_productids(::std::string&& value) {
  productids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productIds)
}
#endif
inline void LaneRate::add_productids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.LaneRate.productIds)
}
inline void LaneRate::add_productids(const char* value, size_t size) {
  productids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.LaneRate.productIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LaneRate::productids() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.productIds)
  return productids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LaneRate::mutable_productids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.productIds)
  return &productids_;
}

// repeated string productGroupIds = 6;
inline int LaneRate::productgroupids_size() const {
  return productgroupids_.size();
}
inline void LaneRate::clear_productgroupids() {
  productgroupids_.Clear();
}
inline const ::std::string& LaneRate::productgroupids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.productGroupIds)
  return productgroupids_.Get(index);
}
inline ::std::string* LaneRate::mutable_productgroupids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.productGroupIds)
  return productgroupids_.Mutable(index);
}
inline void LaneRate::set_productgroupids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productGroupIds)
  productgroupids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LaneRate::set_productgroupids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.LaneRate.productGroupIds)
  productgroupids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LaneRate::set_productgroupids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::set_productgroupids(int index, const char* value, size_t size) {
  productgroupids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.LaneRate.productGroupIds)
}
inline ::std::string* LaneRate::add_productgroupids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.LaneRate.productGroupIds)
  return productgroupids_.Add();
}
inline void LaneRate::add_productgroupids(const ::std::string& value) {
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productGroupIds)
}
#if LANG_CXX11
inline void LaneRate::add_productgroupids(::std::string&& value) {
  productgroupids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.LaneRate.productGroupIds)
}
#endif
inline void LaneRate::add_productgroupids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.LaneRate.productGroupIds)
}
inline void LaneRate::add_productgroupids(const char* value, size_t size) {
  productgroupids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.LaneRate.productGroupIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LaneRate::productgroupids() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.productGroupIds)
  return productgroupids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LaneRate::mutable_productgroupids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.productGroupIds)
  return &productgroupids_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCosts = 7;
inline int LaneRate::unitdimensioncosts_size() const {
  return unitdimensioncosts_.size();
}
inline void LaneRate::clear_unitdimensioncosts() {
  unitdimensioncosts_.Clear();
}
inline ::NS3::UnitDimensionCost* LaneRate::mutable_unitdimensioncosts(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
LaneRate::mutable_unitdimensioncosts() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.unitDimensionCosts)
  return &unitdimensioncosts_;
}
inline const ::NS3::UnitDimensionCost& LaneRate::unitdimensioncosts(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_.Get(index);
}
inline ::NS3::UnitDimensionCost* LaneRate::add_unitdimensioncosts() {
  // @@protoc_insertion_point(field_add:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
LaneRate::unitdimensioncosts() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.unitDimensionCosts)
  return unitdimensioncosts_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 8;
inline int LaneRate::flowconstraints_size() const {
  return flowconstraints_.size();
}
inline void LaneRate::clear_flowconstraints() {
  flowconstraints_.Clear();
}
inline ::NS3::FlowDimensionalConstraint* LaneRate::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.LaneRate.flowConstraints)
  return flowconstraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
LaneRate::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.LaneRate.flowConstraints)
  return &flowconstraints_;
}
inline const ::NS3::FlowDimensionalConstraint& LaneRate::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.LaneRate.flowConstraints)
  return flowconstraints_.Get(index);
}
inline ::NS3::FlowDimensionalConstraint* LaneRate::add_flowconstraints() {
  // @@protoc_insertion_point(field_add:NS3.LaneRate.flowConstraints)
  return flowconstraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
LaneRate::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.LaneRate.flowConstraints)
  return flowconstraints_;
}

// -------------------------------------------------------------------

// CostModel

// required string id = 1;
inline bool CostModel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CostModel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CostModel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CostModel::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& CostModel::id() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.id)
  return id_.GetNoArena();
}
inline void CostModel::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.id)
}
#if LANG_CXX11
inline void CostModel::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.CostModel.id)
}
#endif
inline void CostModel::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.id)
}
inline void CostModel::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.id)
}
inline ::std::string* CostModel::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostModel::release_id() {
  // @@protoc_insertion_point(field_release:NS3.CostModel.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CostModel::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.id)
}

// required string source = 3;
inline bool CostModel::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CostModel::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CostModel::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CostModel::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& CostModel::source() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.source)
  return source_.GetNoArena();
}
inline void CostModel::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.source)
}
#if LANG_CXX11
inline void CostModel::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.CostModel.source)
}
#endif
inline void CostModel::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.source)
}
inline void CostModel::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.source)
}
inline ::std::string* CostModel::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostModel::release_source() {
  // @@protoc_insertion_point(field_release:NS3.CostModel.source)
  if (!has_source()) {
    return NULL;
  }
  clear_has_source();
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CostModel::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.source)
}

// optional string destination = 4;
inline bool CostModel::has_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CostModel::set_has_destination() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CostModel::clear_has_destination() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CostModel::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination();
}
inline const ::std::string& CostModel::destination() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.destination)
  return destination_.GetNoArena();
}
inline void CostModel::set_destination(const ::std::string& value) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.destination)
}
#if LANG_CXX11
inline void CostModel::set_destination(::std::string&& value) {
  set_has_destination();
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.CostModel.destination)
}
#endif
inline void CostModel::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.destination)
}
inline void CostModel::set_destination(const char* value, size_t size) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.destination)
}
inline ::std::string* CostModel::mutable_destination() {
  set_has_destination();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostModel::release_destination() {
  // @@protoc_insertion_point(field_release:NS3.CostModel.destination)
  if (!has_destination()) {
    return NULL;
  }
  clear_has_destination();
  return destination_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CostModel::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.destination)
}

// repeated string productGroupIds = 5;
inline int CostModel::productgroupids_size() const {
  return productgroupids_.size();
}
inline void CostModel::clear_productgroupids() {
  productgroupids_.Clear();
}
inline const ::std::string& CostModel::productgroupids(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.productGroupIds)
  return productgroupids_.Get(index);
}
inline ::std::string* CostModel::mutable_productgroupids(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.productGroupIds)
  return productgroupids_.Mutable(index);
}
inline void CostModel::set_productgroupids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NS3.CostModel.productGroupIds)
  productgroupids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CostModel::set_productgroupids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NS3.CostModel.productGroupIds)
  productgroupids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CostModel::set_productgroupids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.productGroupIds)
}
inline void CostModel::set_productgroupids(int index, const char* value, size_t size) {
  productgroupids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.productGroupIds)
}
inline ::std::string* CostModel::add_productgroupids() {
  // @@protoc_insertion_point(field_add_mutable:NS3.CostModel.productGroupIds)
  return productgroupids_.Add();
}
inline void CostModel::add_productgroupids(const ::std::string& value) {
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NS3.CostModel.productGroupIds)
}
#if LANG_CXX11
inline void CostModel::add_productgroupids(::std::string&& value) {
  productgroupids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NS3.CostModel.productGroupIds)
}
#endif
inline void CostModel::add_productgroupids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productgroupids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NS3.CostModel.productGroupIds)
}
inline void CostModel::add_productgroupids(const char* value, size_t size) {
  productgroupids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NS3.CostModel.productGroupIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostModel::productgroupids() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.productGroupIds)
  return productgroupids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostModel::mutable_productgroupids() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.productGroupIds)
  return &productgroupids_;
}

// repeated .NS3.UnitDimensionCost unitDimensionCost = 6;
inline int CostModel::unitdimensioncost_size() const {
  return unitdimensioncost_.size();
}
inline void CostModel::clear_unitdimensioncost() {
  unitdimensioncost_.Clear();
}
inline ::NS3::UnitDimensionCost* CostModel::mutable_unitdimensioncost(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.unitDimensionCost)
  return unitdimensioncost_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >*
CostModel::mutable_unitdimensioncost() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.unitDimensionCost)
  return &unitdimensioncost_;
}
inline const ::NS3::UnitDimensionCost& CostModel::unitdimensioncost(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.unitDimensionCost)
  return unitdimensioncost_.Get(index);
}
inline ::NS3::UnitDimensionCost* CostModel::add_unitdimensioncost() {
  // @@protoc_insertion_point(field_add:NS3.CostModel.unitDimensionCost)
  return unitdimensioncost_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::UnitDimensionCost >&
CostModel::unitdimensioncost() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.unitDimensionCost)
  return unitdimensioncost_;
}

// repeated .NS3.FlowDimensionalConstraint flowConstraints = 7;
inline int CostModel::flowconstraints_size() const {
  return flowconstraints_.size();
}
inline void CostModel::clear_flowconstraints() {
  flowconstraints_.Clear();
}
inline ::NS3::FlowDimensionalConstraint* CostModel::mutable_flowconstraints(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.flowConstraints)
  return flowconstraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >*
CostModel::mutable_flowconstraints() {
  // @@protoc_insertion_point(field_mutable_list:NS3.CostModel.flowConstraints)
  return &flowconstraints_;
}
inline const ::NS3::FlowDimensionalConstraint& CostModel::flowconstraints(int index) const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.flowConstraints)
  return flowconstraints_.Get(index);
}
inline ::NS3::FlowDimensionalConstraint* CostModel::add_flowconstraints() {
  // @@protoc_insertion_point(field_add:NS3.CostModel.flowConstraints)
  return flowconstraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::FlowDimensionalConstraint >&
CostModel::flowconstraints() const {
  // @@protoc_insertion_point(field_list:NS3.CostModel.flowConstraints)
  return flowconstraints_;
}

// optional string serviceClass = 8;
inline bool CostModel::has_serviceclass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CostModel::set_has_serviceclass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CostModel::clear_has_serviceclass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CostModel::clear_serviceclass() {
  serviceclass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serviceclass();
}
inline const ::std::string& CostModel::serviceclass() const {
  // @@protoc_insertion_point(field_get:NS3.CostModel.serviceClass)
  return serviceclass_.GetNoArena();
}
inline void CostModel::set_serviceclass(const ::std::string& value) {
  set_has_serviceclass();
  serviceclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.CostModel.serviceClass)
}
#if LANG_CXX11
inline void CostModel::set_serviceclass(::std::string&& value) {
  set_has_serviceclass();
  serviceclass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.CostModel.serviceClass)
}
#endif
inline void CostModel::set_serviceclass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serviceclass();
  serviceclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.CostModel.serviceClass)
}
inline void CostModel::set_serviceclass(const char* value, size_t size) {
  set_has_serviceclass();
  serviceclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.CostModel.serviceClass)
}
inline ::std::string* CostModel::mutable_serviceclass() {
  set_has_serviceclass();
  // @@protoc_insertion_point(field_mutable:NS3.CostModel.serviceClass)
  return serviceclass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostModel::release_serviceclass() {
  // @@protoc_insertion_point(field_release:NS3.CostModel.serviceClass)
  if (!has_serviceclass()) {
    return NULL;
  }
  clear_has_serviceclass();
  return serviceclass_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CostModel::set_allocated_serviceclass(::std::string* serviceclass) {
  if (serviceclass != NULL) {
    set_has_serviceclass();
  } else {
    clear_has_serviceclass();
  }
  serviceclass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serviceclass);
  // @@protoc_insertion_point(field_set_allocated:NS3.CostModel.serviceClass)
}

// -------------------------------------------------------------------

// Model

// repeated .NS3.Dimension dimensions = 1;
inline int Model::dimensions_size() const {
  return dimensions_.size();
}
inline void Model::clear_dimensions() {
  dimensions_.Clear();
}
inline ::NS3::Dimension* Model::mutable_dimensions(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.dimensions)
  return dimensions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Dimension >*
Model::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.dimensions)
  return &dimensions_;
}
inline const ::NS3::Dimension& Model::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.dimensions)
  return dimensions_.Get(index);
}
inline ::NS3::Dimension* Model::add_dimensions() {
  // @@protoc_insertion_point(field_add:NS3.Model.dimensions)
  return dimensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Dimension >&
Model::dimensions() const {
  // @@protoc_insertion_point(field_list:NS3.Model.dimensions)
  return dimensions_;
}

// repeated .NS3.Node nodes = 2;
inline int Model::nodes_size() const {
  return nodes_.size();
}
inline void Model::clear_nodes() {
  nodes_.Clear();
}
inline ::NS3::Node* Model::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Node >*
Model::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.nodes)
  return &nodes_;
}
inline const ::NS3::Node& Model::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.nodes)
  return nodes_.Get(index);
}
inline ::NS3::Node* Model::add_nodes() {
  // @@protoc_insertion_point(field_add:NS3.Model.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Node >&
Model::nodes() const {
  // @@protoc_insertion_point(field_list:NS3.Model.nodes)
  return nodes_;
}

// repeated .NS3.LaneRate laneRates = 3;
inline int Model::lanerates_size() const {
  return lanerates_.size();
}
inline void Model::clear_lanerates() {
  lanerates_.Clear();
}
inline ::NS3::LaneRate* Model::mutable_lanerates(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.laneRates)
  return lanerates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >*
Model::mutable_lanerates() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.laneRates)
  return &lanerates_;
}
inline const ::NS3::LaneRate& Model::lanerates(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.laneRates)
  return lanerates_.Get(index);
}
inline ::NS3::LaneRate* Model::add_lanerates() {
  // @@protoc_insertion_point(field_add:NS3.Model.laneRates)
  return lanerates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::LaneRate >&
Model::lanerates() const {
  // @@protoc_insertion_point(field_list:NS3.Model.laneRates)
  return lanerates_;
}

// repeated .NS3.CostModel costModels = 4;
inline int Model::costmodels_size() const {
  return costmodels_.size();
}
inline void Model::clear_costmodels() {
  costmodels_.Clear();
}
inline ::NS3::CostModel* Model::mutable_costmodels(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.costModels)
  return costmodels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >*
Model::mutable_costmodels() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.costModels)
  return &costmodels_;
}
inline const ::NS3::CostModel& Model::costmodels(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.costModels)
  return costmodels_.Get(index);
}
inline ::NS3::CostModel* Model::add_costmodels() {
  // @@protoc_insertion_point(field_add:NS3.Model.costModels)
  return costmodels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::CostModel >&
Model::costmodels() const {
  // @@protoc_insertion_point(field_list:NS3.Model.costModels)
  return costmodels_;
}

// repeated .NS3.ProductGroup productGroups = 5;
inline int Model::productgroups_size() const {
  return productgroups_.size();
}
inline void Model::clear_productgroups() {
  productgroups_.Clear();
}
inline ::NS3::ProductGroup* Model::mutable_productgroups(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.Model.productGroups)
  return productgroups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >*
Model::mutable_productgroups() {
  // @@protoc_insertion_point(field_mutable_list:NS3.Model.productGroups)
  return &productgroups_;
}
inline const ::NS3::ProductGroup& Model::productgroups(int index) const {
  // @@protoc_insertion_point(field_get:NS3.Model.productGroups)
  return productgroups_.Get(index);
}
inline ::NS3::ProductGroup* Model::add_productgroups() {
  // @@protoc_insertion_point(field_add:NS3.Model.productGroups)
  return productgroups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::ProductGroup >&
Model::productgroups() const {
  // @@protoc_insertion_point(field_list:NS3.Model.productGroups)
  return productgroups_;
}

// -------------------------------------------------------------------

// SolveRequest

// optional .NS3.Model model = 1;
inline bool SolveRequest::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolveRequest::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolveRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolveRequest::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::NS3::Model& SolveRequest::_internal_model() const {
  return *model_;
}
inline const ::NS3::Model& SolveRequest::model() const {
  const ::NS3::Model* p = model_;
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.model)
  return p != NULL ? *p : *reinterpret_cast<const ::NS3::Model*>(
      &::NS3::_Model_default_instance_);
}
inline ::NS3::Model* SolveRequest::release_model() {
  // @@protoc_insertion_point(field_release:NS3.SolveRequest.model)
  clear_has_model();
  ::NS3::Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::NS3::Model* SolveRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    auto* p = CreateMaybeMessage<::NS3::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NS3.SolveRequest.model)
  return model_;
}
inline void SolveRequest::set_allocated_model(::NS3::Model* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:NS3.SolveRequest.model)
}

// optional string modelID = 2;
inline bool SolveRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolveRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolveRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolveRequest::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& SolveRequest::modelid() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.modelID)
  return modelid_.GetNoArena();
}
inline void SolveRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.modelID)
}
#if LANG_CXX11
inline void SolveRequest::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolveRequest.modelID)
}
#endif
inline void SolveRequest::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolveRequest.modelID)
}
inline void SolveRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolveRequest.modelID)
}
inline ::std::string* SolveRequest::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:NS3.SolveRequest.modelID)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolveRequest::release_modelid() {
  // @@protoc_insertion_point(field_release:NS3.SolveRequest.modelID)
  if (!has_modelid()) {
    return NULL;
  }
  clear_has_modelid();
  return modelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolveRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolveRequest.modelID)
}

// optional .NS3.SolveRequest.SolveType solveType = 4 [default = Optimise];
inline bool SolveRequest::has_solvetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolveRequest::set_has_solvetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolveRequest::clear_has_solvetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolveRequest::clear_solvetype() {
  solvetype_ = 0;
  clear_has_solvetype();
}
inline ::NS3::SolveRequest_SolveType SolveRequest::solvetype() const {
  // @@protoc_insertion_point(field_get:NS3.SolveRequest.solveType)
  return static_cast< ::NS3::SolveRequest_SolveType >(solvetype_);
}
inline void SolveRequest::set_solvetype(::NS3::SolveRequest_SolveType value) {
  assert(::NS3::SolveRequest_SolveType_IsValid(value));
  set_has_solvetype();
  solvetype_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolveRequest.solveType)
}

// -------------------------------------------------------------------

// SolutionResponse_Assignment

// required string source = 1;
inline bool SolutionResponse_Assignment::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_Assignment::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_Assignment::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_Assignment::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& SolutionResponse_Assignment::source() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.source)
  return source_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.source)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.source)
}
#endif
inline void SolutionResponse_Assignment::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.source)
}
inline void SolutionResponse_Assignment::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.source)
}
inline ::std::string* SolutionResponse_Assignment::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_source() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.source)
  if (!has_source()) {
    return NULL;
  }
  clear_has_source();
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.source)
}

// required string destination = 2;
inline bool SolutionResponse_Assignment::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_Assignment::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_Assignment::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_Assignment::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination();
}
inline const ::std::string& SolutionResponse_Assignment::destination() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.destination)
  return destination_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_destination(const ::std::string& value) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.destination)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_destination(::std::string&& value) {
  set_has_destination();
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.destination)
}
#endif
inline void SolutionResponse_Assignment::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.destination)
}
inline void SolutionResponse_Assignment::set_destination(const char* value, size_t size) {
  set_has_destination();
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.destination)
}
inline ::std::string* SolutionResponse_Assignment::mutable_destination() {
  set_has_destination();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_destination() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.destination)
  if (!has_destination()) {
    return NULL;
  }
  clear_has_destination();
  return destination_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.destination)
}

// required string productId = 3;
inline bool SolutionResponse_Assignment::has_productid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_Assignment::set_has_productid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_Assignment::clear_has_productid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_Assignment::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& SolutionResponse_Assignment::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.productId)
  return productid_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.productId)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.productId)
}
#endif
inline void SolutionResponse_Assignment::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.productId)
}
inline void SolutionResponse_Assignment::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.productId)
}
inline ::std::string* SolutionResponse_Assignment::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.productId)
}

// required float amount = 4;
inline bool SolutionResponse_Assignment::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_Assignment::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_Assignment::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_Assignment::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline float SolutionResponse_Assignment::amount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.amount)
  return amount_;
}
inline void SolutionResponse_Assignment::set_amount(float value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.amount)
}

// required float cost = 5;
inline bool SolutionResponse_Assignment::has_cost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_Assignment::set_has_cost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_Assignment::clear_has_cost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_Assignment::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline float SolutionResponse_Assignment::cost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.cost)
  return cost_;
}
inline void SolutionResponse_Assignment::set_cost(float value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.cost)
}

// optional string laneRateId = 6;
inline bool SolutionResponse_Assignment::has_lanerateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_Assignment::set_has_lanerateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_Assignment::clear_has_lanerateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_Assignment::clear_lanerateid() {
  lanerateid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lanerateid();
}
inline const ::std::string& SolutionResponse_Assignment::lanerateid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.laneRateId)
  return lanerateid_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_lanerateid(const ::std::string& value) {
  set_has_lanerateid();
  lanerateid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.laneRateId)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_lanerateid(::std::string&& value) {
  set_has_lanerateid();
  lanerateid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.laneRateId)
}
#endif
inline void SolutionResponse_Assignment::set_lanerateid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lanerateid();
  lanerateid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.laneRateId)
}
inline void SolutionResponse_Assignment::set_lanerateid(const char* value, size_t size) {
  set_has_lanerateid();
  lanerateid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.laneRateId)
}
inline ::std::string* SolutionResponse_Assignment::mutable_lanerateid() {
  set_has_lanerateid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.laneRateId)
  return lanerateid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_lanerateid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.laneRateId)
  if (!has_lanerateid()) {
    return NULL;
  }
  clear_has_lanerateid();
  return lanerateid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_lanerateid(::std::string* lanerateid) {
  if (lanerateid != NULL) {
    set_has_lanerateid();
  } else {
    clear_has_lanerateid();
  }
  lanerateid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lanerateid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.laneRateId)
}

// optional string costModelId = 7;
inline bool SolutionResponse_Assignment::has_costmodelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_Assignment::set_has_costmodelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_Assignment::clear_has_costmodelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_Assignment::clear_costmodelid() {
  costmodelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_costmodelid();
}
inline const ::std::string& SolutionResponse_Assignment::costmodelid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.costModelId)
  return costmodelid_.GetNoArena();
}
inline void SolutionResponse_Assignment::set_costmodelid(const ::std::string& value) {
  set_has_costmodelid();
  costmodelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.costModelId)
}
#if LANG_CXX11
inline void SolutionResponse_Assignment::set_costmodelid(::std::string&& value) {
  set_has_costmodelid();
  costmodelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.Assignment.costModelId)
}
#endif
inline void SolutionResponse_Assignment::set_costmodelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_costmodelid();
  costmodelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.Assignment.costModelId)
}
inline void SolutionResponse_Assignment::set_costmodelid(const char* value, size_t size) {
  set_has_costmodelid();
  costmodelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.Assignment.costModelId)
}
inline ::std::string* SolutionResponse_Assignment::mutable_costmodelid() {
  set_has_costmodelid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.costModelId)
  return costmodelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_Assignment::release_costmodelid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.Assignment.costModelId)
  if (!has_costmodelid()) {
    return NULL;
  }
  clear_has_costmodelid();
  return costmodelid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_Assignment::set_allocated_costmodelid(::std::string* costmodelid) {
  if (costmodelid != NULL) {
    set_has_costmodelid();
  } else {
    clear_has_costmodelid();
  }
  costmodelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), costmodelid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.Assignment.costModelId)
}

// required float distance = 8;
inline bool SolutionResponse_Assignment::has_distance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_Assignment::set_has_distance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_Assignment::clear_has_distance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_Assignment::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float SolutionResponse_Assignment::distance() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.distance)
  return distance_;
}
inline void SolutionResponse_Assignment::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.distance)
}

// required float duration = 9;
inline bool SolutionResponse_Assignment::has_duration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolutionResponse_Assignment::set_has_duration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolutionResponse_Assignment::clear_has_duration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolutionResponse_Assignment::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float SolutionResponse_Assignment::duration() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.duration)
  return duration_;
}
inline void SolutionResponse_Assignment::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.Assignment.duration)
}

// repeated .NS3.Geocode geometry = 10;
inline int SolutionResponse_Assignment::geometry_size() const {
  return geometry_.size();
}
inline void SolutionResponse_Assignment::clear_geometry() {
  geometry_.Clear();
}
inline ::NS3::Geocode* SolutionResponse_Assignment::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.Assignment.geometry)
  return geometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::Geocode >*
SolutionResponse_Assignment::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.Assignment.geometry)
  return &geometry_;
}
inline const ::NS3::Geocode& SolutionResponse_Assignment::geometry(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.Assignment.geometry)
  return geometry_.Get(index);
}
inline ::NS3::Geocode* SolutionResponse_Assignment::add_geometry() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.Assignment.geometry)
  return geometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::Geocode >&
SolutionResponse_Assignment::geometry() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.Assignment.geometry)
  return geometry_;
}

// -------------------------------------------------------------------

// SolutionResponse_NodeProductFlow

// required string nodeId = 1;
inline bool SolutionResponse_NodeProductFlow::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_NodeProductFlow::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& SolutionResponse_NodeProductFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.nodeId)
  return nodeid_.GetNoArena();
}
inline void SolutionResponse_NodeProductFlow::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductFlow::set_nodeid(::std::string&& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
#endif
inline void SolutionResponse_NodeProductFlow::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
inline void SolutionResponse_NodeProductFlow::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductFlow.nodeId)
}
inline ::std::string* SolutionResponse_NodeProductFlow::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductFlow.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductFlow::release_nodeid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductFlow.nodeId)
  if (!has_nodeid()) {
    return NULL;
  }
  clear_has_nodeid();
  return nodeid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductFlow::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductFlow.nodeId)
}

// required string productId = 2;
inline bool SolutionResponse_NodeProductFlow::has_productid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_NodeProductFlow::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& SolutionResponse_NodeProductFlow::productid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productId)
  return productid_.GetNoArena();
}
inline void SolutionResponse_NodeProductFlow::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeProductFlow::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeProductFlow.productId)
}
#endif
inline void SolutionResponse_NodeProductFlow::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeProductFlow.productId)
}
inline void SolutionResponse_NodeProductFlow::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeProductFlow.productId)
}
inline ::std::string* SolutionResponse_NodeProductFlow::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeProductFlow.productId)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeProductFlow::release_productid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeProductFlow.productId)
  if (!has_productid()) {
    return NULL;
  }
  clear_has_productid();
  return productid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeProductFlow::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeProductFlow.productId)
}

// required float inFlow = 3;
inline bool SolutionResponse_NodeProductFlow::has_inflow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_inflow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_inflow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_NodeProductFlow::clear_inflow() {
  inflow_ = 0;
  clear_has_inflow();
}
inline float SolutionResponse_NodeProductFlow::inflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.inFlow)
  return inflow_;
}
inline void SolutionResponse_NodeProductFlow::set_inflow(float value) {
  set_has_inflow();
  inflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.inFlow)
}

// required float outFlow = 4;
inline bool SolutionResponse_NodeProductFlow::has_outflow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_outflow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_outflow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_NodeProductFlow::clear_outflow() {
  outflow_ = 0;
  clear_has_outflow();
}
inline float SolutionResponse_NodeProductFlow::outflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.outFlow)
  return outflow_;
}
inline void SolutionResponse_NodeProductFlow::set_outflow(float value) {
  set_has_outflow();
  outflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.outFlow)
}

// required float flowCost = 5;
inline bool SolutionResponse_NodeProductFlow::has_flowcost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_flowcost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_flowcost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_NodeProductFlow::clear_flowcost() {
  flowcost_ = 0;
  clear_has_flowcost();
}
inline float SolutionResponse_NodeProductFlow::flowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.flowCost)
  return flowcost_;
}
inline void SolutionResponse_NodeProductFlow::set_flowcost(float value) {
  set_has_flowcost();
  flowcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.flowCost)
}

// required float fixedCost = 6;
inline bool SolutionResponse_NodeProductFlow::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_NodeProductFlow::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float SolutionResponse_NodeProductFlow::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.fixedCost)
  return fixedcost_;
}
inline void SolutionResponse_NodeProductFlow::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.fixedCost)
}

// required float productionAmount = 7;
inline bool SolutionResponse_NodeProductFlow::has_productionamount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productionamount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productionamount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_NodeProductFlow::clear_productionamount() {
  productionamount_ = 0;
  clear_has_productionamount();
}
inline float SolutionResponse_NodeProductFlow::productionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionAmount)
  return productionamount_;
}
inline void SolutionResponse_NodeProductFlow::set_productionamount(float value) {
  set_has_productionamount();
  productionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionAmount)
}

// required float productionPenalty = 8;
inline bool SolutionResponse_NodeProductFlow::has_productionpenalty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productionpenalty() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productionpenalty() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_NodeProductFlow::clear_productionpenalty() {
  productionpenalty_ = 0;
  clear_has_productionpenalty();
}
inline float SolutionResponse_NodeProductFlow::productionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionPenalty)
  return productionpenalty_;
}
inline void SolutionResponse_NodeProductFlow::set_productionpenalty(float value) {
  set_has_productionpenalty();
  productionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionPenalty)
}

// required float productionCost = 9;
inline bool SolutionResponse_NodeProductFlow::has_productioncost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_productioncost() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_productioncost() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolutionResponse_NodeProductFlow::clear_productioncost() {
  productioncost_ = 0;
  clear_has_productioncost();
}
inline float SolutionResponse_NodeProductFlow::productioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.productionCost)
  return productioncost_;
}
inline void SolutionResponse_NodeProductFlow::set_productioncost(float value) {
  set_has_productioncost();
  productioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.productionCost)
}

// required float consumptionAmount = 10;
inline bool SolutionResponse_NodeProductFlow::has_consumptionamount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_consumptionamount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_consumptionamount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptionamount() {
  consumptionamount_ = 0;
  clear_has_consumptionamount();
}
inline float SolutionResponse_NodeProductFlow::consumptionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionAmount)
  return consumptionamount_;
}
inline void SolutionResponse_NodeProductFlow::set_consumptionamount(float value) {
  set_has_consumptionamount();
  consumptionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionAmount)
}

// required float consumptionPenalty = 11;
inline bool SolutionResponse_NodeProductFlow::has_consumptionpenalty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_consumptionpenalty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_consumptionpenalty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptionpenalty() {
  consumptionpenalty_ = 0;
  clear_has_consumptionpenalty();
}
inline float SolutionResponse_NodeProductFlow::consumptionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionPenalty)
  return consumptionpenalty_;
}
inline void SolutionResponse_NodeProductFlow::set_consumptionpenalty(float value) {
  set_has_consumptionpenalty();
  consumptionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionPenalty)
}

// required float consumptionCost = 12;
inline bool SolutionResponse_NodeProductFlow::has_consumptioncost() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolutionResponse_NodeProductFlow::set_has_consumptioncost() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolutionResponse_NodeProductFlow::clear_has_consumptioncost() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolutionResponse_NodeProductFlow::clear_consumptioncost() {
  consumptioncost_ = 0;
  clear_has_consumptioncost();
}
inline float SolutionResponse_NodeProductFlow::consumptioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeProductFlow.consumptionCost)
  return consumptioncost_;
}
inline void SolutionResponse_NodeProductFlow::set_consumptioncost(float value) {
  set_has_consumptioncost();
  consumptioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeProductFlow.consumptionCost)
}

// -------------------------------------------------------------------

// SolutionResponse_NodeFlow

// required string nodeId = 1;
inline bool SolutionResponse_NodeFlow::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse_NodeFlow::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse_NodeFlow::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& SolutionResponse_NodeFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.nodeId)
  return nodeid_.GetNoArena();
}
inline void SolutionResponse_NodeFlow::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.nodeId)
}
#if LANG_CXX11
inline void SolutionResponse_NodeFlow::set_nodeid(::std::string&& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NS3.SolutionResponse.NodeFlow.nodeId)
}
#endif
inline void SolutionResponse_NodeFlow::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NS3.SolutionResponse.NodeFlow.nodeId)
}
inline void SolutionResponse_NodeFlow::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NS3.SolutionResponse.NodeFlow.nodeId)
}
inline ::std::string* SolutionResponse_NodeFlow::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.NodeFlow.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SolutionResponse_NodeFlow::release_nodeid() {
  // @@protoc_insertion_point(field_release:NS3.SolutionResponse.NodeFlow.nodeId)
  if (!has_nodeid()) {
    return NULL;
  }
  clear_has_nodeid();
  return nodeid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SolutionResponse_NodeFlow::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:NS3.SolutionResponse.NodeFlow.nodeId)
}

// required float inFlow = 2;
inline bool SolutionResponse_NodeFlow::has_inflow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_inflow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse_NodeFlow::clear_has_inflow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse_NodeFlow::clear_inflow() {
  inflow_ = 0;
  clear_has_inflow();
}
inline float SolutionResponse_NodeFlow::inflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.inFlow)
  return inflow_;
}
inline void SolutionResponse_NodeFlow::set_inflow(float value) {
  set_has_inflow();
  inflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.inFlow)
}

// required float outFlow = 3;
inline bool SolutionResponse_NodeFlow::has_outflow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_outflow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse_NodeFlow::clear_has_outflow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse_NodeFlow::clear_outflow() {
  outflow_ = 0;
  clear_has_outflow();
}
inline float SolutionResponse_NodeFlow::outflow() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.outFlow)
  return outflow_;
}
inline void SolutionResponse_NodeFlow::set_outflow(float value) {
  set_has_outflow();
  outflow_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.outFlow)
}

// required float flowCost = 4;
inline bool SolutionResponse_NodeFlow::has_flowcost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_flowcost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionResponse_NodeFlow::clear_has_flowcost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionResponse_NodeFlow::clear_flowcost() {
  flowcost_ = 0;
  clear_has_flowcost();
}
inline float SolutionResponse_NodeFlow::flowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.flowCost)
  return flowcost_;
}
inline void SolutionResponse_NodeFlow::set_flowcost(float value) {
  set_has_flowcost();
  flowcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.flowCost)
}

// required float fixedCost = 5;
inline bool SolutionResponse_NodeFlow::has_fixedcost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_fixedcost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionResponse_NodeFlow::clear_has_fixedcost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionResponse_NodeFlow::clear_fixedcost() {
  fixedcost_ = 0;
  clear_has_fixedcost();
}
inline float SolutionResponse_NodeFlow::fixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.fixedCost)
  return fixedcost_;
}
inline void SolutionResponse_NodeFlow::set_fixedcost(float value) {
  set_has_fixedcost();
  fixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.fixedCost)
}

// required float productFlowCost = 6;
inline bool SolutionResponse_NodeFlow::has_productflowcost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productflowcost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionResponse_NodeFlow::clear_has_productflowcost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionResponse_NodeFlow::clear_productflowcost() {
  productflowcost_ = 0;
  clear_has_productflowcost();
}
inline float SolutionResponse_NodeFlow::productflowcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productFlowCost)
  return productflowcost_;
}
inline void SolutionResponse_NodeFlow::set_productflowcost(float value) {
  set_has_productflowcost();
  productflowcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productFlowCost)
}

// required float productFixedCost = 7;
inline bool SolutionResponse_NodeFlow::has_productfixedcost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productfixedcost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionResponse_NodeFlow::clear_has_productfixedcost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionResponse_NodeFlow::clear_productfixedcost() {
  productfixedcost_ = 0;
  clear_has_productfixedcost();
}
inline float SolutionResponse_NodeFlow::productfixedcost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productFixedCost)
  return productfixedcost_;
}
inline void SolutionResponse_NodeFlow::set_productfixedcost(float value) {
  set_has_productfixedcost();
  productfixedcost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productFixedCost)
}

// required float productionAmount = 8;
inline bool SolutionResponse_NodeFlow::has_productionamount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productionamount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionResponse_NodeFlow::clear_has_productionamount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionResponse_NodeFlow::clear_productionamount() {
  productionamount_ = 0;
  clear_has_productionamount();
}
inline float SolutionResponse_NodeFlow::productionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionAmount)
  return productionamount_;
}
inline void SolutionResponse_NodeFlow::set_productionamount(float value) {
  set_has_productionamount();
  productionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionAmount)
}

// required float productionPenalty = 9;
inline bool SolutionResponse_NodeFlow::has_productionpenalty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productionpenalty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolutionResponse_NodeFlow::clear_has_productionpenalty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolutionResponse_NodeFlow::clear_productionpenalty() {
  productionpenalty_ = 0;
  clear_has_productionpenalty();
}
inline float SolutionResponse_NodeFlow::productionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionPenalty)
  return productionpenalty_;
}
inline void SolutionResponse_NodeFlow::set_productionpenalty(float value) {
  set_has_productionpenalty();
  productionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionPenalty)
}

// required float productionCost = 10;
inline bool SolutionResponse_NodeFlow::has_productioncost() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_productioncost() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolutionResponse_NodeFlow::clear_has_productioncost() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolutionResponse_NodeFlow::clear_productioncost() {
  productioncost_ = 0;
  clear_has_productioncost();
}
inline float SolutionResponse_NodeFlow::productioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.productionCost)
  return productioncost_;
}
inline void SolutionResponse_NodeFlow::set_productioncost(float value) {
  set_has_productioncost();
  productioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.productionCost)
}

// required float consumptionAmount = 11;
inline bool SolutionResponse_NodeFlow::has_consumptionamount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_consumptionamount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolutionResponse_NodeFlow::clear_has_consumptionamount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolutionResponse_NodeFlow::clear_consumptionamount() {
  consumptionamount_ = 0;
  clear_has_consumptionamount();
}
inline float SolutionResponse_NodeFlow::consumptionamount() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionAmount)
  return consumptionamount_;
}
inline void SolutionResponse_NodeFlow::set_consumptionamount(float value) {
  set_has_consumptionamount();
  consumptionamount_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionAmount)
}

// required float consumptionPenalty = 12;
inline bool SolutionResponse_NodeFlow::has_consumptionpenalty() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_consumptionpenalty() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolutionResponse_NodeFlow::clear_has_consumptionpenalty() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolutionResponse_NodeFlow::clear_consumptionpenalty() {
  consumptionpenalty_ = 0;
  clear_has_consumptionpenalty();
}
inline float SolutionResponse_NodeFlow::consumptionpenalty() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionPenalty)
  return consumptionpenalty_;
}
inline void SolutionResponse_NodeFlow::set_consumptionpenalty(float value) {
  set_has_consumptionpenalty();
  consumptionpenalty_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionPenalty)
}

// required float consumptionCost = 13;
inline bool SolutionResponse_NodeFlow::has_consumptioncost() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SolutionResponse_NodeFlow::set_has_consumptioncost() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SolutionResponse_NodeFlow::clear_has_consumptioncost() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SolutionResponse_NodeFlow::clear_consumptioncost() {
  consumptioncost_ = 0;
  clear_has_consumptioncost();
}
inline float SolutionResponse_NodeFlow::consumptioncost() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.NodeFlow.consumptionCost)
  return consumptioncost_;
}
inline void SolutionResponse_NodeFlow::set_consumptioncost(float value) {
  set_has_consumptioncost();
  consumptioncost_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.NodeFlow.consumptionCost)
}

// -------------------------------------------------------------------

// SolutionResponse_GeometryEdgeSummary

// repeated float fxs = 1;
inline int SolutionResponse_GeometryEdgeSummary::fxs_size() const {
  return fxs_.size();
}
inline void SolutionResponse_GeometryEdgeSummary::clear_fxs() {
  fxs_.Clear();
}
inline float SolutionResponse_GeometryEdgeSummary::fxs(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometryEdgeSummary.fxs)
  return fxs_.Get(index);
}
inline void SolutionResponse_GeometryEdgeSummary::set_fxs(int index, float value) {
  fxs_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometryEdgeSummary.fxs)
}
inline void SolutionResponse_GeometryEdgeSummary::add_fxs(float value) {
  fxs_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometryEdgeSummary.fxs)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometryEdgeSummary::fxs() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometryEdgeSummary.fxs)
  return fxs_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometryEdgeSummary::mutable_fxs() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometryEdgeSummary.fxs)
  return &fxs_;
}

// repeated float fys = 2;
inline int SolutionResponse_GeometryEdgeSummary::fys_size() const {
  return fys_.size();
}
inline void SolutionResponse_GeometryEdgeSummary::clear_fys() {
  fys_.Clear();
}
inline float SolutionResponse_GeometryEdgeSummary::fys(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometryEdgeSummary.fys)
  return fys_.Get(index);
}
inline void SolutionResponse_GeometryEdgeSummary::set_fys(int index, float value) {
  fys_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometryEdgeSummary.fys)
}
inline void SolutionResponse_GeometryEdgeSummary::add_fys(float value) {
  fys_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometryEdgeSummary.fys)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometryEdgeSummary::fys() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometryEdgeSummary.fys)
  return fys_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometryEdgeSummary::mutable_fys() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometryEdgeSummary.fys)
  return &fys_;
}

// repeated float txs = 3;
inline int SolutionResponse_GeometryEdgeSummary::txs_size() const {
  return txs_.size();
}
inline void SolutionResponse_GeometryEdgeSummary::clear_txs() {
  txs_.Clear();
}
inline float SolutionResponse_GeometryEdgeSummary::txs(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometryEdgeSummary.txs)
  return txs_.Get(index);
}
inline void SolutionResponse_GeometryEdgeSummary::set_txs(int index, float value) {
  txs_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometryEdgeSummary.txs)
}
inline void SolutionResponse_GeometryEdgeSummary::add_txs(float value) {
  txs_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometryEdgeSummary.txs)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometryEdgeSummary::txs() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometryEdgeSummary.txs)
  return txs_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometryEdgeSummary::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometryEdgeSummary.txs)
  return &txs_;
}

// repeated float tys = 4;
inline int SolutionResponse_GeometryEdgeSummary::tys_size() const {
  return tys_.size();
}
inline void SolutionResponse_GeometryEdgeSummary::clear_tys() {
  tys_.Clear();
}
inline float SolutionResponse_GeometryEdgeSummary::tys(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometryEdgeSummary.tys)
  return tys_.Get(index);
}
inline void SolutionResponse_GeometryEdgeSummary::set_tys(int index, float value) {
  tys_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometryEdgeSummary.tys)
}
inline void SolutionResponse_GeometryEdgeSummary::add_tys(float value) {
  tys_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometryEdgeSummary.tys)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometryEdgeSummary::tys() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometryEdgeSummary.tys)
  return tys_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometryEdgeSummary::mutable_tys() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometryEdgeSummary.tys)
  return &tys_;
}

// repeated float weights = 5;
inline int SolutionResponse_GeometryEdgeSummary::weights_size() const {
  return weights_.size();
}
inline void SolutionResponse_GeometryEdgeSummary::clear_weights() {
  weights_.Clear();
}
inline float SolutionResponse_GeometryEdgeSummary::weights(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometryEdgeSummary.weights)
  return weights_.Get(index);
}
inline void SolutionResponse_GeometryEdgeSummary::set_weights(int index, float value) {
  weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometryEdgeSummary.weights)
}
inline void SolutionResponse_GeometryEdgeSummary::add_weights(float value) {
  weights_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometryEdgeSummary.weights)
}
inline const ::google::protobuf::RepeatedField< float >&
SolutionResponse_GeometryEdgeSummary::weights() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometryEdgeSummary.weights)
  return weights_;
}
inline ::google::protobuf::RepeatedField< float >*
SolutionResponse_GeometryEdgeSummary::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometryEdgeSummary.weights)
  return &weights_;
}

// repeated int32 types = 6;
inline int SolutionResponse_GeometryEdgeSummary::types_size() const {
  return types_.size();
}
inline void SolutionResponse_GeometryEdgeSummary::clear_types() {
  types_.Clear();
}
inline ::google::protobuf::int32 SolutionResponse_GeometryEdgeSummary::types(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.GeometryEdgeSummary.types)
  return types_.Get(index);
}
inline void SolutionResponse_GeometryEdgeSummary::set_types(int index, ::google::protobuf::int32 value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.GeometryEdgeSummary.types)
}
inline void SolutionResponse_GeometryEdgeSummary::add_types(::google::protobuf::int32 value) {
  types_.Add(value);
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.GeometryEdgeSummary.types)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SolutionResponse_GeometryEdgeSummary::types() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.GeometryEdgeSummary.types)
  return types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SolutionResponse_GeometryEdgeSummary::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.GeometryEdgeSummary.types)
  return &types_;
}

// -------------------------------------------------------------------

// SolutionResponse

// required float objective = 1;
inline bool SolutionResponse::has_objective() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionResponse::set_has_objective() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionResponse::clear_has_objective() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionResponse::clear_objective() {
  objective_ = 0;
  clear_has_objective();
}
inline float SolutionResponse::objective() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.objective)
  return objective_;
}
inline void SolutionResponse::set_objective(float value) {
  set_has_objective();
  objective_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.objective)
}

// optional float lowerBound = 2;
inline bool SolutionResponse::has_lowerbound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionResponse::set_has_lowerbound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionResponse::clear_has_lowerbound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionResponse::clear_lowerbound() {
  lowerbound_ = 0;
  clear_has_lowerbound();
}
inline float SolutionResponse::lowerbound() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.lowerBound)
  return lowerbound_;
}
inline void SolutionResponse::set_lowerbound(float value) {
  set_has_lowerbound();
  lowerbound_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.lowerBound)
}

// optional float optimalityGap = 3;
inline bool SolutionResponse::has_optimalitygap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionResponse::set_has_optimalitygap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionResponse::clear_has_optimalitygap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionResponse::clear_optimalitygap() {
  optimalitygap_ = 0;
  clear_has_optimalitygap();
}
inline float SolutionResponse::optimalitygap() const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.optimalityGap)
  return optimalitygap_;
}
inline void SolutionResponse::set_optimalitygap(float value) {
  set_has_optimalitygap();
  optimalitygap_ = value;
  // @@protoc_insertion_point(field_set:NS3.SolutionResponse.optimalityGap)
}

// repeated .NS3.SolutionResponse.Assignment assignments = 4;
inline int SolutionResponse::assignments_size() const {
  return assignments_.size();
}
inline void SolutionResponse::clear_assignments() {
  assignments_.Clear();
}
inline ::NS3::SolutionResponse_Assignment* SolutionResponse::mutable_assignments(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.assignments)
  return assignments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >*
SolutionResponse::mutable_assignments() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.assignments)
  return &assignments_;
}
inline const ::NS3::SolutionResponse_Assignment& SolutionResponse::assignments(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.assignments)
  return assignments_.Get(index);
}
inline ::NS3::SolutionResponse_Assignment* SolutionResponse::add_assignments() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.assignments)
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_Assignment >&
SolutionResponse::assignments() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.assignments)
  return assignments_;
}

// repeated .NS3.SolutionResponse.NodeFlow nodeFlows = 5;
inline int SolutionResponse::nodeflows_size() const {
  return nodeflows_.size();
}
inline void SolutionResponse::clear_nodeflows() {
  nodeflows_.Clear();
}
inline ::NS3::SolutionResponse_NodeFlow* SolutionResponse::mutable_nodeflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeFlows)
  return nodeflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >*
SolutionResponse::mutable_nodeflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeFlows)
  return &nodeflows_;
}
inline const ::NS3::SolutionResponse_NodeFlow& SolutionResponse::nodeflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeFlows)
  return nodeflows_.Get(index);
}
inline ::NS3::SolutionResponse_NodeFlow* SolutionResponse::add_nodeflows() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeFlows)
  return nodeflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeFlow >&
SolutionResponse::nodeflows() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeFlows)
  return nodeflows_;
}

// repeated .NS3.SolutionResponse.NodeProductFlow nodeProductFlows = 6;
inline int SolutionResponse::nodeproductflows_size() const {
  return nodeproductflows_.size();
}
inline void SolutionResponse::clear_nodeproductflows() {
  nodeproductflows_.Clear();
}
inline ::NS3::SolutionResponse_NodeProductFlow* SolutionResponse::mutable_nodeproductflows(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >*
SolutionResponse::mutable_nodeproductflows() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.nodeProductFlows)
  return &nodeproductflows_;
}
inline const ::NS3::SolutionResponse_NodeProductFlow& SolutionResponse::nodeproductflows(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_.Get(index);
}
inline ::NS3::SolutionResponse_NodeProductFlow* SolutionResponse::add_nodeproductflows() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_NodeProductFlow >&
SolutionResponse::nodeproductflows() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.nodeProductFlows)
  return nodeproductflows_;
}

// repeated .NS3.SolutionResponse.GeometryEdgeSummary geometryEdgeSummary = 7;
inline int SolutionResponse::geometryedgesummary_size() const {
  return geometryedgesummary_.size();
}
inline void SolutionResponse::clear_geometryedgesummary() {
  geometryedgesummary_.Clear();
}
inline ::NS3::SolutionResponse_GeometryEdgeSummary* SolutionResponse::mutable_geometryedgesummary(int index) {
  // @@protoc_insertion_point(field_mutable:NS3.SolutionResponse.geometryEdgeSummary)
  return geometryedgesummary_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometryEdgeSummary >*
SolutionResponse::mutable_geometryedgesummary() {
  // @@protoc_insertion_point(field_mutable_list:NS3.SolutionResponse.geometryEdgeSummary)
  return &geometryedgesummary_;
}
inline const ::NS3::SolutionResponse_GeometryEdgeSummary& SolutionResponse::geometryedgesummary(int index) const {
  // @@protoc_insertion_point(field_get:NS3.SolutionResponse.geometryEdgeSummary)
  return geometryedgesummary_.Get(index);
}
inline ::NS3::SolutionResponse_GeometryEdgeSummary* SolutionResponse::add_geometryedgesummary() {
  // @@protoc_insertion_point(field_add:NS3.SolutionResponse.geometryEdgeSummary)
  return geometryedgesummary_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NS3::SolutionResponse_GeometryEdgeSummary >&
SolutionResponse::geometryedgesummary() const {
  // @@protoc_insertion_point(field_list:NS3.SolutionResponse.geometryEdgeSummary)
  return geometryedgesummary_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NS3

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NS3::SolveRequest_SolveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NS3::SolveRequest_SolveType>() {
  return ::NS3::SolveRequest_SolveType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ns3_2dtbfvuwtge2iq_2eproto
